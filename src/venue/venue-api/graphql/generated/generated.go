// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	"github.com/omiga-group/omiga/src/venue/shared/entities"
	"github.com/omiga-group/omiga/src/venue/venue-api/graphql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Currency() CurrencyResolver
	Market() MarketResolver
	Query() QueryResolver
	Ticker() TickerResolver
	TradingPair() TradingPairResolver
	Venue() VenueResolver
	CurrencyWhereInput() CurrencyWhereInputResolver
	MarketWhereInput() MarketWhereInputResolver
	OutboxWhereInput() OutboxWhereInputResolver
	VenueWhereInput() VenueWhereInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ConvertedDetails struct {
		Btc func(childComplexity int) int
		Eth func(childComplexity int) int
		Usd func(childComplexity int) int
	}

	Currency struct {
		ID     func(childComplexity int) int
		Name   func(childComplexity int) int
		Symbol func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	CurrencyConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CurrencyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Links struct {
		Facebook func(childComplexity int) int
		Reddit   func(childComplexity int) int
		Slack    func(childComplexity int) int
		Telegram func(childComplexity int) int
		Twitter  func(childComplexity int) int
		Website  func(childComplexity int) int
	}

	Market struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
		Type func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Currencies         func(childComplexity int, after *entities.Cursor, first *int, before *entities.Cursor, last *int, orderBy []*entities.CurrencyOrder, where *entities.CurrencyWhereInput) int
		Currency           func(childComplexity int, where *entities.CurrencyWhereInput) int
		Venue              func(childComplexity int, where *entities.VenueWhereInput) int
		Venues             func(childComplexity int, after *entities.Cursor, first *int, before *entities.Cursor, last *int, orderBy []*entities.VenueOrder, where *entities.VenueWhereInput) int
		__resolve__service func(childComplexity int) int
	}

	Ticker struct {
		Base                   func(childComplexity int) int
		BaseCoinID             func(childComplexity int) int
		BidAskSpreadPercentage func(childComplexity int) int
		ConvertedLast          func(childComplexity int) int
		ConvertedVolume        func(childComplexity int) int
		Counter                func(childComplexity int) int
		CounterCoinID          func(childComplexity int) int
		ID                     func(childComplexity int) int
		IsAnomaly              func(childComplexity int) int
		IsStale                func(childComplexity int) int
		Last                   func(childComplexity int) int
		LastFetchAt            func(childComplexity int) int
		LastTradedAt           func(childComplexity int) int
		Market                 func(childComplexity int) int
		Timestamp              func(childComplexity int) int
		TokenInfoURL           func(childComplexity int) int
		TradeURL               func(childComplexity int) int
		TrustScore             func(childComplexity int) int
		Volume                 func(childComplexity int) int
	}

	TickerMarket struct {
		HasTradingIncentive func(childComplexity int) int
		Identifier          func(childComplexity int) int
		Name                func(childComplexity int) int
	}

	TradingPair struct {
		Base                        func(childComplexity int) int
		BasePriceMaxPrecision       func(childComplexity int) int
		BasePriceMinPrecision       func(childComplexity int) int
		BaseQuantityMaxPrecision    func(childComplexity int) int
		BaseQuantityMinPrecision    func(childComplexity int) int
		Counter                     func(childComplexity int) int
		CounterPriceMaxPrecision    func(childComplexity int) int
		CounterPriceMinPrecision    func(childComplexity int) int
		CounterQuantityMaxPrecision func(childComplexity int) int
		CounterQuantityMinPrecision func(childComplexity int) int
		ID                          func(childComplexity int) int
		Markets                     func(childComplexity int) int
		Symbol                      func(childComplexity int) int
	}

	Venue struct {
		AlertNotice                 func(childComplexity int) int
		Centralized                 func(childComplexity int) int
		Country                     func(childComplexity int) int
		HasTradingIncentive         func(childComplexity int) int
		ID                          func(childComplexity int) int
		Image                       func(childComplexity int) int
		Links                       func(childComplexity int) int
		MakerFee                    func(childComplexity int) int
		Markets                     func(childComplexity int) int
		Name                        func(childComplexity int) int
		PublicNotice                func(childComplexity int) int
		SpreadFee                   func(childComplexity int) int
		SupportAPI                  func(childComplexity int) int
		TakerFee                    func(childComplexity int) int
		Tickers                     func(childComplexity int) int
		TradeVolume24hBtc           func(childComplexity int) int
		TradeVolume24hBtcNormalized func(childComplexity int) int
		TradingPairs                func(childComplexity int) int
		TrustScore                  func(childComplexity int) int
		TrustScoreRank              func(childComplexity int) int
		Type                        func(childComplexity int) int
		VenueID                     func(childComplexity int) int
		YearEstablished             func(childComplexity int) int
	}

	VenueConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	VenueEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type CurrencyResolver interface {
	Type(ctx context.Context, obj *entities.Currency) (models.CurrencyType, error)
}
type MarketResolver interface {
	Type(ctx context.Context, obj *entities.Market) (models.MarketType, error)
}
type QueryResolver interface {
	Currency(ctx context.Context, where *entities.CurrencyWhereInput) (*entities.Currency, error)
	Currencies(ctx context.Context, after *entities.Cursor, first *int, before *entities.Cursor, last *int, orderBy []*entities.CurrencyOrder, where *entities.CurrencyWhereInput) (*entities.CurrencyConnection, error)
	Venue(ctx context.Context, where *entities.VenueWhereInput) (*entities.Venue, error)
	Venues(ctx context.Context, after *entities.Cursor, first *int, before *entities.Cursor, last *int, orderBy []*entities.VenueOrder, where *entities.VenueWhereInput) (*entities.VenueConnection, error)
}
type TickerResolver interface {
	Market(ctx context.Context, obj *entities.Ticker) (*models.TickerMarket, error)

	ConvertedLast(ctx context.Context, obj *entities.Ticker) (*models.ConvertedDetails, error)
	ConvertedVolume(ctx context.Context, obj *entities.Ticker) (*models.ConvertedDetails, error)
}
type TradingPairResolver interface {
	Markets(ctx context.Context, obj *entities.TradingPair) ([]*entities.Market, error)
}
type VenueResolver interface {
	Type(ctx context.Context, obj *entities.Venue) (models.VenueType, error)

	Links(ctx context.Context, obj *entities.Venue) (*models.Links, error)

	Tickers(ctx context.Context, obj *entities.Venue) ([]*entities.Ticker, error)
	TradingPairs(ctx context.Context, obj *entities.Venue) ([]*entities.TradingPair, error)
	Markets(ctx context.Context, obj *entities.Venue) ([]*entities.Market, error)
}

type CurrencyWhereInputResolver interface {
	Type(ctx context.Context, obj *entities.CurrencyWhereInput, data *models.CurrencyType) error
	TypeNeq(ctx context.Context, obj *entities.CurrencyWhereInput, data *models.CurrencyType) error
	TypeIn(ctx context.Context, obj *entities.CurrencyWhereInput, data []models.CurrencyType) error
	TypeNotIn(ctx context.Context, obj *entities.CurrencyWhereInput, data []models.CurrencyType) error
}
type MarketWhereInputResolver interface {
	Type(ctx context.Context, obj *entities.MarketWhereInput, data *models.MarketType) error
	TypeNeq(ctx context.Context, obj *entities.MarketWhereInput, data *models.MarketType) error
	TypeIn(ctx context.Context, obj *entities.MarketWhereInput, data []models.MarketType) error
	TypeNotIn(ctx context.Context, obj *entities.MarketWhereInput, data []models.MarketType) error
}
type OutboxWhereInputResolver interface {
	Status(ctx context.Context, obj *entities.OutboxWhereInput, data *models.OutboxStatus) error
	StatusNeq(ctx context.Context, obj *entities.OutboxWhereInput, data *models.OutboxStatus) error
	StatusIn(ctx context.Context, obj *entities.OutboxWhereInput, data []models.OutboxStatus) error
	StatusNotIn(ctx context.Context, obj *entities.OutboxWhereInput, data []models.OutboxStatus) error
}
type VenueWhereInputResolver interface {
	Type(ctx context.Context, obj *entities.VenueWhereInput, data *models.VenueType) error
	TypeNeq(ctx context.Context, obj *entities.VenueWhereInput, data *models.VenueType) error
	TypeIn(ctx context.Context, obj *entities.VenueWhereInput, data []models.VenueType) error
	TypeNotIn(ctx context.Context, obj *entities.VenueWhereInput, data []models.VenueType) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "ConvertedDetails.btc":
		if e.complexity.ConvertedDetails.Btc == nil {
			break
		}

		return e.complexity.ConvertedDetails.Btc(childComplexity), true

	case "ConvertedDetails.eth":
		if e.complexity.ConvertedDetails.Eth == nil {
			break
		}

		return e.complexity.ConvertedDetails.Eth(childComplexity), true

	case "ConvertedDetails.usd":
		if e.complexity.ConvertedDetails.Usd == nil {
			break
		}

		return e.complexity.ConvertedDetails.Usd(childComplexity), true

	case "Currency.id":
		if e.complexity.Currency.ID == nil {
			break
		}

		return e.complexity.Currency.ID(childComplexity), true

	case "Currency.name":
		if e.complexity.Currency.Name == nil {
			break
		}

		return e.complexity.Currency.Name(childComplexity), true

	case "Currency.symbol":
		if e.complexity.Currency.Symbol == nil {
			break
		}

		return e.complexity.Currency.Symbol(childComplexity), true

	case "Currency.type":
		if e.complexity.Currency.Type == nil {
			break
		}

		return e.complexity.Currency.Type(childComplexity), true

	case "CurrencyConnection.edges":
		if e.complexity.CurrencyConnection.Edges == nil {
			break
		}

		return e.complexity.CurrencyConnection.Edges(childComplexity), true

	case "CurrencyConnection.pageInfo":
		if e.complexity.CurrencyConnection.PageInfo == nil {
			break
		}

		return e.complexity.CurrencyConnection.PageInfo(childComplexity), true

	case "CurrencyConnection.totalCount":
		if e.complexity.CurrencyConnection.TotalCount == nil {
			break
		}

		return e.complexity.CurrencyConnection.TotalCount(childComplexity), true

	case "CurrencyEdge.cursor":
		if e.complexity.CurrencyEdge.Cursor == nil {
			break
		}

		return e.complexity.CurrencyEdge.Cursor(childComplexity), true

	case "CurrencyEdge.node":
		if e.complexity.CurrencyEdge.Node == nil {
			break
		}

		return e.complexity.CurrencyEdge.Node(childComplexity), true

	case "Links.facebook":
		if e.complexity.Links.Facebook == nil {
			break
		}

		return e.complexity.Links.Facebook(childComplexity), true

	case "Links.reddit":
		if e.complexity.Links.Reddit == nil {
			break
		}

		return e.complexity.Links.Reddit(childComplexity), true

	case "Links.slack":
		if e.complexity.Links.Slack == nil {
			break
		}

		return e.complexity.Links.Slack(childComplexity), true

	case "Links.telegram":
		if e.complexity.Links.Telegram == nil {
			break
		}

		return e.complexity.Links.Telegram(childComplexity), true

	case "Links.twitter":
		if e.complexity.Links.Twitter == nil {
			break
		}

		return e.complexity.Links.Twitter(childComplexity), true

	case "Links.website":
		if e.complexity.Links.Website == nil {
			break
		}

		return e.complexity.Links.Website(childComplexity), true

	case "Market.id":
		if e.complexity.Market.ID == nil {
			break
		}

		return e.complexity.Market.ID(childComplexity), true

	case "Market.name":
		if e.complexity.Market.Name == nil {
			break
		}

		return e.complexity.Market.Name(childComplexity), true

	case "Market.type":
		if e.complexity.Market.Type == nil {
			break
		}

		return e.complexity.Market.Type(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.currencies":
		if e.complexity.Query.Currencies == nil {
			break
		}

		args, err := ec.field_Query_currencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Currencies(childComplexity, args["after"].(*entities.Cursor), args["first"].(*int), args["before"].(*entities.Cursor), args["last"].(*int), args["orderBy"].([]*entities.CurrencyOrder), args["where"].(*entities.CurrencyWhereInput)), true

	case "Query.currency":
		if e.complexity.Query.Currency == nil {
			break
		}

		args, err := ec.field_Query_currency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Currency(childComplexity, args["where"].(*entities.CurrencyWhereInput)), true

	case "Query.venue":
		if e.complexity.Query.Venue == nil {
			break
		}

		args, err := ec.field_Query_venue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Venue(childComplexity, args["where"].(*entities.VenueWhereInput)), true

	case "Query.venues":
		if e.complexity.Query.Venues == nil {
			break
		}

		args, err := ec.field_Query_venues_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Venues(childComplexity, args["after"].(*entities.Cursor), args["first"].(*int), args["before"].(*entities.Cursor), args["last"].(*int), args["orderBy"].([]*entities.VenueOrder), args["where"].(*entities.VenueWhereInput)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Ticker.base":
		if e.complexity.Ticker.Base == nil {
			break
		}

		return e.complexity.Ticker.Base(childComplexity), true

	case "Ticker.baseCoinId":
		if e.complexity.Ticker.BaseCoinID == nil {
			break
		}

		return e.complexity.Ticker.BaseCoinID(childComplexity), true

	case "Ticker.bidAskSpreadPercentage":
		if e.complexity.Ticker.BidAskSpreadPercentage == nil {
			break
		}

		return e.complexity.Ticker.BidAskSpreadPercentage(childComplexity), true

	case "Ticker.convertedLast":
		if e.complexity.Ticker.ConvertedLast == nil {
			break
		}

		return e.complexity.Ticker.ConvertedLast(childComplexity), true

	case "Ticker.convertedVolume":
		if e.complexity.Ticker.ConvertedVolume == nil {
			break
		}

		return e.complexity.Ticker.ConvertedVolume(childComplexity), true

	case "Ticker.counter":
		if e.complexity.Ticker.Counter == nil {
			break
		}

		return e.complexity.Ticker.Counter(childComplexity), true

	case "Ticker.counterCoinId":
		if e.complexity.Ticker.CounterCoinID == nil {
			break
		}

		return e.complexity.Ticker.CounterCoinID(childComplexity), true

	case "Ticker.id":
		if e.complexity.Ticker.ID == nil {
			break
		}

		return e.complexity.Ticker.ID(childComplexity), true

	case "Ticker.isAnomaly":
		if e.complexity.Ticker.IsAnomaly == nil {
			break
		}

		return e.complexity.Ticker.IsAnomaly(childComplexity), true

	case "Ticker.isStale":
		if e.complexity.Ticker.IsStale == nil {
			break
		}

		return e.complexity.Ticker.IsStale(childComplexity), true

	case "Ticker.last":
		if e.complexity.Ticker.Last == nil {
			break
		}

		return e.complexity.Ticker.Last(childComplexity), true

	case "Ticker.lastFetchAt":
		if e.complexity.Ticker.LastFetchAt == nil {
			break
		}

		return e.complexity.Ticker.LastFetchAt(childComplexity), true

	case "Ticker.lastTradedAt":
		if e.complexity.Ticker.LastTradedAt == nil {
			break
		}

		return e.complexity.Ticker.LastTradedAt(childComplexity), true

	case "Ticker.market":
		if e.complexity.Ticker.Market == nil {
			break
		}

		return e.complexity.Ticker.Market(childComplexity), true

	case "Ticker.timestamp":
		if e.complexity.Ticker.Timestamp == nil {
			break
		}

		return e.complexity.Ticker.Timestamp(childComplexity), true

	case "Ticker.tokenInfoUrl":
		if e.complexity.Ticker.TokenInfoURL == nil {
			break
		}

		return e.complexity.Ticker.TokenInfoURL(childComplexity), true

	case "Ticker.tradeUrl":
		if e.complexity.Ticker.TradeURL == nil {
			break
		}

		return e.complexity.Ticker.TradeURL(childComplexity), true

	case "Ticker.trustScore":
		if e.complexity.Ticker.TrustScore == nil {
			break
		}

		return e.complexity.Ticker.TrustScore(childComplexity), true

	case "Ticker.volume":
		if e.complexity.Ticker.Volume == nil {
			break
		}

		return e.complexity.Ticker.Volume(childComplexity), true

	case "TickerMarket.hasTradingIncentive":
		if e.complexity.TickerMarket.HasTradingIncentive == nil {
			break
		}

		return e.complexity.TickerMarket.HasTradingIncentive(childComplexity), true

	case "TickerMarket.identifier":
		if e.complexity.TickerMarket.Identifier == nil {
			break
		}

		return e.complexity.TickerMarket.Identifier(childComplexity), true

	case "TickerMarket.name":
		if e.complexity.TickerMarket.Name == nil {
			break
		}

		return e.complexity.TickerMarket.Name(childComplexity), true

	case "TradingPair.base":
		if e.complexity.TradingPair.Base == nil {
			break
		}

		return e.complexity.TradingPair.Base(childComplexity), true

	case "TradingPair.basePriceMaxPrecision":
		if e.complexity.TradingPair.BasePriceMaxPrecision == nil {
			break
		}

		return e.complexity.TradingPair.BasePriceMaxPrecision(childComplexity), true

	case "TradingPair.basePriceMinPrecision":
		if e.complexity.TradingPair.BasePriceMinPrecision == nil {
			break
		}

		return e.complexity.TradingPair.BasePriceMinPrecision(childComplexity), true

	case "TradingPair.baseQuantityMaxPrecision":
		if e.complexity.TradingPair.BaseQuantityMaxPrecision == nil {
			break
		}

		return e.complexity.TradingPair.BaseQuantityMaxPrecision(childComplexity), true

	case "TradingPair.baseQuantityMinPrecision":
		if e.complexity.TradingPair.BaseQuantityMinPrecision == nil {
			break
		}

		return e.complexity.TradingPair.BaseQuantityMinPrecision(childComplexity), true

	case "TradingPair.counter":
		if e.complexity.TradingPair.Counter == nil {
			break
		}

		return e.complexity.TradingPair.Counter(childComplexity), true

	case "TradingPair.counterPriceMaxPrecision":
		if e.complexity.TradingPair.CounterPriceMaxPrecision == nil {
			break
		}

		return e.complexity.TradingPair.CounterPriceMaxPrecision(childComplexity), true

	case "TradingPair.counterPriceMinPrecision":
		if e.complexity.TradingPair.CounterPriceMinPrecision == nil {
			break
		}

		return e.complexity.TradingPair.CounterPriceMinPrecision(childComplexity), true

	case "TradingPair.counterQuantityMaxPrecision":
		if e.complexity.TradingPair.CounterQuantityMaxPrecision == nil {
			break
		}

		return e.complexity.TradingPair.CounterQuantityMaxPrecision(childComplexity), true

	case "TradingPair.counterQuantityMinPrecision":
		if e.complexity.TradingPair.CounterQuantityMinPrecision == nil {
			break
		}

		return e.complexity.TradingPair.CounterQuantityMinPrecision(childComplexity), true

	case "TradingPair.id":
		if e.complexity.TradingPair.ID == nil {
			break
		}

		return e.complexity.TradingPair.ID(childComplexity), true

	case "TradingPair.markets":
		if e.complexity.TradingPair.Markets == nil {
			break
		}

		return e.complexity.TradingPair.Markets(childComplexity), true

	case "TradingPair.symbol":
		if e.complexity.TradingPair.Symbol == nil {
			break
		}

		return e.complexity.TradingPair.Symbol(childComplexity), true

	case "Venue.alertNotice":
		if e.complexity.Venue.AlertNotice == nil {
			break
		}

		return e.complexity.Venue.AlertNotice(childComplexity), true

	case "Venue.centralized":
		if e.complexity.Venue.Centralized == nil {
			break
		}

		return e.complexity.Venue.Centralized(childComplexity), true

	case "Venue.country":
		if e.complexity.Venue.Country == nil {
			break
		}

		return e.complexity.Venue.Country(childComplexity), true

	case "Venue.hasTradingIncentive":
		if e.complexity.Venue.HasTradingIncentive == nil {
			break
		}

		return e.complexity.Venue.HasTradingIncentive(childComplexity), true

	case "Venue.id":
		if e.complexity.Venue.ID == nil {
			break
		}

		return e.complexity.Venue.ID(childComplexity), true

	case "Venue.image":
		if e.complexity.Venue.Image == nil {
			break
		}

		return e.complexity.Venue.Image(childComplexity), true

	case "Venue.links":
		if e.complexity.Venue.Links == nil {
			break
		}

		return e.complexity.Venue.Links(childComplexity), true

	case "Venue.makerFee":
		if e.complexity.Venue.MakerFee == nil {
			break
		}

		return e.complexity.Venue.MakerFee(childComplexity), true

	case "Venue.markets":
		if e.complexity.Venue.Markets == nil {
			break
		}

		return e.complexity.Venue.Markets(childComplexity), true

	case "Venue.name":
		if e.complexity.Venue.Name == nil {
			break
		}

		return e.complexity.Venue.Name(childComplexity), true

	case "Venue.publicNotice":
		if e.complexity.Venue.PublicNotice == nil {
			break
		}

		return e.complexity.Venue.PublicNotice(childComplexity), true

	case "Venue.spreadFee":
		if e.complexity.Venue.SpreadFee == nil {
			break
		}

		return e.complexity.Venue.SpreadFee(childComplexity), true

	case "Venue.supportAPI":
		if e.complexity.Venue.SupportAPI == nil {
			break
		}

		return e.complexity.Venue.SupportAPI(childComplexity), true

	case "Venue.takerFee":
		if e.complexity.Venue.TakerFee == nil {
			break
		}

		return e.complexity.Venue.TakerFee(childComplexity), true

	case "Venue.tickers":
		if e.complexity.Venue.Tickers == nil {
			break
		}

		return e.complexity.Venue.Tickers(childComplexity), true

	case "Venue.tradeVolume24hBtc":
		if e.complexity.Venue.TradeVolume24hBtc == nil {
			break
		}

		return e.complexity.Venue.TradeVolume24hBtc(childComplexity), true

	case "Venue.tradeVolume24hBtcNormalized":
		if e.complexity.Venue.TradeVolume24hBtcNormalized == nil {
			break
		}

		return e.complexity.Venue.TradeVolume24hBtcNormalized(childComplexity), true

	case "Venue.tradingPairs":
		if e.complexity.Venue.TradingPairs == nil {
			break
		}

		return e.complexity.Venue.TradingPairs(childComplexity), true

	case "Venue.trustScore":
		if e.complexity.Venue.TrustScore == nil {
			break
		}

		return e.complexity.Venue.TrustScore(childComplexity), true

	case "Venue.trustScoreRank":
		if e.complexity.Venue.TrustScoreRank == nil {
			break
		}

		return e.complexity.Venue.TrustScoreRank(childComplexity), true

	case "Venue.type":
		if e.complexity.Venue.Type == nil {
			break
		}

		return e.complexity.Venue.Type(childComplexity), true

	case "Venue.venueId":
		if e.complexity.Venue.VenueID == nil {
			break
		}

		return e.complexity.Venue.VenueID(childComplexity), true

	case "Venue.yearEstablished":
		if e.complexity.Venue.YearEstablished == nil {
			break
		}

		return e.complexity.Venue.YearEstablished(childComplexity), true

	case "VenueConnection.edges":
		if e.complexity.VenueConnection.Edges == nil {
			break
		}

		return e.complexity.VenueConnection.Edges(childComplexity), true

	case "VenueConnection.pageInfo":
		if e.complexity.VenueConnection.PageInfo == nil {
			break
		}

		return e.complexity.VenueConnection.PageInfo(childComplexity), true

	case "VenueConnection.totalCount":
		if e.complexity.VenueConnection.TotalCount == nil {
			break
		}

		return e.complexity.VenueConnection.TotalCount(childComplexity), true

	case "VenueEdge.cursor":
		if e.complexity.VenueEdge.Cursor == nil {
			break
		}

		return e.complexity.VenueEdge.Cursor(childComplexity), true

	case "VenueEdge.node":
		if e.complexity.VenueEdge.Node == nil {
			break
		}

		return e.complexity.VenueEdge.Node(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCurrencyOrder,
		ec.unmarshalInputCurrencyWhereInput,
		ec.unmarshalInputMarketWhereInput,
		ec.unmarshalInputOutboxWhereInput,
		ec.unmarshalInputTickerWhereInput,
		ec.unmarshalInputTradingPairWhereInput,
		ec.unmarshalInputVenueOrder,
		ec.unmarshalInputVenueWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../../api-definitions/graphql/omiga/venue/V1/schema.graphql", Input: `scalar Time
scalar Cursor

schema {
  query: Query
}

"""
An object with an ID
"""
interface Node {
  """
  The id of the object.
  """
  id: ID
}

extend type Query {
  currency(
    """
    Ordering directions
    """
    where: CurrencyWhereInput
  ): Currency

  currencies(
    """
    Returns the items in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first n items from the list.
    """
    first: Int

    """
    Returns the items in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last n items from the list.
    """
    last: Int

    """
    Ordering directions
    """
    orderBy: [CurrencyOrder!]

    """
    Ordering directions
    """
    where: CurrencyWhereInput
  ): CurrencyConnection

  venue(
    """
    Ordering directions
    """
    where: VenueWhereInput
  ): Venue

  venues(
    """
    Returns the items in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first n items from the list.
    """
    first: Int

    """
    Returns the items in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last n items from the list.
    """
    last: Int

    """
    Ordering directions
    """
    orderBy: [VenueOrder!]

    """
    Ordering directions
    """
    where: VenueWhereInput
  ): VenueConnection
}

enum OrderDirection {
  ASC
  DESC
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}

enum CurrencyOrderField {
  symbol
  name
  type
}

input CurrencyOrder {
  direction: OrderDirection!
  field: CurrencyOrderField
}

type Currency implements Node {
  id: ID!
  symbol: String!
  name: String
  type: CurrencyType!
}

"""
A connection to a list of items.
"""
type CurrencyConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [CurrencyEdge]

  """
  Total number of currencies
  """
  totalCount: Int
}

"""
An edge in a connection.
"""
type CurrencyEdge {
  """
  The item at the end of the edge
  """
  node: Currency

  """
  A cursor for use in pagination
  """
  cursor: Cursor!
}

enum VenueOrderField {
  venueId
  name
  yearEstablished
  country
  image
  hasTradingIncentive
  centralized
  publicNotice
  alertNotice
  trustScore
  trustScoreRank
  tradeVolume24hBtc
  tradeVolume24hBtcNormalized
}

input VenueOrder {
  direction: OrderDirection!
  field: VenueOrderField
}

type Venue implements Node {
  id: ID!
  venueId: String!
  type: VenueType!

  name: String
  yearEstablished: Int
  country: String
  image: String
  links: Links!
  hasTradingIncentive: Boolean
  centralized: Boolean
  publicNotice: String
  alertNotice: String
  trustScore: Int
  trustScoreRank: Int
  tradeVolume24hBtc: Float
  tradeVolume24hBtcNormalized: Float
  tickers: [Ticker!]!
  tradingPairs: [TradingPair!]!
  markets: [Market!]!
  makerFee: Float
  takerFee: Float
  spreadFee: Boolean
  supportAPI: Boolean
}

type Links {
  website: String
  facebook: String
  reddit: String
  twitter: String
  slack: String
  telegram: String
}

type Ticker implements Node {
  id: ID!
  base: String!
  baseCoinId: String
  counter: String!
  counterCoinId: String
  market: TickerMarket
  last: Float
  volume: Float
  convertedLast: ConvertedDetails
  convertedVolume: ConvertedDetails
  trustScore: String
  bidAskSpreadPercentage: Float
  timestamp: Time
  lastTradedAt: Time
  lastFetchAt: Time
  isAnomaly: Boolean
  isStale: Boolean
  tradeUrl: String
  tokenInfoUrl: String
}

type TradingPair implements Node {
  id: ID!
  symbol: String!
  base: Currency!
  basePriceMinPrecision: Int
  basePriceMaxPrecision: Int
  baseQuantityMinPrecision: Int
  baseQuantityMaxPrecision: Int
  counter: Currency!
  counterPriceMinPrecision: Int
  counterPriceMaxPrecision: Int
  counterQuantityMinPrecision: Int
  counterQuantityMaxPrecision: Int
  markets: [Market!]!
}

type TickerMarket {
  hasTradingIncentive: Boolean!
  identifier: String!
  name: String
}

type ConvertedDetails {
  btc: Float!
  eth: Float!
  usd: Float!
}

"""
A connection to a list of items.
"""
type VenueConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [VenueEdge]

  """
  Total number of venues
  """
  totalCount: Int
}

"""
An edge in a connection.
"""
type VenueEdge {
  """
  The item at the end of the edge
  """
  node: Venue

  """
  A cursor for use in pagination
  """
  cursor: Cursor!
}

enum OutboxStatus {
  PENDING
  SUCCEEDED
  FAILED
}

type Market implements Node {
  id: ID!
  name: String!
  type: MarketType!
}

enum VenueType {
  EXCHANGE
}

enum CurrencyType {
  DIGITAL
  FIAT
}

enum MarketType {
  SPOT_TRADING
  MARGIN_TRADING
  DERIVATIVES
  EARN
  PERPETUAL
  FUTURES
  WARRANT
  OTC
  YIELD
  P2P
  STRATEGY_TRADING
  SWAP_FARMING
  FAN_TOKEN
  ETF
  NFT
  SWAP
  CFD
  LIQUIDITY
  FARM
}
`, BuiltIn: false},
	{Name: "../../../../../api-definitions/graphql/omiga/venue/V1/ent.graphql", Input: `"""
CurrencyWhereInput is used for filtering Currency objects.
Input was generated by ent.
"""
input CurrencyWhereInput {
  not: CurrencyWhereInput
  and: [CurrencyWhereInput!]
  or: [CurrencyWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """symbol field predicates"""
  symbol: String
  symbolNEQ: String
  symbolIn: [String!]
  symbolNotIn: [String!]
  symbolGT: String
  symbolGTE: String
  symbolLT: String
  symbolLTE: String
  symbolContains: String
  symbolHasPrefix: String
  symbolHasSuffix: String
  symbolEqualFold: String
  symbolContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """type field predicates"""
  type: CurrencyType
  typeNEQ: CurrencyType
  typeIn: [CurrencyType!]
  typeNotIn: [CurrencyType!]
  """currency_base edge predicates"""
  hasCurrencyBase: Boolean
  hasCurrencyBaseWith: [TradingPairWhereInput!]
  """currency_counter edge predicates"""
  hasCurrencyCounter: Boolean
  hasCurrencyCounterWith: [TradingPairWhereInput!]
}
"""
MarketWhereInput is used for filtering Market objects.
Input was generated by ent.
"""
input MarketWhereInput {
  not: MarketWhereInput
  and: [MarketWhereInput!]
  or: [MarketWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """type field predicates"""
  type: MarketType
  typeNEQ: MarketType
  typeIn: [MarketType!]
  typeNotIn: [MarketType!]
  """venue edge predicates"""
  hasVenue: Boolean
  hasVenueWith: [VenueWhereInput!]
  """trading_pair edge predicates"""
  hasTradingPair: Boolean
  hasTradingPairWith: [TradingPairWhereInput!]
}
"""
OutboxWhereInput is used for filtering Outbox objects.
Input was generated by ent.
"""
input OutboxWhereInput {
  not: OutboxWhereInput
  and: [OutboxWhereInput!]
  or: [OutboxWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """timestamp field predicates"""
  timestamp: Time
  timestampNEQ: Time
  timestampIn: [Time!]
  timestampNotIn: [Time!]
  timestampGT: Time
  timestampGTE: Time
  timestampLT: Time
  timestampLTE: Time
  """topic field predicates"""
  topic: String
  topicNEQ: String
  topicIn: [String!]
  topicNotIn: [String!]
  topicGT: String
  topicGTE: String
  topicLT: String
  topicLTE: String
  topicContains: String
  topicHasPrefix: String
  topicHasSuffix: String
  topicEqualFold: String
  topicContainsFold: String
  """key field predicates"""
  key: String
  keyNEQ: String
  keyIn: [String!]
  keyNotIn: [String!]
  keyGT: String
  keyGTE: String
  keyLT: String
  keyLTE: String
  keyContains: String
  keyHasPrefix: String
  keyHasSuffix: String
  keyEqualFold: String
  keyContainsFold: String
  """retry_count field predicates"""
  retryCount: Int
  retryCountNEQ: Int
  retryCountIn: [Int!]
  retryCountNotIn: [Int!]
  retryCountGT: Int
  retryCountGTE: Int
  retryCountLT: Int
  retryCountLTE: Int
  """status field predicates"""
  status: OutboxStatus
  statusNEQ: OutboxStatus
  statusIn: [OutboxStatus!]
  statusNotIn: [OutboxStatus!]
  """last_retry field predicates"""
  lastRetry: Time
  lastRetryNEQ: Time
  lastRetryIn: [Time!]
  lastRetryNotIn: [Time!]
  lastRetryGT: Time
  lastRetryGTE: Time
  lastRetryLT: Time
  lastRetryLTE: Time
  lastRetryIsNil: Boolean
  lastRetryNotNil: Boolean
}
"""
TickerWhereInput is used for filtering Ticker objects.
Input was generated by ent.
"""
input TickerWhereInput {
  not: TickerWhereInput
  and: [TickerWhereInput!]
  or: [TickerWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """base field predicates"""
  base: String
  baseNEQ: String
  baseIn: [String!]
  baseNotIn: [String!]
  baseGT: String
  baseGTE: String
  baseLT: String
  baseLTE: String
  baseContains: String
  baseHasPrefix: String
  baseHasSuffix: String
  baseEqualFold: String
  baseContainsFold: String
  """base_coin_id field predicates"""
  baseCoinID: String
  baseCoinIDNEQ: String
  baseCoinIDIn: [String!]
  baseCoinIDNotIn: [String!]
  baseCoinIDGT: String
  baseCoinIDGTE: String
  baseCoinIDLT: String
  baseCoinIDLTE: String
  baseCoinIDContains: String
  baseCoinIDHasPrefix: String
  baseCoinIDHasSuffix: String
  baseCoinIDIsNil: Boolean
  baseCoinIDNotNil: Boolean
  baseCoinIDEqualFold: String
  baseCoinIDContainsFold: String
  """counter field predicates"""
  counter: String
  counterNEQ: String
  counterIn: [String!]
  counterNotIn: [String!]
  counterGT: String
  counterGTE: String
  counterLT: String
  counterLTE: String
  counterContains: String
  counterHasPrefix: String
  counterHasSuffix: String
  counterEqualFold: String
  counterContainsFold: String
  """counter_coin_id field predicates"""
  counterCoinID: String
  counterCoinIDNEQ: String
  counterCoinIDIn: [String!]
  counterCoinIDNotIn: [String!]
  counterCoinIDGT: String
  counterCoinIDGTE: String
  counterCoinIDLT: String
  counterCoinIDLTE: String
  counterCoinIDContains: String
  counterCoinIDHasPrefix: String
  counterCoinIDHasSuffix: String
  counterCoinIDIsNil: Boolean
  counterCoinIDNotNil: Boolean
  counterCoinIDEqualFold: String
  counterCoinIDContainsFold: String
  """last field predicates"""
  last: Float
  lastNEQ: Float
  lastIn: [Float!]
  lastNotIn: [Float!]
  lastGT: Float
  lastGTE: Float
  lastLT: Float
  lastLTE: Float
  lastIsNil: Boolean
  lastNotNil: Boolean
  """volume field predicates"""
  volume: Float
  volumeNEQ: Float
  volumeIn: [Float!]
  volumeNotIn: [Float!]
  volumeGT: Float
  volumeGTE: Float
  volumeLT: Float
  volumeLTE: Float
  volumeIsNil: Boolean
  volumeNotNil: Boolean
  """trust_score field predicates"""
  trustScore: String
  trustScoreNEQ: String
  trustScoreIn: [String!]
  trustScoreNotIn: [String!]
  trustScoreGT: String
  trustScoreGTE: String
  trustScoreLT: String
  trustScoreLTE: String
  trustScoreContains: String
  trustScoreHasPrefix: String
  trustScoreHasSuffix: String
  trustScoreIsNil: Boolean
  trustScoreNotNil: Boolean
  trustScoreEqualFold: String
  trustScoreContainsFold: String
  """bid_ask_spread_percentage field predicates"""
  bidAskSpreadPercentage: Float
  bidAskSpreadPercentageNEQ: Float
  bidAskSpreadPercentageIn: [Float!]
  bidAskSpreadPercentageNotIn: [Float!]
  bidAskSpreadPercentageGT: Float
  bidAskSpreadPercentageGTE: Float
  bidAskSpreadPercentageLT: Float
  bidAskSpreadPercentageLTE: Float
  bidAskSpreadPercentageIsNil: Boolean
  bidAskSpreadPercentageNotNil: Boolean
  """timestamp field predicates"""
  timestamp: Time
  timestampNEQ: Time
  timestampIn: [Time!]
  timestampNotIn: [Time!]
  timestampGT: Time
  timestampGTE: Time
  timestampLT: Time
  timestampLTE: Time
  timestampIsNil: Boolean
  timestampNotNil: Boolean
  """last_traded_at field predicates"""
  lastTradedAt: Time
  lastTradedAtNEQ: Time
  lastTradedAtIn: [Time!]
  lastTradedAtNotIn: [Time!]
  lastTradedAtGT: Time
  lastTradedAtGTE: Time
  lastTradedAtLT: Time
  lastTradedAtLTE: Time
  lastTradedAtIsNil: Boolean
  lastTradedAtNotNil: Boolean
  """last_fetch_at field predicates"""
  lastFetchAt: Time
  lastFetchAtNEQ: Time
  lastFetchAtIn: [Time!]
  lastFetchAtNotIn: [Time!]
  lastFetchAtGT: Time
  lastFetchAtGTE: Time
  lastFetchAtLT: Time
  lastFetchAtLTE: Time
  lastFetchAtIsNil: Boolean
  lastFetchAtNotNil: Boolean
  """is_anomaly field predicates"""
  isAnomaly: Boolean
  isAnomalyNEQ: Boolean
  isAnomalyIsNil: Boolean
  isAnomalyNotNil: Boolean
  """is_stale field predicates"""
  isStale: Boolean
  isStaleNEQ: Boolean
  isStaleIsNil: Boolean
  isStaleNotNil: Boolean
  """trade_url field predicates"""
  tradeURL: String
  tradeURLNEQ: String
  tradeURLIn: [String!]
  tradeURLNotIn: [String!]
  tradeURLGT: String
  tradeURLGTE: String
  tradeURLLT: String
  tradeURLLTE: String
  tradeURLContains: String
  tradeURLHasPrefix: String
  tradeURLHasSuffix: String
  tradeURLIsNil: Boolean
  tradeURLNotNil: Boolean
  tradeURLEqualFold: String
  tradeURLContainsFold: String
  """token_info_url field predicates"""
  tokenInfoURL: String
  tokenInfoURLNEQ: String
  tokenInfoURLIn: [String!]
  tokenInfoURLNotIn: [String!]
  tokenInfoURLGT: String
  tokenInfoURLGTE: String
  tokenInfoURLLT: String
  tokenInfoURLLTE: String
  tokenInfoURLContains: String
  tokenInfoURLHasPrefix: String
  tokenInfoURLHasSuffix: String
  tokenInfoURLIsNil: Boolean
  tokenInfoURLNotNil: Boolean
  tokenInfoURLEqualFold: String
  tokenInfoURLContainsFold: String
  """venue edge predicates"""
  hasVenue: Boolean
  hasVenueWith: [VenueWhereInput!]
}
"""
TradingPairWhereInput is used for filtering TradingPair objects.
Input was generated by ent.
"""
input TradingPairWhereInput {
  not: TradingPairWhereInput
  and: [TradingPairWhereInput!]
  or: [TradingPairWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """symbol field predicates"""
  symbol: String
  symbolNEQ: String
  symbolIn: [String!]
  symbolNotIn: [String!]
  symbolGT: String
  symbolGTE: String
  symbolLT: String
  symbolLTE: String
  symbolContains: String
  symbolHasPrefix: String
  symbolHasSuffix: String
  symbolEqualFold: String
  symbolContainsFold: String
  """base_price_min_precision field predicates"""
  basePriceMinPrecision: Int
  basePriceMinPrecisionNEQ: Int
  basePriceMinPrecisionIn: [Int!]
  basePriceMinPrecisionNotIn: [Int!]
  basePriceMinPrecisionGT: Int
  basePriceMinPrecisionGTE: Int
  basePriceMinPrecisionLT: Int
  basePriceMinPrecisionLTE: Int
  basePriceMinPrecisionIsNil: Boolean
  basePriceMinPrecisionNotNil: Boolean
  """base_price_max_precision field predicates"""
  basePriceMaxPrecision: Int
  basePriceMaxPrecisionNEQ: Int
  basePriceMaxPrecisionIn: [Int!]
  basePriceMaxPrecisionNotIn: [Int!]
  basePriceMaxPrecisionGT: Int
  basePriceMaxPrecisionGTE: Int
  basePriceMaxPrecisionLT: Int
  basePriceMaxPrecisionLTE: Int
  basePriceMaxPrecisionIsNil: Boolean
  basePriceMaxPrecisionNotNil: Boolean
  """base_quantity_min_precision field predicates"""
  baseQuantityMinPrecision: Int
  baseQuantityMinPrecisionNEQ: Int
  baseQuantityMinPrecisionIn: [Int!]
  baseQuantityMinPrecisionNotIn: [Int!]
  baseQuantityMinPrecisionGT: Int
  baseQuantityMinPrecisionGTE: Int
  baseQuantityMinPrecisionLT: Int
  baseQuantityMinPrecisionLTE: Int
  baseQuantityMinPrecisionIsNil: Boolean
  baseQuantityMinPrecisionNotNil: Boolean
  """base_quantity_max_precision field predicates"""
  baseQuantityMaxPrecision: Int
  baseQuantityMaxPrecisionNEQ: Int
  baseQuantityMaxPrecisionIn: [Int!]
  baseQuantityMaxPrecisionNotIn: [Int!]
  baseQuantityMaxPrecisionGT: Int
  baseQuantityMaxPrecisionGTE: Int
  baseQuantityMaxPrecisionLT: Int
  baseQuantityMaxPrecisionLTE: Int
  baseQuantityMaxPrecisionIsNil: Boolean
  baseQuantityMaxPrecisionNotNil: Boolean
  """counter_price_min_precision field predicates"""
  counterPriceMinPrecision: Int
  counterPriceMinPrecisionNEQ: Int
  counterPriceMinPrecisionIn: [Int!]
  counterPriceMinPrecisionNotIn: [Int!]
  counterPriceMinPrecisionGT: Int
  counterPriceMinPrecisionGTE: Int
  counterPriceMinPrecisionLT: Int
  counterPriceMinPrecisionLTE: Int
  counterPriceMinPrecisionIsNil: Boolean
  counterPriceMinPrecisionNotNil: Boolean
  """counter_price_max_precision field predicates"""
  counterPriceMaxPrecision: Int
  counterPriceMaxPrecisionNEQ: Int
  counterPriceMaxPrecisionIn: [Int!]
  counterPriceMaxPrecisionNotIn: [Int!]
  counterPriceMaxPrecisionGT: Int
  counterPriceMaxPrecisionGTE: Int
  counterPriceMaxPrecisionLT: Int
  counterPriceMaxPrecisionLTE: Int
  counterPriceMaxPrecisionIsNil: Boolean
  counterPriceMaxPrecisionNotNil: Boolean
  """counter_quantity_min_precision field predicates"""
  counterQuantityMinPrecision: Int
  counterQuantityMinPrecisionNEQ: Int
  counterQuantityMinPrecisionIn: [Int!]
  counterQuantityMinPrecisionNotIn: [Int!]
  counterQuantityMinPrecisionGT: Int
  counterQuantityMinPrecisionGTE: Int
  counterQuantityMinPrecisionLT: Int
  counterQuantityMinPrecisionLTE: Int
  counterQuantityMinPrecisionIsNil: Boolean
  counterQuantityMinPrecisionNotNil: Boolean
  """counter_quantity_max_precision field predicates"""
  counterQuantityMaxPrecision: Int
  counterQuantityMaxPrecisionNEQ: Int
  counterQuantityMaxPrecisionIn: [Int!]
  counterQuantityMaxPrecisionNotIn: [Int!]
  counterQuantityMaxPrecisionGT: Int
  counterQuantityMaxPrecisionGTE: Int
  counterQuantityMaxPrecisionLT: Int
  counterQuantityMaxPrecisionLTE: Int
  counterQuantityMaxPrecisionIsNil: Boolean
  counterQuantityMaxPrecisionNotNil: Boolean
  """venue edge predicates"""
  hasVenue: Boolean
  hasVenueWith: [VenueWhereInput!]
  """base edge predicates"""
  hasBase: Boolean
  hasBaseWith: [CurrencyWhereInput!]
  """counter edge predicates"""
  hasCounter: Boolean
  hasCounterWith: [CurrencyWhereInput!]
  """market edge predicates"""
  hasMarket: Boolean
  hasMarketWith: [MarketWhereInput!]
}
"""
VenueWhereInput is used for filtering Venue objects.
Input was generated by ent.
"""
input VenueWhereInput {
  not: VenueWhereInput
  and: [VenueWhereInput!]
  or: [VenueWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """venue_id field predicates"""
  venueID: String
  venueIDNEQ: String
  venueIDIn: [String!]
  venueIDNotIn: [String!]
  venueIDGT: String
  venueIDGTE: String
  venueIDLT: String
  venueIDLTE: String
  venueIDContains: String
  venueIDHasPrefix: String
  venueIDHasSuffix: String
  venueIDEqualFold: String
  venueIDContainsFold: String
  """type field predicates"""
  type: VenueType
  typeNEQ: VenueType
  typeIn: [VenueType!]
  typeNotIn: [VenueType!]
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """year_established field predicates"""
  yearEstablished: Int
  yearEstablishedNEQ: Int
  yearEstablishedIn: [Int!]
  yearEstablishedNotIn: [Int!]
  yearEstablishedGT: Int
  yearEstablishedGTE: Int
  yearEstablishedLT: Int
  yearEstablishedLTE: Int
  yearEstablishedIsNil: Boolean
  yearEstablishedNotNil: Boolean
  """country field predicates"""
  country: String
  countryNEQ: String
  countryIn: [String!]
  countryNotIn: [String!]
  countryGT: String
  countryGTE: String
  countryLT: String
  countryLTE: String
  countryContains: String
  countryHasPrefix: String
  countryHasSuffix: String
  countryIsNil: Boolean
  countryNotNil: Boolean
  countryEqualFold: String
  countryContainsFold: String
  """image field predicates"""
  image: String
  imageNEQ: String
  imageIn: [String!]
  imageNotIn: [String!]
  imageGT: String
  imageGTE: String
  imageLT: String
  imageLTE: String
  imageContains: String
  imageHasPrefix: String
  imageHasSuffix: String
  imageIsNil: Boolean
  imageNotNil: Boolean
  imageEqualFold: String
  imageContainsFold: String
  """has_trading_incentive field predicates"""
  hasTradingIncentive: Boolean
  hasTradingIncentiveNEQ: Boolean
  hasTradingIncentiveIsNil: Boolean
  hasTradingIncentiveNotNil: Boolean
  """centralized field predicates"""
  centralized: Boolean
  centralizedNEQ: Boolean
  centralizedIsNil: Boolean
  centralizedNotNil: Boolean
  """public_notice field predicates"""
  publicNotice: String
  publicNoticeNEQ: String
  publicNoticeIn: [String!]
  publicNoticeNotIn: [String!]
  publicNoticeGT: String
  publicNoticeGTE: String
  publicNoticeLT: String
  publicNoticeLTE: String
  publicNoticeContains: String
  publicNoticeHasPrefix: String
  publicNoticeHasSuffix: String
  publicNoticeIsNil: Boolean
  publicNoticeNotNil: Boolean
  publicNoticeEqualFold: String
  publicNoticeContainsFold: String
  """alert_notice field predicates"""
  alertNotice: String
  alertNoticeNEQ: String
  alertNoticeIn: [String!]
  alertNoticeNotIn: [String!]
  alertNoticeGT: String
  alertNoticeGTE: String
  alertNoticeLT: String
  alertNoticeLTE: String
  alertNoticeContains: String
  alertNoticeHasPrefix: String
  alertNoticeHasSuffix: String
  alertNoticeIsNil: Boolean
  alertNoticeNotNil: Boolean
  alertNoticeEqualFold: String
  alertNoticeContainsFold: String
  """trust_score field predicates"""
  trustScore: Int
  trustScoreNEQ: Int
  trustScoreIn: [Int!]
  trustScoreNotIn: [Int!]
  trustScoreGT: Int
  trustScoreGTE: Int
  trustScoreLT: Int
  trustScoreLTE: Int
  trustScoreIsNil: Boolean
  trustScoreNotNil: Boolean
  """trust_score_rank field predicates"""
  trustScoreRank: Int
  trustScoreRankNEQ: Int
  trustScoreRankIn: [Int!]
  trustScoreRankNotIn: [Int!]
  trustScoreRankGT: Int
  trustScoreRankGTE: Int
  trustScoreRankLT: Int
  trustScoreRankLTE: Int
  trustScoreRankIsNil: Boolean
  trustScoreRankNotNil: Boolean
  """trade_volume_24h_btc field predicates"""
  tradeVolume24hBtc: Float
  tradeVolume24hBtcNEQ: Float
  tradeVolume24hBtcIn: [Float!]
  tradeVolume24hBtcNotIn: [Float!]
  tradeVolume24hBtcGT: Float
  tradeVolume24hBtcGTE: Float
  tradeVolume24hBtcLT: Float
  tradeVolume24hBtcLTE: Float
  tradeVolume24hBtcIsNil: Boolean
  tradeVolume24hBtcNotNil: Boolean
  """trade_volume_24h_btc_normalized field predicates"""
  tradeVolume24hBtcNormalized: Float
  tradeVolume24hBtcNormalizedNEQ: Float
  tradeVolume24hBtcNormalizedIn: [Float!]
  tradeVolume24hBtcNormalizedNotIn: [Float!]
  tradeVolume24hBtcNormalizedGT: Float
  tradeVolume24hBtcNormalizedGTE: Float
  tradeVolume24hBtcNormalizedLT: Float
  tradeVolume24hBtcNormalizedLTE: Float
  tradeVolume24hBtcNormalizedIsNil: Boolean
  tradeVolume24hBtcNormalizedNotNil: Boolean
  """maker_fee field predicates"""
  makerFee: Float
  makerFeeNEQ: Float
  makerFeeIn: [Float!]
  makerFeeNotIn: [Float!]
  makerFeeGT: Float
  makerFeeGTE: Float
  makerFeeLT: Float
  makerFeeLTE: Float
  makerFeeIsNil: Boolean
  makerFeeNotNil: Boolean
  """taker_fee field predicates"""
  takerFee: Float
  takerFeeNEQ: Float
  takerFeeIn: [Float!]
  takerFeeNotIn: [Float!]
  takerFeeGT: Float
  takerFeeGTE: Float
  takerFeeLT: Float
  takerFeeLTE: Float
  takerFeeIsNil: Boolean
  takerFeeNotNil: Boolean
  """spread_fee field predicates"""
  spreadFee: Boolean
  spreadFeeNEQ: Boolean
  spreadFeeIsNil: Boolean
  spreadFeeNotNil: Boolean
  """support_api field predicates"""
  supportAPI: Boolean
  supportAPINEQ: Boolean
  supportAPIIsNil: Boolean
  supportAPINotNil: Boolean
  """ticker edge predicates"""
  hasTicker: Boolean
  hasTickerWith: [TickerWhereInput!]
  """trading_pair edge predicates"""
  hasTradingPair: Boolean
  hasTradingPairWith: [TradingPairWhereInput!]
  """market edge predicates"""
  hasMarket: Boolean
  hasMarketWith: [MarketWhereInput!]
}
`, BuiltIn: false},
	{Name: "../../../shared/graphql/federation/directives.graphql", Input: `
	scalar _Any
	scalar _FieldSet

	directive @external on FIELD_DEFINITION
	directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
	directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
	directive @extends on OBJECT | INTERFACE

	directive @key(fields: _FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @shareable on OBJECT | FIELD_DEFINITION
	directive @tag(name: String!) repeatable on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
	directive @override(from: String!) on FIELD_DEFINITION
	directive @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
`, BuiltIn: true},
	{Name: "../../../shared/graphql/federation/entity.graphql", Input: `
type _Service {
  sdl: String
}

extend type Query {
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_currencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entities.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entities.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*entities.CurrencyOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOCurrencyOrder2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *entities.CurrencyWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_currency_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entities.CurrencyWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_venue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entities.VenueWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_venues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entities.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entities.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*entities.VenueOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOVenueOrder2githubcomomigagroupomigasrcvenuesharedentitiesVenueOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *entities.VenueWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ConvertedDetails_btc(ctx context.Context, field graphql.CollectedField, obj *models.ConvertedDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConvertedDetails_btc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Btc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConvertedDetails_btc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConvertedDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConvertedDetails_eth(ctx context.Context, field graphql.CollectedField, obj *models.ConvertedDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConvertedDetails_eth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Eth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConvertedDetails_eth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConvertedDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConvertedDetails_usd(ctx context.Context, field graphql.CollectedField, obj *models.ConvertedDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConvertedDetails_usd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Usd, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConvertedDetails_usd(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConvertedDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_id(ctx context.Context, field graphql.CollectedField, obj *entities.Currency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Currency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Currency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_symbol(ctx context.Context, field graphql.CollectedField, obj *entities.Currency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Currency_symbol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Currency_symbol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_name(ctx context.Context, field graphql.CollectedField, obj *entities.Currency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Currency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Currency_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Currency_type(ctx context.Context, field graphql.CollectedField, obj *entities.Currency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Currency_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Currency().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.CurrencyType)
	fc.Result = res
	return ec.marshalNCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Currency_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Currency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CurrencyType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrencyConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *entities.CurrencyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrencyConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entities.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomomigagroupomigasrcvenuesharedentitiesPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrencyConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrencyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrencyConnection_edges(ctx context.Context, field graphql.CollectedField, obj *entities.CurrencyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrencyConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.CurrencyEdge)
	fc.Result = res
	return ec.marshalOCurrencyEdge2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrencyConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrencyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_CurrencyEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_CurrencyEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CurrencyEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrencyConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *entities.CurrencyConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrencyConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrencyConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrencyConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrencyEdge_node(ctx context.Context, field graphql.CollectedField, obj *entities.CurrencyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrencyEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Currency)
	fc.Result = res
	return ec.marshalOCurrency2githubcomomigagroupomigasrcvenuesharedentitiesCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrencyEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrencyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "symbol":
				return ec.fieldContext_Currency_symbol(ctx, field)
			case "name":
				return ec.fieldContext_Currency_name(ctx, field)
			case "type":
				return ec.fieldContext_Currency_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CurrencyEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *entities.CurrencyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CurrencyEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entities.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CurrencyEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CurrencyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Links_website(ctx context.Context, field graphql.CollectedField, obj *models.Links) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Links_website(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Website, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Links_website(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Links",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Links_facebook(ctx context.Context, field graphql.CollectedField, obj *models.Links) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Links_facebook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Facebook, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Links_facebook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Links",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Links_reddit(ctx context.Context, field graphql.CollectedField, obj *models.Links) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Links_reddit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reddit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Links_reddit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Links",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Links_twitter(ctx context.Context, field graphql.CollectedField, obj *models.Links) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Links_twitter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Twitter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Links_twitter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Links",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Links_slack(ctx context.Context, field graphql.CollectedField, obj *models.Links) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Links_slack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Links_slack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Links",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Links_telegram(ctx context.Context, field graphql.CollectedField, obj *models.Links) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Links_telegram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Telegram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Links_telegram(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Links",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Market_id(ctx context.Context, field graphql.CollectedField, obj *entities.Market) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Market_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Market_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Market",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Market_name(ctx context.Context, field graphql.CollectedField, obj *entities.Market) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Market_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Market_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Market",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Market_type(ctx context.Context, field graphql.CollectedField, obj *entities.Market) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Market_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Market().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MarketType)
	fc.Result = res
	return ec.marshalNMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Market_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Market",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MarketType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entities.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entities.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entities.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entities.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Cursor)
	fc.Result = res
	return ec.marshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_currency(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Currency(rctx, fc.Args["where"].(*entities.CurrencyWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Currency)
	fc.Result = res
	return ec.marshalOCurrency2githubcomomigagroupomigasrcvenuesharedentitiesCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "symbol":
				return ec.fieldContext_Currency_symbol(ctx, field)
			case "name":
				return ec.fieldContext_Currency_name(ctx, field)
			case "type":
				return ec.fieldContext_Currency_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_currency_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_currencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Currencies(rctx, fc.Args["after"].(*entities.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*entities.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].([]*entities.CurrencyOrder), fc.Args["where"].(*entities.CurrencyWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.CurrencyConnection)
	fc.Result = res
	return ec.marshalOCurrencyConnection2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_CurrencyConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_CurrencyConnection_edges(ctx, field)
			case "totalCount":
				return ec.fieldContext_CurrencyConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CurrencyConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_currencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_venue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_venue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Venue(rctx, fc.Args["where"].(*entities.VenueWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Venue)
	fc.Result = res
	return ec.marshalOVenue2githubcomomigagroupomigasrcvenuesharedentitiesVenue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_venue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Venue_id(ctx, field)
			case "venueId":
				return ec.fieldContext_Venue_venueId(ctx, field)
			case "type":
				return ec.fieldContext_Venue_type(ctx, field)
			case "name":
				return ec.fieldContext_Venue_name(ctx, field)
			case "yearEstablished":
				return ec.fieldContext_Venue_yearEstablished(ctx, field)
			case "country":
				return ec.fieldContext_Venue_country(ctx, field)
			case "image":
				return ec.fieldContext_Venue_image(ctx, field)
			case "links":
				return ec.fieldContext_Venue_links(ctx, field)
			case "hasTradingIncentive":
				return ec.fieldContext_Venue_hasTradingIncentive(ctx, field)
			case "centralized":
				return ec.fieldContext_Venue_centralized(ctx, field)
			case "publicNotice":
				return ec.fieldContext_Venue_publicNotice(ctx, field)
			case "alertNotice":
				return ec.fieldContext_Venue_alertNotice(ctx, field)
			case "trustScore":
				return ec.fieldContext_Venue_trustScore(ctx, field)
			case "trustScoreRank":
				return ec.fieldContext_Venue_trustScoreRank(ctx, field)
			case "tradeVolume24hBtc":
				return ec.fieldContext_Venue_tradeVolume24hBtc(ctx, field)
			case "tradeVolume24hBtcNormalized":
				return ec.fieldContext_Venue_tradeVolume24hBtcNormalized(ctx, field)
			case "tickers":
				return ec.fieldContext_Venue_tickers(ctx, field)
			case "tradingPairs":
				return ec.fieldContext_Venue_tradingPairs(ctx, field)
			case "markets":
				return ec.fieldContext_Venue_markets(ctx, field)
			case "makerFee":
				return ec.fieldContext_Venue_makerFee(ctx, field)
			case "takerFee":
				return ec.fieldContext_Venue_takerFee(ctx, field)
			case "spreadFee":
				return ec.fieldContext_Venue_spreadFee(ctx, field)
			case "supportAPI":
				return ec.fieldContext_Venue_supportAPI(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Venue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_venue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_venues(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_venues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Venues(rctx, fc.Args["after"].(*entities.Cursor), fc.Args["first"].(*int), fc.Args["before"].(*entities.Cursor), fc.Args["last"].(*int), fc.Args["orderBy"].([]*entities.VenueOrder), fc.Args["where"].(*entities.VenueWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.VenueConnection)
	fc.Result = res
	return ec.marshalOVenueConnection2githubcomomigagroupomigasrcvenuesharedentitiesVenueConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_venues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pageInfo":
				return ec.fieldContext_VenueConnection_pageInfo(ctx, field)
			case "edges":
				return ec.fieldContext_VenueConnection_edges(ctx, field)
			case "totalCount":
				return ec.fieldContext_VenueConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VenueConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_venues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_id(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_base(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_base(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Base, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_base(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_baseCoinId(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_baseCoinId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseCoinID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_baseCoinId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_counter(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_counter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Counter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_counter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_counterCoinId(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_counterCoinId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CounterCoinID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_counterCoinId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_market(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_market(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ticker().Market(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TickerMarket)
	fc.Result = res
	return ec.marshalOTickerMarket2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsTickerMarket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_market(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasTradingIncentive":
				return ec.fieldContext_TickerMarket_hasTradingIncentive(ctx, field)
			case "identifier":
				return ec.fieldContext_TickerMarket_identifier(ctx, field)
			case "name":
				return ec.fieldContext_TickerMarket_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TickerMarket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_last(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_last(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Last, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_last(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_volume(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_volume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_volume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_convertedLast(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_convertedLast(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ticker().ConvertedLast(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ConvertedDetails)
	fc.Result = res
	return ec.marshalOConvertedDetails2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsConvertedDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_convertedLast(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "btc":
				return ec.fieldContext_ConvertedDetails_btc(ctx, field)
			case "eth":
				return ec.fieldContext_ConvertedDetails_eth(ctx, field)
			case "usd":
				return ec.fieldContext_ConvertedDetails_usd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConvertedDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_convertedVolume(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_convertedVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ticker().ConvertedVolume(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ConvertedDetails)
	fc.Result = res
	return ec.marshalOConvertedDetails2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsConvertedDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_convertedVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "btc":
				return ec.fieldContext_ConvertedDetails_btc(ctx, field)
			case "eth":
				return ec.fieldContext_ConvertedDetails_eth(ctx, field)
			case "usd":
				return ec.fieldContext_ConvertedDetails_usd(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConvertedDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_trustScore(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_trustScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TrustScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_trustScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_bidAskSpreadPercentage(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_bidAskSpreadPercentage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BidAskSpreadPercentage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_bidAskSpreadPercentage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_timestamp(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_lastTradedAt(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_lastTradedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastTradedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_lastTradedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_lastFetchAt(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_lastFetchAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastFetchAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_lastFetchAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_isAnomaly(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_isAnomaly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAnomaly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_isAnomaly(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_isStale(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_isStale(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsStale, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_isStale(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_tradeUrl(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_tradeUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_tradeUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ticker_tokenInfoUrl(ctx context.Context, field graphql.CollectedField, obj *entities.Ticker) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ticker_tokenInfoUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenInfoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ticker_tokenInfoUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ticker",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TickerMarket_hasTradingIncentive(ctx context.Context, field graphql.CollectedField, obj *models.TickerMarket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TickerMarket_hasTradingIncentive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasTradingIncentive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TickerMarket_hasTradingIncentive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TickerMarket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TickerMarket_identifier(ctx context.Context, field graphql.CollectedField, obj *models.TickerMarket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TickerMarket_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TickerMarket_identifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TickerMarket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TickerMarket_name(ctx context.Context, field graphql.CollectedField, obj *models.TickerMarket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TickerMarket_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TickerMarket_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TickerMarket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_id(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_symbol(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_symbol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_symbol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_base(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_base(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Base(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Currency)
	fc.Result = res
	return ec.marshalNCurrency2githubcomomigagroupomigasrcvenuesharedentitiesCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_base(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "symbol":
				return ec.fieldContext_Currency_symbol(ctx, field)
			case "name":
				return ec.fieldContext_Currency_name(ctx, field)
			case "type":
				return ec.fieldContext_Currency_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_basePriceMinPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_basePriceMinPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasePriceMinPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_basePriceMinPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_basePriceMaxPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_basePriceMaxPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasePriceMaxPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_basePriceMaxPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_baseQuantityMinPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_baseQuantityMinPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseQuantityMinPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_baseQuantityMinPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_baseQuantityMaxPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_baseQuantityMaxPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseQuantityMaxPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_baseQuantityMaxPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_counter(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_counter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Counter(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Currency)
	fc.Result = res
	return ec.marshalNCurrency2githubcomomigagroupomigasrcvenuesharedentitiesCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_counter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Currency_id(ctx, field)
			case "symbol":
				return ec.fieldContext_Currency_symbol(ctx, field)
			case "name":
				return ec.fieldContext_Currency_name(ctx, field)
			case "type":
				return ec.fieldContext_Currency_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Currency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_counterPriceMinPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_counterPriceMinPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CounterPriceMinPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_counterPriceMinPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_counterPriceMaxPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_counterPriceMaxPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CounterPriceMaxPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_counterPriceMaxPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_counterQuantityMinPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_counterQuantityMinPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CounterQuantityMinPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_counterQuantityMinPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_counterQuantityMaxPrecision(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_counterQuantityMaxPrecision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CounterQuantityMaxPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_counterQuantityMaxPrecision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TradingPair_markets(ctx context.Context, field graphql.CollectedField, obj *entities.TradingPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TradingPair_markets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TradingPair().Markets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*entities.Market)
	fc.Result = res
	return ec.marshalNMarket2githubcomomigagroupomigasrcvenuesharedentitiesMarket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TradingPair_markets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TradingPair",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Market_id(ctx, field)
			case "name":
				return ec.fieldContext_Market_name(ctx, field)
			case "type":
				return ec.fieldContext_Market_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Market", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_id(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_venueId(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_venueId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VenueID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_venueId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_type(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Venue().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.VenueType)
	fc.Result = res
	return ec.marshalNVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VenueType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_name(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_yearEstablished(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_yearEstablished(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YearEstablished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_yearEstablished(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_country(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_country(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Country, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_country(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_image(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_links(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_links(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Venue().Links(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Links)
	fc.Result = res
	return ec.marshalNLinks2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsLinks(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_links(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "website":
				return ec.fieldContext_Links_website(ctx, field)
			case "facebook":
				return ec.fieldContext_Links_facebook(ctx, field)
			case "reddit":
				return ec.fieldContext_Links_reddit(ctx, field)
			case "twitter":
				return ec.fieldContext_Links_twitter(ctx, field)
			case "slack":
				return ec.fieldContext_Links_slack(ctx, field)
			case "telegram":
				return ec.fieldContext_Links_telegram(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Links", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_hasTradingIncentive(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_hasTradingIncentive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasTradingIncentive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_hasTradingIncentive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_centralized(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_centralized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Centralized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_centralized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_publicNotice(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_publicNotice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicNotice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_publicNotice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_alertNotice(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_alertNotice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertNotice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_alertNotice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_trustScore(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_trustScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TrustScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_trustScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_trustScoreRank(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_trustScoreRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TrustScoreRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_trustScoreRank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_tradeVolume24hBtc(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_tradeVolume24hBtc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeVolume24hBtc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_tradeVolume24hBtc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_tradeVolume24hBtcNormalized(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_tradeVolume24hBtcNormalized(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeVolume24hBtcNormalized, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_tradeVolume24hBtcNormalized(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_tickers(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_tickers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Venue().Tickers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*entities.Ticker)
	fc.Result = res
	return ec.marshalNTicker2githubcomomigagroupomigasrcvenuesharedentitiesTicker(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_tickers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ticker_id(ctx, field)
			case "base":
				return ec.fieldContext_Ticker_base(ctx, field)
			case "baseCoinId":
				return ec.fieldContext_Ticker_baseCoinId(ctx, field)
			case "counter":
				return ec.fieldContext_Ticker_counter(ctx, field)
			case "counterCoinId":
				return ec.fieldContext_Ticker_counterCoinId(ctx, field)
			case "market":
				return ec.fieldContext_Ticker_market(ctx, field)
			case "last":
				return ec.fieldContext_Ticker_last(ctx, field)
			case "volume":
				return ec.fieldContext_Ticker_volume(ctx, field)
			case "convertedLast":
				return ec.fieldContext_Ticker_convertedLast(ctx, field)
			case "convertedVolume":
				return ec.fieldContext_Ticker_convertedVolume(ctx, field)
			case "trustScore":
				return ec.fieldContext_Ticker_trustScore(ctx, field)
			case "bidAskSpreadPercentage":
				return ec.fieldContext_Ticker_bidAskSpreadPercentage(ctx, field)
			case "timestamp":
				return ec.fieldContext_Ticker_timestamp(ctx, field)
			case "lastTradedAt":
				return ec.fieldContext_Ticker_lastTradedAt(ctx, field)
			case "lastFetchAt":
				return ec.fieldContext_Ticker_lastFetchAt(ctx, field)
			case "isAnomaly":
				return ec.fieldContext_Ticker_isAnomaly(ctx, field)
			case "isStale":
				return ec.fieldContext_Ticker_isStale(ctx, field)
			case "tradeUrl":
				return ec.fieldContext_Ticker_tradeUrl(ctx, field)
			case "tokenInfoUrl":
				return ec.fieldContext_Ticker_tokenInfoUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ticker", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_tradingPairs(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_tradingPairs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Venue().TradingPairs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*entities.TradingPair)
	fc.Result = res
	return ec.marshalNTradingPair2githubcomomigagroupomigasrcvenuesharedentitiesTradingPair(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_tradingPairs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TradingPair_id(ctx, field)
			case "symbol":
				return ec.fieldContext_TradingPair_symbol(ctx, field)
			case "base":
				return ec.fieldContext_TradingPair_base(ctx, field)
			case "basePriceMinPrecision":
				return ec.fieldContext_TradingPair_basePriceMinPrecision(ctx, field)
			case "basePriceMaxPrecision":
				return ec.fieldContext_TradingPair_basePriceMaxPrecision(ctx, field)
			case "baseQuantityMinPrecision":
				return ec.fieldContext_TradingPair_baseQuantityMinPrecision(ctx, field)
			case "baseQuantityMaxPrecision":
				return ec.fieldContext_TradingPair_baseQuantityMaxPrecision(ctx, field)
			case "counter":
				return ec.fieldContext_TradingPair_counter(ctx, field)
			case "counterPriceMinPrecision":
				return ec.fieldContext_TradingPair_counterPriceMinPrecision(ctx, field)
			case "counterPriceMaxPrecision":
				return ec.fieldContext_TradingPair_counterPriceMaxPrecision(ctx, field)
			case "counterQuantityMinPrecision":
				return ec.fieldContext_TradingPair_counterQuantityMinPrecision(ctx, field)
			case "counterQuantityMaxPrecision":
				return ec.fieldContext_TradingPair_counterQuantityMaxPrecision(ctx, field)
			case "markets":
				return ec.fieldContext_TradingPair_markets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TradingPair", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_markets(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_markets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Venue().Markets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*entities.Market)
	fc.Result = res
	return ec.marshalNMarket2githubcomomigagroupomigasrcvenuesharedentitiesMarket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_markets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Market_id(ctx, field)
			case "name":
				return ec.fieldContext_Market_name(ctx, field)
			case "type":
				return ec.fieldContext_Market_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Market", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_makerFee(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_makerFee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MakerFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_makerFee(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_takerFee(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_takerFee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TakerFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_takerFee(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_spreadFee(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_spreadFee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpreadFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_spreadFee(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Venue_supportAPI(ctx context.Context, field graphql.CollectedField, obj *entities.Venue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Venue_supportAPI(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupportAPI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Venue_supportAPI(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Venue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VenueConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *entities.VenueConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VenueConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entities.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomomigagroupomigasrcvenuesharedentitiesPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VenueConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VenueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VenueConnection_edges(ctx context.Context, field graphql.CollectedField, obj *entities.VenueConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VenueConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.VenueEdge)
	fc.Result = res
	return ec.marshalOVenueEdge2githubcomomigagroupomigasrcvenuesharedentitiesVenueEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VenueConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VenueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_VenueEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_VenueEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VenueEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VenueConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *entities.VenueConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VenueConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VenueConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VenueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VenueEdge_node(ctx context.Context, field graphql.CollectedField, obj *entities.VenueEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VenueEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Venue)
	fc.Result = res
	return ec.marshalOVenue2githubcomomigagroupomigasrcvenuesharedentitiesVenue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VenueEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VenueEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Venue_id(ctx, field)
			case "venueId":
				return ec.fieldContext_Venue_venueId(ctx, field)
			case "type":
				return ec.fieldContext_Venue_type(ctx, field)
			case "name":
				return ec.fieldContext_Venue_name(ctx, field)
			case "yearEstablished":
				return ec.fieldContext_Venue_yearEstablished(ctx, field)
			case "country":
				return ec.fieldContext_Venue_country(ctx, field)
			case "image":
				return ec.fieldContext_Venue_image(ctx, field)
			case "links":
				return ec.fieldContext_Venue_links(ctx, field)
			case "hasTradingIncentive":
				return ec.fieldContext_Venue_hasTradingIncentive(ctx, field)
			case "centralized":
				return ec.fieldContext_Venue_centralized(ctx, field)
			case "publicNotice":
				return ec.fieldContext_Venue_publicNotice(ctx, field)
			case "alertNotice":
				return ec.fieldContext_Venue_alertNotice(ctx, field)
			case "trustScore":
				return ec.fieldContext_Venue_trustScore(ctx, field)
			case "trustScoreRank":
				return ec.fieldContext_Venue_trustScoreRank(ctx, field)
			case "tradeVolume24hBtc":
				return ec.fieldContext_Venue_tradeVolume24hBtc(ctx, field)
			case "tradeVolume24hBtcNormalized":
				return ec.fieldContext_Venue_tradeVolume24hBtcNormalized(ctx, field)
			case "tickers":
				return ec.fieldContext_Venue_tickers(ctx, field)
			case "tradingPairs":
				return ec.fieldContext_Venue_tradingPairs(ctx, field)
			case "markets":
				return ec.fieldContext_Venue_markets(ctx, field)
			case "makerFee":
				return ec.fieldContext_Venue_makerFee(ctx, field)
			case "takerFee":
				return ec.fieldContext_Venue_takerFee(ctx, field)
			case "spreadFee":
				return ec.fieldContext_Venue_spreadFee(ctx, field)
			case "supportAPI":
				return ec.fieldContext_Venue_supportAPI(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Venue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VenueEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *entities.VenueEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VenueEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entities.Cursor)
	fc.Result = res
	return ec.marshalNCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VenueEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VenueEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCurrencyOrder(ctx context.Context, obj interface{}) (entities.CurrencyOrder, error) {
	var it entities.CurrencyOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomomigagroupomigasrcvenuesharedentitiesOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalOCurrencyOrderField2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCurrencyWhereInput(ctx context.Context, obj interface{}) (entities.CurrencyWhereInput, error) {
	var it entities.CurrencyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "symbol", "symbolNEQ", "symbolIn", "symbolNotIn", "symbolGT", "symbolGTE", "symbolLT", "symbolLTE", "symbolContains", "symbolHasPrefix", "symbolHasSuffix", "symbolEqualFold", "symbolContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameIsNil", "nameNotNil", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "hasCurrencyBase", "hasCurrencyBaseWith", "hasCurrencyCounter", "hasCurrencyCounterWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbol":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbol"))
			it.Symbol, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNEQ"))
			it.SymbolNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolIn"))
			it.SymbolIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNotIn"))
			it.SymbolNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGT"))
			it.SymbolGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGTE"))
			it.SymbolGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLT"))
			it.SymbolLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLTE"))
			it.SymbolLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContains"))
			it.SymbolContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasPrefix"))
			it.SymbolHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasSuffix"))
			it.SymbolHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolEqualFold"))
			it.SymbolEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContainsFold"))
			it.SymbolContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIsNil"))
			it.NameIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotNil"))
			it.NameNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CurrencyWhereInput().Type(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CurrencyWhereInput().TypeNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CurrencyWhereInput().TypeIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CurrencyWhereInput().TypeNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "hasCurrencyBase":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyBase"))
			it.HasCurrencyBase, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCurrencyBaseWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyBaseWith"))
			it.HasCurrencyBaseWith, err = ec.unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCurrencyCounter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyCounter"))
			it.HasCurrencyCounter, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCurrencyCounterWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCurrencyCounterWith"))
			it.HasCurrencyCounterWith, err = ec.unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMarketWhereInput(ctx context.Context, obj interface{}) (entities.MarketWhereInput, error) {
	var it entities.MarketWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "hasVenue", "hasVenueWith", "hasTradingPair", "hasTradingPairWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.MarketWhereInput().Type(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.MarketWhereInput().TypeNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.MarketWhereInput().TypeIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.MarketWhereInput().TypeNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "hasVenue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVenue"))
			it.HasVenue, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVenueWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVenueWith"))
			it.HasVenueWith, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingPair":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingPair"))
			it.HasTradingPair, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingPairWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingPairWith"))
			it.HasTradingPairWith, err = ec.unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOutboxWhereInput(ctx context.Context, obj interface{}) (entities.OutboxWhereInput, error) {
	var it entities.OutboxWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "timestamp", "timestampNEQ", "timestampIn", "timestampNotIn", "timestampGT", "timestampGTE", "timestampLT", "timestampLTE", "topic", "topicNEQ", "topicIn", "topicNotIn", "topicGT", "topicGTE", "topicLT", "topicLTE", "topicContains", "topicHasPrefix", "topicHasSuffix", "topicEqualFold", "topicContainsFold", "key", "keyNEQ", "keyIn", "keyNotIn", "keyGT", "keyGTE", "keyLT", "keyLTE", "keyContains", "keyHasPrefix", "keyHasSuffix", "keyEqualFold", "keyContainsFold", "retryCount", "retryCountNEQ", "retryCountIn", "retryCountNotIn", "retryCountGT", "retryCountGTE", "retryCountLT", "retryCountLTE", "status", "statusNEQ", "statusIn", "statusNotIn", "lastRetry", "lastRetryNEQ", "lastRetryIn", "lastRetryNotIn", "lastRetryGT", "lastRetryGTE", "lastRetryLT", "lastRetryLTE", "lastRetryIsNil", "lastRetryNotNil"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOOutboxWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesOutboxWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOOutboxWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesOutboxWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOOutboxWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesOutboxWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestamp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestamp"))
			it.Timestamp, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNEQ"))
			it.TimestampNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampIn"))
			it.TimestampIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNotIn"))
			it.TimestampNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGT"))
			it.TimestampGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGTE"))
			it.TimestampGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLT"))
			it.TimestampLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLTE"))
			it.TimestampLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "topic":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topic"))
			it.Topic, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicNEQ"))
			it.TopicNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicIn"))
			it.TopicIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicNotIn"))
			it.TopicNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicGT"))
			it.TopicGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicGTE"))
			it.TopicGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicLT"))
			it.TopicLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicLTE"))
			it.TopicLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicContains"))
			it.TopicContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicHasPrefix"))
			it.TopicHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicHasSuffix"))
			it.TopicHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicEqualFold"))
			it.TopicEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "topicContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topicContainsFold"))
			it.TopicContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			it.Key, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyNEQ"))
			it.KeyNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyIn"))
			it.KeyIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyNotIn"))
			it.KeyNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyGT"))
			it.KeyGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyGTE"))
			it.KeyGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyLT"))
			it.KeyLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyLTE"))
			it.KeyLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyContains"))
			it.KeyContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyHasPrefix"))
			it.KeyHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyHasSuffix"))
			it.KeyHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyEqualFold"))
			it.KeyEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "keyContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyContainsFold"))
			it.KeyContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCount"))
			it.RetryCount, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCountNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCountNEQ"))
			it.RetryCountNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCountIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCountIn"))
			it.RetryCountIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCountNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCountNotIn"))
			it.RetryCountNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCountGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCountGT"))
			it.RetryCountGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCountGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCountGTE"))
			it.RetryCountGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCountLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCountLT"))
			it.RetryCountLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "retryCountLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryCountLTE"))
			it.RetryCountLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OutboxWhereInput().Status(ctx, &it, data); err != nil {
				return it, err
			}
		case "statusNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNEQ"))
			data, err := ec.unmarshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OutboxWhereInput().StatusNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "statusIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusIn"))
			data, err := ec.unmarshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OutboxWhereInput().StatusIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "statusNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNotIn"))
			data, err := ec.unmarshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OutboxWhereInput().StatusNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lastRetry":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetry"))
			it.LastRetry, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryNEQ"))
			it.LastRetryNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryIn"))
			it.LastRetryIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryNotIn"))
			it.LastRetryNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryGT"))
			it.LastRetryGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryGTE"))
			it.LastRetryGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryLT"))
			it.LastRetryLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryLTE"))
			it.LastRetryLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryIsNil"))
			it.LastRetryIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastRetryNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastRetryNotNil"))
			it.LastRetryNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTickerWhereInput(ctx context.Context, obj interface{}) (entities.TickerWhereInput, error) {
	var it entities.TickerWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "base", "baseNEQ", "baseIn", "baseNotIn", "baseGT", "baseGTE", "baseLT", "baseLTE", "baseContains", "baseHasPrefix", "baseHasSuffix", "baseEqualFold", "baseContainsFold", "baseCoinID", "baseCoinIDNEQ", "baseCoinIDIn", "baseCoinIDNotIn", "baseCoinIDGT", "baseCoinIDGTE", "baseCoinIDLT", "baseCoinIDLTE", "baseCoinIDContains", "baseCoinIDHasPrefix", "baseCoinIDHasSuffix", "baseCoinIDIsNil", "baseCoinIDNotNil", "baseCoinIDEqualFold", "baseCoinIDContainsFold", "counter", "counterNEQ", "counterIn", "counterNotIn", "counterGT", "counterGTE", "counterLT", "counterLTE", "counterContains", "counterHasPrefix", "counterHasSuffix", "counterEqualFold", "counterContainsFold", "counterCoinID", "counterCoinIDNEQ", "counterCoinIDIn", "counterCoinIDNotIn", "counterCoinIDGT", "counterCoinIDGTE", "counterCoinIDLT", "counterCoinIDLTE", "counterCoinIDContains", "counterCoinIDHasPrefix", "counterCoinIDHasSuffix", "counterCoinIDIsNil", "counterCoinIDNotNil", "counterCoinIDEqualFold", "counterCoinIDContainsFold", "last", "lastNEQ", "lastIn", "lastNotIn", "lastGT", "lastGTE", "lastLT", "lastLTE", "lastIsNil", "lastNotNil", "volume", "volumeNEQ", "volumeIn", "volumeNotIn", "volumeGT", "volumeGTE", "volumeLT", "volumeLTE", "volumeIsNil", "volumeNotNil", "trustScore", "trustScoreNEQ", "trustScoreIn", "trustScoreNotIn", "trustScoreGT", "trustScoreGTE", "trustScoreLT", "trustScoreLTE", "trustScoreContains", "trustScoreHasPrefix", "trustScoreHasSuffix", "trustScoreIsNil", "trustScoreNotNil", "trustScoreEqualFold", "trustScoreContainsFold", "bidAskSpreadPercentage", "bidAskSpreadPercentageNEQ", "bidAskSpreadPercentageIn", "bidAskSpreadPercentageNotIn", "bidAskSpreadPercentageGT", "bidAskSpreadPercentageGTE", "bidAskSpreadPercentageLT", "bidAskSpreadPercentageLTE", "bidAskSpreadPercentageIsNil", "bidAskSpreadPercentageNotNil", "timestamp", "timestampNEQ", "timestampIn", "timestampNotIn", "timestampGT", "timestampGTE", "timestampLT", "timestampLTE", "timestampIsNil", "timestampNotNil", "lastTradedAt", "lastTradedAtNEQ", "lastTradedAtIn", "lastTradedAtNotIn", "lastTradedAtGT", "lastTradedAtGTE", "lastTradedAtLT", "lastTradedAtLTE", "lastTradedAtIsNil", "lastTradedAtNotNil", "lastFetchAt", "lastFetchAtNEQ", "lastFetchAtIn", "lastFetchAtNotIn", "lastFetchAtGT", "lastFetchAtGTE", "lastFetchAtLT", "lastFetchAtLTE", "lastFetchAtIsNil", "lastFetchAtNotNil", "isAnomaly", "isAnomalyNEQ", "isAnomalyIsNil", "isAnomalyNotNil", "isStale", "isStaleNEQ", "isStaleIsNil", "isStaleNotNil", "tradeURL", "tradeURLNEQ", "tradeURLIn", "tradeURLNotIn", "tradeURLGT", "tradeURLGTE", "tradeURLLT", "tradeURLLTE", "tradeURLContains", "tradeURLHasPrefix", "tradeURLHasSuffix", "tradeURLIsNil", "tradeURLNotNil", "tradeURLEqualFold", "tradeURLContainsFold", "tokenInfoURL", "tokenInfoURLNEQ", "tokenInfoURLIn", "tokenInfoURLNotIn", "tokenInfoURLGT", "tokenInfoURLGTE", "tokenInfoURLLT", "tokenInfoURLLTE", "tokenInfoURLContains", "tokenInfoURLHasPrefix", "tokenInfoURLHasSuffix", "tokenInfoURLIsNil", "tokenInfoURLNotNil", "tokenInfoURLEqualFold", "tokenInfoURLContainsFold", "hasVenue", "hasVenueWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "base":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("base"))
			it.Base, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseNEQ"))
			it.BaseNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseIn"))
			it.BaseIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseNotIn"))
			it.BaseNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseGT"))
			it.BaseGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseGTE"))
			it.BaseGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseLT"))
			it.BaseLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseLTE"))
			it.BaseLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseContains"))
			it.BaseContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseHasPrefix"))
			it.BaseHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseHasSuffix"))
			it.BaseHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseEqualFold"))
			it.BaseEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseContainsFold"))
			it.BaseContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinID"))
			it.BaseCoinID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDNEQ"))
			it.BaseCoinIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDIn"))
			it.BaseCoinIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDNotIn"))
			it.BaseCoinIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDGT"))
			it.BaseCoinIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDGTE"))
			it.BaseCoinIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDLT"))
			it.BaseCoinIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDLTE"))
			it.BaseCoinIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDContains"))
			it.BaseCoinIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDHasPrefix"))
			it.BaseCoinIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDHasSuffix"))
			it.BaseCoinIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDIsNil"))
			it.BaseCoinIDIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDNotNil"))
			it.BaseCoinIDNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDEqualFold"))
			it.BaseCoinIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseCoinIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseCoinIDContainsFold"))
			it.BaseCoinIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counter"))
			it.Counter, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterNEQ"))
			it.CounterNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterIn"))
			it.CounterIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterNotIn"))
			it.CounterNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterGT"))
			it.CounterGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterGTE"))
			it.CounterGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterLT"))
			it.CounterLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterLTE"))
			it.CounterLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterContains"))
			it.CounterContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterHasPrefix"))
			it.CounterHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterHasSuffix"))
			it.CounterHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterEqualFold"))
			it.CounterEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterContainsFold"))
			it.CounterContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinID"))
			it.CounterCoinID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDNEQ"))
			it.CounterCoinIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDIn"))
			it.CounterCoinIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDNotIn"))
			it.CounterCoinIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDGT"))
			it.CounterCoinIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDGTE"))
			it.CounterCoinIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDLT"))
			it.CounterCoinIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDLTE"))
			it.CounterCoinIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDContains"))
			it.CounterCoinIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDHasPrefix"))
			it.CounterCoinIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDHasSuffix"))
			it.CounterCoinIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDIsNil"))
			it.CounterCoinIDIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDNotNil"))
			it.CounterCoinIDNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDEqualFold"))
			it.CounterCoinIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterCoinIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterCoinIDContainsFold"))
			it.CounterCoinIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			it.Last, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNEQ"))
			it.LastNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastIn"))
			it.LastIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNotIn"))
			it.LastNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastGT"))
			it.LastGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastGTE"))
			it.LastGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastLT"))
			it.LastLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastLTE"))
			it.LastLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastIsNil"))
			it.LastIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNotNil"))
			it.LastNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "volume":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volume"))
			it.Volume, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeNEQ"))
			it.VolumeNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeIn"))
			it.VolumeIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeNotIn"))
			it.VolumeNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeGT"))
			it.VolumeGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeGTE"))
			it.VolumeGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeLT"))
			it.VolumeLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeLTE"))
			it.VolumeLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeIsNil"))
			it.VolumeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeNotNil"))
			it.VolumeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScore"))
			it.TrustScore, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreNEQ"))
			it.TrustScoreNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreIn"))
			it.TrustScoreIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreNotIn"))
			it.TrustScoreNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreGT"))
			it.TrustScoreGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreGTE"))
			it.TrustScoreGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreLT"))
			it.TrustScoreLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreLTE"))
			it.TrustScoreLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreContains"))
			it.TrustScoreContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreHasPrefix"))
			it.TrustScoreHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreHasSuffix"))
			it.TrustScoreHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreIsNil"))
			it.TrustScoreIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreNotNil"))
			it.TrustScoreNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreEqualFold"))
			it.TrustScoreEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreContainsFold"))
			it.TrustScoreContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentage":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentage"))
			it.BidAskSpreadPercentage, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageNEQ"))
			it.BidAskSpreadPercentageNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageIn"))
			it.BidAskSpreadPercentageIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageNotIn"))
			it.BidAskSpreadPercentageNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageGT"))
			it.BidAskSpreadPercentageGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageGTE"))
			it.BidAskSpreadPercentageGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageLT"))
			it.BidAskSpreadPercentageLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageLTE"))
			it.BidAskSpreadPercentageLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageIsNil"))
			it.BidAskSpreadPercentageIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "bidAskSpreadPercentageNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bidAskSpreadPercentageNotNil"))
			it.BidAskSpreadPercentageNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestamp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestamp"))
			it.Timestamp, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNEQ"))
			it.TimestampNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampIn"))
			it.TimestampIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNotIn"))
			it.TimestampNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGT"))
			it.TimestampGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGTE"))
			it.TimestampGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLT"))
			it.TimestampLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLTE"))
			it.TimestampLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampIsNil"))
			it.TimestampIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "timestampNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNotNil"))
			it.TimestampNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAt"))
			it.LastTradedAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtNEQ"))
			it.LastTradedAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtIn"))
			it.LastTradedAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtNotIn"))
			it.LastTradedAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtGT"))
			it.LastTradedAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtGTE"))
			it.LastTradedAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtLT"))
			it.LastTradedAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtLTE"))
			it.LastTradedAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtIsNil"))
			it.LastTradedAtIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastTradedAtNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastTradedAtNotNil"))
			it.LastTradedAtNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAt"))
			it.LastFetchAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtNEQ"))
			it.LastFetchAtNEQ, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtIn"))
			it.LastFetchAtIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtNotIn"))
			it.LastFetchAtNotIn, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtGT"))
			it.LastFetchAtGT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtGTE"))
			it.LastFetchAtGTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtLT"))
			it.LastFetchAtLT, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtLTE"))
			it.LastFetchAtLTE, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtIsNil"))
			it.LastFetchAtIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastFetchAtNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastFetchAtNotNil"))
			it.LastFetchAtNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAnomaly":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAnomaly"))
			it.IsAnomaly, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAnomalyNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAnomalyNEQ"))
			it.IsAnomalyNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAnomalyIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAnomalyIsNil"))
			it.IsAnomalyIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAnomalyNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAnomalyNotNil"))
			it.IsAnomalyNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isStale":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isStale"))
			it.IsStale, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isStaleNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isStaleNEQ"))
			it.IsStaleNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isStaleIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isStaleIsNil"))
			it.IsStaleIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isStaleNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isStaleNotNil"))
			it.IsStaleNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURL"))
			it.TradeURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLNEQ"))
			it.TradeURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLIn"))
			it.TradeURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLNotIn"))
			it.TradeURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLGT"))
			it.TradeURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLGTE"))
			it.TradeURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLLT"))
			it.TradeURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLLTE"))
			it.TradeURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLContains"))
			it.TradeURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLHasPrefix"))
			it.TradeURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLHasSuffix"))
			it.TradeURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLIsNil"))
			it.TradeURLIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLNotNil"))
			it.TradeURLNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLEqualFold"))
			it.TradeURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeURLContainsFold"))
			it.TradeURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURL"))
			it.TokenInfoURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLNEQ"))
			it.TokenInfoURLNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLIn"))
			it.TokenInfoURLIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLNotIn"))
			it.TokenInfoURLNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLGT"))
			it.TokenInfoURLGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLGTE"))
			it.TokenInfoURLGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLLT"))
			it.TokenInfoURLLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLLTE"))
			it.TokenInfoURLLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLContains"))
			it.TokenInfoURLContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLHasPrefix"))
			it.TokenInfoURLHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLHasSuffix"))
			it.TokenInfoURLHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLIsNil"))
			it.TokenInfoURLIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLNotNil"))
			it.TokenInfoURLNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLEqualFold"))
			it.TokenInfoURLEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tokenInfoURLContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenInfoURLContainsFold"))
			it.TokenInfoURLContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVenue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVenue"))
			it.HasVenue, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVenueWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVenueWith"))
			it.HasVenueWith, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTradingPairWhereInput(ctx context.Context, obj interface{}) (entities.TradingPairWhereInput, error) {
	var it entities.TradingPairWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "symbol", "symbolNEQ", "symbolIn", "symbolNotIn", "symbolGT", "symbolGTE", "symbolLT", "symbolLTE", "symbolContains", "symbolHasPrefix", "symbolHasSuffix", "symbolEqualFold", "symbolContainsFold", "basePriceMinPrecision", "basePriceMinPrecisionNEQ", "basePriceMinPrecisionIn", "basePriceMinPrecisionNotIn", "basePriceMinPrecisionGT", "basePriceMinPrecisionGTE", "basePriceMinPrecisionLT", "basePriceMinPrecisionLTE", "basePriceMinPrecisionIsNil", "basePriceMinPrecisionNotNil", "basePriceMaxPrecision", "basePriceMaxPrecisionNEQ", "basePriceMaxPrecisionIn", "basePriceMaxPrecisionNotIn", "basePriceMaxPrecisionGT", "basePriceMaxPrecisionGTE", "basePriceMaxPrecisionLT", "basePriceMaxPrecisionLTE", "basePriceMaxPrecisionIsNil", "basePriceMaxPrecisionNotNil", "baseQuantityMinPrecision", "baseQuantityMinPrecisionNEQ", "baseQuantityMinPrecisionIn", "baseQuantityMinPrecisionNotIn", "baseQuantityMinPrecisionGT", "baseQuantityMinPrecisionGTE", "baseQuantityMinPrecisionLT", "baseQuantityMinPrecisionLTE", "baseQuantityMinPrecisionIsNil", "baseQuantityMinPrecisionNotNil", "baseQuantityMaxPrecision", "baseQuantityMaxPrecisionNEQ", "baseQuantityMaxPrecisionIn", "baseQuantityMaxPrecisionNotIn", "baseQuantityMaxPrecisionGT", "baseQuantityMaxPrecisionGTE", "baseQuantityMaxPrecisionLT", "baseQuantityMaxPrecisionLTE", "baseQuantityMaxPrecisionIsNil", "baseQuantityMaxPrecisionNotNil", "counterPriceMinPrecision", "counterPriceMinPrecisionNEQ", "counterPriceMinPrecisionIn", "counterPriceMinPrecisionNotIn", "counterPriceMinPrecisionGT", "counterPriceMinPrecisionGTE", "counterPriceMinPrecisionLT", "counterPriceMinPrecisionLTE", "counterPriceMinPrecisionIsNil", "counterPriceMinPrecisionNotNil", "counterPriceMaxPrecision", "counterPriceMaxPrecisionNEQ", "counterPriceMaxPrecisionIn", "counterPriceMaxPrecisionNotIn", "counterPriceMaxPrecisionGT", "counterPriceMaxPrecisionGTE", "counterPriceMaxPrecisionLT", "counterPriceMaxPrecisionLTE", "counterPriceMaxPrecisionIsNil", "counterPriceMaxPrecisionNotNil", "counterQuantityMinPrecision", "counterQuantityMinPrecisionNEQ", "counterQuantityMinPrecisionIn", "counterQuantityMinPrecisionNotIn", "counterQuantityMinPrecisionGT", "counterQuantityMinPrecisionGTE", "counterQuantityMinPrecisionLT", "counterQuantityMinPrecisionLTE", "counterQuantityMinPrecisionIsNil", "counterQuantityMinPrecisionNotNil", "counterQuantityMaxPrecision", "counterQuantityMaxPrecisionNEQ", "counterQuantityMaxPrecisionIn", "counterQuantityMaxPrecisionNotIn", "counterQuantityMaxPrecisionGT", "counterQuantityMaxPrecisionGTE", "counterQuantityMaxPrecisionLT", "counterQuantityMaxPrecisionLTE", "counterQuantityMaxPrecisionIsNil", "counterQuantityMaxPrecisionNotNil", "hasVenue", "hasVenueWith", "hasBase", "hasBaseWith", "hasCounter", "hasCounterWith", "hasMarket", "hasMarketWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbol":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbol"))
			it.Symbol, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNEQ"))
			it.SymbolNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolIn"))
			it.SymbolIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolNotIn"))
			it.SymbolNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGT"))
			it.SymbolGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolGTE"))
			it.SymbolGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLT"))
			it.SymbolLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolLTE"))
			it.SymbolLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContains"))
			it.SymbolContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasPrefix"))
			it.SymbolHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolHasSuffix"))
			it.SymbolHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolEqualFold"))
			it.SymbolEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "symbolContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbolContainsFold"))
			it.SymbolContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecision"))
			it.BasePriceMinPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionNEQ"))
			it.BasePriceMinPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionIn"))
			it.BasePriceMinPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionNotIn"))
			it.BasePriceMinPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionGT"))
			it.BasePriceMinPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionGTE"))
			it.BasePriceMinPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionLT"))
			it.BasePriceMinPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionLTE"))
			it.BasePriceMinPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionIsNil"))
			it.BasePriceMinPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMinPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMinPrecisionNotNil"))
			it.BasePriceMinPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecision"))
			it.BasePriceMaxPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionNEQ"))
			it.BasePriceMaxPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionIn"))
			it.BasePriceMaxPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionNotIn"))
			it.BasePriceMaxPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionGT"))
			it.BasePriceMaxPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionGTE"))
			it.BasePriceMaxPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionLT"))
			it.BasePriceMaxPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionLTE"))
			it.BasePriceMaxPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionIsNil"))
			it.BasePriceMaxPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "basePriceMaxPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basePriceMaxPrecisionNotNil"))
			it.BasePriceMaxPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecision"))
			it.BaseQuantityMinPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionNEQ"))
			it.BaseQuantityMinPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionIn"))
			it.BaseQuantityMinPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionNotIn"))
			it.BaseQuantityMinPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionGT"))
			it.BaseQuantityMinPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionGTE"))
			it.BaseQuantityMinPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionLT"))
			it.BaseQuantityMinPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionLTE"))
			it.BaseQuantityMinPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionIsNil"))
			it.BaseQuantityMinPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMinPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMinPrecisionNotNil"))
			it.BaseQuantityMinPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecision"))
			it.BaseQuantityMaxPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionNEQ"))
			it.BaseQuantityMaxPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionIn"))
			it.BaseQuantityMaxPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionNotIn"))
			it.BaseQuantityMaxPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionGT"))
			it.BaseQuantityMaxPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionGTE"))
			it.BaseQuantityMaxPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionLT"))
			it.BaseQuantityMaxPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionLTE"))
			it.BaseQuantityMaxPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionIsNil"))
			it.BaseQuantityMaxPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "baseQuantityMaxPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseQuantityMaxPrecisionNotNil"))
			it.BaseQuantityMaxPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecision"))
			it.CounterPriceMinPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionNEQ"))
			it.CounterPriceMinPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionIn"))
			it.CounterPriceMinPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionNotIn"))
			it.CounterPriceMinPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionGT"))
			it.CounterPriceMinPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionGTE"))
			it.CounterPriceMinPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionLT"))
			it.CounterPriceMinPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionLTE"))
			it.CounterPriceMinPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionIsNil"))
			it.CounterPriceMinPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMinPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMinPrecisionNotNil"))
			it.CounterPriceMinPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecision"))
			it.CounterPriceMaxPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionNEQ"))
			it.CounterPriceMaxPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionIn"))
			it.CounterPriceMaxPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionNotIn"))
			it.CounterPriceMaxPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionGT"))
			it.CounterPriceMaxPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionGTE"))
			it.CounterPriceMaxPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionLT"))
			it.CounterPriceMaxPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionLTE"))
			it.CounterPriceMaxPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionIsNil"))
			it.CounterPriceMaxPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterPriceMaxPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterPriceMaxPrecisionNotNil"))
			it.CounterPriceMaxPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecision"))
			it.CounterQuantityMinPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionNEQ"))
			it.CounterQuantityMinPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionIn"))
			it.CounterQuantityMinPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionNotIn"))
			it.CounterQuantityMinPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionGT"))
			it.CounterQuantityMinPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionGTE"))
			it.CounterQuantityMinPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionLT"))
			it.CounterQuantityMinPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionLTE"))
			it.CounterQuantityMinPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionIsNil"))
			it.CounterQuantityMinPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMinPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMinPrecisionNotNil"))
			it.CounterQuantityMinPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecision"))
			it.CounterQuantityMaxPrecision, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionNEQ"))
			it.CounterQuantityMaxPrecisionNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionIn"))
			it.CounterQuantityMaxPrecisionIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionNotIn"))
			it.CounterQuantityMaxPrecisionNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionGT"))
			it.CounterQuantityMaxPrecisionGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionGTE"))
			it.CounterQuantityMaxPrecisionGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionLT"))
			it.CounterQuantityMaxPrecisionLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionLTE"))
			it.CounterQuantityMaxPrecisionLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionIsNil"))
			it.CounterQuantityMaxPrecisionIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "counterQuantityMaxPrecisionNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("counterQuantityMaxPrecisionNotNil"))
			it.CounterQuantityMaxPrecisionNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVenue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVenue"))
			it.HasVenue, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVenueWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVenueWith"))
			it.HasVenueWith, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBase":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBase"))
			it.HasBase, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasBaseWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBaseWith"))
			it.HasBaseWith, err = ec.unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCounter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCounter"))
			it.HasCounter, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCounterWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCounterWith"))
			it.HasCounterWith, err = ec.unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMarket":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMarket"))
			it.HasMarket, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMarketWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMarketWith"))
			it.HasMarketWith, err = ec.unmarshalOMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVenueOrder(ctx context.Context, obj interface{}) (entities.VenueOrder, error) {
	var it entities.VenueOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2githubcomomigagroupomigasrcvenuesharedentitiesOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalOVenueOrderField2githubcomomigagroupomigasrcvenuesharedentitiesVenueOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVenueWhereInput(ctx context.Context, obj interface{}) (entities.VenueWhereInput, error) {
	var it entities.VenueWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "venueID", "venueIDNEQ", "venueIDIn", "venueIDNotIn", "venueIDGT", "venueIDGTE", "venueIDLT", "venueIDLTE", "venueIDContains", "venueIDHasPrefix", "venueIDHasSuffix", "venueIDEqualFold", "venueIDContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameIsNil", "nameNotNil", "nameEqualFold", "nameContainsFold", "yearEstablished", "yearEstablishedNEQ", "yearEstablishedIn", "yearEstablishedNotIn", "yearEstablishedGT", "yearEstablishedGTE", "yearEstablishedLT", "yearEstablishedLTE", "yearEstablishedIsNil", "yearEstablishedNotNil", "country", "countryNEQ", "countryIn", "countryNotIn", "countryGT", "countryGTE", "countryLT", "countryLTE", "countryContains", "countryHasPrefix", "countryHasSuffix", "countryIsNil", "countryNotNil", "countryEqualFold", "countryContainsFold", "image", "imageNEQ", "imageIn", "imageNotIn", "imageGT", "imageGTE", "imageLT", "imageLTE", "imageContains", "imageHasPrefix", "imageHasSuffix", "imageIsNil", "imageNotNil", "imageEqualFold", "imageContainsFold", "hasTradingIncentive", "hasTradingIncentiveNEQ", "hasTradingIncentiveIsNil", "hasTradingIncentiveNotNil", "centralized", "centralizedNEQ", "centralizedIsNil", "centralizedNotNil", "publicNotice", "publicNoticeNEQ", "publicNoticeIn", "publicNoticeNotIn", "publicNoticeGT", "publicNoticeGTE", "publicNoticeLT", "publicNoticeLTE", "publicNoticeContains", "publicNoticeHasPrefix", "publicNoticeHasSuffix", "publicNoticeIsNil", "publicNoticeNotNil", "publicNoticeEqualFold", "publicNoticeContainsFold", "alertNotice", "alertNoticeNEQ", "alertNoticeIn", "alertNoticeNotIn", "alertNoticeGT", "alertNoticeGTE", "alertNoticeLT", "alertNoticeLTE", "alertNoticeContains", "alertNoticeHasPrefix", "alertNoticeHasSuffix", "alertNoticeIsNil", "alertNoticeNotNil", "alertNoticeEqualFold", "alertNoticeContainsFold", "trustScore", "trustScoreNEQ", "trustScoreIn", "trustScoreNotIn", "trustScoreGT", "trustScoreGTE", "trustScoreLT", "trustScoreLTE", "trustScoreIsNil", "trustScoreNotNil", "trustScoreRank", "trustScoreRankNEQ", "trustScoreRankIn", "trustScoreRankNotIn", "trustScoreRankGT", "trustScoreRankGTE", "trustScoreRankLT", "trustScoreRankLTE", "trustScoreRankIsNil", "trustScoreRankNotNil", "tradeVolume24hBtc", "tradeVolume24hBtcNEQ", "tradeVolume24hBtcIn", "tradeVolume24hBtcNotIn", "tradeVolume24hBtcGT", "tradeVolume24hBtcGTE", "tradeVolume24hBtcLT", "tradeVolume24hBtcLTE", "tradeVolume24hBtcIsNil", "tradeVolume24hBtcNotNil", "tradeVolume24hBtcNormalized", "tradeVolume24hBtcNormalizedNEQ", "tradeVolume24hBtcNormalizedIn", "tradeVolume24hBtcNormalizedNotIn", "tradeVolume24hBtcNormalizedGT", "tradeVolume24hBtcNormalizedGTE", "tradeVolume24hBtcNormalizedLT", "tradeVolume24hBtcNormalizedLTE", "tradeVolume24hBtcNormalizedIsNil", "tradeVolume24hBtcNormalizedNotNil", "makerFee", "makerFeeNEQ", "makerFeeIn", "makerFeeNotIn", "makerFeeGT", "makerFeeGTE", "makerFeeLT", "makerFeeLTE", "makerFeeIsNil", "makerFeeNotNil", "takerFee", "takerFeeNEQ", "takerFeeIn", "takerFeeNotIn", "takerFeeGT", "takerFeeGTE", "takerFeeLT", "takerFeeLTE", "takerFeeIsNil", "takerFeeNotNil", "spreadFee", "spreadFeeNEQ", "spreadFeeIsNil", "spreadFeeNotNil", "supportAPI", "supportAPINEQ", "supportAPIIsNil", "supportAPINotNil", "hasTicker", "hasTickerWith", "hasTradingPair", "hasTradingPairWith", "hasMarket", "hasMarketWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueID"))
			it.VenueID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDNEQ"))
			it.VenueIDNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDIn"))
			it.VenueIDIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDNotIn"))
			it.VenueIDNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDGT"))
			it.VenueIDGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDGTE"))
			it.VenueIDGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDLT"))
			it.VenueIDLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDLTE"))
			it.VenueIDLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDContains"))
			it.VenueIDContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDHasPrefix"))
			it.VenueIDHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDHasSuffix"))
			it.VenueIDHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDEqualFold"))
			it.VenueIDEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "venueIDContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("venueIDContainsFold"))
			it.VenueIDContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.VenueWhereInput().Type(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.VenueWhereInput().TypeNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.VenueWhereInput().TypeIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "typeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.VenueWhereInput().TypeNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIsNil"))
			it.NameIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotNil"))
			it.NameNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablished":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablished"))
			it.YearEstablished, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedNEQ"))
			it.YearEstablishedNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedIn"))
			it.YearEstablishedIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedNotIn"))
			it.YearEstablishedNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedGT"))
			it.YearEstablishedGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedGTE"))
			it.YearEstablishedGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedLT"))
			it.YearEstablishedLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedLTE"))
			it.YearEstablishedLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedIsNil"))
			it.YearEstablishedIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "yearEstablishedNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("yearEstablishedNotNil"))
			it.YearEstablishedNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "country":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			it.Country, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryNEQ"))
			it.CountryNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryIn"))
			it.CountryIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryNotIn"))
			it.CountryNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryGT"))
			it.CountryGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryGTE"))
			it.CountryGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryLT"))
			it.CountryLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryLTE"))
			it.CountryLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryContains"))
			it.CountryContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryHasPrefix"))
			it.CountryHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryHasSuffix"))
			it.CountryHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryIsNil"))
			it.CountryIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryNotNil"))
			it.CountryNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryEqualFold"))
			it.CountryEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "countryContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countryContainsFold"))
			it.CountryContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "image":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image"))
			it.Image, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageNEQ"))
			it.ImageNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageIn"))
			it.ImageIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageNotIn"))
			it.ImageNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageGT"))
			it.ImageGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageGTE"))
			it.ImageGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageLT"))
			it.ImageLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageLTE"))
			it.ImageLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageContains"))
			it.ImageContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageHasPrefix"))
			it.ImageHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageHasSuffix"))
			it.ImageHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageIsNil"))
			it.ImageIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageNotNil"))
			it.ImageNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageEqualFold"))
			it.ImageEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageContainsFold"))
			it.ImageContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingIncentive":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingIncentive"))
			it.HasTradingIncentive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingIncentiveNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingIncentiveNEQ"))
			it.HasTradingIncentiveNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingIncentiveIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingIncentiveIsNil"))
			it.HasTradingIncentiveIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingIncentiveNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingIncentiveNotNil"))
			it.HasTradingIncentiveNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "centralized":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("centralized"))
			it.Centralized, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "centralizedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("centralizedNEQ"))
			it.CentralizedNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "centralizedIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("centralizedIsNil"))
			it.CentralizedIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "centralizedNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("centralizedNotNil"))
			it.CentralizedNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNotice":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNotice"))
			it.PublicNotice, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeNEQ"))
			it.PublicNoticeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeIn"))
			it.PublicNoticeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeNotIn"))
			it.PublicNoticeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeGT"))
			it.PublicNoticeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeGTE"))
			it.PublicNoticeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeLT"))
			it.PublicNoticeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeLTE"))
			it.PublicNoticeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeContains"))
			it.PublicNoticeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeHasPrefix"))
			it.PublicNoticeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeHasSuffix"))
			it.PublicNoticeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeIsNil"))
			it.PublicNoticeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeNotNil"))
			it.PublicNoticeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeEqualFold"))
			it.PublicNoticeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "publicNoticeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNoticeContainsFold"))
			it.PublicNoticeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNotice":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNotice"))
			it.AlertNotice, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeNEQ"))
			it.AlertNoticeNEQ, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeIn"))
			it.AlertNoticeIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeNotIn"))
			it.AlertNoticeNotIn, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeGT"))
			it.AlertNoticeGT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeGTE"))
			it.AlertNoticeGTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeLT"))
			it.AlertNoticeLT, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeLTE"))
			it.AlertNoticeLTE, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeContains"))
			it.AlertNoticeContains, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeHasPrefix"))
			it.AlertNoticeHasPrefix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeHasSuffix"))
			it.AlertNoticeHasSuffix, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeIsNil"))
			it.AlertNoticeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeNotNil"))
			it.AlertNoticeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeEqualFold"))
			it.AlertNoticeEqualFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "alertNoticeContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertNoticeContainsFold"))
			it.AlertNoticeContainsFold, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScore"))
			it.TrustScore, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreNEQ"))
			it.TrustScoreNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreIn"))
			it.TrustScoreIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreNotIn"))
			it.TrustScoreNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreGT"))
			it.TrustScoreGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreGTE"))
			it.TrustScoreGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreLT"))
			it.TrustScoreLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreLTE"))
			it.TrustScoreLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreIsNil"))
			it.TrustScoreIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreNotNil"))
			it.TrustScoreNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRank":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRank"))
			it.TrustScoreRank, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankNEQ"))
			it.TrustScoreRankNEQ, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankIn"))
			it.TrustScoreRankIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankNotIn"))
			it.TrustScoreRankNotIn, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankGT"))
			it.TrustScoreRankGT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankGTE"))
			it.TrustScoreRankGTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankLT"))
			it.TrustScoreRankLT, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankLTE"))
			it.TrustScoreRankLTE, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankIsNil"))
			it.TrustScoreRankIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "trustScoreRankNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trustScoreRankNotNil"))
			it.TrustScoreRankNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtc"))
			it.TradeVolume24hBtc, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNEQ"))
			it.TradeVolume24hBtcNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcIn"))
			it.TradeVolume24hBtcIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNotIn"))
			it.TradeVolume24hBtcNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcGT"))
			it.TradeVolume24hBtcGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcGTE"))
			it.TradeVolume24hBtcGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcLT"))
			it.TradeVolume24hBtcLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcLTE"))
			it.TradeVolume24hBtcLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcIsNil"))
			it.TradeVolume24hBtcIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNotNil"))
			it.TradeVolume24hBtcNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalized":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalized"))
			it.TradeVolume24hBtcNormalized, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedNEQ"))
			it.TradeVolume24hBtcNormalizedNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedIn"))
			it.TradeVolume24hBtcNormalizedIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedNotIn"))
			it.TradeVolume24hBtcNormalizedNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedGT"))
			it.TradeVolume24hBtcNormalizedGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedGTE"))
			it.TradeVolume24hBtcNormalizedGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedLT"))
			it.TradeVolume24hBtcNormalizedLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedLTE"))
			it.TradeVolume24hBtcNormalizedLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedIsNil"))
			it.TradeVolume24hBtcNormalizedIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "tradeVolume24hBtcNormalizedNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tradeVolume24hBtcNormalizedNotNil"))
			it.TradeVolume24hBtcNormalizedNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFee":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFee"))
			it.MakerFee, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeNEQ"))
			it.MakerFeeNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeIn"))
			it.MakerFeeIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeNotIn"))
			it.MakerFeeNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeGT"))
			it.MakerFeeGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeGTE"))
			it.MakerFeeGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeLT"))
			it.MakerFeeLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeLTE"))
			it.MakerFeeLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeIsNil"))
			it.MakerFeeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "makerFeeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("makerFeeNotNil"))
			it.MakerFeeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFee":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFee"))
			it.TakerFee, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeNEQ"))
			it.TakerFeeNEQ, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeIn"))
			it.TakerFeeIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeNotIn"))
			it.TakerFeeNotIn, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeGT"))
			it.TakerFeeGT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeGTE"))
			it.TakerFeeGTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeLT"))
			it.TakerFeeLT, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeLTE"))
			it.TakerFeeLTE, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeIsNil"))
			it.TakerFeeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "takerFeeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("takerFeeNotNil"))
			it.TakerFeeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "spreadFee":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spreadFee"))
			it.SpreadFee, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "spreadFeeNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spreadFeeNEQ"))
			it.SpreadFeeNEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "spreadFeeIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spreadFeeIsNil"))
			it.SpreadFeeIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "spreadFeeNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spreadFeeNotNil"))
			it.SpreadFeeNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "supportAPI":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("supportAPI"))
			it.SupportAPI, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "supportAPINEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("supportAPINEQ"))
			it.SupportAPINEQ, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "supportAPIIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("supportAPIIsNil"))
			it.SupportAPIIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "supportAPINotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("supportAPINotNil"))
			it.SupportAPINotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTicker":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTicker"))
			it.HasTicker, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTickerWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTickerWith"))
			it.HasTickerWith, err = ec.unmarshalOTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingPair":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingPair"))
			it.HasTradingPair, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTradingPairWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTradingPairWith"))
			it.HasTradingPairWith, err = ec.unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMarket":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMarket"))
			it.HasMarket, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMarketWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMarketWith"))
			it.HasMarketWith, err = ec.unmarshalOMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj entities.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *entities.Currency:
		if obj == nil {
			return graphql.Null
		}
		return ec._Currency(ctx, sel, obj)
	case *entities.Venue:
		if obj == nil {
			return graphql.Null
		}
		return ec._Venue(ctx, sel, obj)
	case *entities.Ticker:
		if obj == nil {
			return graphql.Null
		}
		return ec._Ticker(ctx, sel, obj)
	case *entities.TradingPair:
		if obj == nil {
			return graphql.Null
		}
		return ec._TradingPair(ctx, sel, obj)
	case *entities.Market:
		if obj == nil {
			return graphql.Null
		}
		return ec._Market(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var convertedDetailsImplementors = []string{"ConvertedDetails"}

func (ec *executionContext) _ConvertedDetails(ctx context.Context, sel ast.SelectionSet, obj *models.ConvertedDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, convertedDetailsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConvertedDetails")
		case "btc":

			out.Values[i] = ec._ConvertedDetails_btc(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eth":

			out.Values[i] = ec._ConvertedDetails_eth(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "usd":

			out.Values[i] = ec._ConvertedDetails_usd(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var currencyImplementors = []string{"Currency", "Node"}

func (ec *executionContext) _Currency(ctx context.Context, sel ast.SelectionSet, obj *entities.Currency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, currencyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Currency")
		case "id":

			out.Values[i] = ec._Currency_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "symbol":

			out.Values[i] = ec._Currency_symbol(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Currency_name(ctx, field, obj)

		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Currency_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var currencyConnectionImplementors = []string{"CurrencyConnection"}

func (ec *executionContext) _CurrencyConnection(ctx context.Context, sel ast.SelectionSet, obj *entities.CurrencyConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, currencyConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CurrencyConnection")
		case "pageInfo":

			out.Values[i] = ec._CurrencyConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":

			out.Values[i] = ec._CurrencyConnection_edges(ctx, field, obj)

		case "totalCount":

			out.Values[i] = ec._CurrencyConnection_totalCount(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var currencyEdgeImplementors = []string{"CurrencyEdge"}

func (ec *executionContext) _CurrencyEdge(ctx context.Context, sel ast.SelectionSet, obj *entities.CurrencyEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, currencyEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CurrencyEdge")
		case "node":

			out.Values[i] = ec._CurrencyEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._CurrencyEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var linksImplementors = []string{"Links"}

func (ec *executionContext) _Links(ctx context.Context, sel ast.SelectionSet, obj *models.Links) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linksImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Links")
		case "website":

			out.Values[i] = ec._Links_website(ctx, field, obj)

		case "facebook":

			out.Values[i] = ec._Links_facebook(ctx, field, obj)

		case "reddit":

			out.Values[i] = ec._Links_reddit(ctx, field, obj)

		case "twitter":

			out.Values[i] = ec._Links_twitter(ctx, field, obj)

		case "slack":

			out.Values[i] = ec._Links_slack(ctx, field, obj)

		case "telegram":

			out.Values[i] = ec._Links_telegram(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var marketImplementors = []string{"Market", "Node"}

func (ec *executionContext) _Market(ctx context.Context, sel ast.SelectionSet, obj *entities.Market) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, marketImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Market")
		case "id":

			out.Values[i] = ec._Market_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Market_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Market_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entities.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "currency":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currency(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "currencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currencies(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "venue":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_venue(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "venues":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_venues(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "_service":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tickerImplementors = []string{"Ticker", "Node"}

func (ec *executionContext) _Ticker(ctx context.Context, sel ast.SelectionSet, obj *entities.Ticker) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tickerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Ticker")
		case "id":

			out.Values[i] = ec._Ticker_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "base":

			out.Values[i] = ec._Ticker_base(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "baseCoinId":

			out.Values[i] = ec._Ticker_baseCoinId(ctx, field, obj)

		case "counter":

			out.Values[i] = ec._Ticker_counter(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "counterCoinId":

			out.Values[i] = ec._Ticker_counterCoinId(ctx, field, obj)

		case "market":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ticker_market(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "last":

			out.Values[i] = ec._Ticker_last(ctx, field, obj)

		case "volume":

			out.Values[i] = ec._Ticker_volume(ctx, field, obj)

		case "convertedLast":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ticker_convertedLast(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "convertedVolume":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ticker_convertedVolume(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "trustScore":

			out.Values[i] = ec._Ticker_trustScore(ctx, field, obj)

		case "bidAskSpreadPercentage":

			out.Values[i] = ec._Ticker_bidAskSpreadPercentage(ctx, field, obj)

		case "timestamp":

			out.Values[i] = ec._Ticker_timestamp(ctx, field, obj)

		case "lastTradedAt":

			out.Values[i] = ec._Ticker_lastTradedAt(ctx, field, obj)

		case "lastFetchAt":

			out.Values[i] = ec._Ticker_lastFetchAt(ctx, field, obj)

		case "isAnomaly":

			out.Values[i] = ec._Ticker_isAnomaly(ctx, field, obj)

		case "isStale":

			out.Values[i] = ec._Ticker_isStale(ctx, field, obj)

		case "tradeUrl":

			out.Values[i] = ec._Ticker_tradeUrl(ctx, field, obj)

		case "tokenInfoUrl":

			out.Values[i] = ec._Ticker_tokenInfoUrl(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tickerMarketImplementors = []string{"TickerMarket"}

func (ec *executionContext) _TickerMarket(ctx context.Context, sel ast.SelectionSet, obj *models.TickerMarket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tickerMarketImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TickerMarket")
		case "hasTradingIncentive":

			out.Values[i] = ec._TickerMarket_hasTradingIncentive(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "identifier":

			out.Values[i] = ec._TickerMarket_identifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._TickerMarket_name(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tradingPairImplementors = []string{"TradingPair", "Node"}

func (ec *executionContext) _TradingPair(ctx context.Context, sel ast.SelectionSet, obj *entities.TradingPair) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tradingPairImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TradingPair")
		case "id":

			out.Values[i] = ec._TradingPair_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "symbol":

			out.Values[i] = ec._TradingPair_symbol(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "base":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradingPair_base(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "basePriceMinPrecision":

			out.Values[i] = ec._TradingPair_basePriceMinPrecision(ctx, field, obj)

		case "basePriceMaxPrecision":

			out.Values[i] = ec._TradingPair_basePriceMaxPrecision(ctx, field, obj)

		case "baseQuantityMinPrecision":

			out.Values[i] = ec._TradingPair_baseQuantityMinPrecision(ctx, field, obj)

		case "baseQuantityMaxPrecision":

			out.Values[i] = ec._TradingPair_baseQuantityMaxPrecision(ctx, field, obj)

		case "counter":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradingPair_counter(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "counterPriceMinPrecision":

			out.Values[i] = ec._TradingPair_counterPriceMinPrecision(ctx, field, obj)

		case "counterPriceMaxPrecision":

			out.Values[i] = ec._TradingPair_counterPriceMaxPrecision(ctx, field, obj)

		case "counterQuantityMinPrecision":

			out.Values[i] = ec._TradingPair_counterQuantityMinPrecision(ctx, field, obj)

		case "counterQuantityMaxPrecision":

			out.Values[i] = ec._TradingPair_counterQuantityMaxPrecision(ctx, field, obj)

		case "markets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TradingPair_markets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var venueImplementors = []string{"Venue", "Node"}

func (ec *executionContext) _Venue(ctx context.Context, sel ast.SelectionSet, obj *entities.Venue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, venueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Venue")
		case "id":

			out.Values[i] = ec._Venue_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "venueId":

			out.Values[i] = ec._Venue_venueId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Venue_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._Venue_name(ctx, field, obj)

		case "yearEstablished":

			out.Values[i] = ec._Venue_yearEstablished(ctx, field, obj)

		case "country":

			out.Values[i] = ec._Venue_country(ctx, field, obj)

		case "image":

			out.Values[i] = ec._Venue_image(ctx, field, obj)

		case "links":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Venue_links(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hasTradingIncentive":

			out.Values[i] = ec._Venue_hasTradingIncentive(ctx, field, obj)

		case "centralized":

			out.Values[i] = ec._Venue_centralized(ctx, field, obj)

		case "publicNotice":

			out.Values[i] = ec._Venue_publicNotice(ctx, field, obj)

		case "alertNotice":

			out.Values[i] = ec._Venue_alertNotice(ctx, field, obj)

		case "trustScore":

			out.Values[i] = ec._Venue_trustScore(ctx, field, obj)

		case "trustScoreRank":

			out.Values[i] = ec._Venue_trustScoreRank(ctx, field, obj)

		case "tradeVolume24hBtc":

			out.Values[i] = ec._Venue_tradeVolume24hBtc(ctx, field, obj)

		case "tradeVolume24hBtcNormalized":

			out.Values[i] = ec._Venue_tradeVolume24hBtcNormalized(ctx, field, obj)

		case "tickers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Venue_tickers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tradingPairs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Venue_tradingPairs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Venue_markets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "makerFee":

			out.Values[i] = ec._Venue_makerFee(ctx, field, obj)

		case "takerFee":

			out.Values[i] = ec._Venue_takerFee(ctx, field, obj)

		case "spreadFee":

			out.Values[i] = ec._Venue_spreadFee(ctx, field, obj)

		case "supportAPI":

			out.Values[i] = ec._Venue_supportAPI(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var venueConnectionImplementors = []string{"VenueConnection"}

func (ec *executionContext) _VenueConnection(ctx context.Context, sel ast.SelectionSet, obj *entities.VenueConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, venueConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VenueConnection")
		case "pageInfo":

			out.Values[i] = ec._VenueConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":

			out.Values[i] = ec._VenueConnection_edges(ctx, field, obj)

		case "totalCount":

			out.Values[i] = ec._VenueConnection_totalCount(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var venueEdgeImplementors = []string{"VenueEdge"}

func (ec *executionContext) _VenueEdge(ctx context.Context, sel ast.SelectionSet, obj *entities.VenueEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, venueEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VenueEdge")
		case "node":

			out.Values[i] = ec._VenueEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._VenueEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":

			out.Values[i] = ec.__Service_sdl(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCurrency2githubcomomigagroupomigasrcvenuesharedentitiesCurrency(ctx context.Context, sel ast.SelectionSet, v *entities.Currency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Currency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCurrencyOrder2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyOrder(ctx context.Context, v interface{}) (*entities.CurrencyOrder, error) {
	res, err := ec.unmarshalInputCurrencyOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx context.Context, v interface{}) (models.CurrencyType, error) {
	var res models.CurrencyType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx context.Context, sel ast.SelectionSet, v models.CurrencyType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx context.Context, v interface{}) (*entities.CurrencyWhereInput, error) {
	res, err := ec.unmarshalInputCurrencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx context.Context, v interface{}) (entities.Cursor, error) {
	var res entities.Cursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx context.Context, sel ast.SelectionSet, v entities.Cursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLinks2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsLinks(ctx context.Context, sel ast.SelectionSet, v models.Links) graphql.Marshaler {
	return ec._Links(ctx, sel, &v)
}

func (ec *executionContext) marshalNLinks2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsLinks(ctx context.Context, sel ast.SelectionSet, v *models.Links) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Links(ctx, sel, v)
}

func (ec *executionContext) marshalNMarket2githubcomomigagroupomigasrcvenuesharedentitiesMarket(ctx context.Context, sel ast.SelectionSet, v []*entities.Market) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarket2githubcomomigagroupomigasrcvenuesharedentitiesMarket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMarket2githubcomomigagroupomigasrcvenuesharedentitiesMarket(ctx context.Context, sel ast.SelectionSet, v *entities.Market) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Market(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx context.Context, v interface{}) (models.MarketType, error) {
	var res models.MarketType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx context.Context, sel ast.SelectionSet, v models.MarketType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx context.Context, v interface{}) (*entities.MarketWhereInput, error) {
	res, err := ec.unmarshalInputMarketWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNOrderDirection2githubcomomigagroupomigasrcvenuesharedentitiesOrderDirection(ctx context.Context, v interface{}) (entities.OrderDirection, error) {
	var res entities.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2githubcomomigagroupomigasrcvenuesharedentitiesOrderDirection(ctx context.Context, sel ast.SelectionSet, v entities.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx context.Context, v interface{}) (models.OutboxStatus, error) {
	var res models.OutboxStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx context.Context, sel ast.SelectionSet, v models.OutboxStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNOutboxWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesOutboxWhereInput(ctx context.Context, v interface{}) (*entities.OutboxWhereInput, error) {
	res, err := ec.unmarshalInputOutboxWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageInfo2githubcomomigagroupomigasrcvenuesharedentitiesPageInfo(ctx context.Context, sel ast.SelectionSet, v entities.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTicker2githubcomomigagroupomigasrcvenuesharedentitiesTicker(ctx context.Context, sel ast.SelectionSet, v []*entities.Ticker) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTicker2githubcomomigagroupomigasrcvenuesharedentitiesTicker(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTicker2githubcomomigagroupomigasrcvenuesharedentitiesTicker(ctx context.Context, sel ast.SelectionSet, v *entities.Ticker) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Ticker(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx context.Context, v interface{}) (*entities.TickerWhereInput, error) {
	res, err := ec.unmarshalInputTickerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTradingPair2githubcomomigagroupomigasrcvenuesharedentitiesTradingPair(ctx context.Context, sel ast.SelectionSet, v []*entities.TradingPair) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTradingPair2githubcomomigagroupomigasrcvenuesharedentitiesTradingPair(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTradingPair2githubcomomigagroupomigasrcvenuesharedentitiesTradingPair(ctx context.Context, sel ast.SelectionSet, v *entities.TradingPair) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TradingPair(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx context.Context, v interface{}) (*entities.TradingPairWhereInput, error) {
	res, err := ec.unmarshalInputTradingPairWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNVenueOrder2githubcomomigagroupomigasrcvenuesharedentitiesVenueOrder(ctx context.Context, v interface{}) (*entities.VenueOrder, error) {
	res, err := ec.unmarshalInputVenueOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx context.Context, v interface{}) (models.VenueType, error) {
	var res models.VenueType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx context.Context, sel ast.SelectionSet, v models.VenueType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx context.Context, v interface{}) (*entities.VenueWhereInput, error) {
	res, err := ec.unmarshalInputVenueWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalN_FieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_FieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOConvertedDetails2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsConvertedDetails(ctx context.Context, sel ast.SelectionSet, v *models.ConvertedDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConvertedDetails(ctx, sel, v)
}

func (ec *executionContext) marshalOCurrency2githubcomomigagroupomigasrcvenuesharedentitiesCurrency(ctx context.Context, sel ast.SelectionSet, v *entities.Currency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Currency(ctx, sel, v)
}

func (ec *executionContext) marshalOCurrencyConnection2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyConnection(ctx context.Context, sel ast.SelectionSet, v *entities.CurrencyConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CurrencyConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOCurrencyEdge2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyEdge(ctx context.Context, sel ast.SelectionSet, v []*entities.CurrencyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCurrencyEdge2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCurrencyEdge2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyEdge(ctx context.Context, sel ast.SelectionSet, v *entities.CurrencyEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CurrencyEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCurrencyOrder2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyOrder(ctx context.Context, v interface{}) ([]*entities.CurrencyOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.CurrencyOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCurrencyOrder2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCurrencyOrderField2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyOrderField(ctx context.Context, v interface{}) (*entities.CurrencyOrderField, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entities.CurrencyOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCurrencyOrderField2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyOrderField(ctx context.Context, sel ast.SelectionSet, v *entities.CurrencyOrderField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx context.Context, v interface{}) ([]models.CurrencyType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.CurrencyType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx context.Context, sel ast.SelectionSet, v []models.CurrencyType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx context.Context, v interface{}) (*models.CurrencyType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.CurrencyType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCurrencyType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsCurrencyType(ctx context.Context, sel ast.SelectionSet, v *models.CurrencyType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx context.Context, v interface{}) ([]*entities.CurrencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.CurrencyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCurrencyWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesCurrencyWhereInput(ctx context.Context, v interface{}) (*entities.CurrencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCurrencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx context.Context, v interface{}) (*entities.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entities.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2githubcomomigagroupomigasrcvenuesharedentitiesCursor(ctx context.Context, sel ast.SelectionSet, v *entities.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) ([]float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNFloat2float64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx context.Context, v interface{}) ([]models.MarketType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.MarketType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx context.Context, sel ast.SelectionSet, v []models.MarketType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx context.Context, v interface{}) (*models.MarketType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.MarketType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMarketType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsMarketType(ctx context.Context, sel ast.SelectionSet, v *models.MarketType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx context.Context, v interface{}) ([]*entities.MarketWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.MarketWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMarketWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesMarketWhereInput(ctx context.Context, v interface{}) (*entities.MarketWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMarketWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx context.Context, v interface{}) ([]models.OutboxStatus, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.OutboxStatus, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx context.Context, sel ast.SelectionSet, v []models.OutboxStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx context.Context, v interface{}) (*models.OutboxStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.OutboxStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOutboxStatus2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsOutboxStatus(ctx context.Context, sel ast.SelectionSet, v *models.OutboxStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOutboxWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesOutboxWhereInput(ctx context.Context, v interface{}) ([]*entities.OutboxWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.OutboxWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOutboxWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesOutboxWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOutboxWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesOutboxWhereInput(ctx context.Context, v interface{}) (*entities.OutboxWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOutboxWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTickerMarket2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsTickerMarket(ctx context.Context, sel ast.SelectionSet, v *models.TickerMarket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TickerMarket(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx context.Context, v interface{}) ([]*entities.TickerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.TickerWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTickerWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTickerWhereInput(ctx context.Context, v interface{}) (*entities.TickerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTickerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx context.Context, v interface{}) ([]*entities.TradingPairWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.TradingPairWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTradingPairWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesTradingPairWhereInput(ctx context.Context, v interface{}) (*entities.TradingPairWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTradingPairWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVenue2githubcomomigagroupomigasrcvenuesharedentitiesVenue(ctx context.Context, sel ast.SelectionSet, v *entities.Venue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Venue(ctx, sel, v)
}

func (ec *executionContext) marshalOVenueConnection2githubcomomigagroupomigasrcvenuesharedentitiesVenueConnection(ctx context.Context, sel ast.SelectionSet, v *entities.VenueConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VenueConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOVenueEdge2githubcomomigagroupomigasrcvenuesharedentitiesVenueEdge(ctx context.Context, sel ast.SelectionSet, v []*entities.VenueEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOVenueEdge2githubcomomigagroupomigasrcvenuesharedentitiesVenueEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOVenueEdge2githubcomomigagroupomigasrcvenuesharedentitiesVenueEdge(ctx context.Context, sel ast.SelectionSet, v *entities.VenueEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VenueEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVenueOrder2githubcomomigagroupomigasrcvenuesharedentitiesVenueOrder(ctx context.Context, v interface{}) ([]*entities.VenueOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.VenueOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVenueOrder2githubcomomigagroupomigasrcvenuesharedentitiesVenueOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOVenueOrderField2githubcomomigagroupomigasrcvenuesharedentitiesVenueOrderField(ctx context.Context, v interface{}) (*entities.VenueOrderField, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entities.VenueOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVenueOrderField2githubcomomigagroupomigasrcvenuesharedentitiesVenueOrderField(ctx context.Context, sel ast.SelectionSet, v *entities.VenueOrderField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx context.Context, v interface{}) ([]models.VenueType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]models.VenueType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx context.Context, sel ast.SelectionSet, v []models.VenueType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx context.Context, v interface{}) (*models.VenueType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.VenueType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVenueType2githubcomomigagroupomigasrcvenuevenueapigraphqlmodelsVenueType(ctx context.Context, sel ast.SelectionSet, v *models.VenueType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx context.Context, v interface{}) ([]*entities.VenueWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entities.VenueWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOVenueWhereInput2githubcomomigagroupomigasrcvenuesharedentitiesVenueWhereInput(ctx context.Context, v interface{}) (*entities.VenueWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVenueWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
