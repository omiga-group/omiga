// Code generated by ent, DO NOT EDIT.

package repositories

import (
	"errors"
	"fmt"
	"time"

	"github.com/omiga-group/omiga/src/exchange/shared/repositories/exchange"
	"github.com/omiga-group/omiga/src/exchange/shared/repositories/outbox"
	"github.com/omiga-group/omiga/src/exchange/shared/repositories/predicate"
)

// ExchangeWhereInput represents a where input for filtering Exchange queries.
type ExchangeWhereInput struct {
	Predicates []predicate.Exchange  `json:"-"`
	Not        *ExchangeWhereInput   `json:"not,omitempty"`
	Or         []*ExchangeWhereInput `json:"or,omitempty"`
	And        []*ExchangeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExchangeWhereInput) AddPredicates(predicates ...predicate.Exchange) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExchangeWhereInput filter on the ExchangeQuery builder.
func (i *ExchangeWhereInput) Filter(q *ExchangeQuery) (*ExchangeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExchangeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExchangeWhereInput is returned in case the ExchangeWhereInput is empty.
var ErrEmptyExchangeWhereInput = errors.New("repositories: empty predicate ExchangeWhereInput")

// P returns a predicate for filtering exchanges.
// An error is returned if the input is empty or invalid.
func (i *ExchangeWhereInput) P() (predicate.Exchange, error) {
	var predicates []predicate.Exchange
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, exchange.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Exchange, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, exchange.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Exchange, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, exchange.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, exchange.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, exchange.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, exchange.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, exchange.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, exchange.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, exchange.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, exchange.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, exchange.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExchangeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return exchange.And(predicates...), nil
	}
}

// OutboxWhereInput represents a where input for filtering Outbox queries.
type OutboxWhereInput struct {
	Predicates []predicate.Outbox  `json:"-"`
	Not        *OutboxWhereInput   `json:"not,omitempty"`
	Or         []*OutboxWhereInput `json:"or,omitempty"`
	And        []*OutboxWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "topic" field predicates.
	Topic             *string  `json:"topic,omitempty"`
	TopicNEQ          *string  `json:"topicNEQ,omitempty"`
	TopicIn           []string `json:"topicIn,omitempty"`
	TopicNotIn        []string `json:"topicNotIn,omitempty"`
	TopicGT           *string  `json:"topicGT,omitempty"`
	TopicGTE          *string  `json:"topicGTE,omitempty"`
	TopicLT           *string  `json:"topicLT,omitempty"`
	TopicLTE          *string  `json:"topicLTE,omitempty"`
	TopicContains     *string  `json:"topicContains,omitempty"`
	TopicHasPrefix    *string  `json:"topicHasPrefix,omitempty"`
	TopicHasSuffix    *string  `json:"topicHasSuffix,omitempty"`
	TopicEqualFold    *string  `json:"topicEqualFold,omitempty"`
	TopicContainsFold *string  `json:"topicContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "retry_count" field predicates.
	RetryCount      *int  `json:"retryCount,omitempty"`
	RetryCountNEQ   *int  `json:"retryCountNEQ,omitempty"`
	RetryCountIn    []int `json:"retryCountIn,omitempty"`
	RetryCountNotIn []int `json:"retryCountNotIn,omitempty"`
	RetryCountGT    *int  `json:"retryCountGT,omitempty"`
	RetryCountGTE   *int  `json:"retryCountGTE,omitempty"`
	RetryCountLT    *int  `json:"retryCountLT,omitempty"`
	RetryCountLTE   *int  `json:"retryCountLTE,omitempty"`

	// "status" field predicates.
	Status      *outbox.Status  `json:"status,omitempty"`
	StatusNEQ   *outbox.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []outbox.Status `json:"statusIn,omitempty"`
	StatusNotIn []outbox.Status `json:"statusNotIn,omitempty"`

	// "last_retry" field predicates.
	LastRetry       *time.Time  `json:"lastRetry,omitempty"`
	LastRetryNEQ    *time.Time  `json:"lastRetryNEQ,omitempty"`
	LastRetryIn     []time.Time `json:"lastRetryIn,omitempty"`
	LastRetryNotIn  []time.Time `json:"lastRetryNotIn,omitempty"`
	LastRetryGT     *time.Time  `json:"lastRetryGT,omitempty"`
	LastRetryGTE    *time.Time  `json:"lastRetryGTE,omitempty"`
	LastRetryLT     *time.Time  `json:"lastRetryLT,omitempty"`
	LastRetryLTE    *time.Time  `json:"lastRetryLTE,omitempty"`
	LastRetryIsNil  bool        `json:"lastRetryIsNil,omitempty"`
	LastRetryNotNil bool        `json:"lastRetryNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OutboxWhereInput) AddPredicates(predicates ...predicate.Outbox) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OutboxWhereInput filter on the OutboxQuery builder.
func (i *OutboxWhereInput) Filter(q *OutboxQuery) (*OutboxQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOutboxWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOutboxWhereInput is returned in case the OutboxWhereInput is empty.
var ErrEmptyOutboxWhereInput = errors.New("repositories: empty predicate OutboxWhereInput")

// P returns a predicate for filtering outboxes.
// An error is returned if the input is empty or invalid.
func (i *OutboxWhereInput) P() (predicate.Outbox, error) {
	var predicates []predicate.Outbox
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, outbox.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Outbox, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, outbox.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Outbox, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, outbox.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, outbox.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, outbox.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, outbox.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, outbox.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, outbox.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, outbox.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, outbox.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, outbox.IDLTE(*i.IDLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, outbox.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, outbox.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, outbox.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, outbox.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, outbox.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, outbox.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, outbox.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, outbox.TimestampLTE(*i.TimestampLTE))
	}
	if i.Topic != nil {
		predicates = append(predicates, outbox.TopicEQ(*i.Topic))
	}
	if i.TopicNEQ != nil {
		predicates = append(predicates, outbox.TopicNEQ(*i.TopicNEQ))
	}
	if len(i.TopicIn) > 0 {
		predicates = append(predicates, outbox.TopicIn(i.TopicIn...))
	}
	if len(i.TopicNotIn) > 0 {
		predicates = append(predicates, outbox.TopicNotIn(i.TopicNotIn...))
	}
	if i.TopicGT != nil {
		predicates = append(predicates, outbox.TopicGT(*i.TopicGT))
	}
	if i.TopicGTE != nil {
		predicates = append(predicates, outbox.TopicGTE(*i.TopicGTE))
	}
	if i.TopicLT != nil {
		predicates = append(predicates, outbox.TopicLT(*i.TopicLT))
	}
	if i.TopicLTE != nil {
		predicates = append(predicates, outbox.TopicLTE(*i.TopicLTE))
	}
	if i.TopicContains != nil {
		predicates = append(predicates, outbox.TopicContains(*i.TopicContains))
	}
	if i.TopicHasPrefix != nil {
		predicates = append(predicates, outbox.TopicHasPrefix(*i.TopicHasPrefix))
	}
	if i.TopicHasSuffix != nil {
		predicates = append(predicates, outbox.TopicHasSuffix(*i.TopicHasSuffix))
	}
	if i.TopicEqualFold != nil {
		predicates = append(predicates, outbox.TopicEqualFold(*i.TopicEqualFold))
	}
	if i.TopicContainsFold != nil {
		predicates = append(predicates, outbox.TopicContainsFold(*i.TopicContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, outbox.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, outbox.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, outbox.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, outbox.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, outbox.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, outbox.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, outbox.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, outbox.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, outbox.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, outbox.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, outbox.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, outbox.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, outbox.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.RetryCount != nil {
		predicates = append(predicates, outbox.RetryCountEQ(*i.RetryCount))
	}
	if i.RetryCountNEQ != nil {
		predicates = append(predicates, outbox.RetryCountNEQ(*i.RetryCountNEQ))
	}
	if len(i.RetryCountIn) > 0 {
		predicates = append(predicates, outbox.RetryCountIn(i.RetryCountIn...))
	}
	if len(i.RetryCountNotIn) > 0 {
		predicates = append(predicates, outbox.RetryCountNotIn(i.RetryCountNotIn...))
	}
	if i.RetryCountGT != nil {
		predicates = append(predicates, outbox.RetryCountGT(*i.RetryCountGT))
	}
	if i.RetryCountGTE != nil {
		predicates = append(predicates, outbox.RetryCountGTE(*i.RetryCountGTE))
	}
	if i.RetryCountLT != nil {
		predicates = append(predicates, outbox.RetryCountLT(*i.RetryCountLT))
	}
	if i.RetryCountLTE != nil {
		predicates = append(predicates, outbox.RetryCountLTE(*i.RetryCountLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, outbox.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, outbox.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, outbox.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, outbox.StatusNotIn(i.StatusNotIn...))
	}
	if i.LastRetry != nil {
		predicates = append(predicates, outbox.LastRetryEQ(*i.LastRetry))
	}
	if i.LastRetryNEQ != nil {
		predicates = append(predicates, outbox.LastRetryNEQ(*i.LastRetryNEQ))
	}
	if len(i.LastRetryIn) > 0 {
		predicates = append(predicates, outbox.LastRetryIn(i.LastRetryIn...))
	}
	if len(i.LastRetryNotIn) > 0 {
		predicates = append(predicates, outbox.LastRetryNotIn(i.LastRetryNotIn...))
	}
	if i.LastRetryGT != nil {
		predicates = append(predicates, outbox.LastRetryGT(*i.LastRetryGT))
	}
	if i.LastRetryGTE != nil {
		predicates = append(predicates, outbox.LastRetryGTE(*i.LastRetryGTE))
	}
	if i.LastRetryLT != nil {
		predicates = append(predicates, outbox.LastRetryLT(*i.LastRetryLT))
	}
	if i.LastRetryLTE != nil {
		predicates = append(predicates, outbox.LastRetryLTE(*i.LastRetryLTE))
	}
	if i.LastRetryIsNil {
		predicates = append(predicates, outbox.LastRetryIsNil())
	}
	if i.LastRetryNotNil {
		predicates = append(predicates, outbox.LastRetryNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOutboxWhereInput
	case 1:
		return predicates[0], nil
	default:
		return outbox.And(predicates...), nil
	}
}
