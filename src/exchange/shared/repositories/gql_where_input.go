// Code generated by ent, DO NOT EDIT.

package repositories

import (
	"errors"
	"fmt"
	"time"

	"github.com/omiga-group/omiga/src/exchange/shared/repositories/exchange"
	"github.com/omiga-group/omiga/src/exchange/shared/repositories/outbox"
	"github.com/omiga-group/omiga/src/exchange/shared/repositories/predicate"
)

// ExchangeWhereInput represents a where input for filtering Exchange queries.
type ExchangeWhereInput struct {
	Predicates []predicate.Exchange  `json:"-"`
	Not        *ExchangeWhereInput   `json:"not,omitempty"`
	Or         []*ExchangeWhereInput `json:"or,omitempty"`
	And        []*ExchangeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "exchange_id" field predicates.
	ExchangeID             *string  `json:"exchangeID,omitempty"`
	ExchangeIDNEQ          *string  `json:"exchangeIDNEQ,omitempty"`
	ExchangeIDIn           []string `json:"exchangeIDIn,omitempty"`
	ExchangeIDNotIn        []string `json:"exchangeIDNotIn,omitempty"`
	ExchangeIDGT           *string  `json:"exchangeIDGT,omitempty"`
	ExchangeIDGTE          *string  `json:"exchangeIDGTE,omitempty"`
	ExchangeIDLT           *string  `json:"exchangeIDLT,omitempty"`
	ExchangeIDLTE          *string  `json:"exchangeIDLTE,omitempty"`
	ExchangeIDContains     *string  `json:"exchangeIDContains,omitempty"`
	ExchangeIDHasPrefix    *string  `json:"exchangeIDHasPrefix,omitempty"`
	ExchangeIDHasSuffix    *string  `json:"exchangeIDHasSuffix,omitempty"`
	ExchangeIDEqualFold    *string  `json:"exchangeIDEqualFold,omitempty"`
	ExchangeIDContainsFold *string  `json:"exchangeIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "year_established" field predicates.
	YearEstablished       *int  `json:"yearEstablished,omitempty"`
	YearEstablishedNEQ    *int  `json:"yearEstablishedNEQ,omitempty"`
	YearEstablishedIn     []int `json:"yearEstablishedIn,omitempty"`
	YearEstablishedNotIn  []int `json:"yearEstablishedNotIn,omitempty"`
	YearEstablishedGT     *int  `json:"yearEstablishedGT,omitempty"`
	YearEstablishedGTE    *int  `json:"yearEstablishedGTE,omitempty"`
	YearEstablishedLT     *int  `json:"yearEstablishedLT,omitempty"`
	YearEstablishedLTE    *int  `json:"yearEstablishedLTE,omitempty"`
	YearEstablishedIsNil  bool  `json:"yearEstablishedIsNil,omitempty"`
	YearEstablishedNotNil bool  `json:"yearEstablishedNotNil,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryIsNil        bool     `json:"countryIsNil,omitempty"`
	CountryNotNil       bool     `json:"countryNotNil,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageIsNil        bool     `json:"imageIsNil,omitempty"`
	ImageNotNil       bool     `json:"imageNotNil,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "has_trading_incentive" field predicates.
	HasTradingIncentive    *bool `json:"hasTradingIncentive,omitempty"`
	HasTradingIncentiveNEQ *bool `json:"hasTradingIncentiveNEQ,omitempty"`

	// "centralized" field predicates.
	Centralized    *bool `json:"centralized,omitempty"`
	CentralizedNEQ *bool `json:"centralizedNEQ,omitempty"`

	// "public_notice" field predicates.
	PublicNotice             *string  `json:"publicNotice,omitempty"`
	PublicNoticeNEQ          *string  `json:"publicNoticeNEQ,omitempty"`
	PublicNoticeIn           []string `json:"publicNoticeIn,omitempty"`
	PublicNoticeNotIn        []string `json:"publicNoticeNotIn,omitempty"`
	PublicNoticeGT           *string  `json:"publicNoticeGT,omitempty"`
	PublicNoticeGTE          *string  `json:"publicNoticeGTE,omitempty"`
	PublicNoticeLT           *string  `json:"publicNoticeLT,omitempty"`
	PublicNoticeLTE          *string  `json:"publicNoticeLTE,omitempty"`
	PublicNoticeContains     *string  `json:"publicNoticeContains,omitempty"`
	PublicNoticeHasPrefix    *string  `json:"publicNoticeHasPrefix,omitempty"`
	PublicNoticeHasSuffix    *string  `json:"publicNoticeHasSuffix,omitempty"`
	PublicNoticeEqualFold    *string  `json:"publicNoticeEqualFold,omitempty"`
	PublicNoticeContainsFold *string  `json:"publicNoticeContainsFold,omitempty"`

	// "alert_notice" field predicates.
	AlertNotice             *string  `json:"alertNotice,omitempty"`
	AlertNoticeNEQ          *string  `json:"alertNoticeNEQ,omitempty"`
	AlertNoticeIn           []string `json:"alertNoticeIn,omitempty"`
	AlertNoticeNotIn        []string `json:"alertNoticeNotIn,omitempty"`
	AlertNoticeGT           *string  `json:"alertNoticeGT,omitempty"`
	AlertNoticeGTE          *string  `json:"alertNoticeGTE,omitempty"`
	AlertNoticeLT           *string  `json:"alertNoticeLT,omitempty"`
	AlertNoticeLTE          *string  `json:"alertNoticeLTE,omitempty"`
	AlertNoticeContains     *string  `json:"alertNoticeContains,omitempty"`
	AlertNoticeHasPrefix    *string  `json:"alertNoticeHasPrefix,omitempty"`
	AlertNoticeHasSuffix    *string  `json:"alertNoticeHasSuffix,omitempty"`
	AlertNoticeEqualFold    *string  `json:"alertNoticeEqualFold,omitempty"`
	AlertNoticeContainsFold *string  `json:"alertNoticeContainsFold,omitempty"`

	// "trust_score" field predicates.
	TrustScore      *int  `json:"trustScore,omitempty"`
	TrustScoreNEQ   *int  `json:"trustScoreNEQ,omitempty"`
	TrustScoreIn    []int `json:"trustScoreIn,omitempty"`
	TrustScoreNotIn []int `json:"trustScoreNotIn,omitempty"`
	TrustScoreGT    *int  `json:"trustScoreGT,omitempty"`
	TrustScoreGTE   *int  `json:"trustScoreGTE,omitempty"`
	TrustScoreLT    *int  `json:"trustScoreLT,omitempty"`
	TrustScoreLTE   *int  `json:"trustScoreLTE,omitempty"`

	// "trust_score_rank" field predicates.
	TrustScoreRank      *int  `json:"trustScoreRank,omitempty"`
	TrustScoreRankNEQ   *int  `json:"trustScoreRankNEQ,omitempty"`
	TrustScoreRankIn    []int `json:"trustScoreRankIn,omitempty"`
	TrustScoreRankNotIn []int `json:"trustScoreRankNotIn,omitempty"`
	TrustScoreRankGT    *int  `json:"trustScoreRankGT,omitempty"`
	TrustScoreRankGTE   *int  `json:"trustScoreRankGTE,omitempty"`
	TrustScoreRankLT    *int  `json:"trustScoreRankLT,omitempty"`
	TrustScoreRankLTE   *int  `json:"trustScoreRankLTE,omitempty"`

	// "trade_volume_24h_btc" field predicates.
	TradeVolume24hBtc      *float64  `json:"tradeVolume24hBtc,omitempty"`
	TradeVolume24hBtcNEQ   *float64  `json:"tradeVolume24hBtcNEQ,omitempty"`
	TradeVolume24hBtcIn    []float64 `json:"tradeVolume24hBtcIn,omitempty"`
	TradeVolume24hBtcNotIn []float64 `json:"tradeVolume24hBtcNotIn,omitempty"`
	TradeVolume24hBtcGT    *float64  `json:"tradeVolume24hBtcGT,omitempty"`
	TradeVolume24hBtcGTE   *float64  `json:"tradeVolume24hBtcGTE,omitempty"`
	TradeVolume24hBtcLT    *float64  `json:"tradeVolume24hBtcLT,omitempty"`
	TradeVolume24hBtcLTE   *float64  `json:"tradeVolume24hBtcLTE,omitempty"`

	// "trade_volume_24h_btc_normalized" field predicates.
	TradeVolume24hBtcNormalized      *float64  `json:"tradeVolume24hBtcNormalized,omitempty"`
	TradeVolume24hBtcNormalizedNEQ   *float64  `json:"tradeVolume24hBtcNormalizedNEQ,omitempty"`
	TradeVolume24hBtcNormalizedIn    []float64 `json:"tradeVolume24hBtcNormalizedIn,omitempty"`
	TradeVolume24hBtcNormalizedNotIn []float64 `json:"tradeVolume24hBtcNormalizedNotIn,omitempty"`
	TradeVolume24hBtcNormalizedGT    *float64  `json:"tradeVolume24hBtcNormalizedGT,omitempty"`
	TradeVolume24hBtcNormalizedGTE   *float64  `json:"tradeVolume24hBtcNormalizedGTE,omitempty"`
	TradeVolume24hBtcNormalizedLT    *float64  `json:"tradeVolume24hBtcNormalizedLT,omitempty"`
	TradeVolume24hBtcNormalizedLTE   *float64  `json:"tradeVolume24hBtcNormalizedLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExchangeWhereInput) AddPredicates(predicates ...predicate.Exchange) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExchangeWhereInput filter on the ExchangeQuery builder.
func (i *ExchangeWhereInput) Filter(q *ExchangeQuery) (*ExchangeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExchangeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExchangeWhereInput is returned in case the ExchangeWhereInput is empty.
var ErrEmptyExchangeWhereInput = errors.New("repositories: empty predicate ExchangeWhereInput")

// P returns a predicate for filtering exchanges.
// An error is returned if the input is empty or invalid.
func (i *ExchangeWhereInput) P() (predicate.Exchange, error) {
	var predicates []predicate.Exchange
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, exchange.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Exchange, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, exchange.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Exchange, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, exchange.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, exchange.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, exchange.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, exchange.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, exchange.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, exchange.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, exchange.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, exchange.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, exchange.IDLTE(*i.IDLTE))
	}
	if i.ExchangeID != nil {
		predicates = append(predicates, exchange.ExchangeIDEQ(*i.ExchangeID))
	}
	if i.ExchangeIDNEQ != nil {
		predicates = append(predicates, exchange.ExchangeIDNEQ(*i.ExchangeIDNEQ))
	}
	if len(i.ExchangeIDIn) > 0 {
		predicates = append(predicates, exchange.ExchangeIDIn(i.ExchangeIDIn...))
	}
	if len(i.ExchangeIDNotIn) > 0 {
		predicates = append(predicates, exchange.ExchangeIDNotIn(i.ExchangeIDNotIn...))
	}
	if i.ExchangeIDGT != nil {
		predicates = append(predicates, exchange.ExchangeIDGT(*i.ExchangeIDGT))
	}
	if i.ExchangeIDGTE != nil {
		predicates = append(predicates, exchange.ExchangeIDGTE(*i.ExchangeIDGTE))
	}
	if i.ExchangeIDLT != nil {
		predicates = append(predicates, exchange.ExchangeIDLT(*i.ExchangeIDLT))
	}
	if i.ExchangeIDLTE != nil {
		predicates = append(predicates, exchange.ExchangeIDLTE(*i.ExchangeIDLTE))
	}
	if i.ExchangeIDContains != nil {
		predicates = append(predicates, exchange.ExchangeIDContains(*i.ExchangeIDContains))
	}
	if i.ExchangeIDHasPrefix != nil {
		predicates = append(predicates, exchange.ExchangeIDHasPrefix(*i.ExchangeIDHasPrefix))
	}
	if i.ExchangeIDHasSuffix != nil {
		predicates = append(predicates, exchange.ExchangeIDHasSuffix(*i.ExchangeIDHasSuffix))
	}
	if i.ExchangeIDEqualFold != nil {
		predicates = append(predicates, exchange.ExchangeIDEqualFold(*i.ExchangeIDEqualFold))
	}
	if i.ExchangeIDContainsFold != nil {
		predicates = append(predicates, exchange.ExchangeIDContainsFold(*i.ExchangeIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, exchange.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, exchange.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, exchange.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, exchange.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, exchange.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, exchange.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, exchange.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, exchange.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, exchange.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, exchange.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, exchange.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, exchange.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, exchange.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, exchange.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, exchange.NameContainsFold(*i.NameContainsFold))
	}
	if i.YearEstablished != nil {
		predicates = append(predicates, exchange.YearEstablishedEQ(*i.YearEstablished))
	}
	if i.YearEstablishedNEQ != nil {
		predicates = append(predicates, exchange.YearEstablishedNEQ(*i.YearEstablishedNEQ))
	}
	if len(i.YearEstablishedIn) > 0 {
		predicates = append(predicates, exchange.YearEstablishedIn(i.YearEstablishedIn...))
	}
	if len(i.YearEstablishedNotIn) > 0 {
		predicates = append(predicates, exchange.YearEstablishedNotIn(i.YearEstablishedNotIn...))
	}
	if i.YearEstablishedGT != nil {
		predicates = append(predicates, exchange.YearEstablishedGT(*i.YearEstablishedGT))
	}
	if i.YearEstablishedGTE != nil {
		predicates = append(predicates, exchange.YearEstablishedGTE(*i.YearEstablishedGTE))
	}
	if i.YearEstablishedLT != nil {
		predicates = append(predicates, exchange.YearEstablishedLT(*i.YearEstablishedLT))
	}
	if i.YearEstablishedLTE != nil {
		predicates = append(predicates, exchange.YearEstablishedLTE(*i.YearEstablishedLTE))
	}
	if i.YearEstablishedIsNil {
		predicates = append(predicates, exchange.YearEstablishedIsNil())
	}
	if i.YearEstablishedNotNil {
		predicates = append(predicates, exchange.YearEstablishedNotNil())
	}
	if i.Country != nil {
		predicates = append(predicates, exchange.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, exchange.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, exchange.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, exchange.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, exchange.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, exchange.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, exchange.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, exchange.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, exchange.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, exchange.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, exchange.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryIsNil {
		predicates = append(predicates, exchange.CountryIsNil())
	}
	if i.CountryNotNil {
		predicates = append(predicates, exchange.CountryNotNil())
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, exchange.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, exchange.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, exchange.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, exchange.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, exchange.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, exchange.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, exchange.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, exchange.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, exchange.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, exchange.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, exchange.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, exchange.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, exchange.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageIsNil {
		predicates = append(predicates, exchange.ImageIsNil())
	}
	if i.ImageNotNil {
		predicates = append(predicates, exchange.ImageNotNil())
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, exchange.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, exchange.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.HasTradingIncentive != nil {
		predicates = append(predicates, exchange.HasTradingIncentiveEQ(*i.HasTradingIncentive))
	}
	if i.HasTradingIncentiveNEQ != nil {
		predicates = append(predicates, exchange.HasTradingIncentiveNEQ(*i.HasTradingIncentiveNEQ))
	}
	if i.Centralized != nil {
		predicates = append(predicates, exchange.CentralizedEQ(*i.Centralized))
	}
	if i.CentralizedNEQ != nil {
		predicates = append(predicates, exchange.CentralizedNEQ(*i.CentralizedNEQ))
	}
	if i.PublicNotice != nil {
		predicates = append(predicates, exchange.PublicNoticeEQ(*i.PublicNotice))
	}
	if i.PublicNoticeNEQ != nil {
		predicates = append(predicates, exchange.PublicNoticeNEQ(*i.PublicNoticeNEQ))
	}
	if len(i.PublicNoticeIn) > 0 {
		predicates = append(predicates, exchange.PublicNoticeIn(i.PublicNoticeIn...))
	}
	if len(i.PublicNoticeNotIn) > 0 {
		predicates = append(predicates, exchange.PublicNoticeNotIn(i.PublicNoticeNotIn...))
	}
	if i.PublicNoticeGT != nil {
		predicates = append(predicates, exchange.PublicNoticeGT(*i.PublicNoticeGT))
	}
	if i.PublicNoticeGTE != nil {
		predicates = append(predicates, exchange.PublicNoticeGTE(*i.PublicNoticeGTE))
	}
	if i.PublicNoticeLT != nil {
		predicates = append(predicates, exchange.PublicNoticeLT(*i.PublicNoticeLT))
	}
	if i.PublicNoticeLTE != nil {
		predicates = append(predicates, exchange.PublicNoticeLTE(*i.PublicNoticeLTE))
	}
	if i.PublicNoticeContains != nil {
		predicates = append(predicates, exchange.PublicNoticeContains(*i.PublicNoticeContains))
	}
	if i.PublicNoticeHasPrefix != nil {
		predicates = append(predicates, exchange.PublicNoticeHasPrefix(*i.PublicNoticeHasPrefix))
	}
	if i.PublicNoticeHasSuffix != nil {
		predicates = append(predicates, exchange.PublicNoticeHasSuffix(*i.PublicNoticeHasSuffix))
	}
	if i.PublicNoticeEqualFold != nil {
		predicates = append(predicates, exchange.PublicNoticeEqualFold(*i.PublicNoticeEqualFold))
	}
	if i.PublicNoticeContainsFold != nil {
		predicates = append(predicates, exchange.PublicNoticeContainsFold(*i.PublicNoticeContainsFold))
	}
	if i.AlertNotice != nil {
		predicates = append(predicates, exchange.AlertNoticeEQ(*i.AlertNotice))
	}
	if i.AlertNoticeNEQ != nil {
		predicates = append(predicates, exchange.AlertNoticeNEQ(*i.AlertNoticeNEQ))
	}
	if len(i.AlertNoticeIn) > 0 {
		predicates = append(predicates, exchange.AlertNoticeIn(i.AlertNoticeIn...))
	}
	if len(i.AlertNoticeNotIn) > 0 {
		predicates = append(predicates, exchange.AlertNoticeNotIn(i.AlertNoticeNotIn...))
	}
	if i.AlertNoticeGT != nil {
		predicates = append(predicates, exchange.AlertNoticeGT(*i.AlertNoticeGT))
	}
	if i.AlertNoticeGTE != nil {
		predicates = append(predicates, exchange.AlertNoticeGTE(*i.AlertNoticeGTE))
	}
	if i.AlertNoticeLT != nil {
		predicates = append(predicates, exchange.AlertNoticeLT(*i.AlertNoticeLT))
	}
	if i.AlertNoticeLTE != nil {
		predicates = append(predicates, exchange.AlertNoticeLTE(*i.AlertNoticeLTE))
	}
	if i.AlertNoticeContains != nil {
		predicates = append(predicates, exchange.AlertNoticeContains(*i.AlertNoticeContains))
	}
	if i.AlertNoticeHasPrefix != nil {
		predicates = append(predicates, exchange.AlertNoticeHasPrefix(*i.AlertNoticeHasPrefix))
	}
	if i.AlertNoticeHasSuffix != nil {
		predicates = append(predicates, exchange.AlertNoticeHasSuffix(*i.AlertNoticeHasSuffix))
	}
	if i.AlertNoticeEqualFold != nil {
		predicates = append(predicates, exchange.AlertNoticeEqualFold(*i.AlertNoticeEqualFold))
	}
	if i.AlertNoticeContainsFold != nil {
		predicates = append(predicates, exchange.AlertNoticeContainsFold(*i.AlertNoticeContainsFold))
	}
	if i.TrustScore != nil {
		predicates = append(predicates, exchange.TrustScoreEQ(*i.TrustScore))
	}
	if i.TrustScoreNEQ != nil {
		predicates = append(predicates, exchange.TrustScoreNEQ(*i.TrustScoreNEQ))
	}
	if len(i.TrustScoreIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreIn(i.TrustScoreIn...))
	}
	if len(i.TrustScoreNotIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreNotIn(i.TrustScoreNotIn...))
	}
	if i.TrustScoreGT != nil {
		predicates = append(predicates, exchange.TrustScoreGT(*i.TrustScoreGT))
	}
	if i.TrustScoreGTE != nil {
		predicates = append(predicates, exchange.TrustScoreGTE(*i.TrustScoreGTE))
	}
	if i.TrustScoreLT != nil {
		predicates = append(predicates, exchange.TrustScoreLT(*i.TrustScoreLT))
	}
	if i.TrustScoreLTE != nil {
		predicates = append(predicates, exchange.TrustScoreLTE(*i.TrustScoreLTE))
	}
	if i.TrustScoreRank != nil {
		predicates = append(predicates, exchange.TrustScoreRankEQ(*i.TrustScoreRank))
	}
	if i.TrustScoreRankNEQ != nil {
		predicates = append(predicates, exchange.TrustScoreRankNEQ(*i.TrustScoreRankNEQ))
	}
	if len(i.TrustScoreRankIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreRankIn(i.TrustScoreRankIn...))
	}
	if len(i.TrustScoreRankNotIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreRankNotIn(i.TrustScoreRankNotIn...))
	}
	if i.TrustScoreRankGT != nil {
		predicates = append(predicates, exchange.TrustScoreRankGT(*i.TrustScoreRankGT))
	}
	if i.TrustScoreRankGTE != nil {
		predicates = append(predicates, exchange.TrustScoreRankGTE(*i.TrustScoreRankGTE))
	}
	if i.TrustScoreRankLT != nil {
		predicates = append(predicates, exchange.TrustScoreRankLT(*i.TrustScoreRankLT))
	}
	if i.TrustScoreRankLTE != nil {
		predicates = append(predicates, exchange.TrustScoreRankLTE(*i.TrustScoreRankLTE))
	}
	if i.TradeVolume24hBtc != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcEQ(*i.TradeVolume24hBtc))
	}
	if i.TradeVolume24hBtcNEQ != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNEQ(*i.TradeVolume24hBtcNEQ))
	}
	if len(i.TradeVolume24hBtcIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcIn(i.TradeVolume24hBtcIn...))
	}
	if len(i.TradeVolume24hBtcNotIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNotIn(i.TradeVolume24hBtcNotIn...))
	}
	if i.TradeVolume24hBtcGT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcGT(*i.TradeVolume24hBtcGT))
	}
	if i.TradeVolume24hBtcGTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcGTE(*i.TradeVolume24hBtcGTE))
	}
	if i.TradeVolume24hBtcLT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcLT(*i.TradeVolume24hBtcLT))
	}
	if i.TradeVolume24hBtcLTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcLTE(*i.TradeVolume24hBtcLTE))
	}
	if i.TradeVolume24hBtcNormalized != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedEQ(*i.TradeVolume24hBtcNormalized))
	}
	if i.TradeVolume24hBtcNormalizedNEQ != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNEQ(*i.TradeVolume24hBtcNormalizedNEQ))
	}
	if len(i.TradeVolume24hBtcNormalizedIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedIn(i.TradeVolume24hBtcNormalizedIn...))
	}
	if len(i.TradeVolume24hBtcNormalizedNotIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNotIn(i.TradeVolume24hBtcNormalizedNotIn...))
	}
	if i.TradeVolume24hBtcNormalizedGT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedGT(*i.TradeVolume24hBtcNormalizedGT))
	}
	if i.TradeVolume24hBtcNormalizedGTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedGTE(*i.TradeVolume24hBtcNormalizedGTE))
	}
	if i.TradeVolume24hBtcNormalizedLT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedLT(*i.TradeVolume24hBtcNormalizedLT))
	}
	if i.TradeVolume24hBtcNormalizedLTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedLTE(*i.TradeVolume24hBtcNormalizedLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExchangeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return exchange.And(predicates...), nil
	}
}

// OutboxWhereInput represents a where input for filtering Outbox queries.
type OutboxWhereInput struct {
	Predicates []predicate.Outbox  `json:"-"`
	Not        *OutboxWhereInput   `json:"not,omitempty"`
	Or         []*OutboxWhereInput `json:"or,omitempty"`
	And        []*OutboxWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "topic" field predicates.
	Topic             *string  `json:"topic,omitempty"`
	TopicNEQ          *string  `json:"topicNEQ,omitempty"`
	TopicIn           []string `json:"topicIn,omitempty"`
	TopicNotIn        []string `json:"topicNotIn,omitempty"`
	TopicGT           *string  `json:"topicGT,omitempty"`
	TopicGTE          *string  `json:"topicGTE,omitempty"`
	TopicLT           *string  `json:"topicLT,omitempty"`
	TopicLTE          *string  `json:"topicLTE,omitempty"`
	TopicContains     *string  `json:"topicContains,omitempty"`
	TopicHasPrefix    *string  `json:"topicHasPrefix,omitempty"`
	TopicHasSuffix    *string  `json:"topicHasSuffix,omitempty"`
	TopicEqualFold    *string  `json:"topicEqualFold,omitempty"`
	TopicContainsFold *string  `json:"topicContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "retry_count" field predicates.
	RetryCount      *int  `json:"retryCount,omitempty"`
	RetryCountNEQ   *int  `json:"retryCountNEQ,omitempty"`
	RetryCountIn    []int `json:"retryCountIn,omitempty"`
	RetryCountNotIn []int `json:"retryCountNotIn,omitempty"`
	RetryCountGT    *int  `json:"retryCountGT,omitempty"`
	RetryCountGTE   *int  `json:"retryCountGTE,omitempty"`
	RetryCountLT    *int  `json:"retryCountLT,omitempty"`
	RetryCountLTE   *int  `json:"retryCountLTE,omitempty"`

	// "status" field predicates.
	Status      *outbox.Status  `json:"status,omitempty"`
	StatusNEQ   *outbox.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []outbox.Status `json:"statusIn,omitempty"`
	StatusNotIn []outbox.Status `json:"statusNotIn,omitempty"`

	// "last_retry" field predicates.
	LastRetry       *time.Time  `json:"lastRetry,omitempty"`
	LastRetryNEQ    *time.Time  `json:"lastRetryNEQ,omitempty"`
	LastRetryIn     []time.Time `json:"lastRetryIn,omitempty"`
	LastRetryNotIn  []time.Time `json:"lastRetryNotIn,omitempty"`
	LastRetryGT     *time.Time  `json:"lastRetryGT,omitempty"`
	LastRetryGTE    *time.Time  `json:"lastRetryGTE,omitempty"`
	LastRetryLT     *time.Time  `json:"lastRetryLT,omitempty"`
	LastRetryLTE    *time.Time  `json:"lastRetryLTE,omitempty"`
	LastRetryIsNil  bool        `json:"lastRetryIsNil,omitempty"`
	LastRetryNotNil bool        `json:"lastRetryNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OutboxWhereInput) AddPredicates(predicates ...predicate.Outbox) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OutboxWhereInput filter on the OutboxQuery builder.
func (i *OutboxWhereInput) Filter(q *OutboxQuery) (*OutboxQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOutboxWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOutboxWhereInput is returned in case the OutboxWhereInput is empty.
var ErrEmptyOutboxWhereInput = errors.New("repositories: empty predicate OutboxWhereInput")

// P returns a predicate for filtering outboxes.
// An error is returned if the input is empty or invalid.
func (i *OutboxWhereInput) P() (predicate.Outbox, error) {
	var predicates []predicate.Outbox
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, outbox.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Outbox, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, outbox.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Outbox, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, outbox.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, outbox.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, outbox.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, outbox.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, outbox.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, outbox.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, outbox.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, outbox.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, outbox.IDLTE(*i.IDLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, outbox.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, outbox.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, outbox.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, outbox.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, outbox.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, outbox.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, outbox.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, outbox.TimestampLTE(*i.TimestampLTE))
	}
	if i.Topic != nil {
		predicates = append(predicates, outbox.TopicEQ(*i.Topic))
	}
	if i.TopicNEQ != nil {
		predicates = append(predicates, outbox.TopicNEQ(*i.TopicNEQ))
	}
	if len(i.TopicIn) > 0 {
		predicates = append(predicates, outbox.TopicIn(i.TopicIn...))
	}
	if len(i.TopicNotIn) > 0 {
		predicates = append(predicates, outbox.TopicNotIn(i.TopicNotIn...))
	}
	if i.TopicGT != nil {
		predicates = append(predicates, outbox.TopicGT(*i.TopicGT))
	}
	if i.TopicGTE != nil {
		predicates = append(predicates, outbox.TopicGTE(*i.TopicGTE))
	}
	if i.TopicLT != nil {
		predicates = append(predicates, outbox.TopicLT(*i.TopicLT))
	}
	if i.TopicLTE != nil {
		predicates = append(predicates, outbox.TopicLTE(*i.TopicLTE))
	}
	if i.TopicContains != nil {
		predicates = append(predicates, outbox.TopicContains(*i.TopicContains))
	}
	if i.TopicHasPrefix != nil {
		predicates = append(predicates, outbox.TopicHasPrefix(*i.TopicHasPrefix))
	}
	if i.TopicHasSuffix != nil {
		predicates = append(predicates, outbox.TopicHasSuffix(*i.TopicHasSuffix))
	}
	if i.TopicEqualFold != nil {
		predicates = append(predicates, outbox.TopicEqualFold(*i.TopicEqualFold))
	}
	if i.TopicContainsFold != nil {
		predicates = append(predicates, outbox.TopicContainsFold(*i.TopicContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, outbox.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, outbox.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, outbox.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, outbox.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, outbox.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, outbox.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, outbox.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, outbox.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, outbox.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, outbox.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, outbox.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, outbox.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, outbox.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.RetryCount != nil {
		predicates = append(predicates, outbox.RetryCountEQ(*i.RetryCount))
	}
	if i.RetryCountNEQ != nil {
		predicates = append(predicates, outbox.RetryCountNEQ(*i.RetryCountNEQ))
	}
	if len(i.RetryCountIn) > 0 {
		predicates = append(predicates, outbox.RetryCountIn(i.RetryCountIn...))
	}
	if len(i.RetryCountNotIn) > 0 {
		predicates = append(predicates, outbox.RetryCountNotIn(i.RetryCountNotIn...))
	}
	if i.RetryCountGT != nil {
		predicates = append(predicates, outbox.RetryCountGT(*i.RetryCountGT))
	}
	if i.RetryCountGTE != nil {
		predicates = append(predicates, outbox.RetryCountGTE(*i.RetryCountGTE))
	}
	if i.RetryCountLT != nil {
		predicates = append(predicates, outbox.RetryCountLT(*i.RetryCountLT))
	}
	if i.RetryCountLTE != nil {
		predicates = append(predicates, outbox.RetryCountLTE(*i.RetryCountLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, outbox.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, outbox.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, outbox.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, outbox.StatusNotIn(i.StatusNotIn...))
	}
	if i.LastRetry != nil {
		predicates = append(predicates, outbox.LastRetryEQ(*i.LastRetry))
	}
	if i.LastRetryNEQ != nil {
		predicates = append(predicates, outbox.LastRetryNEQ(*i.LastRetryNEQ))
	}
	if len(i.LastRetryIn) > 0 {
		predicates = append(predicates, outbox.LastRetryIn(i.LastRetryIn...))
	}
	if len(i.LastRetryNotIn) > 0 {
		predicates = append(predicates, outbox.LastRetryNotIn(i.LastRetryNotIn...))
	}
	if i.LastRetryGT != nil {
		predicates = append(predicates, outbox.LastRetryGT(*i.LastRetryGT))
	}
	if i.LastRetryGTE != nil {
		predicates = append(predicates, outbox.LastRetryGTE(*i.LastRetryGTE))
	}
	if i.LastRetryLT != nil {
		predicates = append(predicates, outbox.LastRetryLT(*i.LastRetryLT))
	}
	if i.LastRetryLTE != nil {
		predicates = append(predicates, outbox.LastRetryLTE(*i.LastRetryLTE))
	}
	if i.LastRetryIsNil {
		predicates = append(predicates, outbox.LastRetryIsNil())
	}
	if i.LastRetryNotNil {
		predicates = append(predicates, outbox.LastRetryNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOutboxWhereInput
	case 1:
		return predicates[0], nil
	default:
		return outbox.And(predicates...), nil
	}
}
