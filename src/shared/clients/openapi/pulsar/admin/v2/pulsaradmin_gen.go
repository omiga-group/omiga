// Package pulsaradminv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package pulsaradminv2

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for AutoFailoverPolicyDataPolicyType.
const (
	MinAvailable AutoFailoverPolicyDataPolicyType = "min_available"
)

// Defines values for BacklogQuotaPolicy.
const (
	ConsumerBacklogEviction BacklogQuotaPolicy = "consumer_backlog_eviction"
	ProducerException       BacklogQuotaPolicy = "producer_exception"
	ProducerRequestHold     BacklogQuotaPolicy = "producer_request_hold"
)

// Defines values for ClusterDataProxyProtocol.
const (
	SNI ClusterDataProxyProtocol = "SNI"
)

// Defines values for GetSchemaResponseType.
const (
	AUTO           GetSchemaResponseType = "AUTO"
	AUTOCONSUME    GetSchemaResponseType = "AUTO_CONSUME"
	AUTOPUBLISH    GetSchemaResponseType = "AUTO_PUBLISH"
	AVRO           GetSchemaResponseType = "AVRO"
	BOOLEAN        GetSchemaResponseType = "BOOLEAN"
	BYTES          GetSchemaResponseType = "BYTES"
	DATE           GetSchemaResponseType = "DATE"
	DOUBLE         GetSchemaResponseType = "DOUBLE"
	FLOAT          GetSchemaResponseType = "FLOAT"
	INSTANT        GetSchemaResponseType = "INSTANT"
	INT16          GetSchemaResponseType = "INT16"
	INT32          GetSchemaResponseType = "INT32"
	INT64          GetSchemaResponseType = "INT64"
	INT8           GetSchemaResponseType = "INT8"
	JSON           GetSchemaResponseType = "JSON"
	KEYVALUE       GetSchemaResponseType = "KEY_VALUE"
	LOCALDATE      GetSchemaResponseType = "LOCAL_DATE"
	LOCALDATETIME  GetSchemaResponseType = "LOCAL_DATE_TIME"
	LOCALTIME      GetSchemaResponseType = "LOCAL_TIME"
	NONE           GetSchemaResponseType = "NONE"
	PROTOBUF       GetSchemaResponseType = "PROTOBUF"
	PROTOBUFNATIVE GetSchemaResponseType = "PROTOBUF_NATIVE"
	STRING         GetSchemaResponseType = "STRING"
	TIME           GetSchemaResponseType = "TIME"
	TIMESTAMP      GetSchemaResponseType = "TIMESTAMP"
)

// Defines values for InactiveTopicPoliciesInactiveTopicDeleteMode.
const (
	DeleteWhenNoSubscriptions       InactiveTopicPoliciesInactiveTopicDeleteMode = "delete_when_no_subscriptions"
	DeleteWhenSubscriptionsCaughtUp InactiveTopicPoliciesInactiveTopicDeleteMode = "delete_when_subscriptions_caught_up"
)

// Defines values for LongRunningProcessStatusStatus.
const (
	ERROR   LongRunningProcessStatusStatus = "ERROR"
	NOTRUN  LongRunningProcessStatusStatus = "NOT_RUN"
	RUNNING LongRunningProcessStatusStatus = "RUNNING"
	SUCCESS LongRunningProcessStatusStatus = "SUCCESS"
)

// Defines values for NamespaceOwnershipStatusBrokerAssignment.
const (
	Primary   NamespaceOwnershipStatusBrokerAssignment = "primary"
	Secondary NamespaceOwnershipStatusBrokerAssignment = "secondary"
	Shared    NamespaceOwnershipStatusBrokerAssignment = "shared"
)

// Defines values for OffloadPoliciesManagedLedgerOffloadedReadPriority.
const (
	OffloadPoliciesManagedLedgerOffloadedReadPriorityBOOKKEEPERFIRST    OffloadPoliciesManagedLedgerOffloadedReadPriority = "BOOKKEEPER_FIRST"
	OffloadPoliciesManagedLedgerOffloadedReadPriorityTIEREDSTORAGEFIRST OffloadPoliciesManagedLedgerOffloadedReadPriority = "TIERED_STORAGE_FIRST"
)

// Defines values for OffloadPoliciesImplManagedLedgerOffloadedReadPriority.
const (
	OffloadPoliciesImplManagedLedgerOffloadedReadPriorityBOOKKEEPERFIRST    OffloadPoliciesImplManagedLedgerOffloadedReadPriority = "BOOKKEEPER_FIRST"
	OffloadPoliciesImplManagedLedgerOffloadedReadPriorityTIEREDSTORAGEFIRST OffloadPoliciesImplManagedLedgerOffloadedReadPriority = "TIERED_STORAGE_FIRST"
)

// Defines values for PoliciesSchemaAutoUpdateCompatibilityStrategy.
const (
	AlwaysCompatible   PoliciesSchemaAutoUpdateCompatibilityStrategy = "AlwaysCompatible"
	AutoUpdateDisabled PoliciesSchemaAutoUpdateCompatibilityStrategy = "AutoUpdateDisabled"
	Backward           PoliciesSchemaAutoUpdateCompatibilityStrategy = "Backward"
	BackwardTransitive PoliciesSchemaAutoUpdateCompatibilityStrategy = "BackwardTransitive"
	Forward            PoliciesSchemaAutoUpdateCompatibilityStrategy = "Forward"
	ForwardTransitive  PoliciesSchemaAutoUpdateCompatibilityStrategy = "ForwardTransitive"
	Full               PoliciesSchemaAutoUpdateCompatibilityStrategy = "Full"
	FullTransitive     PoliciesSchemaAutoUpdateCompatibilityStrategy = "FullTransitive"
)

// Defines values for PoliciesSchemaCompatibilityStrategy.
const (
	ALWAYSCOMPATIBLE   PoliciesSchemaCompatibilityStrategy = "ALWAYS_COMPATIBLE"
	ALWAYSINCOMPATIBLE PoliciesSchemaCompatibilityStrategy = "ALWAYS_INCOMPATIBLE"
	BACKWARD           PoliciesSchemaCompatibilityStrategy = "BACKWARD"
	BACKWARDTRANSITIVE PoliciesSchemaCompatibilityStrategy = "BACKWARD_TRANSITIVE"
	FORWARD            PoliciesSchemaCompatibilityStrategy = "FORWARD"
	FORWARDTRANSITIVE  PoliciesSchemaCompatibilityStrategy = "FORWARD_TRANSITIVE"
	FULL               PoliciesSchemaCompatibilityStrategy = "FULL"
	FULLTRANSITIVE     PoliciesSchemaCompatibilityStrategy = "FULL_TRANSITIVE"
	UNDEFINED          PoliciesSchemaCompatibilityStrategy = "UNDEFINED"
)

// Defines values for PoliciesSubscriptionAuthMode.
const (
	None   PoliciesSubscriptionAuthMode = "None"
	Prefix PoliciesSubscriptionAuthMode = "Prefix"
)

// AllocatorStats defines model for AllocatorStats.
type AllocatorStats struct {
	DirectArenas         *[]PoolArenaStats `json:"directArenas,omitempty"`
	HeapArenas           *[]PoolArenaStats `json:"heapArenas,omitempty"`
	NormalCacheSize      *int32            `json:"normalCacheSize,omitempty"`
	NumDirectArenas      *int32            `json:"numDirectArenas,omitempty"`
	NumHeapArenas        *int32            `json:"numHeapArenas,omitempty"`
	NumThreadLocalCaches *int32            `json:"numThreadLocalCaches,omitempty"`
	SmallCacheSize       *int32            `json:"smallCacheSize,omitempty"`
}

// Annotation defines model for Annotation.
type Annotation = map[string]interface{}

// AuthPolicies defines model for AuthPolicies.
type AuthPolicies struct {
	NamespaceAuthentication    *AuthPolicies_NamespaceAuthentication    `json:"namespaceAuthentication,omitempty"`
	SubscriptionAuthentication *AuthPolicies_SubscriptionAuthentication `json:"subscriptionAuthentication,omitempty"`
	TopicAuthentication        *AuthPolicies_TopicAuthentication        `json:"topicAuthentication,omitempty"`
}

// AuthPolicies_NamespaceAuthentication defines model for AuthPolicies.NamespaceAuthentication.
type AuthPolicies_NamespaceAuthentication struct {
	AdditionalProperties map[string][]AuthPoliciesNamespaceAuthentication `json:"-"`
}

// AuthPolicies_SubscriptionAuthentication defines model for AuthPolicies.SubscriptionAuthentication.
type AuthPolicies_SubscriptionAuthentication struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// AuthPolicies_TopicAuthentication defines model for AuthPolicies.TopicAuthentication.
type AuthPolicies_TopicAuthentication struct {
	AdditionalProperties map[string]struct {
		AdditionalProperties map[string][]AuthPoliciesTopicAuthentication `json:"-"`
	} `json:"-"`
}

// AutoFailoverPolicyData defines model for AutoFailoverPolicyData.
type AutoFailoverPolicyData struct {
	Parameters *AutoFailoverPolicyData_Parameters `json:"parameters,omitempty"`
	PolicyType *AutoFailoverPolicyDataPolicyType  `json:"policyType,omitempty"`
}

// AutoFailoverPolicyData_Parameters defines model for AutoFailoverPolicyData.Parameters.
type AutoFailoverPolicyData_Parameters struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AutoFailoverPolicyDataPolicyType defines model for AutoFailoverPolicyData.PolicyType.
type AutoFailoverPolicyDataPolicyType string

// AutoSubscriptionCreationOverride defines model for AutoSubscriptionCreationOverride.
type AutoSubscriptionCreationOverride struct {
	AllowAutoSubscriptionCreation *bool `json:"allowAutoSubscriptionCreation,omitempty"`
}

// AutoTopicCreationOverride defines model for AutoTopicCreationOverride.
type AutoTopicCreationOverride struct {
	AllowAutoTopicCreation *bool   `json:"allowAutoTopicCreation,omitempty"`
	DefaultNumPartitions   *int32  `json:"defaultNumPartitions,omitempty"`
	TopicType              *string `json:"topicType,omitempty"`
}

// BacklogQuota defines model for BacklogQuota.
type BacklogQuota struct {
	Limit     *int64              `json:"limit,omitempty"`
	LimitSize *int64              `json:"limitSize,omitempty"`
	LimitTime *int32              `json:"limitTime,omitempty"`
	Policy    *BacklogQuotaPolicy `json:"policy,omitempty"`
}

// BacklogQuotaPolicy defines model for BacklogQuota.Policy.
type BacklogQuotaPolicy string

// BookieAffinityGroupData defines model for BookieAffinityGroupData.
type BookieAffinityGroupData struct {
	BookkeeperAffinityGroupPrimary   *string `json:"bookkeeperAffinityGroupPrimary,omitempty"`
	BookkeeperAffinityGroupSecondary *string `json:"bookkeeperAffinityGroupSecondary,omitempty"`
}

// BookieInfo defines model for BookieInfo.
type BookieInfo struct {
	Hostname *string `json:"hostname,omitempty"`
	Rack     *string `json:"rack,omitempty"`
}

// BookiesClusterInfo defines model for BookiesClusterInfo.
type BookiesClusterInfo struct {
	Bookies *[]RawBookieInfo `json:"bookies,omitempty"`
}

// BrokerInfo defines model for BrokerInfo.
type BrokerInfo struct {
	ServiceUrl *string `json:"serviceUrl,omitempty"`
}

// The namespace isolation data for a given broker
type BrokerNamespaceIsolationData struct {
	// The broker name
	BrokerName *string `json:"brokerName,omitempty"`

	// The namespace-isolation policies attached to this broker
	NamespaceRegex *[]string `json:"namespaceRegex,omitempty"`

	// Policy name
	PolicyName *string `json:"policyName,omitempty"`
	Primary    *bool   `json:"primary,omitempty"`
}

// BundlesData defines model for BundlesData.
type BundlesData struct {
	Boundaries *[]string `json:"boundaries,omitempty"`
	NumBundles *int32    `json:"numBundles,omitempty"`
}

// CharacterEscapes defines model for CharacterEscapes.
type CharacterEscapes struct {
	EscapeCodesForAscii *[]int32 `json:"escapeCodesForAscii,omitempty"`
}

// ClassLoader defines model for ClassLoader.
type ClassLoader struct {
	DefinedPackages             *[]Package   `json:"definedPackages,omitempty"`
	Name                        *string      `json:"name,omitempty"`
	Parent                      *ClassLoader `json:"parent,omitempty"`
	RegisteredAsParallelCapable *bool        `json:"registeredAsParallelCapable,omitempty"`
	UnnamedModule               *Module      `json:"unnamedModule,omitempty"`
}

// The configuration data for a cluster
type ClusterData struct {
	// Authentication parameters when client would like to connect to cluster.
	AuthenticationParameters *string `json:"authenticationParameters,omitempty"`

	// Authentication plugin when client would like to connect to cluster.
	AuthenticationPlugin *string `json:"authenticationPlugin,omitempty"`

	// Enable TLS when talking with other brokers in the same cluster (admin operation) or different clusters (replication)
	BrokerClientTlsEnabled *bool `json:"brokerClientTlsEnabled,omitempty"`

	// Whether internal client use KeyStore type to authenticate with other Pulsar brokers
	BrokerClientTlsEnabledWithKeyStore *bool `json:"brokerClientTlsEnabledWithKeyStore,omitempty"`

	// TLS TrustStore path for internal client used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStore *string `json:"brokerClientTlsTrustStore,omitempty"`

	// TLS TrustStore password for internal client used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStorePassword *string `json:"brokerClientTlsTrustStorePassword,omitempty"`

	// TLS TrustStore type configuration for internal client: JKS, PKCS12 used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStoreType *string `json:"brokerClientTlsTrustStoreType,omitempty"`

	// Path for the trusted TLS certificate file for outgoing connection to a server (broker)
	BrokerClientTrustCertsFilePath *string `json:"brokerClientTrustCertsFilePath,omitempty"`

	// The broker service url (for produce and consume operations)
	BrokerServiceUrl *string `json:"brokerServiceUrl,omitempty"`

	// The secured broker service url (for produce and consume operations)
	BrokerServiceUrlTls *string `json:"brokerServiceUrlTls,omitempty"`

	// listenerName when client would like to connect to cluster
	ListenerName *string `json:"listenerName,omitempty"`

	// A set of peer cluster names
	PeerClusterNames *[]string `json:"peerClusterNames,omitempty"`

	// protocol to decide type of proxy routing eg: SNI-routing
	ProxyProtocol *ClusterDataProxyProtocol `json:"proxyProtocol,omitempty"`

	// Proxy-service url when client would like to connect to broker via proxy.
	ProxyServiceUrl *string `json:"proxyServiceUrl,omitempty"`

	// The HTTP rest service URL (for admin operations)
	ServiceUrl *string `json:"serviceUrl,omitempty"`

	// The HTTPS rest service URL (for admin operations)
	ServiceUrlTls *string `json:"serviceUrlTls,omitempty"`

	// Allow TLS connections to servers whose certificate cannot be be verified to have been signed by a trusted certificate authority.
	TlsAllowInsecureConnection *bool `json:"tlsAllowInsecureConnection,omitempty"`
}

// protocol to decide type of proxy routing eg: SNI-routing
type ClusterDataProxyProtocol string

// DelayedDeliveryPolicies defines model for DelayedDeliveryPolicies.
type DelayedDeliveryPolicies struct {
	Active   *bool  `json:"active,omitempty"`
	TickTime *int64 `json:"tickTime,omitempty"`
}

// DeleteSchemaResponse defines model for DeleteSchemaResponse.
type DeleteSchemaResponse struct {
	Version *int64 `json:"version,omitempty"`
}

// DispatchRateImpl defines model for DispatchRateImpl.
type DispatchRateImpl struct {
	DispatchThrottlingRateInByte *int64 `json:"dispatchThrottlingRateInByte,omitempty"`
	DispatchThrottlingRateInMsg  *int32 `json:"dispatchThrottlingRateInMsg,omitempty"`
	RatePeriodInSecond           *int32 `json:"ratePeriodInSecond,omitempty"`
	RelativeToPublishRate        *bool  `json:"relativeToPublishRate,omitempty"`
}

// EntryFilters defines model for EntryFilters.
type EntryFilters struct {
	EntryFilterNames *string `json:"entryFilterNames,omitempty"`
}

// The data of a failure domain configuration in a cluster
type FailureDomain struct {
	// The collection of brokers in the same failure domain
	Brokers *[]string `json:"brokers,omitempty"`
}

// FunctionInstanceStatsData defines model for FunctionInstanceStatsData.
type FunctionInstanceStatsData struct {
	AvgProcessLatency          *float64                               `json:"avgProcessLatency,omitempty"`
	LastInvocation             *int64                                 `json:"lastInvocation,omitempty"`
	OneMin                     *FunctionInstanceStatsDataBase         `json:"oneMin,omitempty"`
	ProcessedSuccessfullyTotal *int64                                 `json:"processedSuccessfullyTotal,omitempty"`
	ReceivedTotal              *int64                                 `json:"receivedTotal,omitempty"`
	SystemExceptionsTotal      *int64                                 `json:"systemExceptionsTotal,omitempty"`
	UserExceptionsTotal        *int64                                 `json:"userExceptionsTotal,omitempty"`
	UserMetrics                *FunctionInstanceStatsData_UserMetrics `json:"userMetrics,omitempty"`
}

// FunctionInstanceStatsData_UserMetrics defines model for FunctionInstanceStatsData.UserMetrics.
type FunctionInstanceStatsData_UserMetrics struct {
	AdditionalProperties map[string]float64 `json:"-"`
}

// FunctionInstanceStatsDataBase defines model for FunctionInstanceStatsDataBase.
type FunctionInstanceStatsDataBase struct {
	AvgProcessLatency          *float64 `json:"avgProcessLatency,omitempty"`
	ProcessedSuccessfullyTotal *int64   `json:"processedSuccessfullyTotal,omitempty"`
	ReceivedTotal              *int64   `json:"receivedTotal,omitempty"`
	SystemExceptionsTotal      *int64   `json:"systemExceptionsTotal,omitempty"`
	UserExceptionsTotal        *int64   `json:"userExceptionsTotal,omitempty"`
}

// GetAllVersionsSchemaResponse defines model for GetAllVersionsSchemaResponse.
type GetAllVersionsSchemaResponse struct {
	GetSchemaResponses *[]GetSchemaResponse `json:"getSchemaResponses,omitempty"`
}

// GetSchemaResponse defines model for GetSchemaResponse.
type GetSchemaResponse struct {
	Data       *string                       `json:"data,omitempty"`
	Properties *GetSchemaResponse_Properties `json:"properties,omitempty"`
	Timestamp  *int64                        `json:"timestamp,omitempty"`
	Type       *GetSchemaResponseType        `json:"type,omitempty"`
	Version    *int64                        `json:"version,omitempty"`
}

// GetSchemaResponse_Properties defines model for GetSchemaResponse.Properties.
type GetSchemaResponse_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// GetSchemaResponseType defines model for GetSchemaResponse.Type.
type GetSchemaResponseType string

// InactiveTopicPolicies defines model for InactiveTopicPolicies.
type InactiveTopicPolicies struct {
	DeleteWhileInactive        *bool                                         `json:"deleteWhileInactive,omitempty"`
	InactiveTopicDeleteMode    *InactiveTopicPoliciesInactiveTopicDeleteMode `json:"inactiveTopicDeleteMode,omitempty"`
	MaxInactiveDurationSeconds *int32                                        `json:"maxInactiveDurationSeconds,omitempty"`
}

// InactiveTopicPoliciesInactiveTopicDeleteMode defines model for InactiveTopicPolicies.InactiveTopicDeleteMode.
type InactiveTopicPoliciesInactiveTopicDeleteMode string

// InputDecorator defines model for InputDecorator.
type InputDecorator = map[string]interface{}

// InternalConfigurationData defines model for InternalConfigurationData.
type InternalConfigurationData struct {
	BookkeeperMetadataServiceUri  *string `json:"bookkeeperMetadataServiceUri,omitempty"`
	ConfigurationMetadataStoreUrl *string `json:"configurationMetadataStoreUrl,omitempty"`
	LedgersRootPath               *string `json:"ledgersRootPath,omitempty"`
	MetadataStoreUrl              *string `json:"metadataStoreUrl,omitempty"`
	StateStorageServiceUrl        *string `json:"stateStorageServiceUrl,omitempty"`
}

// IsCompatibilityResponse defines model for IsCompatibilityResponse.
type IsCompatibilityResponse struct {
	Compatibility               *bool   `json:"compatibility,omitempty"`
	SchemaCompatibilityStrategy *string `json:"schemaCompatibilityStrategy,omitempty"`
}

// JavaType defines model for JavaType.
type JavaType struct {
	Abstract            *bool                   `json:"abstract,omitempty"`
	ArrayType           *bool                   `json:"arrayType,omitempty"`
	Bindings            *TypeBindings           `json:"bindings,omitempty"`
	CollectionLikeType  *bool                   `json:"collectionLikeType,omitempty"`
	Concrete            *bool                   `json:"concrete,omitempty"`
	ContainerType       *bool                   `json:"containerType,omitempty"`
	ContentType         *JavaType               `json:"contentType,omitempty"`
	ContentTypeHandler  *map[string]interface{} `json:"contentTypeHandler,omitempty"`
	ContentValueHandler *map[string]interface{} `json:"contentValueHandler,omitempty"`
	EnumType            *bool                   `json:"enumType,omitempty"`
	ErasedSignature     *string                 `json:"erasedSignature,omitempty"`
	Final               *bool                   `json:"final,omitempty"`
	GenericSignature    *string                 `json:"genericSignature,omitempty"`
	Interface           *bool                   `json:"interface,omitempty"`
	Interfaces          *[]JavaType             `json:"interfaces,omitempty"`
	JavaLangObject      *bool                   `json:"javaLangObject,omitempty"`
	KeyType             *JavaType               `json:"keyType,omitempty"`
	MapLikeType         *bool                   `json:"mapLikeType,omitempty"`
	Primitive           *bool                   `json:"primitive,omitempty"`
	ReferenceType       *bool                   `json:"referenceType,omitempty"`
	ReferencedType      *JavaType               `json:"referencedType,omitempty"`
	SuperClass          *JavaType               `json:"superClass,omitempty"`
	Throwable           *bool                   `json:"throwable,omitempty"`
	TypeHandler         *map[string]interface{} `json:"typeHandler,omitempty"`
	TypeName            *string                 `json:"typeName,omitempty"`
	ValueHandler        *map[string]interface{} `json:"valueHandler,omitempty"`
}

// JsonFactory defines model for JsonFactory.
type JsonFactory struct {
	CharacterEscapes   *CharacterEscapes `json:"characterEscapes,omitempty"`
	Codec              *ObjectCodec      `json:"codec,omitempty"`
	FormatName         *string           `json:"formatName,omitempty"`
	InputDecorator     *InputDecorator   `json:"inputDecorator,omitempty"`
	OutputDecorator    *OutputDecorator  `json:"outputDecorator,omitempty"`
	RootValueSeparator *string           `json:"rootValueSeparator,omitempty"`
}

// JsonSerializerObject defines model for JsonSerializerObject.
type JsonSerializerObject struct {
	Delegatee            *JsonSerializerObject `json:"delegatee,omitempty"`
	UnwrappingSerializer *bool                 `json:"unwrappingSerializer,omitempty"`
}

// JsonStreamContext defines model for JsonStreamContext.
type JsonStreamContext struct {
	CurrentIndex *int32                  `json:"currentIndex,omitempty"`
	CurrentName  *string                 `json:"currentName,omitempty"`
	CurrentValue *map[string]interface{} `json:"currentValue,omitempty"`
	EntryCount   *int32                  `json:"entryCount,omitempty"`
	Parent       *JsonStreamContext      `json:"parent,omitempty"`
	TypeDesc     *string                 `json:"typeDesc,omitempty"`
}

// LoadReport defines model for LoadReport.
type LoadReport struct {
	AllocatedBandwidthIn       *float64                `json:"allocatedBandwidthIn,omitempty"`
	AllocatedBandwidthOut      *float64                `json:"allocatedBandwidthOut,omitempty"`
	AllocatedCPU               *float64                `json:"allocatedCPU,omitempty"`
	AllocatedMemory            *float64                `json:"allocatedMemory,omitempty"`
	AllocatedMsgRateIn         *float64                `json:"allocatedMsgRateIn,omitempty"`
	AllocatedMsgRateOut        *float64                `json:"allocatedMsgRateOut,omitempty"`
	BandwidthIn                *ResourceUsage          `json:"bandwidthIn,omitempty"`
	BandwidthOut               *ResourceUsage          `json:"bandwidthOut,omitempty"`
	BrokerVersionString        *string                 `json:"brokerVersionString,omitempty"`
	BundleGains                *[]string               `json:"bundleGains,omitempty"`
	BundleLosses               *[]string               `json:"bundleLosses,omitempty"`
	BundleStats                *LoadReport_BundleStats `json:"bundleStats,omitempty"`
	Cpu                        *ResourceUsage          `json:"cpu,omitempty"`
	DirectMemory               *ResourceUsage          `json:"directMemory,omitempty"`
	LastUpdate                 *int64                  `json:"lastUpdate,omitempty"`
	LoadReportType             *string                 `json:"loadReportType,omitempty"`
	Memory                     *ResourceUsage          `json:"memory,omitempty"`
	MsgRateIn                  *float64                `json:"msgRateIn,omitempty"`
	MsgRateOut                 *float64                `json:"msgRateOut,omitempty"`
	MsgThroughputIn            *float64                `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut           *float64                `json:"msgThroughputOut,omitempty"`
	Name                       *string                 `json:"name,omitempty"`
	NonPersistentTopicsEnabled *bool                   `json:"nonPersistentTopicsEnabled,omitempty"`
	NumBundles                 *int32                  `json:"numBundles,omitempty"`
	NumConsumers               *int32                  `json:"numConsumers,omitempty"`
	NumProducers               *int32                  `json:"numProducers,omitempty"`
	NumTopics                  *int32                  `json:"numTopics,omitempty"`
	OverLoaded                 *bool                   `json:"overLoaded,omitempty"`
	PersistentTopicsEnabled    *bool                   `json:"persistentTopicsEnabled,omitempty"`
	PreAllocatedBandwidthIn    *float64                `json:"preAllocatedBandwidthIn,omitempty"`
	PreAllocatedBandwidthOut   *float64                `json:"preAllocatedBandwidthOut,omitempty"`
	PreAllocatedCPU            *float64                `json:"preAllocatedCPU,omitempty"`
	PreAllocatedMemory         *float64                `json:"preAllocatedMemory,omitempty"`
	PreAllocatedMsgRateIn      *float64                `json:"preAllocatedMsgRateIn,omitempty"`
	PreAllocatedMsgRateOut     *float64                `json:"preAllocatedMsgRateOut,omitempty"`
	Protocols                  *LoadReport_Protocols   `json:"protocols,omitempty"`
	PulsarServiceUrl           *string                 `json:"pulsarServiceUrl,omitempty"`
	PulsarServiceUrlTls        *string                 `json:"pulsarServiceUrlTls,omitempty"`
	SystemResourceUsage        *SystemResourceUsage    `json:"systemResourceUsage,omitempty"`
	Timestamp                  *int64                  `json:"timestamp,omitempty"`
	UnderLoaded                *bool                   `json:"underLoaded,omitempty"`
	WebServiceUrl              *string                 `json:"webServiceUrl,omitempty"`
	WebServiceUrlTls           *string                 `json:"webServiceUrlTls,omitempty"`
}

// LoadReport_BundleStats defines model for LoadReport.BundleStats.
type LoadReport_BundleStats struct {
	AdditionalProperties map[string]NamespaceBundleStats `json:"-"`
}

// LoadReport_Protocols defines model for LoadReport.Protocols.
type LoadReport_Protocols struct {
	AdditionalProperties map[string]string `json:"-"`
}

// LongRunningProcessStatus defines model for LongRunningProcessStatus.
type LongRunningProcessStatus struct {
	LastError *string                         `json:"lastError,omitempty"`
	Status    *LongRunningProcessStatusStatus `json:"status,omitempty"`
}

// LongRunningProcessStatusStatus defines model for LongRunningProcessStatus.Status.
type LongRunningProcessStatusStatus string

// LongSchemaVersion defines model for LongSchemaVersion.
type LongSchemaVersion struct {
	Version *int64 `json:"version,omitempty"`
}

// Metrics defines model for Metrics.
type Metrics struct {
	Dimensions *Metrics_Dimensions `json:"dimensions,omitempty"`
	Metrics    *Metrics_Metrics    `json:"metrics,omitempty"`
}

// Metrics_Dimensions defines model for Metrics.Dimensions.
type Metrics_Dimensions struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Metrics_Metrics defines model for Metrics.Metrics.
type Metrics_Metrics struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// Module defines model for Module.
type Module struct {
	Annotations         *[]Annotation     `json:"annotations,omitempty"`
	ClassLoader         *ClassLoader      `json:"classLoader,omitempty"`
	DeclaredAnnotations *[]Annotation     `json:"declaredAnnotations,omitempty"`
	Descriptor          *ModuleDescriptor `json:"descriptor,omitempty"`
	Layer               *ModuleLayer      `json:"layer,omitempty"`
	Name                *string           `json:"name,omitempty"`
	Named               *bool             `json:"named,omitempty"`
	Packages            *[]string         `json:"packages,omitempty"`
}

// ModuleDescriptor defines model for ModuleDescriptor.
type ModuleDescriptor struct {
	Automatic *bool `json:"automatic,omitempty"`
	Open      *bool `json:"open,omitempty"`
}

// ModuleLayer defines model for ModuleLayer.
type ModuleLayer = map[string]interface{}

// NamespaceBundleStats defines model for NamespaceBundleStats.
type NamespaceBundleStats struct {
	CacheSize        *int64   `json:"cacheSize,omitempty"`
	ConsumerCount    *int32   `json:"consumerCount,omitempty"`
	MsgRateIn        *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut       *float64 `json:"msgRateOut,omitempty"`
	MsgThroughputIn  *float64 `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut *float64 `json:"msgThroughputOut,omitempty"`
	ProducerCount    *int32   `json:"producerCount,omitempty"`
	Topics           *int64   `json:"topics,omitempty"`
}

// The data of namespace isolation configuration
type NamespaceIsolationData struct {
	AutoFailoverPolicy *AutoFailoverPolicyData `json:"auto_failover_policy,omitempty"`

	// The list of namespaces to apply this namespace isolation data
	Namespaces *[]string `json:"namespaces,omitempty"`

	// The list of primary brokers for serving the list of namespaces in this isolation policy
	Primary *[]string `json:"primary,omitempty"`

	// The list of secondary brokers for serving the list of namespaces in this isolation policy
	Secondary *[]string `json:"secondary,omitempty"`
}

// NamespaceOwnershipStatus defines model for NamespaceOwnershipStatus.
type NamespaceOwnershipStatus struct {
	BrokerAssignment *NamespaceOwnershipStatusBrokerAssignment `json:"broker_assignment,omitempty"`
	IsActive         *bool                                     `json:"is_active,omitempty"`
	IsControlled     *bool                                     `json:"is_controlled,omitempty"`
}

// NamespaceOwnershipStatusBrokerAssignment defines model for NamespaceOwnershipStatus.BrokerAssignment.
type NamespaceOwnershipStatusBrokerAssignment string

// ObjectCodec defines model for ObjectCodec.
type ObjectCodec struct {
	Factory     *JsonFactory `json:"factory,omitempty"`
	JsonFactory *JsonFactory `json:"jsonFactory,omitempty"`
}

// OffloadPolicies defines model for OffloadPolicies.
type OffloadPolicies struct {
	FileSystemProfilePath                        *string                                            `json:"fileSystemProfilePath,omitempty"`
	FileSystemURI                                *string                                            `json:"fileSystemURI,omitempty"`
	GcsManagedLedgerOffloadBucket                *string                                            `json:"gcsManagedLedgerOffloadBucket,omitempty"`
	GcsManagedLedgerOffloadMaxBlockSizeInBytes   *int32                                             `json:"gcsManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadReadBufferSizeInBytes *int32                                             `json:"gcsManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadRegion                *string                                            `json:"gcsManagedLedgerOffloadRegion,omitempty"`
	GcsManagedLedgerOffloadServiceAccountKeyFile *string                                            `json:"gcsManagedLedgerOffloadServiceAccountKeyFile,omitempty"`
	ManagedLedgerOffloadBucket                   *string                                            `json:"managedLedgerOffloadBucket,omitempty"`
	ManagedLedgerOffloadDeletionLagInMillis      *int64                                             `json:"managedLedgerOffloadDeletionLagInMillis,omitempty"`
	ManagedLedgerOffloadDriver                   *string                                            `json:"managedLedgerOffloadDriver,omitempty"`
	ManagedLedgerOffloadMaxBlockSizeInBytes      *int32                                             `json:"managedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	ManagedLedgerOffloadMaxThreads               *int32                                             `json:"managedLedgerOffloadMaxThreads,omitempty"`
	ManagedLedgerOffloadPrefetchRounds           *int32                                             `json:"managedLedgerOffloadPrefetchRounds,omitempty"`
	ManagedLedgerOffloadReadBufferSizeInBytes    *int32                                             `json:"managedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	ManagedLedgerOffloadRegion                   *string                                            `json:"managedLedgerOffloadRegion,omitempty"`
	ManagedLedgerOffloadServiceEndpoint          *string                                            `json:"managedLedgerOffloadServiceEndpoint,omitempty"`
	ManagedLedgerOffloadThresholdInBytes         *int64                                             `json:"managedLedgerOffloadThresholdInBytes,omitempty"`
	ManagedLedgerOffloadedReadPriority           *OffloadPoliciesManagedLedgerOffloadedReadPriority `json:"managedLedgerOffloadedReadPriority,omitempty"`
	OffloadersDirectory                          *string                                            `json:"offloadersDirectory,omitempty"`
	S3ManagedLedgerOffloadBucket                 *string                                            `json:"s3ManagedLedgerOffloadBucket,omitempty"`
	S3ManagedLedgerOffloadCredentialId           *string                                            `json:"s3ManagedLedgerOffloadCredentialId,omitempty"`
	S3ManagedLedgerOffloadCredentialSecret       *string                                            `json:"s3ManagedLedgerOffloadCredentialSecret,omitempty"`
	S3ManagedLedgerOffloadMaxBlockSizeInBytes    *int32                                             `json:"s3ManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadReadBufferSizeInBytes  *int32                                             `json:"s3ManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadRegion                 *string                                            `json:"s3ManagedLedgerOffloadRegion,omitempty"`
	S3ManagedLedgerOffloadRole                   *string                                            `json:"s3ManagedLedgerOffloadRole,omitempty"`
	S3ManagedLedgerOffloadRoleSessionName        *string                                            `json:"s3ManagedLedgerOffloadRoleSessionName,omitempty"`
	S3ManagedLedgerOffloadServiceEndpoint        *string                                            `json:"s3ManagedLedgerOffloadServiceEndpoint,omitempty"`
}

// OffloadPoliciesManagedLedgerOffloadedReadPriority defines model for OffloadPolicies.ManagedLedgerOffloadedReadPriority.
type OffloadPoliciesManagedLedgerOffloadedReadPriority string

// OffloadPoliciesImpl defines model for OffloadPoliciesImpl.
type OffloadPoliciesImpl struct {
	FileSystemDriver                             *bool                                                  `json:"fileSystemDriver,omitempty"`
	FileSystemProfilePath                        *string                                                `json:"fileSystemProfilePath,omitempty"`
	FileSystemURI                                *string                                                `json:"fileSystemURI,omitempty"`
	GcsDriver                                    *bool                                                  `json:"gcsDriver,omitempty"`
	GcsManagedLedgerOffloadBucket                *string                                                `json:"gcsManagedLedgerOffloadBucket,omitempty"`
	GcsManagedLedgerOffloadMaxBlockSizeInBytes   *int32                                                 `json:"gcsManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadReadBufferSizeInBytes *int32                                                 `json:"gcsManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadRegion                *string                                                `json:"gcsManagedLedgerOffloadRegion,omitempty"`
	GcsManagedLedgerOffloadServiceAccountKeyFile *string                                                `json:"gcsManagedLedgerOffloadServiceAccountKeyFile,omitempty"`
	ManagedLedgerOffloadBucket                   *string                                                `json:"managedLedgerOffloadBucket,omitempty"`
	ManagedLedgerOffloadDeletionLagInMillis      *int64                                                 `json:"managedLedgerOffloadDeletionLagInMillis,omitempty"`
	ManagedLedgerOffloadDriver                   *string                                                `json:"managedLedgerOffloadDriver,omitempty"`
	ManagedLedgerOffloadMaxBlockSizeInBytes      *int32                                                 `json:"managedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	ManagedLedgerOffloadMaxThreads               *int32                                                 `json:"managedLedgerOffloadMaxThreads,omitempty"`
	ManagedLedgerOffloadPrefetchRounds           *int32                                                 `json:"managedLedgerOffloadPrefetchRounds,omitempty"`
	ManagedLedgerOffloadReadBufferSizeInBytes    *int32                                                 `json:"managedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	ManagedLedgerOffloadRegion                   *string                                                `json:"managedLedgerOffloadRegion,omitempty"`
	ManagedLedgerOffloadServiceEndpoint          *string                                                `json:"managedLedgerOffloadServiceEndpoint,omitempty"`
	ManagedLedgerOffloadThresholdInBytes         *int64                                                 `json:"managedLedgerOffloadThresholdInBytes,omitempty"`
	ManagedLedgerOffloadedReadPriority           *OffloadPoliciesImplManagedLedgerOffloadedReadPriority `json:"managedLedgerOffloadedReadPriority,omitempty"`
	OffloadersDirectory                          *string                                                `json:"offloadersDirectory,omitempty"`
	S3Driver                                     *bool                                                  `json:"s3Driver,omitempty"`
	S3ManagedLedgerOffloadBucket                 *string                                                `json:"s3ManagedLedgerOffloadBucket,omitempty"`
	S3ManagedLedgerOffloadCredentialId           *string                                                `json:"s3ManagedLedgerOffloadCredentialId,omitempty"`
	S3ManagedLedgerOffloadCredentialSecret       *string                                                `json:"s3ManagedLedgerOffloadCredentialSecret,omitempty"`
	S3ManagedLedgerOffloadMaxBlockSizeInBytes    *int32                                                 `json:"s3ManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadReadBufferSizeInBytes  *int32                                                 `json:"s3ManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadRegion                 *string                                                `json:"s3ManagedLedgerOffloadRegion,omitempty"`
	S3ManagedLedgerOffloadRole                   *string                                                `json:"s3ManagedLedgerOffloadRole,omitempty"`
	S3ManagedLedgerOffloadRoleSessionName        *string                                                `json:"s3ManagedLedgerOffloadRoleSessionName,omitempty"`
	S3ManagedLedgerOffloadServiceEndpoint        *string                                                `json:"s3ManagedLedgerOffloadServiceEndpoint,omitempty"`
}

// OffloadPoliciesImplManagedLedgerOffloadedReadPriority defines model for OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriority.
type OffloadPoliciesImplManagedLedgerOffloadedReadPriority string

// OutputDecorator defines model for OutputDecorator.
type OutputDecorator = map[string]interface{}

// OutputStream defines model for OutputStream.
type OutputStream = map[string]interface{}

// Package defines model for Package.
type Package struct {
	Annotations           *[]Annotation `json:"annotations,omitempty"`
	DeclaredAnnotations   *[]Annotation `json:"declaredAnnotations,omitempty"`
	ImplementationTitle   *string       `json:"implementationTitle,omitempty"`
	ImplementationVendor  *string       `json:"implementationVendor,omitempty"`
	ImplementationVersion *string       `json:"implementationVersion,omitempty"`
	Name                  *string       `json:"name,omitempty"`
	Sealed                *bool         `json:"sealed,omitempty"`
	SpecificationTitle    *string       `json:"specificationTitle,omitempty"`
	SpecificationVendor   *string       `json:"specificationVendor,omitempty"`
	SpecificationVersion  *string       `json:"specificationVersion,omitempty"`
}

// PartitionedTopicMetadata defines model for PartitionedTopicMetadata.
type PartitionedTopicMetadata struct {
	Partitions *int32                               `json:"partitions,omitempty"`
	Properties *PartitionedTopicMetadata_Properties `json:"properties,omitempty"`
}

// PartitionedTopicMetadata_Properties defines model for PartitionedTopicMetadata.Properties.
type PartitionedTopicMetadata_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// PendingBookieOpsStats defines model for PendingBookieOpsStats.
type PendingBookieOpsStats struct {
	CursorLedgerCloseOp  *int64 `json:"cursorLedgerCloseOp,omitempty"`
	CursorLedgerCreateOp *int64 `json:"cursorLedgerCreateOp,omitempty"`
	CursorLedgerDeleteOp *int64 `json:"cursorLedgerDeleteOp,omitempty"`
	CursorLedgerOpenOp   *int64 `json:"cursorLedgerOpenOp,omitempty"`
	DataLedgerCloseOp    *int64 `json:"dataLedgerCloseOp,omitempty"`
	DataLedgerCreateOp   *int64 `json:"dataLedgerCreateOp,omitempty"`
	DataLedgerDeleteOp   *int64 `json:"dataLedgerDeleteOp,omitempty"`
	DataLedgerOpenOp     *int64 `json:"dataLedgerOpenOp,omitempty"`
}

// PersistencePolicies defines model for PersistencePolicies.
type PersistencePolicies struct {
	BookkeeperAckQuorum            *int32   `json:"bookkeeperAckQuorum,omitempty"`
	BookkeeperEnsemble             *int32   `json:"bookkeeperEnsemble,omitempty"`
	BookkeeperWriteQuorum          *int32   `json:"bookkeeperWriteQuorum,omitempty"`
	ManagedLedgerMaxMarkDeleteRate *float64 `json:"managedLedgerMaxMarkDeleteRate,omitempty"`
}

// Policies defines model for Policies.
type Policies struct {
	AuthPolicies                          *AuthPolicies                                  `json:"auth_policies,omitempty"`
	AutoSubscriptionCreationOverride      *AutoSubscriptionCreationOverride              `json:"autoSubscriptionCreationOverride,omitempty"`
	AutoTopicCreationOverride             *AutoTopicCreationOverride                     `json:"autoTopicCreationOverride,omitempty"`
	BacklogQuotaMap                       *Policies_BacklogQuotaMap                      `json:"backlog_quota_map,omitempty"`
	Bundles                               *BundlesData                                   `json:"bundles,omitempty"`
	ClusterDispatchRate                   *Policies_ClusterDispatchRate                  `json:"clusterDispatchRate,omitempty"`
	ClusterSubscribeRate                  *Policies_ClusterSubscribeRate                 `json:"clusterSubscribeRate,omitempty"`
	CompactionThreshold                   *int64                                         `json:"compaction_threshold,omitempty"`
	DeduplicationEnabled                  *bool                                          `json:"deduplicationEnabled,omitempty"`
	DeduplicationSnapshotIntervalSeconds  *int32                                         `json:"deduplicationSnapshotIntervalSeconds,omitempty"`
	DelayedDeliveryPolicies               *DelayedDeliveryPolicies                       `json:"delayed_delivery_policies,omitempty"`
	Deleted                               *bool                                          `json:"deleted,omitempty"`
	EncryptionRequired                    *bool                                          `json:"encryption_required,omitempty"`
	EntryFilters                          *EntryFilters                                  `json:"entryFilters,omitempty"`
	InactiveTopicPolicies                 *InactiveTopicPolicies                         `json:"inactive_topic_policies,omitempty"`
	IsAllowAutoUpdateSchema               *bool                                          `json:"is_allow_auto_update_schema,omitempty"`
	LatencyStatsSampleRate                *Policies_LatencyStatsSampleRate               `json:"latency_stats_sample_rate,omitempty"`
	MaxConsumersPerSubscription           *int32                                         `json:"max_consumers_per_subscription,omitempty"`
	MaxConsumersPerTopic                  *int32                                         `json:"max_consumers_per_topic,omitempty"`
	MaxProducersPerTopic                  *int32                                         `json:"max_producers_per_topic,omitempty"`
	MaxSubscriptionsPerTopic              *int32                                         `json:"max_subscriptions_per_topic,omitempty"`
	MaxTopicsPerNamespace                 *int32                                         `json:"max_topics_per_namespace,omitempty"`
	MaxUnackedMessagesPerConsumer         *int32                                         `json:"max_unacked_messages_per_consumer,omitempty"`
	MaxUnackedMessagesPerSubscription     *int32                                         `json:"max_unacked_messages_per_subscription,omitempty"`
	MessageTtlInSeconds                   *int32                                         `json:"message_ttl_in_seconds,omitempty"`
	OffloadDeletionLagMs                  *int64                                         `json:"offload_deletion_lag_ms,omitempty"`
	OffloadPolicies                       *OffloadPolicies                               `json:"offload_policies,omitempty"`
	OffloadThreshold                      *int64                                         `json:"offload_threshold,omitempty"`
	Persistence                           *PersistencePolicies                           `json:"persistence,omitempty"`
	Properties                            *Policies_Properties                           `json:"properties,omitempty"`
	PublishMaxMessageRate                 *Policies_PublishMaxMessageRate                `json:"publishMaxMessageRate,omitempty"`
	ReplicationClusters                   *[]string                                      `json:"replication_clusters,omitempty"`
	ReplicatorDispatchRate                *Policies_ReplicatorDispatchRate               `json:"replicatorDispatchRate,omitempty"`
	ResourceGroupName                     *string                                        `json:"resource_group_name,omitempty"`
	RetentionPolicies                     *RetentionPolicies                             `json:"retention_policies,omitempty"`
	SchemaAutoUpdateCompatibilityStrategy *PoliciesSchemaAutoUpdateCompatibilityStrategy `json:"schema_auto_update_compatibility_strategy,omitempty"`
	SchemaCompatibilityStrategy           *PoliciesSchemaCompatibilityStrategy           `json:"schema_compatibility_strategy,omitempty"`
	SchemaValidationEnforced              *bool                                          `json:"schema_validation_enforced,omitempty"`
	SubscriptionDispatchRate              *Policies_SubscriptionDispatchRate             `json:"subscriptionDispatchRate,omitempty"`
	SubscriptionAuthMode                  *PoliciesSubscriptionAuthMode                  `json:"subscription_auth_mode,omitempty"`
	SubscriptionExpirationTimeMinutes     *int32                                         `json:"subscription_expiration_time_minutes,omitempty"`
	SubscriptionTypesEnabled              *[]string                                      `json:"subscription_types_enabled,omitempty"`
	TopicDispatchRate                     *Policies_TopicDispatchRate                    `json:"topicDispatchRate,omitempty"`
}

// Policies_BacklogQuotaMap defines model for Policies.BacklogQuotaMap.
type Policies_BacklogQuotaMap struct {
	AdditionalProperties map[string]BacklogQuota `json:"-"`
}

// Policies_ClusterDispatchRate defines model for Policies.ClusterDispatchRate.
type Policies_ClusterDispatchRate struct {
	AdditionalProperties map[string]DispatchRateImpl `json:"-"`
}

// Policies_ClusterSubscribeRate defines model for Policies.ClusterSubscribeRate.
type Policies_ClusterSubscribeRate struct {
	AdditionalProperties map[string]SubscribeRate `json:"-"`
}

// Policies_LatencyStatsSampleRate defines model for Policies.LatencyStatsSampleRate.
type Policies_LatencyStatsSampleRate struct {
	AdditionalProperties map[string]int32 `json:"-"`
}

// Policies_Properties defines model for Policies.Properties.
type Policies_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Policies_PublishMaxMessageRate defines model for Policies.PublishMaxMessageRate.
type Policies_PublishMaxMessageRate struct {
	AdditionalProperties map[string]PublishRate `json:"-"`
}

// Policies_ReplicatorDispatchRate defines model for Policies.ReplicatorDispatchRate.
type Policies_ReplicatorDispatchRate struct {
	AdditionalProperties map[string]DispatchRateImpl `json:"-"`
}

// PoliciesSchemaAutoUpdateCompatibilityStrategy defines model for Policies.SchemaAutoUpdateCompatibilityStrategy.
type PoliciesSchemaAutoUpdateCompatibilityStrategy string

// PoliciesSchemaCompatibilityStrategy defines model for Policies.SchemaCompatibilityStrategy.
type PoliciesSchemaCompatibilityStrategy string

// Policies_SubscriptionDispatchRate defines model for Policies.SubscriptionDispatchRate.
type Policies_SubscriptionDispatchRate struct {
	AdditionalProperties map[string]DispatchRateImpl `json:"-"`
}

// PoliciesSubscriptionAuthMode defines model for Policies.SubscriptionAuthMode.
type PoliciesSubscriptionAuthMode string

// Policies_TopicDispatchRate defines model for Policies.TopicDispatchRate.
type Policies_TopicDispatchRate struct {
	AdditionalProperties map[string]DispatchRateImpl `json:"-"`
}

// PoolArenaStats defines model for PoolArenaStats.
type PoolArenaStats struct {
	ChunkLists                 *[]PoolChunkListStats `json:"chunkLists,omitempty"`
	NumActiveAllocations       *int64                `json:"numActiveAllocations,omitempty"`
	NumActiveHugeAllocations   *int64                `json:"numActiveHugeAllocations,omitempty"`
	NumActiveNormalAllocations *int64                `json:"numActiveNormalAllocations,omitempty"`
	NumActiveSmallAllocations  *int64                `json:"numActiveSmallAllocations,omitempty"`
	NumAllocations             *int64                `json:"numAllocations,omitempty"`
	NumChunkLists              *int32                `json:"numChunkLists,omitempty"`
	NumDeallocations           *int64                `json:"numDeallocations,omitempty"`
	NumHugeAllocations         *int64                `json:"numHugeAllocations,omitempty"`
	NumHugeDeallocations       *int64                `json:"numHugeDeallocations,omitempty"`
	NumNormalAllocations       *int64                `json:"numNormalAllocations,omitempty"`
	NumNormalDeallocations     *int64                `json:"numNormalDeallocations,omitempty"`
	NumSmallAllocations        *int64                `json:"numSmallAllocations,omitempty"`
	NumSmallDeallocations      *int64                `json:"numSmallDeallocations,omitempty"`
	NumSmallSubpages           *int32                `json:"numSmallSubpages,omitempty"`
	SmallSubpages              *[]PoolSubpageStats   `json:"smallSubpages,omitempty"`
}

// PoolChunkListStats defines model for PoolChunkListStats.
type PoolChunkListStats struct {
	Chunks   *[]PoolChunkStats `json:"chunks,omitempty"`
	MaxUsage *int32            `json:"maxUsage,omitempty"`
	MinUsage *int32            `json:"minUsage,omitempty"`
}

// PoolChunkStats defines model for PoolChunkStats.
type PoolChunkStats struct {
	ChunkSize *int32 `json:"chunkSize,omitempty"`
	FreeBytes *int32 `json:"freeBytes,omitempty"`
	Usage     *int32 `json:"usage,omitempty"`
}

// PoolSubpageStats defines model for PoolSubpageStats.
type PoolSubpageStats struct {
	ElementSize    *int32 `json:"elementSize,omitempty"`
	MaxNumElements *int32 `json:"maxNumElements,omitempty"`
	NumAvailable   *int32 `json:"numAvailable,omitempty"`
	PageSize       *int32 `json:"pageSize,omitempty"`
}

// PostSchemaPayload defines model for PostSchemaPayload.
type PostSchemaPayload struct {
	Properties *PostSchemaPayload_Properties `json:"properties,omitempty"`
	Schema     *string                       `json:"schema,omitempty"`
	Type       *string                       `json:"type,omitempty"`
}

// PostSchemaPayload_Properties defines model for PostSchemaPayload.Properties.
type PostSchemaPayload_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// PostSchemaResponse defines model for PostSchemaResponse.
type PostSchemaResponse struct {
	Version *SchemaVersion `json:"version,omitempty"`
}

// PublishRate defines model for PublishRate.
type PublishRate struct {
	PublishThrottlingRateInByte *int64 `json:"publishThrottlingRateInByte,omitempty"`
	PublishThrottlingRateInMsg  *int32 `json:"publishThrottlingRateInMsg,omitempty"`
}

// RawBookieInfo defines model for RawBookieInfo.
type RawBookieInfo struct {
	BookieId *string `json:"bookieId,omitempty"`
}

// ResetCursorData defines model for ResetCursorData.
type ResetCursorData struct {
	BatchIndex     *int32                      `json:"batchIndex,omitempty"`
	EntryId        *int64                      `json:"entryId,omitempty"`
	Excluded       *bool                       `json:"excluded,omitempty"`
	LedgerId       *int64                      `json:"ledgerId,omitempty"`
	PartitionIndex *int32                      `json:"partitionIndex,omitempty"`
	Properties     *ResetCursorData_Properties `json:"properties,omitempty"`
}

// ResetCursorData_Properties defines model for ResetCursorData.Properties.
type ResetCursorData_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ResourceDescription defines model for ResourceDescription.
type ResourceDescription struct {
	ResourceUsage *ResourceDescription_ResourceUsage `json:"resourceUsage,omitempty"`
	UsagePct      *int32                             `json:"usagePct,omitempty"`
}

// ResourceDescription_ResourceUsage defines model for ResourceDescription.ResourceUsage.
type ResourceDescription_ResourceUsage struct {
	AdditionalProperties map[string]ResourceUsage `json:"-"`
}

// ResourceGroup defines model for ResourceGroup.
type ResourceGroup struct {
	DispatchRateInBytes *int64 `json:"dispatchRateInBytes,omitempty"`
	DispatchRateInMsgs  *int32 `json:"dispatchRateInMsgs,omitempty"`
	PublishRateInBytes  *int64 `json:"publishRateInBytes,omitempty"`
	PublishRateInMsgs   *int32 `json:"publishRateInMsgs,omitempty"`
}

// ResourceQuota defines model for ResourceQuota.
type ResourceQuota struct {
	BandwidthIn  *float64 `json:"bandwidthIn,omitempty"`
	BandwidthOut *float64 `json:"bandwidthOut,omitempty"`
	Dynamic      *bool    `json:"dynamic,omitempty"`
	Memory       *float64 `json:"memory,omitempty"`
	MsgRateIn    *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut   *float64 `json:"msgRateOut,omitempty"`
}

// ResourceUnit defines model for ResourceUnit.
type ResourceUnit struct {
	AvailableResource *ResourceDescription `json:"availableResource,omitempty"`
	ResourceId        *string              `json:"resourceId,omitempty"`
}

// ResourceUsage defines model for ResourceUsage.
type ResourceUsage struct {
	Limit *float64 `json:"limit,omitempty"`
	Usage *float64 `json:"usage,omitempty"`
}

// RetentionPolicies defines model for RetentionPolicies.
type RetentionPolicies struct {
	RetentionSizeInMB      *int64 `json:"retentionSizeInMB,omitempty"`
	RetentionTimeInMinutes *int32 `json:"retentionTimeInMinutes,omitempty"`
}

// SchemaVersion defines model for SchemaVersion.
type SchemaVersion = map[string]interface{}

// SubscribeRate defines model for SubscribeRate.
type SubscribeRate struct {
	RatePeriodInSecond                 *int32 `json:"ratePeriodInSecond,omitempty"`
	SubscribeThrottlingRatePerConsumer *int32 `json:"subscribeThrottlingRatePerConsumer,omitempty"`
}

// SystemResourceUsage defines model for SystemResourceUsage.
type SystemResourceUsage struct {
	BandwidthIn  *ResourceUsage `json:"bandwidthIn,omitempty"`
	BandwidthOut *ResourceUsage `json:"bandwidthOut,omitempty"`
	Cpu          *ResourceUsage `json:"cpu,omitempty"`
	DirectMemory *ResourceUsage `json:"directMemory,omitempty"`
	Memory       *ResourceUsage `json:"memory,omitempty"`
}

// Information of adminRoles and allowedClusters for tenant
type TenantInfo struct {
	// Comma separated list of auth principal allowed to administrate the tenant.
	AdminRoles *[]string `json:"adminRoles,omitempty"`

	// Comma separated allowed clusters.
	AllowedClusters *[]string `json:"allowedClusters,omitempty"`
}

// TypeBindings defines model for TypeBindings.
type TypeBindings struct {
	Empty          *bool       `json:"empty,omitempty"`
	TypeParameters *[]JavaType `json:"typeParameters,omitempty"`
}

// WorkerFunctionInstanceStats defines model for WorkerFunctionInstanceStats.
type WorkerFunctionInstanceStats struct {
	Metrics *FunctionInstanceStatsData `json:"metrics,omitempty"`
	Name    *string                    `json:"name,omitempty"`
}

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo struct {
	Port           *int32  `json:"port,omitempty"`
	WorkerHostname *string `json:"workerHostname,omitempty"`
	WorkerId       *string `json:"workerId,omitempty"`
}

// UpdateBookieRackInfoParams defines parameters for UpdateBookieRackInfo.
type UpdateBookieRackInfoParams struct {
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// HealthCheckParams defines parameters for HealthCheck.
type HealthCheckParams struct {
	TopicVersion *HealthCheckParamsTopicVersion `form:"topicVersion,omitempty" json:"topicVersion,omitempty"`
}

// HealthCheckParamsTopicVersion defines parameters for HealthCheck.
type HealthCheckParamsTopicVersion string

// ShutDownBrokerGracefullyParams defines parameters for ShutDownBrokerGracefully.
type ShutDownBrokerGracefullyParams struct {
	// if the value absent(value=0) means no concurrent limitation.
	MaxConcurrentUnloadPerSec *int32 `form:"maxConcurrentUnloadPerSec,omitempty" json:"maxConcurrentUnloadPerSec,omitempty"`
	ForcedTerminateTopic      *bool  `form:"forcedTerminateTopic,omitempty" json:"forcedTerminateTopic,omitempty"`
}

// GetAntiAffinityNamespacesParams defines parameters for GetAntiAffinityNamespaces.
type GetAntiAffinityNamespacesParams struct {
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`
}

// DeleteNamespaceParams defines parameters for DeleteNamespace.
type DeleteNamespaceParams struct {
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreateNamespaceJSONBody defines parameters for CreateNamespace.
type CreateNamespaceJSONBody = Policies

// SetNamespaceAntiAffinityGroupJSONBody defines parameters for SetNamespaceAntiAffinityGroup.
type SetNamespaceAntiAffinityGroupJSONBody = string

// SetAutoSubscriptionCreationJSONBody defines parameters for SetAutoSubscriptionCreation.
type SetAutoSubscriptionCreationJSONBody = AutoSubscriptionCreationOverride

// SetAutoTopicCreationJSONBody defines parameters for SetAutoTopicCreation.
type SetAutoTopicCreationJSONBody = AutoTopicCreationOverride

// RemoveBacklogQuotaParams defines parameters for RemoveBacklogQuota.
type RemoveBacklogQuotaParams struct {
	BacklogQuotaType *RemoveBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// RemoveBacklogQuotaParamsBacklogQuotaType defines parameters for RemoveBacklogQuota.
type RemoveBacklogQuotaParamsBacklogQuotaType string

// SetBacklogQuotaJSONBody defines parameters for SetBacklogQuota.
type SetBacklogQuotaJSONBody = BacklogQuota

// SetBacklogQuotaParams defines parameters for SetBacklogQuota.
type SetBacklogQuotaParams struct {
	BacklogQuotaType *SetBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// SetBacklogQuotaParamsBacklogQuotaType defines parameters for SetBacklogQuota.
type SetBacklogQuotaParamsBacklogQuotaType string

// ClearNamespaceBacklogParams defines parameters for ClearNamespaceBacklog.
type ClearNamespaceBacklogParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ClearNamespaceBacklogForSubscriptionParams defines parameters for ClearNamespaceBacklogForSubscription.
type ClearNamespaceBacklogForSubscriptionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetCompactionThresholdJSONBody defines parameters for SetCompactionThreshold.
type SetCompactionThresholdJSONBody = int64

// ModifyDeduplicationJSONBody defines parameters for ModifyDeduplication.
type ModifyDeduplicationJSONBody = bool

// SetDeduplicationSnapshotIntervalJSONBody defines parameters for SetDeduplicationSnapshotInterval.
type SetDeduplicationSnapshotIntervalJSONBody = int32

// SetDelayedDeliveryPoliciesJSONBody defines parameters for SetDelayedDeliveryPolicies.
type SetDelayedDeliveryPoliciesJSONBody = DelayedDeliveryPolicies

// SetDispatchRateJSONBody defines parameters for SetDispatchRate.
type SetDispatchRateJSONBody = DispatchRateImpl

// ModifyEncryptionRequiredJSONBody defines parameters for ModifyEncryptionRequired.
type ModifyEncryptionRequiredJSONBody = bool

// SetEntryFiltersPerTopicJSONBody defines parameters for SetEntryFiltersPerTopic.
type SetEntryFiltersPerTopicJSONBody = EntryFilters

// SetInactiveTopicPoliciesJSONBody defines parameters for SetInactiveTopicPolicies.
type SetInactiveTopicPoliciesJSONBody = InactiveTopicPolicies

// SetIsAllowAutoUpdateSchemaJSONBody defines parameters for SetIsAllowAutoUpdateSchema.
type SetIsAllowAutoUpdateSchemaJSONBody = bool

// SetMaxConsumersPerSubscriptionJSONBody defines parameters for SetMaxConsumersPerSubscription.
type SetMaxConsumersPerSubscriptionJSONBody = int32

// SetMaxConsumersPerTopicJSONBody defines parameters for SetMaxConsumersPerTopic.
type SetMaxConsumersPerTopicJSONBody = int32

// SetMaxProducersPerTopicJSONBody defines parameters for SetMaxProducersPerTopic.
type SetMaxProducersPerTopicJSONBody = int32

// SetMaxSubscriptionsPerTopicJSONBody defines parameters for SetMaxSubscriptionsPerTopic.
type SetMaxSubscriptionsPerTopicJSONBody = int32

// SetInactiveTopicPoliciesJSONBody defines parameters for SetInactiveTopicPolicies.
type SetInactiveTopicPoliciesJSONBody = int32

// SetMaxUnackedMessagesPerConsumerJSONBody defines parameters for SetMaxUnackedMessagesPerConsumer.
type SetMaxUnackedMessagesPerConsumerJSONBody = int32

// SetMaxUnackedMessagesPerSubscriptionJSONBody defines parameters for SetMaxUnackedMessagesPerSubscription.
type SetMaxUnackedMessagesPerSubscriptionJSONBody = int32

// SetNamespaceMessageTTLJSONBody defines parameters for SetNamespaceMessageTTL.
type SetNamespaceMessageTTLJSONBody = int32

// SetOffloadDeletionLagJSONBody defines parameters for SetOffloadDeletionLag.
type SetOffloadDeletionLagJSONBody = int64

// SetOffloadPoliciesJSONBody defines parameters for SetOffloadPolicies.
type SetOffloadPoliciesJSONBody = OffloadPoliciesImpl

// SetOffloadThresholdJSONBody defines parameters for SetOffloadThreshold.
type SetOffloadThresholdJSONBody = int64

// GrantPermissionOnNamespaceJSONBody defines parameters for GrantPermissionOnNamespace.
type GrantPermissionOnNamespaceJSONBody = []string

// SetPersistenceJSONBody defines parameters for SetPersistence.
type SetPersistenceJSONBody = PersistencePolicies

// SetBookieAffinityGroupJSONBody defines parameters for SetBookieAffinityGroup.
type SetBookieAffinityGroupJSONBody = BookieAffinityGroupData

// SetPropertiesJSONBody defines parameters for SetProperties.
type SetPropertiesJSONBody struct {
	AdditionalProperties map[string]string `json:"-"`
}

// SetNamespaceReplicationClustersJSONBody defines parameters for SetNamespaceReplicationClusters.
type SetNamespaceReplicationClustersJSONBody = []string

// SetReplicatorDispatchRateJSONBody defines parameters for SetReplicatorDispatchRate.
type SetReplicatorDispatchRateJSONBody = DispatchRateImpl

// RemoveRetentionJSONBody defines parameters for RemoveRetention.
type RemoveRetentionJSONBody = RetentionPolicies

// SetRetentionJSONBody defines parameters for SetRetention.
type SetRetentionJSONBody = RetentionPolicies

// SetSchemaAutoUpdateCompatibilityStrategyJSONBody defines parameters for SetSchemaAutoUpdateCompatibilityStrategy.
type SetSchemaAutoUpdateCompatibilityStrategyJSONBody = string

// SetSchemaCompatibilityStrategyJSONBody defines parameters for SetSchemaCompatibilityStrategy.
type SetSchemaCompatibilityStrategyJSONBody = string

// GetSchemaValidtionEnforcedParams defines parameters for GetSchemaValidtionEnforced.
type GetSchemaValidtionEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`
}

// SetSchemaValidationEnforcedJSONBody defines parameters for SetSchemaValidationEnforced.
type SetSchemaValidationEnforcedJSONBody = bool

// SetSubscribeRateJSONBody defines parameters for SetSubscribeRate.
type SetSubscribeRateJSONBody = SubscribeRate

// SetSubscriptionAuthModeJSONBody defines parameters for SetSubscriptionAuthMode.
type SetSubscriptionAuthModeJSONBody = string

// SetSubscriptionDispatchRateJSONBody defines parameters for SetSubscriptionDispatchRate.
type SetSubscriptionDispatchRateJSONBody = DispatchRateImpl

// SetSubscriptionExpirationTimeJSONBody defines parameters for SetSubscriptionExpirationTime.
type SetSubscriptionExpirationTimeJSONBody = int32

// SetSubscriptionTypesEnabledJSONBody defines parameters for SetSubscriptionTypesEnabled.
type SetSubscriptionTypesEnabledJSONBody = []string

// GetTopicsParams defines parameters for GetTopics.
type GetTopicsParams struct {
	Mode *GetTopicsParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// GetTopicsParamsMode defines parameters for GetTopics.
type GetTopicsParamsMode string

// UnsubscribeNamespaceParams defines parameters for UnsubscribeNamespace.
type UnsubscribeNamespaceParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNamespaceBundleParams defines parameters for DeleteNamespaceBundle.
type DeleteNamespaceBundleParams struct {
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ClearNamespaceBundleBacklogParams defines parameters for ClearNamespaceBundleBacklog.
type ClearNamespaceBundleBacklogParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ClearNamespaceBundleBacklogForSubscriptionParams defines parameters for ClearNamespaceBundleBacklogForSubscription.
type ClearNamespaceBundleBacklogForSubscriptionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SplitNamespaceBundleJSONBody defines parameters for SplitNamespaceBundle.
type SplitNamespaceBundleJSONBody = []int64

// SplitNamespaceBundleParams defines parameters for SplitNamespaceBundle.
type SplitNamespaceBundleParams struct {
	Authoritative      *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Unload             *bool   `form:"unload,omitempty" json:"unload,omitempty"`
	SplitAlgorithmName *string `form:"splitAlgorithmName,omitempty" json:"splitAlgorithmName,omitempty"`
}

// GetTopicHashPositionsParams defines parameters for GetTopicHashPositions.
type GetTopicHashPositionsParams struct {
	Topics *[]string `form:"topics,omitempty" json:"topics,omitempty"`
}

// UnloadNamespaceBundleParams defines parameters for UnloadNamespaceBundle.
type UnloadNamespaceBundleParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UnsubscribeNamespaceBundleParams defines parameters for UnsubscribeNamespaceBundle.
type UnsubscribeNamespaceBundleParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetListParams defines parameters for GetList.
type GetListParams struct {
	// Specify the bundle name
	Bundle *string `form:"bundle,omitempty" json:"bundle,omitempty"`

	// Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// GetPartitionedTopicListParams defines parameters for GetPartitionedTopicList.
type GetPartitionedTopicListParams struct {
	// Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// DeleteTopicParams defines parameters for DeleteTopic.
type DeleteTopicParams struct {
	// Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreateNonPartitionedTopicParams defines parameters for CreateNonPartitionedTopic.
type CreateNonPartitionedTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireMessagesForAllSubscriptionsParams defines parameters for ExpireMessagesForAllSubscriptions.
type ExpireMessagesForAllSubscriptionsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetBacklogParams defines parameters for GetBacklog.
type GetBacklogParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveBacklogQuotaParams defines parameters for RemoveBacklogQuota.
type RemoveBacklogQuotaParams struct {
	BacklogQuotaType *RemoveBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveBacklogQuotaParamsBacklogQuotaType defines parameters for RemoveBacklogQuota.
type RemoveBacklogQuotaParamsBacklogQuotaType string

// SetBacklogQuotaParams defines parameters for SetBacklogQuota.
type SetBacklogQuotaParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative    *bool                                  `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal         *bool                                  `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	BacklogQuotaType *SetBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// SetBacklogQuotaParamsBacklogQuotaType defines parameters for SetBacklogQuota.
type SetBacklogQuotaParamsBacklogQuotaType string

// GetBacklogQuotaMapParams defines parameters for GetBacklogQuotaMap.
type GetBacklogQuotaMapParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetBacklogSizeByMessageIdParams defines parameters for GetBacklogSizeByMessageId.
type GetBacklogSizeByMessageIdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CompactionStatusParams defines parameters for CompactionStatus.
type CompactionStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CompactParams defines parameters for Compact.
type CompactParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveCompactionThresholdParams defines parameters for RemoveCompactionThreshold.
type RemoveCompactionThresholdParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetCompactionThresholdParams defines parameters for GetCompactionThreshold.
type GetCompactionThresholdParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetCompactionThresholdParams defines parameters for SetCompactionThreshold.
type SetCompactionThresholdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveDeduplicationParams defines parameters for RemoveDeduplication.
type RemoveDeduplicationParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDeduplicationParams defines parameters for GetDeduplication.
type GetDeduplicationParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDeduplicationParams defines parameters for SetDeduplication.
type SetDeduplicationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteDeduplicationSnapshotIntervalParams defines parameters for DeleteDeduplicationSnapshotInterval.
type DeleteDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDeduplicationSnapshotIntervalParams defines parameters for GetDeduplicationSnapshotInterval.
type GetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDeduplicationSnapshotIntervalParams defines parameters for SetDeduplicationSnapshotInterval.
type SetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteDelayedDeliveryPoliciesParams defines parameters for DeleteDelayedDeliveryPolicies.
type DeleteDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDelayedDeliveryPoliciesParams defines parameters for GetDelayedDeliveryPolicies.
type GetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDelayedDeliveryPoliciesParams defines parameters for SetDelayedDeliveryPolicies.
type SetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveDispatchRateParams defines parameters for RemoveDispatchRate.
type RemoveDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDispatchRateParams defines parameters for GetDispatchRate.
type GetDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDispatchRateParams defines parameters for SetDispatchRate.
type SetDispatchRateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveEntryFiltersParams defines parameters for RemoveEntryFilters.
type RemoveEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetEntryFiltersParams defines parameters for GetEntryFilters.
type GetEntryFiltersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetEntryFiltersParams defines parameters for SetEntryFilters.
type SetEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExamineMessageParams defines parameters for ExamineMessage.
type ExamineMessageParams struct {
	// Relative start position to examine message.It can be 'latest' or 'earliest'
	InitialPosition *ExamineMessageParamsInitialPosition `form:"initialPosition,omitempty" json:"initialPosition,omitempty"`

	// The position of messages (default 1)
	MessagePosition *int64 `form:"messagePosition,omitempty" json:"messagePosition,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExamineMessageParamsInitialPosition defines parameters for ExamineMessage.
type ExamineMessageParamsInitialPosition string

// DeleteInactiveTopicPoliciesParams defines parameters for DeleteInactiveTopicPolicies.
type DeleteInactiveTopicPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetInactiveTopicPoliciesParams defines parameters for GetInactiveTopicPolicies.
type GetInactiveTopicPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetInactiveTopicPoliciesParams defines parameters for SetInactiveTopicPolicies.
type SetInactiveTopicPoliciesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetManagedLedgerInfoParams defines parameters for GetManagedLedgerInfo.
type GetManagedLedgerInfoParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetInternalStatsParams defines parameters for GetInternalStats.
type GetInternalStatsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Metadata      *bool `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetLastMessageIdParams defines parameters for GetLastMessageId.
type GetLastMessageIdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMessageByIdParams defines parameters for GetMessageById.
type GetMessageByIdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxConsumersParams defines parameters for RemoveMaxConsumers.
type RemoveMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxConsumersParams defines parameters for GetMaxConsumers.
type GetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxConsumersParams defines parameters for SetMaxConsumers.
type SetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxConsumersPerSubscriptionParams defines parameters for RemoveMaxConsumersPerSubscription.
type RemoveMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxConsumersPerSubscriptionParams defines parameters for GetMaxConsumersPerSubscription.
type GetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxConsumersPerSubscriptionParams defines parameters for SetMaxConsumersPerSubscription.
type SetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxMessageSizeParams defines parameters for RemoveMaxMessageSize.
type RemoveMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxMessageSizeParams defines parameters for GetMaxMessageSize.
type GetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxMessageSizeParams defines parameters for SetMaxMessageSize.
type SetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxProducersParams defines parameters for RemoveMaxProducers.
type RemoveMaxProducersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxProducersParams defines parameters for GetMaxProducers.
type GetMaxProducersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxProducersParams defines parameters for SetMaxProducers.
type SetMaxProducersParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveMaxSubscriptionsPerTopicParams defines parameters for RemoveMaxSubscriptionsPerTopic.
type RemoveMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxSubscriptionsPerTopicParams defines parameters for GetMaxSubscriptionsPerTopic.
type GetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxSubscriptionsPerTopicParams defines parameters for SetMaxSubscriptionsPerTopic.
type SetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteMaxUnackedMessagesOnConsumerParams defines parameters for DeleteMaxUnackedMessagesOnConsumer.
type DeleteMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxUnackedMessagesOnConsumerParams defines parameters for GetMaxUnackedMessagesOnConsumer.
type GetMaxUnackedMessagesOnConsumerParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxUnackedMessagesOnConsumerParams defines parameters for SetMaxUnackedMessagesOnConsumer.
type SetMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteMaxUnackedMessagesOnSubscriptionParams defines parameters for DeleteMaxUnackedMessagesOnSubscription.
type DeleteMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxUnackedMessagesOnSubscriptionParams defines parameters for GetMaxUnackedMessagesOnSubscription.
type GetMaxUnackedMessagesOnSubscriptionParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxUnackedMessagesOnSubscriptionParams defines parameters for SetMaxUnackedMessagesOnSubscription.
type SetMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMessageTTLParams defines parameters for RemoveMessageTTL.
type RemoveMessageTTLParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMessageTTLParams defines parameters for GetMessageTTL.
type GetMessageTTLParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMessageTTLParams defines parameters for SetMessageTTL.
type SetMessageTTLParams struct {
	// TTL in seconds for the specified namespace
	MessageTTL int32 `form:"messageTTL" json:"messageTTL"`
	IsGlobal   *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMessageIdByTimestampParams defines parameters for GetMessageIdByTimestamp.
type GetMessageIdByTimestampParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// OffloadStatusParams defines parameters for OffloadStatus.
type OffloadStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TriggerOffloadParams defines parameters for TriggerOffload.
type TriggerOffloadParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveOffloadPoliciesParams defines parameters for RemoveOffloadPolicies.
type RemoveOffloadPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetOffloadPoliciesParams defines parameters for GetOffloadPolicies.
type GetOffloadPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetOffloadPoliciesParams defines parameters for SetOffloadPolicies.
type SetOffloadPoliciesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetPartitionedStatsParams defines parameters for GetPartitionedStats.
type GetPartitionedStatsParams struct {
	// Get per partition stats
	PerPartition *bool `form:"perPartition,omitempty" json:"perPartition,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// If return the earliest time in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// DeletePartitionedTopicParams defines parameters for DeletePartitionedTopic.
type DeletePartitionedTopicParams struct {
	// Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPartitionedMetadataParams defines parameters for GetPartitionedMetadata.
type GetPartitionedMetadataParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Is check configuration required to automatically create topic
	CheckAllowAutoCreation *bool `form:"checkAllowAutoCreation,omitempty" json:"checkAllowAutoCreation,omitempty"`
}

// UpdatePartitionedTopicParams defines parameters for UpdatePartitionedTopic.
type UpdatePartitionedTopicParams struct {
	UpdateLocalTopicOnly *bool `form:"updateLocalTopicOnly,omitempty" json:"updateLocalTopicOnly,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// CreatePartitionedTopicParams defines parameters for CreatePartitionedTopic.
type CreatePartitionedTopicParams struct {
	CreateLocalTopicOnly *bool `form:"createLocalTopicOnly,omitempty" json:"createLocalTopicOnly,omitempty"`
}

// RemovePersistenceParams defines parameters for RemovePersistence.
type RemovePersistenceParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistenceParams defines parameters for GetPersistence.
type GetPersistenceParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistenceParams defines parameters for SetPersistence.
type SetPersistenceParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePropertiesParams defines parameters for RemoveProperties.
type RemovePropertiesParams struct {
	Key           *string `form:"key,omitempty" json:"key,omitempty"`
	Authoritative *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPropertiesParams defines parameters for GetProperties.
type GetPropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdatePropertiesParams defines parameters for UpdateProperties.
type UpdatePropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePublishRateParams defines parameters for RemovePublishRate.
type RemovePublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPublishRateParams defines parameters for GetPublishRate.
type GetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPublishRateParams defines parameters for SetPublishRate.
type SetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveReplicationClustersParams defines parameters for RemoveReplicationClusters.
type RemoveReplicationClustersParams struct {
	BacklogQuotaType *RemoveReplicationClustersParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveReplicationClustersParamsBacklogQuotaType defines parameters for RemoveReplicationClusters.
type RemoveReplicationClustersParamsBacklogQuotaType string

// GetReplicationClustersParams defines parameters for GetReplicationClusters.
type GetReplicationClustersParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetReplicationClustersParams defines parameters for SetReplicationClusters.
type SetReplicationClustersParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveReplicatorDispatchRateParams defines parameters for RemoveReplicatorDispatchRate.
type RemoveReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetReplicatorDispatchRateParams defines parameters for GetReplicatorDispatchRate.
type GetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetReplicatorDispatchRateParams defines parameters for SetReplicatorDispatchRate.
type SetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveRetentionParams defines parameters for RemoveRetention.
type RemoveRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetRetentionParams defines parameters for GetRetention.
type GetRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetRetentionParams defines parameters for SetRetention.
type SetRetentionParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveSchemaCompatibilityStrategyParams defines parameters for RemoveSchemaCompatibilityStrategy.
type RemoveSchemaCompatibilityStrategyParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSchemaCompatibilityStrategyParams defines parameters for GetSchemaCompatibilityStrategy.
type GetSchemaCompatibilityStrategyParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSchemaCompatibilityStrategyParams defines parameters for SetSchemaCompatibilityStrategy.
type SetSchemaCompatibilityStrategyParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSchemaValidationEnforcedParams defines parameters for GetSchemaValidationEnforced.
type GetSchemaValidationEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSchemaValidationEnforcedParams defines parameters for SetSchemaValidationEnforced.
type SetSchemaValidationEnforcedParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteShadowTopicsParams defines parameters for DeleteShadowTopics.
type DeleteShadowTopicsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetShadowTopicsParams defines parameters for GetShadowTopics.
type GetShadowTopicsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetShadowTopicsParams defines parameters for SetShadowTopics.
type SetShadowTopicsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetStatsParams defines parameters for GetStats.
type GetStatsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// If return time of the earliest message in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// RemoveSubscribeRateParams defines parameters for RemoveSubscribeRate.
type RemoveSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscribeRateParams defines parameters for GetSubscribeRate.
type GetSubscribeRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscribeRateParams defines parameters for SetSubscribeRate.
type SetSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteSubscriptionParams defines parameters for DeleteSubscription.
type DeleteSubscriptionParams struct {
	// Disconnect and close all consumers and delete subscription forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// AnalyzeSubscriptionBacklogParams defines parameters for AnalyzeSubscriptionBacklog.
type AnalyzeSubscriptionBacklogParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireTopicMessagesParams defines parameters for ExpireTopicMessages.
type ExpireTopicMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireTopicMessagesParams defines parameters for ExpireTopicMessages.
type ExpireTopicMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PeekNthMessageParams defines parameters for PeekNthMessage.
type PeekNthMessageParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionPropertiesParams defines parameters for GetSubscriptionProperties.
type GetSubscriptionPropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdateSubscriptionPropertiesParams defines parameters for UpdateSubscriptionProperties.
type UpdateSubscriptionPropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetReplicatedSubscriptionStatusParams defines parameters for GetReplicatedSubscriptionStatus.
type GetReplicatedSubscriptionStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetReplicatedSubscriptionStatusParams defines parameters for SetReplicatedSubscriptionStatus.
type SetReplicatedSubscriptionStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetCursorOnPositionParams defines parameters for ResetCursorOnPosition.
type ResetCursorOnPositionParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetCursorParams defines parameters for ResetCursor.
type ResetCursorParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipMessagesParams defines parameters for SkipMessages.
type SkipMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipAllMessagesParams defines parameters for SkipAllMessages.
type SkipAllMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreateSubscriptionParams defines parameters for CreateSubscription.
type CreateSubscriptionParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Is replicated required to perform this operation
	Replicated *bool `form:"replicated,omitempty" json:"replicated,omitempty"`
}

// RemoveSubscriptionDispatchRateParams defines parameters for RemoveSubscriptionDispatchRate.
type RemoveSubscriptionDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionDispatchRateParams defines parameters for GetSubscriptionDispatchRate.
type GetSubscriptionDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscriptionDispatchRateParams defines parameters for SetSubscriptionDispatchRate.
type SetSubscriptionDispatchRateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveSubscriptionTypesEnabledParams defines parameters for RemoveSubscriptionTypesEnabled.
type RemoveSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionTypesEnabledParams defines parameters for GetSubscriptionTypesEnabled.
type GetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscriptionTypesEnabledParams defines parameters for SetSubscriptionTypesEnabled.
type SetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionsParams defines parameters for GetSubscriptions.
type GetSubscriptionsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminateParams defines parameters for Terminate.
type TerminateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminatePartitionedTopicParams defines parameters for TerminatePartitionedTopic.
type TerminatePartitionedTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TruncateTopicParams defines parameters for TruncateTopic.
type TruncateTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UnloadTopicParams defines parameters for UnloadTopic.
type UnloadTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveSubscriptionLevelDispatchRateParams defines parameters for RemoveSubscriptionLevelDispatchRate.
type RemoveSubscriptionLevelDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionLevelDispatchRateParams defines parameters for GetSubscriptionLevelDispatchRate.
type GetSubscriptionLevelDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscriptionLevelDispatchRateParams defines parameters for SetSubscriptionLevelDispatchRate.
type SetSubscriptionLevelDispatchRateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetListParams defines parameters for GetList.
type GetListParams struct {
	// Specify the bundle name
	Bundle *string `form:"bundle,omitempty" json:"bundle,omitempty"`

	// Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// GetPartitionedTopicListParams defines parameters for GetPartitionedTopicList.
type GetPartitionedTopicListParams struct {
	// Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// DeleteTopicParams defines parameters for DeleteTopic.
type DeleteTopicParams struct {
	// Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreateNonPartitionedTopicParams defines parameters for CreateNonPartitionedTopic.
type CreateNonPartitionedTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireMessagesForAllSubscriptionsParams defines parameters for ExpireMessagesForAllSubscriptions.
type ExpireMessagesForAllSubscriptionsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetBacklogParams defines parameters for GetBacklog.
type GetBacklogParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveBacklogQuotaParams defines parameters for RemoveBacklogQuota.
type RemoveBacklogQuotaParams struct {
	BacklogQuotaType *RemoveBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveBacklogQuotaParamsBacklogQuotaType defines parameters for RemoveBacklogQuota.
type RemoveBacklogQuotaParamsBacklogQuotaType string

// SetBacklogQuotaParams defines parameters for SetBacklogQuota.
type SetBacklogQuotaParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative    *bool                                  `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal         *bool                                  `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	BacklogQuotaType *SetBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// SetBacklogQuotaParamsBacklogQuotaType defines parameters for SetBacklogQuota.
type SetBacklogQuotaParamsBacklogQuotaType string

// GetBacklogQuotaMapParams defines parameters for GetBacklogQuotaMap.
type GetBacklogQuotaMapParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetBacklogSizeByMessageIdParams defines parameters for GetBacklogSizeByMessageId.
type GetBacklogSizeByMessageIdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CompactionStatusParams defines parameters for CompactionStatus.
type CompactionStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CompactParams defines parameters for Compact.
type CompactParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveCompactionThresholdParams defines parameters for RemoveCompactionThreshold.
type RemoveCompactionThresholdParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetCompactionThresholdParams defines parameters for GetCompactionThreshold.
type GetCompactionThresholdParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetCompactionThresholdParams defines parameters for SetCompactionThreshold.
type SetCompactionThresholdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveDeduplicationParams defines parameters for RemoveDeduplication.
type RemoveDeduplicationParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDeduplicationParams defines parameters for GetDeduplication.
type GetDeduplicationParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDeduplicationParams defines parameters for SetDeduplication.
type SetDeduplicationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteDeduplicationSnapshotIntervalParams defines parameters for DeleteDeduplicationSnapshotInterval.
type DeleteDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDeduplicationSnapshotIntervalParams defines parameters for GetDeduplicationSnapshotInterval.
type GetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDeduplicationSnapshotIntervalParams defines parameters for SetDeduplicationSnapshotInterval.
type SetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteDelayedDeliveryPoliciesParams defines parameters for DeleteDelayedDeliveryPolicies.
type DeleteDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDelayedDeliveryPoliciesParams defines parameters for GetDelayedDeliveryPolicies.
type GetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDelayedDeliveryPoliciesParams defines parameters for SetDelayedDeliveryPolicies.
type SetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveDispatchRateParams defines parameters for RemoveDispatchRate.
type RemoveDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetDispatchRateParams defines parameters for GetDispatchRate.
type GetDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetDispatchRateParams defines parameters for SetDispatchRate.
type SetDispatchRateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveEntryFiltersParams defines parameters for RemoveEntryFilters.
type RemoveEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetEntryFiltersParams defines parameters for GetEntryFilters.
type GetEntryFiltersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetEntryFiltersParams defines parameters for SetEntryFilters.
type SetEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExamineMessageParams defines parameters for ExamineMessage.
type ExamineMessageParams struct {
	// Relative start position to examine message.It can be 'latest' or 'earliest'
	InitialPosition *ExamineMessageParamsInitialPosition `form:"initialPosition,omitempty" json:"initialPosition,omitempty"`

	// The position of messages (default 1)
	MessagePosition *int64 `form:"messagePosition,omitempty" json:"messagePosition,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExamineMessageParamsInitialPosition defines parameters for ExamineMessage.
type ExamineMessageParamsInitialPosition string

// DeleteInactiveTopicPoliciesParams defines parameters for DeleteInactiveTopicPolicies.
type DeleteInactiveTopicPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetInactiveTopicPoliciesParams defines parameters for GetInactiveTopicPolicies.
type GetInactiveTopicPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetInactiveTopicPoliciesParams defines parameters for SetInactiveTopicPolicies.
type SetInactiveTopicPoliciesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetManagedLedgerInfoParams defines parameters for GetManagedLedgerInfo.
type GetManagedLedgerInfoParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetInternalStatsParams defines parameters for GetInternalStats.
type GetInternalStatsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Metadata      *bool `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetLastMessageIdParams defines parameters for GetLastMessageId.
type GetLastMessageIdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMessageByIdParams defines parameters for GetMessageById.
type GetMessageByIdParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxConsumersParams defines parameters for RemoveMaxConsumers.
type RemoveMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxConsumersParams defines parameters for GetMaxConsumers.
type GetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxConsumersParams defines parameters for SetMaxConsumers.
type SetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxConsumersPerSubscriptionParams defines parameters for RemoveMaxConsumersPerSubscription.
type RemoveMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxConsumersPerSubscriptionParams defines parameters for GetMaxConsumersPerSubscription.
type GetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxConsumersPerSubscriptionParams defines parameters for SetMaxConsumersPerSubscription.
type SetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxMessageSizeParams defines parameters for RemoveMaxMessageSize.
type RemoveMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxMessageSizeParams defines parameters for GetMaxMessageSize.
type GetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxMessageSizeParams defines parameters for SetMaxMessageSize.
type SetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMaxProducersParams defines parameters for RemoveMaxProducers.
type RemoveMaxProducersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxProducersParams defines parameters for GetMaxProducers.
type GetMaxProducersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxProducersParams defines parameters for SetMaxProducers.
type SetMaxProducersParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveMaxSubscriptionsPerTopicParams defines parameters for RemoveMaxSubscriptionsPerTopic.
type RemoveMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxSubscriptionsPerTopicParams defines parameters for GetMaxSubscriptionsPerTopic.
type GetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxSubscriptionsPerTopicParams defines parameters for SetMaxSubscriptionsPerTopic.
type SetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteMaxUnackedMessagesOnConsumerParams defines parameters for DeleteMaxUnackedMessagesOnConsumer.
type DeleteMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxUnackedMessagesOnConsumerParams defines parameters for GetMaxUnackedMessagesOnConsumer.
type GetMaxUnackedMessagesOnConsumerParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxUnackedMessagesOnConsumerParams defines parameters for SetMaxUnackedMessagesOnConsumer.
type SetMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteMaxUnackedMessagesOnSubscriptionParams defines parameters for DeleteMaxUnackedMessagesOnSubscription.
type DeleteMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMaxUnackedMessagesOnSubscriptionParams defines parameters for GetMaxUnackedMessagesOnSubscription.
type GetMaxUnackedMessagesOnSubscriptionParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMaxUnackedMessagesOnSubscriptionParams defines parameters for SetMaxUnackedMessagesOnSubscription.
type SetMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveMessageTTLParams defines parameters for RemoveMessageTTL.
type RemoveMessageTTLParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMessageTTLParams defines parameters for GetMessageTTL.
type GetMessageTTLParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetMessageTTLParams defines parameters for SetMessageTTL.
type SetMessageTTLParams struct {
	// TTL in seconds for the specified namespace
	MessageTTL int32 `form:"messageTTL" json:"messageTTL"`
	IsGlobal   *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetMessageIdByTimestampParams defines parameters for GetMessageIdByTimestamp.
type GetMessageIdByTimestampParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// OffloadStatusParams defines parameters for OffloadStatus.
type OffloadStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TriggerOffloadParams defines parameters for TriggerOffload.
type TriggerOffloadParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveOffloadPoliciesParams defines parameters for RemoveOffloadPolicies.
type RemoveOffloadPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetOffloadPoliciesParams defines parameters for GetOffloadPolicies.
type GetOffloadPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetOffloadPoliciesParams defines parameters for SetOffloadPolicies.
type SetOffloadPoliciesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetPartitionedStatsParams defines parameters for GetPartitionedStats.
type GetPartitionedStatsParams struct {
	// Get per partition stats
	PerPartition *bool `form:"perPartition,omitempty" json:"perPartition,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// If return the earliest time in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// DeletePartitionedTopicParams defines parameters for DeletePartitionedTopic.
type DeletePartitionedTopicParams struct {
	// Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPartitionedMetadataParams defines parameters for GetPartitionedMetadata.
type GetPartitionedMetadataParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Is check configuration required to automatically create topic
	CheckAllowAutoCreation *bool `form:"checkAllowAutoCreation,omitempty" json:"checkAllowAutoCreation,omitempty"`
}

// UpdatePartitionedTopicParams defines parameters for UpdatePartitionedTopic.
type UpdatePartitionedTopicParams struct {
	UpdateLocalTopicOnly *bool `form:"updateLocalTopicOnly,omitempty" json:"updateLocalTopicOnly,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// CreatePartitionedTopicParams defines parameters for CreatePartitionedTopic.
type CreatePartitionedTopicParams struct {
	CreateLocalTopicOnly *bool `form:"createLocalTopicOnly,omitempty" json:"createLocalTopicOnly,omitempty"`
}

// RemovePersistenceParams defines parameters for RemovePersistence.
type RemovePersistenceParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistenceParams defines parameters for GetPersistence.
type GetPersistenceParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistenceParams defines parameters for SetPersistence.
type SetPersistenceParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePropertiesParams defines parameters for RemoveProperties.
type RemovePropertiesParams struct {
	Key           *string `form:"key,omitempty" json:"key,omitempty"`
	Authoritative *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPropertiesParams defines parameters for GetProperties.
type GetPropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdatePropertiesParams defines parameters for UpdateProperties.
type UpdatePropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePublishRateParams defines parameters for RemovePublishRate.
type RemovePublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPublishRateParams defines parameters for GetPublishRate.
type GetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPublishRateParams defines parameters for SetPublishRate.
type SetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveReplicationClustersParams defines parameters for RemoveReplicationClusters.
type RemoveReplicationClustersParams struct {
	BacklogQuotaType *RemoveReplicationClustersParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveReplicationClustersParamsBacklogQuotaType defines parameters for RemoveReplicationClusters.
type RemoveReplicationClustersParamsBacklogQuotaType string

// GetReplicationClustersParams defines parameters for GetReplicationClusters.
type GetReplicationClustersParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetReplicationClustersParams defines parameters for SetReplicationClusters.
type SetReplicationClustersParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveReplicatorDispatchRateParams defines parameters for RemoveReplicatorDispatchRate.
type RemoveReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetReplicatorDispatchRateParams defines parameters for GetReplicatorDispatchRate.
type GetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetReplicatorDispatchRateParams defines parameters for SetReplicatorDispatchRate.
type SetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveRetentionParams defines parameters for RemoveRetention.
type RemoveRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetRetentionParams defines parameters for GetRetention.
type GetRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetRetentionParams defines parameters for SetRetention.
type SetRetentionParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveSchemaCompatibilityStrategyParams defines parameters for RemoveSchemaCompatibilityStrategy.
type RemoveSchemaCompatibilityStrategyParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSchemaCompatibilityStrategyParams defines parameters for GetSchemaCompatibilityStrategy.
type GetSchemaCompatibilityStrategyParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSchemaCompatibilityStrategyParams defines parameters for SetSchemaCompatibilityStrategy.
type SetSchemaCompatibilityStrategyParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSchemaValidationEnforcedParams defines parameters for GetSchemaValidationEnforced.
type GetSchemaValidationEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSchemaValidationEnforcedParams defines parameters for SetSchemaValidationEnforced.
type SetSchemaValidationEnforcedParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteShadowTopicsParams defines parameters for DeleteShadowTopics.
type DeleteShadowTopicsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetShadowTopicsParams defines parameters for GetShadowTopics.
type GetShadowTopicsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetShadowTopicsParams defines parameters for SetShadowTopics.
type SetShadowTopicsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetStatsParams defines parameters for GetStats.
type GetStatsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// If return time of the earliest message in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// RemoveSubscribeRateParams defines parameters for RemoveSubscribeRate.
type RemoveSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscribeRateParams defines parameters for GetSubscribeRate.
type GetSubscribeRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscribeRateParams defines parameters for SetSubscribeRate.
type SetSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteSubscriptionParams defines parameters for DeleteSubscription.
type DeleteSubscriptionParams struct {
	// Disconnect and close all consumers and delete subscription forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// AnalyzeSubscriptionBacklogParams defines parameters for AnalyzeSubscriptionBacklog.
type AnalyzeSubscriptionBacklogParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireTopicMessagesParams defines parameters for ExpireTopicMessages.
type ExpireTopicMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireTopicMessagesParams defines parameters for ExpireTopicMessages.
type ExpireTopicMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PeekNthMessageParams defines parameters for PeekNthMessage.
type PeekNthMessageParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionPropertiesParams defines parameters for GetSubscriptionProperties.
type GetSubscriptionPropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdateSubscriptionPropertiesParams defines parameters for UpdateSubscriptionProperties.
type UpdateSubscriptionPropertiesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetReplicatedSubscriptionStatusParams defines parameters for GetReplicatedSubscriptionStatus.
type GetReplicatedSubscriptionStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetReplicatedSubscriptionStatusParams defines parameters for SetReplicatedSubscriptionStatus.
type SetReplicatedSubscriptionStatusParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetCursorOnPositionParams defines parameters for ResetCursorOnPosition.
type ResetCursorOnPositionParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetCursorParams defines parameters for ResetCursor.
type ResetCursorParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipMessagesParams defines parameters for SkipMessages.
type SkipMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipAllMessagesParams defines parameters for SkipAllMessages.
type SkipAllMessagesParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreateSubscriptionParams defines parameters for CreateSubscription.
type CreateSubscriptionParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Is replicated required to perform this operation
	Replicated *bool `form:"replicated,omitempty" json:"replicated,omitempty"`
}

// RemoveSubscriptionDispatchRateParams defines parameters for RemoveSubscriptionDispatchRate.
type RemoveSubscriptionDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionDispatchRateParams defines parameters for GetSubscriptionDispatchRate.
type GetSubscriptionDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscriptionDispatchRateParams defines parameters for SetSubscriptionDispatchRate.
type SetSubscriptionDispatchRateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveSubscriptionTypesEnabledParams defines parameters for RemoveSubscriptionTypesEnabled.
type RemoveSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionTypesEnabledParams defines parameters for GetSubscriptionTypesEnabled.
type GetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscriptionTypesEnabledParams defines parameters for SetSubscriptionTypesEnabled.
type SetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionsParams defines parameters for GetSubscriptions.
type GetSubscriptionsParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminateParams defines parameters for Terminate.
type TerminateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminatePartitionedTopicParams defines parameters for TerminatePartitionedTopic.
type TerminatePartitionedTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TruncateTopicParams defines parameters for TruncateTopic.
type TruncateTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UnloadTopicParams defines parameters for UnloadTopic.
type UnloadTopicParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveSubscriptionLevelDispatchRateParams defines parameters for RemoveSubscriptionLevelDispatchRate.
type RemoveSubscriptionLevelDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSubscriptionLevelDispatchRateParams defines parameters for GetSubscriptionLevelDispatchRate.
type GetSubscriptionLevelDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetSubscriptionLevelDispatchRateParams defines parameters for SetSubscriptionLevelDispatchRate.
type SetSubscriptionLevelDispatchRateParams struct {
	// Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// SetDefaultResourceQuotaJSONBody defines parameters for SetDefaultResourceQuota.
type SetDefaultResourceQuotaJSONBody = ResourceQuota

// SetNamespaceBundleResourceQuotaJSONBody defines parameters for SetNamespaceBundleResourceQuota.
type SetNamespaceBundleResourceQuotaJSONBody = ResourceQuota

// CreateOrUpdateResourceGroupJSONBody defines parameters for CreateOrUpdateResourceGroup.
type CreateOrUpdateResourceGroupJSONBody = ResourceGroup

// TestCompatibilityJSONBody defines parameters for TestCompatibility.
type TestCompatibilityJSONBody = PostSchemaPayload

// TestCompatibilityParams defines parameters for TestCompatibility.
type TestCompatibilityParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteSchemaParams defines parameters for DeleteSchema.
type DeleteSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetSchemaParams defines parameters for GetSchema.
type GetSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PostSchemaJSONBody defines parameters for PostSchema.
type PostSchemaJSONBody = PostSchemaPayload

// PostSchemaParams defines parameters for PostSchema.
type PostSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSchemaParams defines parameters for GetSchema.
type GetSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetAllSchemasParams defines parameters for GetAllSchemas.
type GetAllSchemasParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetVersionBySchemaJSONBody defines parameters for GetVersionBySchema.
type GetVersionBySchemaJSONBody = PostSchemaPayload

// GetVersionBySchemaParams defines parameters for GetVersionBySchema.
type GetVersionBySchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteTenantParams defines parameters for DeleteTenant.
type DeleteTenantParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// UpdateTenantJSONBody defines parameters for UpdateTenant.
type UpdateTenantJSONBody = TenantInfo

// CreateTenantJSONBody defines parameters for CreateTenant.
type CreateTenantJSONBody = TenantInfo

// GetDrainStatusFromLeaderParams defines parameters for GetDrainStatusFromLeader.
type GetDrainStatusFromLeaderParams struct {
	WorkerId *string `form:"workerId,omitempty" json:"workerId,omitempty"`
}

// DrainAtLeaderParams defines parameters for DrainAtLeader.
type DrainAtLeaderParams struct {
	WorkerId *string `form:"workerId,omitempty" json:"workerId,omitempty"`
}

// CreateNamespaceJSONRequestBody defines body for CreateNamespace for application/json ContentType.
type CreateNamespaceJSONRequestBody = CreateNamespaceJSONBody

// SetNamespaceAntiAffinityGroupJSONRequestBody defines body for SetNamespaceAntiAffinityGroup for application/json ContentType.
type SetNamespaceAntiAffinityGroupJSONRequestBody = SetNamespaceAntiAffinityGroupJSONBody

// SetAutoSubscriptionCreationJSONRequestBody defines body for SetAutoSubscriptionCreation for application/json ContentType.
type SetAutoSubscriptionCreationJSONRequestBody = SetAutoSubscriptionCreationJSONBody

// SetAutoTopicCreationJSONRequestBody defines body for SetAutoTopicCreation for application/json ContentType.
type SetAutoTopicCreationJSONRequestBody = SetAutoTopicCreationJSONBody

// SetBacklogQuotaJSONRequestBody defines body for SetBacklogQuota for application/json ContentType.
type SetBacklogQuotaJSONRequestBody = SetBacklogQuotaJSONBody

// SetCompactionThresholdJSONRequestBody defines body for SetCompactionThreshold for application/json ContentType.
type SetCompactionThresholdJSONRequestBody = SetCompactionThresholdJSONBody

// ModifyDeduplicationJSONRequestBody defines body for ModifyDeduplication for application/json ContentType.
type ModifyDeduplicationJSONRequestBody = ModifyDeduplicationJSONBody

// SetDeduplicationSnapshotIntervalJSONRequestBody defines body for SetDeduplicationSnapshotInterval for application/json ContentType.
type SetDeduplicationSnapshotIntervalJSONRequestBody = SetDeduplicationSnapshotIntervalJSONBody

// SetDelayedDeliveryPoliciesJSONRequestBody defines body for SetDelayedDeliveryPolicies for application/json ContentType.
type SetDelayedDeliveryPoliciesJSONRequestBody = SetDelayedDeliveryPoliciesJSONBody

// SetDispatchRateJSONRequestBody defines body for SetDispatchRate for application/json ContentType.
type SetDispatchRateJSONRequestBody = SetDispatchRateJSONBody

// ModifyEncryptionRequiredJSONRequestBody defines body for ModifyEncryptionRequired for application/json ContentType.
type ModifyEncryptionRequiredJSONRequestBody = ModifyEncryptionRequiredJSONBody

// SetEntryFiltersPerTopicJSONRequestBody defines body for SetEntryFiltersPerTopic for application/json ContentType.
type SetEntryFiltersPerTopicJSONRequestBody = SetEntryFiltersPerTopicJSONBody

// SetInactiveTopicPoliciesJSONRequestBody defines body for SetInactiveTopicPolicies for application/json ContentType.
type SetInactiveTopicPoliciesJSONRequestBody = SetInactiveTopicPoliciesJSONBody

// SetIsAllowAutoUpdateSchemaJSONRequestBody defines body for SetIsAllowAutoUpdateSchema for application/json ContentType.
type SetIsAllowAutoUpdateSchemaJSONRequestBody = SetIsAllowAutoUpdateSchemaJSONBody

// SetMaxConsumersPerSubscriptionJSONRequestBody defines body for SetMaxConsumersPerSubscription for application/json ContentType.
type SetMaxConsumersPerSubscriptionJSONRequestBody = SetMaxConsumersPerSubscriptionJSONBody

// SetMaxConsumersPerTopicJSONRequestBody defines body for SetMaxConsumersPerTopic for application/json ContentType.
type SetMaxConsumersPerTopicJSONRequestBody = SetMaxConsumersPerTopicJSONBody

// SetMaxProducersPerTopicJSONRequestBody defines body for SetMaxProducersPerTopic for application/json ContentType.
type SetMaxProducersPerTopicJSONRequestBody = SetMaxProducersPerTopicJSONBody

// SetMaxSubscriptionsPerTopicJSONRequestBody defines body for SetMaxSubscriptionsPerTopic for application/json ContentType.
type SetMaxSubscriptionsPerTopicJSONRequestBody = SetMaxSubscriptionsPerTopicJSONBody

// SetInactiveTopicPoliciesJSONRequestBody defines body for SetInactiveTopicPolicies for application/json ContentType.
type SetInactiveTopicPoliciesJSONRequestBody = SetInactiveTopicPoliciesJSONBody

// SetMaxUnackedMessagesPerConsumerJSONRequestBody defines body for SetMaxUnackedMessagesPerConsumer for application/json ContentType.
type SetMaxUnackedMessagesPerConsumerJSONRequestBody = SetMaxUnackedMessagesPerConsumerJSONBody

// SetMaxUnackedMessagesPerSubscriptionJSONRequestBody defines body for SetMaxUnackedMessagesPerSubscription for application/json ContentType.
type SetMaxUnackedMessagesPerSubscriptionJSONRequestBody = SetMaxUnackedMessagesPerSubscriptionJSONBody

// SetNamespaceMessageTTLJSONRequestBody defines body for SetNamespaceMessageTTL for application/json ContentType.
type SetNamespaceMessageTTLJSONRequestBody = SetNamespaceMessageTTLJSONBody

// SetOffloadDeletionLagJSONRequestBody defines body for SetOffloadDeletionLag for application/json ContentType.
type SetOffloadDeletionLagJSONRequestBody = SetOffloadDeletionLagJSONBody

// SetOffloadPoliciesJSONRequestBody defines body for SetOffloadPolicies for application/json ContentType.
type SetOffloadPoliciesJSONRequestBody = SetOffloadPoliciesJSONBody

// SetOffloadThresholdJSONRequestBody defines body for SetOffloadThreshold for application/json ContentType.
type SetOffloadThresholdJSONRequestBody = SetOffloadThresholdJSONBody

// GrantPermissionOnNamespaceJSONRequestBody defines body for GrantPermissionOnNamespace for application/json ContentType.
type GrantPermissionOnNamespaceJSONRequestBody = GrantPermissionOnNamespaceJSONBody

// SetPersistenceJSONRequestBody defines body for SetPersistence for application/json ContentType.
type SetPersistenceJSONRequestBody = SetPersistenceJSONBody

// SetBookieAffinityGroupJSONRequestBody defines body for SetBookieAffinityGroup for application/json ContentType.
type SetBookieAffinityGroupJSONRequestBody = SetBookieAffinityGroupJSONBody

// SetPropertiesJSONRequestBody defines body for SetProperties for application/json ContentType.
type SetPropertiesJSONRequestBody SetPropertiesJSONBody

// SetNamespaceReplicationClustersJSONRequestBody defines body for SetNamespaceReplicationClusters for application/json ContentType.
type SetNamespaceReplicationClustersJSONRequestBody = SetNamespaceReplicationClustersJSONBody

// SetReplicatorDispatchRateJSONRequestBody defines body for SetReplicatorDispatchRate for application/json ContentType.
type SetReplicatorDispatchRateJSONRequestBody = SetReplicatorDispatchRateJSONBody

// RemoveRetentionJSONRequestBody defines body for RemoveRetention for application/json ContentType.
type RemoveRetentionJSONRequestBody = RemoveRetentionJSONBody

// SetRetentionJSONRequestBody defines body for SetRetention for application/json ContentType.
type SetRetentionJSONRequestBody = SetRetentionJSONBody

// SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody defines body for SetSchemaAutoUpdateCompatibilityStrategy for application/json ContentType.
type SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody = SetSchemaAutoUpdateCompatibilityStrategyJSONBody

// SetSchemaCompatibilityStrategyJSONRequestBody defines body for SetSchemaCompatibilityStrategy for application/json ContentType.
type SetSchemaCompatibilityStrategyJSONRequestBody = SetSchemaCompatibilityStrategyJSONBody

// SetSchemaValidationEnforcedJSONRequestBody defines body for SetSchemaValidationEnforced for application/json ContentType.
type SetSchemaValidationEnforcedJSONRequestBody = SetSchemaValidationEnforcedJSONBody

// SetSubscribeRateJSONRequestBody defines body for SetSubscribeRate for application/json ContentType.
type SetSubscribeRateJSONRequestBody = SetSubscribeRateJSONBody

// SetSubscriptionAuthModeJSONRequestBody defines body for SetSubscriptionAuthMode for application/json ContentType.
type SetSubscriptionAuthModeJSONRequestBody = SetSubscriptionAuthModeJSONBody

// SetSubscriptionDispatchRateJSONRequestBody defines body for SetSubscriptionDispatchRate for application/json ContentType.
type SetSubscriptionDispatchRateJSONRequestBody = SetSubscriptionDispatchRateJSONBody

// SetSubscriptionExpirationTimeJSONRequestBody defines body for SetSubscriptionExpirationTime for application/json ContentType.
type SetSubscriptionExpirationTimeJSONRequestBody = SetSubscriptionExpirationTimeJSONBody

// SetSubscriptionTypesEnabledJSONRequestBody defines body for SetSubscriptionTypesEnabled for application/json ContentType.
type SetSubscriptionTypesEnabledJSONRequestBody = SetSubscriptionTypesEnabledJSONBody

// SplitNamespaceBundleJSONRequestBody defines body for SplitNamespaceBundle for application/json ContentType.
type SplitNamespaceBundleJSONRequestBody = SplitNamespaceBundleJSONBody

// SetDefaultResourceQuotaJSONRequestBody defines body for SetDefaultResourceQuota for application/json ContentType.
type SetDefaultResourceQuotaJSONRequestBody = SetDefaultResourceQuotaJSONBody

// SetNamespaceBundleResourceQuotaJSONRequestBody defines body for SetNamespaceBundleResourceQuota for application/json ContentType.
type SetNamespaceBundleResourceQuotaJSONRequestBody = SetNamespaceBundleResourceQuotaJSONBody

// CreateOrUpdateResourceGroupJSONRequestBody defines body for CreateOrUpdateResourceGroup for application/json ContentType.
type CreateOrUpdateResourceGroupJSONRequestBody = CreateOrUpdateResourceGroupJSONBody

// TestCompatibilityJSONRequestBody defines body for TestCompatibility for application/json ContentType.
type TestCompatibilityJSONRequestBody = TestCompatibilityJSONBody

// PostSchemaJSONRequestBody defines body for PostSchema for application/json ContentType.
type PostSchemaJSONRequestBody = PostSchemaJSONBody

// GetVersionBySchemaJSONRequestBody defines body for GetVersionBySchema for application/json ContentType.
type GetVersionBySchemaJSONRequestBody = GetVersionBySchemaJSONBody

// UpdateTenantJSONRequestBody defines body for UpdateTenant for application/json ContentType.
type UpdateTenantJSONRequestBody = UpdateTenantJSONBody

// CreateTenantJSONRequestBody defines body for CreateTenant for application/json ContentType.
type CreateTenantJSONRequestBody = CreateTenantJSONBody

// Getter for additional properties for SetPropertiesJSONBody. Returns the specified
// element and whether it was found
func (a SetPropertiesJSONBody) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SetPropertiesJSONBody
func (a *SetPropertiesJSONBody) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SetPropertiesJSONBody to handle AdditionalProperties
func (a *SetPropertiesJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SetPropertiesJSONBody to handle AdditionalProperties
func (a SetPropertiesJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AuthPolicies_NamespaceAuthentication. Returns the specified
// element and whether it was found
func (a AuthPolicies_NamespaceAuthentication) Get(fieldName string) (value []AuthPoliciesNamespaceAuthentication, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AuthPolicies_NamespaceAuthentication
func (a *AuthPolicies_NamespaceAuthentication) Set(fieldName string, value []AuthPoliciesNamespaceAuthentication) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]AuthPoliciesNamespaceAuthentication)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AuthPolicies_NamespaceAuthentication to handle AdditionalProperties
func (a *AuthPolicies_NamespaceAuthentication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]AuthPoliciesNamespaceAuthentication)
		for fieldName, fieldBuf := range object {
			var fieldVal []AuthPoliciesNamespaceAuthentication
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AuthPolicies_NamespaceAuthentication to handle AdditionalProperties
func (a AuthPolicies_NamespaceAuthentication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AuthPolicies_SubscriptionAuthentication. Returns the specified
// element and whether it was found
func (a AuthPolicies_SubscriptionAuthentication) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AuthPolicies_SubscriptionAuthentication
func (a *AuthPolicies_SubscriptionAuthentication) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AuthPolicies_SubscriptionAuthentication to handle AdditionalProperties
func (a *AuthPolicies_SubscriptionAuthentication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AuthPolicies_SubscriptionAuthentication to handle AdditionalProperties
func (a AuthPolicies_SubscriptionAuthentication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AuthPolicies_TopicAuthentication. Returns the specified
// element and whether it was found
func (a AuthPolicies_TopicAuthentication) Get(fieldName string) (value struct {
	AdditionalProperties map[string][]AuthPoliciesTopicAuthentication `json:"-"`
}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AuthPolicies_TopicAuthentication
func (a *AuthPolicies_TopicAuthentication) Set(fieldName string, value struct {
	AdditionalProperties map[string][]AuthPoliciesTopicAuthentication `json:"-"`
}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]struct {
			AdditionalProperties map[string][]AuthPoliciesTopicAuthentication `json:"-"`
		})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AuthPolicies_TopicAuthentication to handle AdditionalProperties
func (a *AuthPolicies_TopicAuthentication) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]struct {
			AdditionalProperties map[string][]AuthPoliciesTopicAuthentication `json:"-"`
		})
		for fieldName, fieldBuf := range object {
			var fieldVal struct {
				AdditionalProperties map[string][]AuthPoliciesTopicAuthentication `json:"-"`
			}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AuthPolicies_TopicAuthentication to handle AdditionalProperties
func (a AuthPolicies_TopicAuthentication) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AutoFailoverPolicyData_Parameters. Returns the specified
// element and whether it was found
func (a AutoFailoverPolicyData_Parameters) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AutoFailoverPolicyData_Parameters
func (a *AutoFailoverPolicyData_Parameters) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AutoFailoverPolicyData_Parameters to handle AdditionalProperties
func (a *AutoFailoverPolicyData_Parameters) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AutoFailoverPolicyData_Parameters to handle AdditionalProperties
func (a AutoFailoverPolicyData_Parameters) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for FunctionInstanceStatsData_UserMetrics. Returns the specified
// element and whether it was found
func (a FunctionInstanceStatsData_UserMetrics) Get(fieldName string) (value float64, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for FunctionInstanceStatsData_UserMetrics
func (a *FunctionInstanceStatsData_UserMetrics) Set(fieldName string, value float64) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]float64)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for FunctionInstanceStatsData_UserMetrics to handle AdditionalProperties
func (a *FunctionInstanceStatsData_UserMetrics) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]float64)
		for fieldName, fieldBuf := range object {
			var fieldVal float64
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for FunctionInstanceStatsData_UserMetrics to handle AdditionalProperties
func (a FunctionInstanceStatsData_UserMetrics) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GetSchemaResponse_Properties. Returns the specified
// element and whether it was found
func (a GetSchemaResponse_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GetSchemaResponse_Properties
func (a *GetSchemaResponse_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GetSchemaResponse_Properties to handle AdditionalProperties
func (a *GetSchemaResponse_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GetSchemaResponse_Properties to handle AdditionalProperties
func (a GetSchemaResponse_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LoadReport_BundleStats. Returns the specified
// element and whether it was found
func (a LoadReport_BundleStats) Get(fieldName string) (value NamespaceBundleStats, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LoadReport_BundleStats
func (a *LoadReport_BundleStats) Set(fieldName string, value NamespaceBundleStats) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]NamespaceBundleStats)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LoadReport_BundleStats to handle AdditionalProperties
func (a *LoadReport_BundleStats) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]NamespaceBundleStats)
		for fieldName, fieldBuf := range object {
			var fieldVal NamespaceBundleStats
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LoadReport_BundleStats to handle AdditionalProperties
func (a LoadReport_BundleStats) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LoadReport_Protocols. Returns the specified
// element and whether it was found
func (a LoadReport_Protocols) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LoadReport_Protocols
func (a *LoadReport_Protocols) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LoadReport_Protocols to handle AdditionalProperties
func (a *LoadReport_Protocols) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LoadReport_Protocols to handle AdditionalProperties
func (a LoadReport_Protocols) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Metrics_Dimensions. Returns the specified
// element and whether it was found
func (a Metrics_Dimensions) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Metrics_Dimensions
func (a *Metrics_Dimensions) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Metrics_Dimensions to handle AdditionalProperties
func (a *Metrics_Dimensions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Metrics_Dimensions to handle AdditionalProperties
func (a Metrics_Dimensions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Metrics_Metrics. Returns the specified
// element and whether it was found
func (a Metrics_Metrics) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Metrics_Metrics
func (a *Metrics_Metrics) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Metrics_Metrics to handle AdditionalProperties
func (a *Metrics_Metrics) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Metrics_Metrics to handle AdditionalProperties
func (a Metrics_Metrics) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PartitionedTopicMetadata_Properties. Returns the specified
// element and whether it was found
func (a PartitionedTopicMetadata_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PartitionedTopicMetadata_Properties
func (a *PartitionedTopicMetadata_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PartitionedTopicMetadata_Properties to handle AdditionalProperties
func (a *PartitionedTopicMetadata_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PartitionedTopicMetadata_Properties to handle AdditionalProperties
func (a PartitionedTopicMetadata_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_BacklogQuotaMap. Returns the specified
// element and whether it was found
func (a Policies_BacklogQuotaMap) Get(fieldName string) (value BacklogQuota, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_BacklogQuotaMap
func (a *Policies_BacklogQuotaMap) Set(fieldName string, value BacklogQuota) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]BacklogQuota)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_BacklogQuotaMap to handle AdditionalProperties
func (a *Policies_BacklogQuotaMap) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]BacklogQuota)
		for fieldName, fieldBuf := range object {
			var fieldVal BacklogQuota
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_BacklogQuotaMap to handle AdditionalProperties
func (a Policies_BacklogQuotaMap) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_ClusterDispatchRate. Returns the specified
// element and whether it was found
func (a Policies_ClusterDispatchRate) Get(fieldName string) (value DispatchRateImpl, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_ClusterDispatchRate
func (a *Policies_ClusterDispatchRate) Set(fieldName string, value DispatchRateImpl) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_ClusterDispatchRate to handle AdditionalProperties
func (a *Policies_ClusterDispatchRate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
		for fieldName, fieldBuf := range object {
			var fieldVal DispatchRateImpl
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_ClusterDispatchRate to handle AdditionalProperties
func (a Policies_ClusterDispatchRate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_ClusterSubscribeRate. Returns the specified
// element and whether it was found
func (a Policies_ClusterSubscribeRate) Get(fieldName string) (value SubscribeRate, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_ClusterSubscribeRate
func (a *Policies_ClusterSubscribeRate) Set(fieldName string, value SubscribeRate) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]SubscribeRate)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_ClusterSubscribeRate to handle AdditionalProperties
func (a *Policies_ClusterSubscribeRate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]SubscribeRate)
		for fieldName, fieldBuf := range object {
			var fieldVal SubscribeRate
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_ClusterSubscribeRate to handle AdditionalProperties
func (a Policies_ClusterSubscribeRate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_LatencyStatsSampleRate. Returns the specified
// element and whether it was found
func (a Policies_LatencyStatsSampleRate) Get(fieldName string) (value int32, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_LatencyStatsSampleRate
func (a *Policies_LatencyStatsSampleRate) Set(fieldName string, value int32) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]int32)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_LatencyStatsSampleRate to handle AdditionalProperties
func (a *Policies_LatencyStatsSampleRate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]int32)
		for fieldName, fieldBuf := range object {
			var fieldVal int32
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_LatencyStatsSampleRate to handle AdditionalProperties
func (a Policies_LatencyStatsSampleRate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_Properties. Returns the specified
// element and whether it was found
func (a Policies_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_Properties
func (a *Policies_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_Properties to handle AdditionalProperties
func (a *Policies_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_Properties to handle AdditionalProperties
func (a Policies_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_PublishMaxMessageRate. Returns the specified
// element and whether it was found
func (a Policies_PublishMaxMessageRate) Get(fieldName string) (value PublishRate, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_PublishMaxMessageRate
func (a *Policies_PublishMaxMessageRate) Set(fieldName string, value PublishRate) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]PublishRate)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_PublishMaxMessageRate to handle AdditionalProperties
func (a *Policies_PublishMaxMessageRate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]PublishRate)
		for fieldName, fieldBuf := range object {
			var fieldVal PublishRate
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_PublishMaxMessageRate to handle AdditionalProperties
func (a Policies_PublishMaxMessageRate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_ReplicatorDispatchRate. Returns the specified
// element and whether it was found
func (a Policies_ReplicatorDispatchRate) Get(fieldName string) (value DispatchRateImpl, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_ReplicatorDispatchRate
func (a *Policies_ReplicatorDispatchRate) Set(fieldName string, value DispatchRateImpl) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_ReplicatorDispatchRate to handle AdditionalProperties
func (a *Policies_ReplicatorDispatchRate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
		for fieldName, fieldBuf := range object {
			var fieldVal DispatchRateImpl
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_ReplicatorDispatchRate to handle AdditionalProperties
func (a Policies_ReplicatorDispatchRate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_SubscriptionDispatchRate. Returns the specified
// element and whether it was found
func (a Policies_SubscriptionDispatchRate) Get(fieldName string) (value DispatchRateImpl, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_SubscriptionDispatchRate
func (a *Policies_SubscriptionDispatchRate) Set(fieldName string, value DispatchRateImpl) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_SubscriptionDispatchRate to handle AdditionalProperties
func (a *Policies_SubscriptionDispatchRate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
		for fieldName, fieldBuf := range object {
			var fieldVal DispatchRateImpl
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_SubscriptionDispatchRate to handle AdditionalProperties
func (a Policies_SubscriptionDispatchRate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policies_TopicDispatchRate. Returns the specified
// element and whether it was found
func (a Policies_TopicDispatchRate) Get(fieldName string) (value DispatchRateImpl, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policies_TopicDispatchRate
func (a *Policies_TopicDispatchRate) Set(fieldName string, value DispatchRateImpl) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policies_TopicDispatchRate to handle AdditionalProperties
func (a *Policies_TopicDispatchRate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DispatchRateImpl)
		for fieldName, fieldBuf := range object {
			var fieldVal DispatchRateImpl
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policies_TopicDispatchRate to handle AdditionalProperties
func (a Policies_TopicDispatchRate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PostSchemaPayload_Properties. Returns the specified
// element and whether it was found
func (a PostSchemaPayload_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PostSchemaPayload_Properties
func (a *PostSchemaPayload_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PostSchemaPayload_Properties to handle AdditionalProperties
func (a *PostSchemaPayload_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PostSchemaPayload_Properties to handle AdditionalProperties
func (a PostSchemaPayload_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ResetCursorData_Properties. Returns the specified
// element and whether it was found
func (a ResetCursorData_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ResetCursorData_Properties
func (a *ResetCursorData_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ResetCursorData_Properties to handle AdditionalProperties
func (a *ResetCursorData_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ResetCursorData_Properties to handle AdditionalProperties
func (a ResetCursorData_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ResourceDescription_ResourceUsage. Returns the specified
// element and whether it was found
func (a ResourceDescription_ResourceUsage) Get(fieldName string) (value ResourceUsage, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ResourceDescription_ResourceUsage
func (a *ResourceDescription_ResourceUsage) Set(fieldName string, value ResourceUsage) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ResourceUsage)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ResourceDescription_ResourceUsage to handle AdditionalProperties
func (a *ResourceDescription_ResourceUsage) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ResourceUsage)
		for fieldName, fieldBuf := range object {
			var fieldVal ResourceUsage
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ResourceDescription_ResourceUsage to handle AdditionalProperties
func (a ResourceDescription_ResourceUsage) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllBookies request
	GetAllBookies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookiesRackInfo request
	GetBookiesRackInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBookieRackInfo request
	DeleteBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookieRackInfo request
	GetBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBookieRackInfo request
	UpdateBookieRackInfo(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllocatorStats request
	GetAllocatorStats(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingBookieOpsStats request
	GetPendingBookieOpsStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrokerResourceAvailability request
	GetBrokerResourceAvailability(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoadReport request
	GetLoadReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMBeans request
	GetMBeans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetrics request
	GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopics2 request
	GetTopics2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActiveBrokers request
	GetActiveBrokers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BacklogQuotaCheck request
	BacklogQuotaCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDynamicConfigurationName request
	GetDynamicConfigurationName(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeConfiguration request
	GetRuntimeConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDynamicConfigurations request
	GetAllDynamicConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDynamicConfiguration request
	DeleteDynamicConfiguration(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDynamicConfiguration request
	UpdateDynamicConfiguration(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInternalConfigurationData request
	GetInternalConfigurationData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaderBroker request
	GetLeaderBroker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsReady request
	IsReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShutDownBrokerGracefully request
	ShutDownBrokerGracefully(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Version request
	Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOwnedNamespaces request
	GetOwnedNamespaces(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActiveBrokers request
	GetActiveBrokers(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusters request
	GetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCluster request with any body
	UpdateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCluster request with any body
	CreateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFailureDomains request
	GetFailureDomains(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFailureDomain request
	DeleteFailureDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomain request
	GetDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetFailureDomain request with any body
	SetFailureDomainWithBody(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceIsolationPolicies request
	GetNamespaceIsolationPolicies(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrokersWithNamespaceIsolationPolicy request
	GetBrokersWithNamespaceIsolationPolicy(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrokerWithNamespaceIsolationPolicy request
	GetBrokerWithNamespaceIsolationPolicy(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespaceIsolationPolicy request
	DeleteNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceIsolationPolicy request
	GetNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceIsolationPolicy request with any body
	SetNamespaceIsolationPolicyWithBody(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerCluster request
	GetPeerCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPeerClusterNames request with any body
	SetPeerClusterNamesWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAntiAffinityNamespaces request
	GetAntiAffinityNamespaces(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBookieAffinityGroup request
	DeleteBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookieAffinityGroup request
	GetBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenantNamespaces request
	GetTenantNamespaces(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespace request
	DeleteNamespace(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicies request
	GetPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNamespace request with any body
	CreateNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNamespace(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceAntiAffinityGroup request
	RemoveNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceAntiAffinityGroup request
	GetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceAntiAffinityGroup request with any body
	SetNamespaceAntiAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAutoSubscriptionCreation request
	RemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoSubscriptionCreation request
	GetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAutoSubscriptionCreation request with any body
	SetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAutoTopicCreation request
	RemoveAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoTopicCreation request
	GetAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAutoTopicCreation request with any body
	SetAutoTopicCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAutoTopicCreation(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveBacklogQuota request
	RemoveBacklogQuota(ctx context.Context, tenant string, namespace string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBacklogQuota request with any body
	SetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBacklogQuota(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, body SetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBacklogQuotaMap request
	GetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundlesData request
	GetBundlesData(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBacklog request
	ClearNamespaceBacklog(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBacklogForSubscription request
	ClearNamespaceBacklogForSubscription(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCompactionThreshold request
	DeleteCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompactionThreshold request
	GetCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCompactionThreshold request with any body
	SetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCompactionThreshold(ctx context.Context, tenant string, namespace string, body SetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDeduplication request
	RemoveDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeduplication request
	GetDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyDeduplication request with any body
	ModifyDeduplicationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyDeduplication(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeduplicationSnapshotInterval request
	GetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDeduplicationSnapshotInterval request with any body
	SetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, body SetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDelayedDeliveryPolicies request
	RemoveDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDelayedDeliveryPolicies request
	GetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDelayedDeliveryPolicies request with any body
	SetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, body SetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDispatchRate request
	DeleteDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDispatchRate request
	GetDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDispatchRate request with any body
	SetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDispatchRate(ctx context.Context, tenant string, namespace string, body SetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEncryptionRequired request
	GetEncryptionRequired(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyEncryptionRequired request with any body
	ModifyEncryptionRequiredWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyEncryptionRequired(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceEntryFilters request
	RemoveNamespaceEntryFilters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntryFiltersPerTopic request
	GetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEntryFiltersPerTopic request with any body
	SetEntryFiltersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveInactiveTopicPolicies request
	RemoveInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInactiveTopicPolicies request
	GetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIsAllowAutoUpdateSchema request
	GetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIsAllowAutoUpdateSchema request with any body
	SetIsAllowAutoUpdateSchemaWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxConsumersPerSubscription request
	RemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxConsumersPerSubscription request
	GetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxConsumersPerSubscription request with any body
	SetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxConsumersPerTopic request
	RemoveMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxConsumersPerTopic request
	GetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxConsumersPerTopic request with any body
	SetMaxConsumersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxProducersPerTopic request
	RemoveMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxProducersPerTopic request
	GetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxProducersPerTopic request with any body
	SetMaxProducersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, body SetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxSubscriptionsPerTopic request
	RemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxSubscriptionsPerTopic request
	GetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxSubscriptionsPerTopic request with any body
	SetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, body SetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetInactiveTopicPolicies request
	SetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxTopicsPerNamespace request
	GetMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxUnackedmessagesPerConsumer request
	RemoveMaxUnackedmessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxUnackedMessagesPerConsumer request
	GetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxUnackedMessagesPerConsumer request with any body
	SetMaxUnackedMessagesPerConsumerWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxUnackedmessagesPerSubscription request
	RemoveMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxUnackedmessagesPerSubscription request
	GetMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxUnackedMessagesPerSubscription request with any body
	SetMaxUnackedMessagesPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMaxUnackedMessagesPerSubscription(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMessageTTL request
	RemoveNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMessageTTL request
	GetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMessageTTL request with any body
	SetNamespaceMessageTTLWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearOffloadDeletionLag request
	ClearOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOffloadDeletionLag request
	GetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOffloadDeletionLag request with any body
	SetOffloadDeletionLagWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, body SetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOffloadPolicies request
	GetOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOffloadPolicies request with any body
	SetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetOffloadPolicies(ctx context.Context, tenant string, namespace string, body SetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOffloadThreshold request
	GetOffloadThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOffloadThreshold request with any body
	SetOffloadThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetOffloadThreshold(ctx context.Context, tenant string, namespace string, body SetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissions request
	GetPermissions(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionOnSubscription request
	GetPermissionOnSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsOnNamespace request
	RevokePermissionsOnNamespace(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantPermissionOnNamespace request with any body
	GrantPermissionOnNamespaceWithBody(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GrantPermissionOnNamespace(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistence request
	DeletePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistence request
	GetPersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistence request with any body
	SetPersistenceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPersistence(ctx context.Context, tenant string, namespace string, body SetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBookieAffinityGroup request with any body
	SetBookieAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBookieAffinityGroup(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearProperties request
	ClearProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProperties request
	GetProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetProperties request with any body
	SetPropertiesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetProperties(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveProperty request
	RemoveProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProperty request
	GetProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetProperty request
	SetProperty(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOffloadPolicies request
	RemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceReplicationClusters request
	GetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceReplicationClusters request with any body
	SetNamespaceReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveReplicatorDispatchRate request
	RemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplicatorDispatchRate request
	GetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetReplicatorDispatchRate request with any body
	SetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, body SetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceResourceGroup request
	RemoveNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceResourceGroup request
	GetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceResourceGroup request
	SetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRetention request with any body
	RemoveRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveRetention(ctx context.Context, tenant string, namespace string, body RemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRetention request
	GetRetention(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRetention request with any body
	SetRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRetention(ctx context.Context, tenant string, namespace string, body SetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScanOffloadedLedgers request
	ScanOffloadedLedgers(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaAutoUpdateCompatibilityStrategy request
	GetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaAutoUpdateCompatibilityStrategy request with any body
	SetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaCompatibilityStrategy request
	GetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaCompatibilityStrategy request with any body
	SetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaValidtionEnforced request
	GetSchemaValidtionEnforced(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaValidationEnforced request with any body
	SetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, body SetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscribeRate request
	DeleteSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscribeRate request
	GetSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscribeRate request with any body
	SetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSubscribeRate(ctx context.Context, tenant string, namespace string, body SetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionAuthMode request
	GetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionAuthMode request with any body
	SetSubscriptionAuthModeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, body SetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscriptionDispatchRate request
	DeleteSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionDispatchRate request
	GetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionDispatchRate request with any body
	SetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, body SetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionExpirationTime request
	RemoveSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionExpirationTime request
	GetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionExpirationTime request with any body
	SetSubscriptionExpirationTimeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, body SetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionTypesEnabled request
	RemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionTypesEnabled request
	GetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionTypesEnabled request with any body
	SetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, body SetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopics request
	GetTopics(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadNamespace request
	UnloadNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsubscribeNamespace request
	UnsubscribeNamespace(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespaceBundle request
	DeleteNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBundleBacklog request
	ClearNamespaceBundleBacklog(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBundleBacklogForSubscription request
	ClearNamespaceBundleBacklogForSubscription(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SplitNamespaceBundle request with any body
	SplitNamespaceBundleWithBody(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SplitNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopicHashPositions request
	GetTopicHashPositions(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadNamespaceBundle request
	UnloadNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsubscribeNamespaceBundle request
	UnsubscribeNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetList request
	GetList(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPartitionedTopicList request
	GetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListFromBundle request
	GetListFromBundle(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTopic request
	DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNonPartitionedTopic request with any body
	CreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireMessagesForAllSubscriptions request
	ExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBacklog request
	GetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveBacklogQuota request
	RemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBacklogQuota request
	SetBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBacklogQuotaMap request
	GetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBacklogSizeByMessageId request
	GetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompactionStatus request
	CompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Compact request
	Compact(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveCompactionThreshold request
	RemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompactionThreshold request
	GetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCompactionThreshold request with any body
	SetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMissedPartitions request
	CreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDeduplication request
	RemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeduplication request
	GetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDeduplication request with any body
	SetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeduplicationSnapshotInterval request
	DeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeduplicationSnapshotInterval request
	GetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDeduplicationSnapshotInterval request with any body
	SetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDelayedDeliveryPolicies request
	DeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDelayedDeliveryPolicies request
	GetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDelayedDeliveryPolicies request with any body
	SetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDispatchRate request
	RemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDispatchRate request
	GetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDispatchRate request with any body
	SetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveEntryFilters request
	RemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntryFilters request
	GetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEntryFilters request with any body
	SetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExamineMessage request
	ExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInactiveTopicPolicies request
	DeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInactiveTopicPolicies request
	GetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManagedLedgerInfo request
	GetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInternalStats request
	GetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastMessageId request
	GetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessageById request
	GetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxConsumers request
	RemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxConsumers request
	GetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxConsumers request with any body
	SetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxConsumersPerSubscription request
	RemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxConsumersPerSubscription request
	GetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxConsumersPerSubscription request with any body
	SetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxMessageSize request
	RemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxMessageSize request
	GetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxMessageSize request with any body
	SetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxProducers request
	RemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxProducers request
	GetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxProducers request with any body
	SetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxSubscriptionsPerTopic request
	RemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxSubscriptionsPerTopic request
	GetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxSubscriptionsPerTopic request with any body
	SetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMaxUnackedMessagesOnConsumer request
	DeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxUnackedMessagesOnConsumer request
	GetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxUnackedMessagesOnConsumer request with any body
	SetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMaxUnackedMessagesOnSubscription request
	DeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxUnackedMessagesOnSubscription request
	GetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxUnackedMessagesOnSubscription request with any body
	SetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMessageTTL request
	RemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessageTTL request
	GetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMessageTTL request
	SetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessageIdByTimestamp request
	GetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OffloadStatus request
	OffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerOffload request
	TriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOffloadPolicies request
	RemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOffloadPolicies request
	GetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOffloadPolicies request with any body
	SetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPartitionedStats request
	GetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePartitionedTopic request
	DeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPartitionedMetadata request
	GetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePartitionedTopic request with any body
	UpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePartitionedTopic request with any body
	CreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionsOnTopic request
	GetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsOnTopic request
	RevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantPermissionsOnTopic request with any body
	GrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistence request
	RemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistence request
	GetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistence request with any body
	SetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveProperties request
	RemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProperties request
	GetProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProperties request with any body
	UpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePublishRate request
	RemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublishRate request
	GetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPublishRate request with any body
	SetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveReplicationClusters request
	RemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplicationClusters request
	GetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetReplicationClusters request with any body
	SetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveReplicatorDispatchRate request
	RemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplicatorDispatchRate request
	GetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetReplicatorDispatchRate request with any body
	SetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRetention request
	RemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRetention request
	GetRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRetention request with any body
	SetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSchemaCompatibilityStrategy request with any body
	RemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaCompatibilityStrategy request
	GetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaCompatibilityStrategy request with any body
	SetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaValidationEnforced request
	GetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaValidationEnforced request with any body
	SetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShadowTopics request
	DeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShadowTopics request
	GetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetShadowTopics request with any body
	SetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscribeRate request with any body
	RemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscribeRate request
	GetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscribeRate request with any body
	SetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnalyzeSubscriptionBacklog request with any body
	AnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireTopicMessages request with any body
	ExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireTopicMessages request
	ExpireTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PeekNthMessage request
	PeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionProperties request
	GetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubscriptionProperties request with any body
	UpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplicatedSubscriptionStatus request
	GetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetReplicatedSubscriptionStatus request with any body
	SetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetCursorOnPosition request with any body
	ResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetCursor request
	ResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipMessages request
	SkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipAllMessages request
	SkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscription request with any body
	CreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionDispatchRate request
	RemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionDispatchRate request
	GetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionDispatchRate request with any body
	SetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionTypesEnabled request
	RemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionTypesEnabled request
	GetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionTypesEnabled request with any body
	SetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptions request
	GetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Terminate request
	Terminate(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminatePartitionedTopic request
	TerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TruncateTopic request
	TruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadTopic request
	UnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionLevelDispatchRate request
	RemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionLevelDispatchRate request
	GetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionLevelDispatchRate request with any body
	SetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetList request
	GetList(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPartitionedTopicList request
	GetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTopic request
	DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNonPartitionedTopic request with any body
	CreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireMessagesForAllSubscriptions request
	ExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBacklog request
	GetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveBacklogQuota request
	RemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBacklogQuota request
	SetBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBacklogQuotaMap request
	GetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBacklogSizeByMessageId request
	GetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompactionStatus request
	CompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Compact request
	Compact(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveCompactionThreshold request
	RemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompactionThreshold request
	GetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCompactionThreshold request with any body
	SetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMissedPartitions request
	CreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDeduplication request
	RemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeduplication request
	GetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDeduplication request with any body
	SetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeduplicationSnapshotInterval request
	DeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeduplicationSnapshotInterval request
	GetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDeduplicationSnapshotInterval request with any body
	SetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDelayedDeliveryPolicies request
	DeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDelayedDeliveryPolicies request
	GetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDelayedDeliveryPolicies request with any body
	SetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDispatchRate request
	RemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDispatchRate request
	GetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDispatchRate request with any body
	SetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveEntryFilters request
	RemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntryFilters request
	GetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEntryFilters request with any body
	SetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExamineMessage request
	ExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInactiveTopicPolicies request
	DeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInactiveTopicPolicies request
	GetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManagedLedgerInfo request
	GetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInternalStats request
	GetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLastMessageId request
	GetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessageById request
	GetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxConsumers request
	RemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxConsumers request
	GetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxConsumers request with any body
	SetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxConsumersPerSubscription request
	RemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxConsumersPerSubscription request
	GetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxConsumersPerSubscription request with any body
	SetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxMessageSize request
	RemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxMessageSize request
	GetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxMessageSize request with any body
	SetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxProducers request
	RemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxProducers request
	GetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxProducers request with any body
	SetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMaxSubscriptionsPerTopic request
	RemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxSubscriptionsPerTopic request
	GetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxSubscriptionsPerTopic request with any body
	SetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMaxUnackedMessagesOnConsumer request
	DeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxUnackedMessagesOnConsumer request
	GetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxUnackedMessagesOnConsumer request with any body
	SetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMaxUnackedMessagesOnSubscription request
	DeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaxUnackedMessagesOnSubscription request
	GetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMaxUnackedMessagesOnSubscription request with any body
	SetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMessageTTL request
	RemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessageTTL request
	GetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMessageTTL request
	SetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessageIdByTimestamp request
	GetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OffloadStatus request
	OffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerOffload request
	TriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOffloadPolicies request
	RemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOffloadPolicies request
	GetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOffloadPolicies request with any body
	SetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPartitionedStats request
	GetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePartitionedTopic request
	DeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPartitionedMetadata request
	GetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePartitionedTopic request with any body
	UpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePartitionedTopic request with any body
	CreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionsOnTopic request
	GetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsOnTopic request
	RevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantPermissionsOnTopic request with any body
	GrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistence request
	RemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistence request
	GetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistence request with any body
	SetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveProperties request
	RemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProperties request
	GetProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProperties request with any body
	UpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePublishRate request
	RemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublishRate request
	GetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPublishRate request with any body
	SetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveReplicationClusters request
	RemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplicationClusters request
	GetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetReplicationClusters request with any body
	SetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveReplicatorDispatchRate request
	RemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplicatorDispatchRate request
	GetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetReplicatorDispatchRate request with any body
	SetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRetention request
	RemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRetention request
	GetRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRetention request with any body
	SetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSchemaCompatibilityStrategy request with any body
	RemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaCompatibilityStrategy request
	GetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaCompatibilityStrategy request with any body
	SetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaValidationEnforced request
	GetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaValidationEnforced request with any body
	SetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShadowTopics request
	DeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShadowTopics request
	GetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetShadowTopics request with any body
	SetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscribeRate request with any body
	RemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscribeRate request
	GetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscribeRate request with any body
	SetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnalyzeSubscriptionBacklog request with any body
	AnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireTopicMessages request with any body
	ExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireTopicMessages request
	ExpireTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PeekNthMessage request
	PeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionProperties request
	GetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubscriptionProperties request with any body
	UpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReplicatedSubscriptionStatus request
	GetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetReplicatedSubscriptionStatus request with any body
	SetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetCursorOnPosition request with any body
	ResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetCursor request
	ResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipMessages request
	SkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipAllMessages request
	SkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscription request with any body
	CreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionDispatchRate request
	RemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionDispatchRate request
	GetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionDispatchRate request with any body
	SetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionTypesEnabled request
	RemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionTypesEnabled request
	GetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionTypesEnabled request with any body
	SetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptions request
	GetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Terminate request
	Terminate(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminatePartitionedTopic request
	TerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TruncateTopic request
	TruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadTopic request
	UnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionLevelDispatchRate request
	RemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionLevelDispatchRate request
	GetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSubscriptionLevelDispatchRate request with any body
	SetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultResourceQuota request
	GetDefaultResourceQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultResourceQuota request with any body
	SetDefaultResourceQuotaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDefaultResourceQuota(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceBundleResourceQuota request
	RemoveNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceBundleResourceQuota request
	GetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceBundleResourceQuota request with any body
	SetNamespaceBundleResourceQuotaWithBody(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceGroups request
	GetResourceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceGroup request
	DeleteResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceGroup request
	GetResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateResourceGroup request with any body
	CreateOrUpdateResourceGroupWithBody(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateResourceGroup(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestCompatibility request with any body
	TestCompatibilityWithBody(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestCompatibility(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSchema request
	DeleteSchema(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchema request
	GetSchema(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchema request with any body
	PostSchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSchema(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchema request
	GetSchema(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSchemas request
	GetAllSchemas(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionBySchema request with any body
	GetVersionBySchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetVersionBySchema(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenants request
	GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTenant request
	DeleteTenant(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenantAdmin request
	GetTenantAdmin(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTenant request with any body
	UpdateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTenant(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTenant request with any body
	CreateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTenant(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetrics request
	GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssignments request
	GetAssignments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterLeader request
	GetClusterLeader(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsLeaderReady request
	IsLeaderReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectorsList request
	GetConnectorsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDrainStatus request
	GetDrainStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Drain request
	Drain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDrainStatusFromLeader request
	GetDrainStatusFromLeader(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DrainAtLeader request
	DrainAtLeader(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Rebalance request
	Rebalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllBookies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBookiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookiesRackInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookiesRackInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBookieRackInfoRequest(c.Server, bookie)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookieRackInfoRequest(c.Server, bookie)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBookieRackInfo(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBookieRackInfoRequest(c.Server, bookie, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllocatorStats(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllocatorStatsRequest(c.Server, allocator)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingBookieOpsStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingBookieOpsStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrokerResourceAvailability(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrokerResourceAvailabilityRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoadReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoadReportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMBeans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMBeansRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopics2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopics2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActiveBrokers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActiveBrokersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BacklogQuotaCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBacklogQuotaCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDynamicConfigurationName(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDynamicConfigurationNameRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDynamicConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDynamicConfigurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDynamicConfiguration(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDynamicConfigurationRequest(c.Server, configName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDynamicConfiguration(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDynamicConfigurationRequest(c.Server, configName, configValue)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInternalConfigurationData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInternalConfigurationDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeaderBroker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaderBrokerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShutDownBrokerGracefully(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShutDownBrokerGracefullyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOwnedNamespaces(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOwnedNamespacesRequest(c.Server, clusterName, brokerWebserviceurl)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActiveBrokers(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActiveBrokersRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFailureDomains(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFailureDomainsRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFailureDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFailureDomainRequest(c.Server, cluster, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainRequest(c.Server, cluster, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFailureDomainWithBody(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFailureDomainRequestWithBody(c.Server, cluster, domainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceIsolationPolicies(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceIsolationPoliciesRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrokersWithNamespaceIsolationPolicy(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrokersWithNamespaceIsolationPolicyRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrokerWithNamespaceIsolationPolicy(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrokerWithNamespaceIsolationPolicyRequest(c.Server, cluster, broker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceIsolationPolicyRequest(c.Server, cluster, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceIsolationPolicyRequest(c.Server, cluster, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceIsolationPolicyWithBody(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceIsolationPolicyRequestWithBody(c.Server, cluster, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPeerClusterNamesWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPeerClusterNamesRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAntiAffinityNamespaces(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAntiAffinityNamespacesRequest(c.Server, cluster, group, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBookieAffinityGroupRequest(c.Server, property, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookieAffinityGroupRequest(c.Server, property, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenantNamespaces(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantNamespacesRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespace(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespace(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceAntiAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceAntiAffinityGroupRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAutoSubscriptionCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoSubscriptionCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoSubscriptionCreationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoSubscriptionCreationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAutoTopicCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoTopicCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoTopicCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoTopicCreationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoTopicCreation(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoTopicCreationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveBacklogQuota(ctx context.Context, tenant string, namespace string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveBacklogQuotaRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBacklogQuotaRequestWithBody(c.Server, tenant, namespace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBacklogQuota(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, body SetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBacklogQuotaRequest(c.Server, tenant, namespace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBacklogQuotaMapRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundlesData(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundlesDataRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBacklog(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBacklogRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBacklogForSubscription(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBacklogForSubscriptionRequest(c.Server, tenant, namespace, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCompactionThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompactionThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCompactionThresholdRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCompactionThreshold(ctx context.Context, tenant string, namespace string, body SetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCompactionThresholdRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDeduplicationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeduplicationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyDeduplicationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyDeduplicationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyDeduplication(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyDeduplicationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, body SetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, body SetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDispatchRate(ctx context.Context, tenant string, namespace string, body SetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEncryptionRequired(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEncryptionRequiredRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyEncryptionRequiredWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyEncryptionRequiredRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyEncryptionRequired(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyEncryptionRequiredRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceEntryFilters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceEntryFiltersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryFiltersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEntryFiltersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEntryFiltersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEntryFiltersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveInactiveTopicPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInactiveTopicPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInactiveTopicPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIsAllowAutoUpdateSchemaRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIsAllowAutoUpdateSchemaWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIsAllowAutoUpdateSchemaRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIsAllowAutoUpdateSchemaRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxConsumersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxConsumersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxProducersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxProducersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxProducersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxProducersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, body SetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxProducersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, body SetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInactiveTopicPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxTopicsPerNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInactiveTopicPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxUnackedmessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxUnackedmessagesPerConsumerRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxUnackedMessagesPerConsumerRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesPerConsumerWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesPerConsumerRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesPerConsumerRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxUnackedmessagesPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxUnackedmessagesPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesPerSubscriptionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesPerSubscription(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesPerSubscriptionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMessageTTLRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMessageTTLRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMessageTTLWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMessageTTLRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMessageTTLRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearOffloadDeletionLagRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOffloadDeletionLagRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadDeletionLagWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadDeletionLagRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, body SetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadDeletionLagRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOffloadPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadPolicies(ctx context.Context, tenant string, namespace string, body SetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOffloadThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOffloadThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadThresholdRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadThreshold(ctx context.Context, tenant string, namespace string, body SetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadThresholdRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissions(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionsRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionOnSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionOnSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsOnNamespace(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsOnNamespaceRequest(c.Server, tenant, namespace, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantPermissionOnNamespaceWithBody(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantPermissionOnNamespaceRequestWithBody(c.Server, tenant, namespace, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantPermissionOnNamespace(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantPermissionOnNamespaceRequest(c.Server, tenant, namespace, role, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistenceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistenceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistenceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistenceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistence(ctx context.Context, tenant string, namespace string, body SetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistenceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBookieAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBookieAffinityGroupRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBookieAffinityGroup(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBookieAffinityGroupRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearPropertiesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPropertiesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPropertiesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPropertiesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetProperties(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPropertiesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePropertyRequest(c.Server, tenant, namespace, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPropertyRequest(c.Server, tenant, namespace, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetProperty(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPropertyRequest(c.Server, tenant, namespace, key, value)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOffloadPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceReplicationClustersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceReplicationClustersRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceReplicationClustersRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveReplicatorDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicatorDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, body SetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicatorDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceResourceGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceResourceGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceResourceGroupRequest(c.Server, tenant, namespace, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRetentionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRetention(ctx context.Context, tenant string, namespace string, body RemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRetentionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRetention(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRetentionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRetentionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRetention(ctx context.Context, tenant string, namespace string, body SetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRetentionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScanOffloadedLedgers(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScanOffloadedLedgersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaAutoUpdateCompatibilityStrategyRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaAutoUpdateCompatibilityStrategyRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaValidtionEnforced(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaValidtionEnforcedRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, body SetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaValidationEnforcedRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscribeRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscribeRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscribeRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscribeRate(ctx context.Context, tenant string, namespace string, body SetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscribeRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionAuthModeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionAuthModeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionAuthModeRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, body SetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionAuthModeRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, body SetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionExpirationTimeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionExpirationTimeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionExpirationTimeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionExpirationTimeRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, body SetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionExpirationTimeRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionTypesEnabledRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, body SetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopics(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopicsRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsubscribeNamespace(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeNamespaceRequest(c.Server, tenant, namespace, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBundleBacklog(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBundleBacklogRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBundleBacklogForSubscription(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBundleBacklogForSubscriptionRequest(c.Server, tenant, namespace, bundle, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SplitNamespaceBundleWithBody(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSplitNamespaceBundleRequestWithBody(c.Server, tenant, namespace, bundle, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SplitNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSplitNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopicHashPositions(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopicHashPositionsRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsubscribeNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeNamespaceBundleRequest(c.Server, tenant, namespace, bundle, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetList(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartitionedTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListFromBundle(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListFromBundleRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNonPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireMessagesForAllSubscriptionsRequest(c.Server, tenant, namespace, topic, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBacklogRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBacklogQuotaMapRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBacklogSizeByMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompactionStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Compact(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompactRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCompactionThresholdRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMissedPartitionsRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDeduplicationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEntryFiltersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExamineMessageRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManagedLedgerInfoRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInternalStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageByIdRequest(c.Server, tenant, namespace, topic, ledgerId, entryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxMessageSizeRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxProducersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesOnConsumerRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesOnSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageIdByTimestampRequest(c.Server, tenant, namespace, topic, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOffloadStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerOffloadRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartitionedStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartitionedMetadataRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionsOnTopicRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsOnTopicRequest(c.Server, tenant, namespace, topic, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantPermissionsOnTopicRequestWithBody(c.Server, tenant, namespace, topic, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistenceRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePropertiesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPublishRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicationClustersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRetentionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaValidationEnforcedRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetShadowTopicsRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscribeRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnalyzeSubscriptionBacklogRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireTopicMessagesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireTopicMessagesRequest(c.Server, tenant, namespace, topic, subName, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPeekNthMessageRequest(c.Server, tenant, namespace, topic, subName, messagePosition, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionPropertiesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubscriptionPropertiesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicatedSubscriptionStatusRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicatedSubscriptionStatusRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetCursorOnPositionRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetCursorRequest(c.Server, tenant, namespace, topic, subName, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipMessagesRequest(c.Server, tenant, namespace, topic, subName, numMessages, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipAllMessagesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, subscriptionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Terminate(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminatePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTruncateTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionLevelDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetList(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartitionedTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNonPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireMessagesForAllSubscriptionsRequest(c.Server, tenant, namespace, topic, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBacklogRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBacklogQuotaMapRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBacklogSizeByMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompactionStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Compact(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompactRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCompactionThresholdRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMissedPartitionsRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDeduplicationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEntryFiltersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExamineMessageRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManagedLedgerInfoRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInternalStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLastMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageByIdRequest(c.Server, tenant, namespace, topic, ledgerId, entryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxMessageSizeRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxProducersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesOnConsumerRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMaxUnackedMessagesOnSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageIdByTimestampRequest(c.Server, tenant, namespace, topic, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOffloadStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerOffloadRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartitionedStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPartitionedMetadataRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionsOnTopicRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsOnTopicRequest(c.Server, tenant, namespace, topic, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantPermissionsOnTopicRequestWithBody(c.Server, tenant, namespace, topic, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistenceRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePropertiesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPublishRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicationClustersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRetentionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaValidationEnforcedRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetShadowTopicsRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscribeRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnalyzeSubscriptionBacklogRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireTopicMessagesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireTopicMessagesRequest(c.Server, tenant, namespace, topic, subName, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPeekNthMessageRequest(c.Server, tenant, namespace, topic, subName, messagePosition, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionPropertiesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubscriptionPropertiesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReplicatedSubscriptionStatusRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReplicatedSubscriptionStatusRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetCursorOnPositionRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetCursorRequest(c.Server, tenant, namespace, topic, subName, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipMessagesRequest(c.Server, tenant, namespace, topic, subName, numMessages, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipAllMessagesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, subscriptionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Terminate(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminatePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTruncateTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSubscriptionLevelDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultResourceQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultResourceQuotaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultResourceQuotaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultResourceQuotaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultResourceQuota(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultResourceQuotaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceBundleResourceQuotaWithBody(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceBundleResourceQuotaRequestWithBody(c.Server, tenant, namespace, bundle, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceGroupRequest(c.Server, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceGroupRequest(c.Server, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateResourceGroupWithBody(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateResourceGroupRequestWithBody(c.Server, resourcegroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateResourceGroup(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateResourceGroupRequest(c.Server, resourcegroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestCompatibilityWithBody(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestCompatibilityRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestCompatibility(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestCompatibilityRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSchema(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSchemaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchema(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchema(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemaRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchema(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaRequest(c.Server, tenant, namespace, topic, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSchemas(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSchemasRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionBySchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionBySchemaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionBySchema(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionBySchemaRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTenant(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTenantRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenantAdmin(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantAdminRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenant(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenant(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssignments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssignmentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterLeader(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterLeaderRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsLeaderReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsLeaderReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectorsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDrainStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDrainStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Drain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDrainRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDrainStatusFromLeader(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDrainStatusFromLeaderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DrainAtLeader(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDrainAtLeaderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Rebalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebalanceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllBookiesRequest generates requests for GetAllBookies
func NewGetAllBookiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBookiesRackInfoRequest generates requests for GetBookiesRackInfo
func NewGetBookiesRackInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBookieRackInfoRequest generates requests for DeleteBookieRackInfo
func NewDeleteBookieRackInfoRequest(server string, bookie string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBookieRackInfoRequest generates requests for GetBookieRackInfo
func NewGetBookieRackInfoRequest(server string, bookie string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBookieRackInfoRequest generates requests for UpdateBookieRackInfo
func NewUpdateBookieRackInfoRequest(server string, bookie string, params *UpdateBookieRackInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllocatorStatsRequest generates requests for GetAllocatorStats
func NewGetAllocatorStatsRequest(server string, allocator string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "allocator", runtime.ParamLocationPath, allocator)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/allocator-stats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingBookieOpsStatsRequest generates requests for GetPendingBookieOpsStats
func NewGetPendingBookieOpsStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/bookieops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrokerResourceAvailabilityRequest generates requests for GetBrokerResourceAvailability
func NewGetBrokerResourceAvailabilityRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/broker-resource-availability/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoadReportRequest generates requests for GetLoadReport
func NewGetLoadReportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/load-report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMBeansRequest generates requests for GetMBeans
func NewGetMBeansRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/mbeans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsRequest generates requests for GetMetrics
func NewGetMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopics2Request generates requests for GetTopics2
func NewGetTopics2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/topics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActiveBrokersRequest generates requests for GetActiveBrokers
func NewGetActiveBrokersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBacklogQuotaCheckRequest generates requests for BacklogQuotaCheck
func NewBacklogQuotaCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/backlog-quota-check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDynamicConfigurationNameRequest generates requests for GetDynamicConfigurationName
func NewGetDynamicConfigurationNameRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeConfigurationRequest generates requests for GetRuntimeConfiguration
func NewGetRuntimeConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/runtime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllDynamicConfigurationsRequest generates requests for GetAllDynamicConfigurations
func NewGetAllDynamicConfigurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/values")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDynamicConfigurationRequest generates requests for DeleteDynamicConfiguration
func NewDeleteDynamicConfigurationRequest(server string, configName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configName", runtime.ParamLocationPath, configName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDynamicConfigurationRequest generates requests for UpdateDynamicConfiguration
func NewUpdateDynamicConfigurationRequest(server string, configName string, configValue string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configName", runtime.ParamLocationPath, configName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "configValue", runtime.ParamLocationPath, configValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string, params *HealthCheckParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.TopicVersion != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topicVersion", runtime.ParamLocationQuery, *params.TopicVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInternalConfigurationDataRequest generates requests for GetInternalConfigurationData
func NewGetInternalConfigurationDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/internal-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaderBrokerRequest generates requests for GetLeaderBroker
func NewGetLeaderBrokerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/leaderBroker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsReadyRequest generates requests for IsReady
func NewIsReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShutDownBrokerGracefullyRequest generates requests for ShutDownBrokerGracefully
func NewShutDownBrokerGracefullyRequest(server string, params *ShutDownBrokerGracefullyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.MaxConcurrentUnloadPerSec != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxConcurrentUnloadPerSec", runtime.ParamLocationQuery, *params.MaxConcurrentUnloadPerSec); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ForcedTerminateTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forcedTerminateTopic", runtime.ParamLocationQuery, *params.ForcedTerminateTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVersionRequest generates requests for Version
func NewVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOwnedNamespacesRequest generates requests for GetOwnedNamespaces
func NewGetOwnedNamespacesRequest(server string, clusterName string, brokerWebserviceurl string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterName", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "broker-webserviceurl", runtime.ParamLocationPath, brokerWebserviceurl)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/%s/%s/ownedNamespaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActiveBrokersRequest generates requests for GetActiveBrokers
func NewGetActiveBrokersRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClustersRequest generates requests for GetClusters
func NewGetClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFailureDomainsRequest generates requests for GetFailureDomains
func NewGetFailureDomainsRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFailureDomainRequest generates requests for DeleteFailureDomain
func NewDeleteFailureDomainRequest(server string, cluster string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainRequest generates requests for GetDomain
func NewGetDomainRequest(server string, cluster string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetFailureDomainRequestWithBody generates requests for SetFailureDomain with any type of body
func NewSetFailureDomainRequestWithBody(server string, cluster string, domainName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceIsolationPoliciesRequest generates requests for GetNamespaceIsolationPolicies
func NewGetNamespaceIsolationPoliciesRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrokersWithNamespaceIsolationPolicyRequest generates requests for GetBrokersWithNamespaceIsolationPolicy
func NewGetBrokersWithNamespaceIsolationPolicyRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/brokers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrokerWithNamespaceIsolationPolicyRequest generates requests for GetBrokerWithNamespaceIsolationPolicy
func NewGetBrokerWithNamespaceIsolationPolicyRequest(server string, cluster string, broker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "broker", runtime.ParamLocationPath, broker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/brokers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNamespaceIsolationPolicyRequest generates requests for DeleteNamespaceIsolationPolicy
func NewDeleteNamespaceIsolationPolicyRequest(server string, cluster string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceIsolationPolicyRequest generates requests for GetNamespaceIsolationPolicy
func NewGetNamespaceIsolationPolicyRequest(server string, cluster string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceIsolationPolicyRequestWithBody generates requests for SetNamespaceIsolationPolicy with any type of body
func NewSetNamespaceIsolationPolicyRequestWithBody(server string, cluster string, policyName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerClusterRequest generates requests for GetPeerCluster
func NewGetPeerClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/peers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPeerClusterNamesRequestWithBody generates requests for SetPeerClusterNames with any type of body
func NewSetPeerClusterNamesRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/peers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAntiAffinityNamespacesRequest generates requests for GetAntiAffinityNamespaces
func NewGetAntiAffinityNamespacesRequest(server string, cluster string, group string, params *GetAntiAffinityNamespacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/antiAffinity/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Tenant != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBookieAffinityGroupRequest generates requests for DeleteBookieAffinityGroup
func NewDeleteBookieAffinityGroupRequest(server string, property string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property", runtime.ParamLocationPath, property)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBookieAffinityGroupRequest generates requests for GetBookieAffinityGroup
func NewGetBookieAffinityGroupRequest(server string, property string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property", runtime.ParamLocationPath, property)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantNamespacesRequest generates requests for GetTenantNamespaces
func NewGetTenantNamespacesRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNamespaceRequest generates requests for DeleteNamespace
func NewDeleteNamespaceRequest(server string, tenant string, namespace string, params *DeleteNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPoliciesRequest generates requests for GetPolicies
func NewGetPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNamespaceRequest calls the generic CreateNamespace builder with application/json body
func NewCreateNamespaceRequest(server string, tenant string, namespace string, body CreateNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNamespaceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewCreateNamespaceRequestWithBody generates requests for CreateNamespace with any type of body
func NewCreateNamespaceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceAntiAffinityGroupRequest generates requests for RemoveNamespaceAntiAffinityGroup
func NewRemoveNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceAntiAffinityGroupRequest generates requests for GetNamespaceAntiAffinityGroup
func NewGetNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceAntiAffinityGroupRequest calls the generic SetNamespaceAntiAffinityGroup builder with application/json body
func NewSetNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceAntiAffinityGroupRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceAntiAffinityGroupRequestWithBody generates requests for SetNamespaceAntiAffinityGroup with any type of body
func NewSetNamespaceAntiAffinityGroupRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveAutoSubscriptionCreationRequest generates requests for RemoveAutoSubscriptionCreation
func NewRemoveAutoSubscriptionCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoSubscriptionCreationRequest generates requests for GetAutoSubscriptionCreation
func NewGetAutoSubscriptionCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAutoSubscriptionCreationRequest calls the generic SetAutoSubscriptionCreation builder with application/json body
func NewSetAutoSubscriptionCreationRequest(server string, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAutoSubscriptionCreationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetAutoSubscriptionCreationRequestWithBody generates requests for SetAutoSubscriptionCreation with any type of body
func NewSetAutoSubscriptionCreationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveAutoTopicCreationRequest generates requests for RemoveAutoTopicCreation
func NewRemoveAutoTopicCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoTopicCreationRequest generates requests for GetAutoTopicCreation
func NewGetAutoTopicCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAutoTopicCreationRequest calls the generic SetAutoTopicCreation builder with application/json body
func NewSetAutoTopicCreationRequest(server string, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAutoTopicCreationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetAutoTopicCreationRequestWithBody generates requests for SetAutoTopicCreation with any type of body
func NewSetAutoTopicCreationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveBacklogQuotaRequest generates requests for RemoveBacklogQuota
func NewRemoveBacklogQuotaRequest(server string, tenant string, namespace string, params *RemoveBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuota", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBacklogQuotaRequest calls the generic SetBacklogQuota builder with application/json body
func NewSetBacklogQuotaRequest(server string, tenant string, namespace string, params *SetBacklogQuotaParams, body SetBacklogQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBacklogQuotaRequestWithBody(server, tenant, namespace, params, "application/json", bodyReader)
}

// NewSetBacklogQuotaRequestWithBody generates requests for SetBacklogQuota with any type of body
func NewSetBacklogQuotaRequestWithBody(server string, tenant string, namespace string, params *SetBacklogQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuota", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBacklogQuotaMapRequest generates requests for GetBacklogQuotaMap
func NewGetBacklogQuotaMapRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuotaMap", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBundlesDataRequest generates requests for GetBundlesData
func NewGetBundlesDataRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/bundles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBacklogRequest generates requests for ClearNamespaceBacklog
func NewClearNamespaceBacklogRequest(server string, tenant string, namespace string, params *ClearNamespaceBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/clearBacklog", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBacklogForSubscriptionRequest generates requests for ClearNamespaceBacklogForSubscription
func NewClearNamespaceBacklogForSubscriptionRequest(server string, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/clearBacklog/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCompactionThresholdRequest generates requests for DeleteCompactionThreshold
func NewDeleteCompactionThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompactionThresholdRequest generates requests for GetCompactionThreshold
func NewGetCompactionThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCompactionThresholdRequest calls the generic SetCompactionThreshold builder with application/json body
func NewSetCompactionThresholdRequest(server string, tenant string, namespace string, body SetCompactionThresholdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCompactionThresholdRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetCompactionThresholdRequestWithBody generates requests for SetCompactionThreshold with any type of body
func NewSetCompactionThresholdRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveDeduplicationRequest generates requests for RemoveDeduplication
func NewRemoveDeduplicationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeduplicationRequest generates requests for GetDeduplication
func NewGetDeduplicationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyDeduplicationRequest calls the generic ModifyDeduplication builder with application/json body
func NewModifyDeduplicationRequest(server string, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyDeduplicationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewModifyDeduplicationRequestWithBody generates requests for ModifyDeduplication with any type of body
func NewModifyDeduplicationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeduplicationSnapshotIntervalRequest generates requests for GetDeduplicationSnapshotInterval
func NewGetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDeduplicationSnapshotIntervalRequest calls the generic SetDeduplicationSnapshotInterval builder with application/json body
func NewSetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, body SetDeduplicationSnapshotIntervalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDeduplicationSnapshotIntervalRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetDeduplicationSnapshotIntervalRequestWithBody generates requests for SetDeduplicationSnapshotInterval with any type of body
func NewSetDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveDelayedDeliveryPoliciesRequest generates requests for RemoveDelayedDeliveryPolicies
func NewRemoveDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDelayedDeliveryPoliciesRequest generates requests for GetDelayedDeliveryPolicies
func NewGetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDelayedDeliveryPoliciesRequest calls the generic SetDelayedDeliveryPolicies builder with application/json body
func NewSetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, body SetDelayedDeliveryPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDelayedDeliveryPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetDelayedDeliveryPoliciesRequestWithBody generates requests for SetDelayedDeliveryPolicies with any type of body
func NewSetDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDispatchRateRequest generates requests for DeleteDispatchRate
func NewDeleteDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDispatchRateRequest generates requests for GetDispatchRate
func NewGetDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDispatchRateRequest calls the generic SetDispatchRate builder with application/json body
func NewSetDispatchRateRequest(server string, tenant string, namespace string, body SetDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetDispatchRateRequestWithBody generates requests for SetDispatchRate with any type of body
func NewSetDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEncryptionRequiredRequest generates requests for GetEncryptionRequired
func NewGetEncryptionRequiredRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/encryptionRequired", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyEncryptionRequiredRequest calls the generic ModifyEncryptionRequired builder with application/json body
func NewModifyEncryptionRequiredRequest(server string, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyEncryptionRequiredRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewModifyEncryptionRequiredRequestWithBody generates requests for ModifyEncryptionRequired with any type of body
func NewModifyEncryptionRequiredRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/encryptionRequired", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceEntryFiltersRequest generates requests for RemoveNamespaceEntryFilters
func NewRemoveNamespaceEntryFiltersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryFiltersPerTopicRequest generates requests for GetEntryFiltersPerTopic
func NewGetEntryFiltersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetEntryFiltersPerTopicRequest calls the generic SetEntryFiltersPerTopic builder with application/json body
func NewSetEntryFiltersPerTopicRequest(server string, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetEntryFiltersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetEntryFiltersPerTopicRequestWithBody generates requests for SetEntryFiltersPerTopic with any type of body
func NewSetEntryFiltersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveInactiveTopicPoliciesRequest generates requests for RemoveInactiveTopicPolicies
func NewRemoveInactiveTopicPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInactiveTopicPoliciesRequest generates requests for GetInactiveTopicPolicies
func NewGetInactiveTopicPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetInactiveTopicPoliciesRequest calls the generic SetInactiveTopicPolicies builder with application/json body
func NewSetInactiveTopicPoliciesRequest(server string, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetInactiveTopicPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetInactiveTopicPoliciesRequestWithBody generates requests for SetInactiveTopicPolicies with any type of body
func NewSetInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIsAllowAutoUpdateSchemaRequest generates requests for GetIsAllowAutoUpdateSchema
func NewGetIsAllowAutoUpdateSchemaRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/isAllowAutoUpdateSchema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIsAllowAutoUpdateSchemaRequest calls the generic SetIsAllowAutoUpdateSchema builder with application/json body
func NewSetIsAllowAutoUpdateSchemaRequest(server string, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIsAllowAutoUpdateSchemaRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetIsAllowAutoUpdateSchemaRequestWithBody generates requests for SetIsAllowAutoUpdateSchema with any type of body
func NewSetIsAllowAutoUpdateSchemaRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/isAllowAutoUpdateSchema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxConsumersPerSubscriptionRequest generates requests for RemoveMaxConsumersPerSubscription
func NewRemoveMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxConsumersPerSubscriptionRequest generates requests for GetMaxConsumersPerSubscription
func NewGetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxConsumersPerSubscriptionRequest calls the generic SetMaxConsumersPerSubscription builder with application/json body
func NewSetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, body SetMaxConsumersPerSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMaxConsumersPerSubscriptionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetMaxConsumersPerSubscriptionRequestWithBody generates requests for SetMaxConsumersPerSubscription with any type of body
func NewSetMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxConsumersPerTopicRequest generates requests for RemoveMaxConsumersPerTopic
func NewRemoveMaxConsumersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxConsumersPerTopicRequest generates requests for GetMaxConsumersPerTopic
func NewGetMaxConsumersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxConsumersPerTopicRequest calls the generic SetMaxConsumersPerTopic builder with application/json body
func NewSetMaxConsumersPerTopicRequest(server string, tenant string, namespace string, body SetMaxConsumersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMaxConsumersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetMaxConsumersPerTopicRequestWithBody generates requests for SetMaxConsumersPerTopic with any type of body
func NewSetMaxConsumersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxProducersPerTopicRequest generates requests for RemoveMaxProducersPerTopic
func NewRemoveMaxProducersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxProducersPerTopicRequest generates requests for GetMaxProducersPerTopic
func NewGetMaxProducersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxProducersPerTopicRequest calls the generic SetMaxProducersPerTopic builder with application/json body
func NewSetMaxProducersPerTopicRequest(server string, tenant string, namespace string, body SetMaxProducersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMaxProducersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetMaxProducersPerTopicRequestWithBody generates requests for SetMaxProducersPerTopic with any type of body
func NewSetMaxProducersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxSubscriptionsPerTopicRequest generates requests for RemoveMaxSubscriptionsPerTopic
func NewRemoveMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxSubscriptionsPerTopicRequest generates requests for GetMaxSubscriptionsPerTopic
func NewGetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxSubscriptionsPerTopicRequest calls the generic SetMaxSubscriptionsPerTopic builder with application/json body
func NewSetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, body SetMaxSubscriptionsPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMaxSubscriptionsPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetMaxSubscriptionsPerTopicRequestWithBody generates requests for SetMaxSubscriptionsPerTopic with any type of body
func NewSetMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetInactiveTopicPoliciesRequest generates requests for SetInactiveTopicPolicies
func NewSetInactiveTopicPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxTopicsPerNamespaceRequest generates requests for GetMaxTopicsPerNamespace
func NewGetMaxTopicsPerNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetInactiveTopicPoliciesRequest calls the generic SetInactiveTopicPolicies builder with application/json body
func NewSetInactiveTopicPoliciesRequest(server string, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetInactiveTopicPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetInactiveTopicPoliciesRequestWithBody generates requests for SetInactiveTopicPolicies with any type of body
func NewSetInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxUnackedmessagesPerConsumerRequest generates requests for RemoveMaxUnackedmessagesPerConsumer
func NewRemoveMaxUnackedmessagesPerConsumerRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxUnackedMessagesPerConsumerRequest generates requests for GetMaxUnackedMessagesPerConsumer
func NewGetMaxUnackedMessagesPerConsumerRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxUnackedMessagesPerConsumerRequest calls the generic SetMaxUnackedMessagesPerConsumer builder with application/json body
func NewSetMaxUnackedMessagesPerConsumerRequest(server string, tenant string, namespace string, body SetMaxUnackedMessagesPerConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMaxUnackedMessagesPerConsumerRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetMaxUnackedMessagesPerConsumerRequestWithBody generates requests for SetMaxUnackedMessagesPerConsumer with any type of body
func NewSetMaxUnackedMessagesPerConsumerRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxUnackedmessagesPerSubscriptionRequest generates requests for RemoveMaxUnackedmessagesPerSubscription
func NewRemoveMaxUnackedmessagesPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxUnackedmessagesPerSubscriptionRequest generates requests for GetMaxUnackedmessagesPerSubscription
func NewGetMaxUnackedmessagesPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxUnackedMessagesPerSubscriptionRequest calls the generic SetMaxUnackedMessagesPerSubscription builder with application/json body
func NewSetMaxUnackedMessagesPerSubscriptionRequest(server string, tenant string, namespace string, body SetMaxUnackedMessagesPerSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMaxUnackedMessagesPerSubscriptionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetMaxUnackedMessagesPerSubscriptionRequestWithBody generates requests for SetMaxUnackedMessagesPerSubscription with any type of body
func NewSetMaxUnackedMessagesPerSubscriptionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMessageTTLRequest generates requests for RemoveNamespaceMessageTTL
func NewRemoveNamespaceMessageTTLRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMessageTTLRequest generates requests for GetNamespaceMessageTTL
func NewGetNamespaceMessageTTLRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMessageTTLRequest calls the generic SetNamespaceMessageTTL builder with application/json body
func NewSetNamespaceMessageTTLRequest(server string, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMessageTTLRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMessageTTLRequestWithBody generates requests for SetNamespaceMessageTTL with any type of body
func NewSetNamespaceMessageTTLRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearOffloadDeletionLagRequest generates requests for ClearOffloadDeletionLag
func NewClearOffloadDeletionLagRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOffloadDeletionLagRequest generates requests for GetOffloadDeletionLag
func NewGetOffloadDeletionLagRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOffloadDeletionLagRequest calls the generic SetOffloadDeletionLag builder with application/json body
func NewSetOffloadDeletionLagRequest(server string, tenant string, namespace string, body SetOffloadDeletionLagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetOffloadDeletionLagRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetOffloadDeletionLagRequestWithBody generates requests for SetOffloadDeletionLag with any type of body
func NewSetOffloadDeletionLagRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOffloadPoliciesRequest generates requests for GetOffloadPolicies
func NewGetOffloadPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOffloadPoliciesRequest calls the generic SetOffloadPolicies builder with application/json body
func NewSetOffloadPoliciesRequest(server string, tenant string, namespace string, body SetOffloadPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetOffloadPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetOffloadPoliciesRequestWithBody generates requests for SetOffloadPolicies with any type of body
func NewSetOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOffloadThresholdRequest generates requests for GetOffloadThreshold
func NewGetOffloadThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOffloadThresholdRequest calls the generic SetOffloadThreshold builder with application/json body
func NewSetOffloadThresholdRequest(server string, tenant string, namespace string, body SetOffloadThresholdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetOffloadThresholdRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetOffloadThresholdRequestWithBody generates requests for SetOffloadThreshold with any type of body
func NewSetOffloadThresholdRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPermissionsRequest generates requests for GetPermissions
func NewGetPermissionsRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionOnSubscriptionRequest generates requests for GetPermissionOnSubscription
func NewGetPermissionOnSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/subscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsOnNamespaceRequest generates requests for RevokePermissionsOnNamespace
func NewRevokePermissionsOnNamespaceRequest(server string, tenant string, namespace string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGrantPermissionOnNamespaceRequest calls the generic GrantPermissionOnNamespace builder with application/json body
func NewGrantPermissionOnNamespaceRequest(server string, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGrantPermissionOnNamespaceRequestWithBody(server, tenant, namespace, role, "application/json", bodyReader)
}

// NewGrantPermissionOnNamespaceRequestWithBody generates requests for GrantPermissionOnNamespace with any type of body
func NewGrantPermissionOnNamespaceRequestWithBody(server string, tenant string, namespace string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistenceRequest generates requests for DeletePersistence
func NewDeletePersistenceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistenceRequest generates requests for GetPersistence
func NewGetPersistenceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistenceRequest calls the generic SetPersistence builder with application/json body
func NewSetPersistenceRequest(server string, tenant string, namespace string, body SetPersistenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPersistenceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetPersistenceRequestWithBody generates requests for SetPersistence with any type of body
func NewSetPersistenceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetBookieAffinityGroupRequest calls the generic SetBookieAffinityGroup builder with application/json body
func NewSetBookieAffinityGroupRequest(server string, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBookieAffinityGroupRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetBookieAffinityGroupRequestWithBody generates requests for SetBookieAffinityGroup with any type of body
func NewSetBookieAffinityGroupRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearPropertiesRequest generates requests for ClearProperties
func NewClearPropertiesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPropertiesRequest generates requests for GetProperties
func NewGetPropertiesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPropertiesRequest calls the generic SetProperties builder with application/json body
func NewSetPropertiesRequest(server string, tenant string, namespace string, body SetPropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPropertiesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetPropertiesRequestWithBody generates requests for SetProperties with any type of body
func NewSetPropertiesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePropertyRequest generates requests for RemoveProperty
func NewRemovePropertyRequest(server string, tenant string, namespace string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPropertyRequest generates requests for GetProperty
func NewGetPropertyRequest(server string, tenant string, namespace string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPropertyRequest generates requests for SetProperty
func NewSetPropertyRequest(server string, tenant string, namespace string, key string, value string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "value", runtime.ParamLocationPath, value)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveOffloadPoliciesRequest generates requests for RemoveOffloadPolicies
func NewRemoveOffloadPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/removeOffloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceReplicationClustersRequest generates requests for GetNamespaceReplicationClusters
func NewGetNamespaceReplicationClustersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceReplicationClustersRequest calls the generic SetNamespaceReplicationClusters builder with application/json body
func NewSetNamespaceReplicationClustersRequest(server string, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceReplicationClustersRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceReplicationClustersRequestWithBody generates requests for SetNamespaceReplicationClusters with any type of body
func NewSetNamespaceReplicationClustersRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveReplicatorDispatchRateRequest generates requests for RemoveReplicatorDispatchRate
func NewRemoveReplicatorDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReplicatorDispatchRateRequest generates requests for GetReplicatorDispatchRate
func NewGetReplicatorDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReplicatorDispatchRateRequest calls the generic SetReplicatorDispatchRate builder with application/json body
func NewSetReplicatorDispatchRateRequest(server string, tenant string, namespace string, body SetReplicatorDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetReplicatorDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetReplicatorDispatchRateRequestWithBody generates requests for SetReplicatorDispatchRate with any type of body
func NewSetReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceResourceGroupRequest generates requests for RemoveNamespaceResourceGroup
func NewRemoveNamespaceResourceGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceResourceGroupRequest generates requests for GetNamespaceResourceGroup
func NewGetNamespaceResourceGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceResourceGroupRequest generates requests for SetNamespaceResourceGroup
func NewSetNamespaceResourceGroupRequest(server string, tenant string, namespace string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveRetentionRequest calls the generic RemoveRetention builder with application/json body
func NewRemoveRetentionRequest(server string, tenant string, namespace string, body RemoveRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveRetentionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewRemoveRetentionRequestWithBody generates requests for RemoveRetention with any type of body
func NewRemoveRetentionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRetentionRequest generates requests for GetRetention
func NewGetRetentionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRetentionRequest calls the generic SetRetention builder with application/json body
func NewSetRetentionRequest(server string, tenant string, namespace string, body SetRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRetentionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetRetentionRequestWithBody generates requests for SetRetention with any type of body
func NewSetRetentionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScanOffloadedLedgersRequest generates requests for ScanOffloadedLedgers
func NewScanOffloadedLedgersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/scanOffloadedLedgers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemaAutoUpdateCompatibilityStrategyRequest generates requests for GetSchemaAutoUpdateCompatibilityStrategy
func NewGetSchemaAutoUpdateCompatibilityStrategyRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaAutoUpdateCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaAutoUpdateCompatibilityStrategyRequest calls the generic SetSchemaAutoUpdateCompatibilityStrategy builder with application/json body
func NewSetSchemaAutoUpdateCompatibilityStrategyRequest(server string, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody generates requests for SetSchemaAutoUpdateCompatibilityStrategy with any type of body
func NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaAutoUpdateCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaCompatibilityStrategyRequest generates requests for GetSchemaCompatibilityStrategy
func NewGetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaCompatibilityStrategyRequest calls the generic SetSchemaCompatibilityStrategy builder with application/json body
func NewSetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, body SetSchemaCompatibilityStrategyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSchemaCompatibilityStrategyRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSchemaCompatibilityStrategyRequestWithBody generates requests for SetSchemaCompatibilityStrategy with any type of body
func NewSetSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaValidtionEnforcedRequest generates requests for GetSchemaValidtionEnforced
func NewGetSchemaValidtionEnforcedRequest(server string, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaValidationEnforced", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaValidationEnforcedRequest calls the generic SetSchemaValidationEnforced builder with application/json body
func NewSetSchemaValidationEnforcedRequest(server string, tenant string, namespace string, body SetSchemaValidationEnforcedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSchemaValidationEnforcedRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSchemaValidationEnforcedRequestWithBody generates requests for SetSchemaValidationEnforced with any type of body
func NewSetSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaValidationEnforced", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscribeRateRequest generates requests for DeleteSubscribeRate
func NewDeleteSubscribeRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscribeRateRequest generates requests for GetSubscribeRate
func NewGetSubscribeRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscribeRateRequest calls the generic SetSubscribeRate builder with application/json body
func NewSetSubscribeRateRequest(server string, tenant string, namespace string, body SetSubscribeRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSubscribeRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSubscribeRateRequestWithBody generates requests for SetSubscribeRate with any type of body
func NewSetSubscribeRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionAuthModeRequest generates requests for GetSubscriptionAuthMode
func NewGetSubscriptionAuthModeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionAuthMode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionAuthModeRequest calls the generic SetSubscriptionAuthMode builder with application/json body
func NewSetSubscriptionAuthModeRequest(server string, tenant string, namespace string, body SetSubscriptionAuthModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSubscriptionAuthModeRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSubscriptionAuthModeRequestWithBody generates requests for SetSubscriptionAuthMode with any type of body
func NewSetSubscriptionAuthModeRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionAuthMode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionDispatchRateRequest generates requests for DeleteSubscriptionDispatchRate
func NewDeleteSubscriptionDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionDispatchRateRequest generates requests for GetSubscriptionDispatchRate
func NewGetSubscriptionDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionDispatchRateRequest calls the generic SetSubscriptionDispatchRate builder with application/json body
func NewSetSubscriptionDispatchRateRequest(server string, tenant string, namespace string, body SetSubscriptionDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSubscriptionDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSubscriptionDispatchRateRequestWithBody generates requests for SetSubscriptionDispatchRate with any type of body
func NewSetSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubscriptionExpirationTimeRequest generates requests for RemoveSubscriptionExpirationTime
func NewRemoveSubscriptionExpirationTimeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionExpirationTimeRequest generates requests for GetSubscriptionExpirationTime
func NewGetSubscriptionExpirationTimeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionExpirationTimeRequest calls the generic SetSubscriptionExpirationTime builder with application/json body
func NewSetSubscriptionExpirationTimeRequest(server string, tenant string, namespace string, body SetSubscriptionExpirationTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSubscriptionExpirationTimeRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSubscriptionExpirationTimeRequestWithBody generates requests for SetSubscriptionExpirationTime with any type of body
func NewSetSubscriptionExpirationTimeRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubscriptionTypesEnabledRequest generates requests for RemoveSubscriptionTypesEnabled
func NewRemoveSubscriptionTypesEnabledRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionTypesEnabledRequest generates requests for GetSubscriptionTypesEnabled
func NewGetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionTypesEnabledRequest calls the generic SetSubscriptionTypesEnabled builder with application/json body
func NewSetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, body SetSubscriptionTypesEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSubscriptionTypesEnabledRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSubscriptionTypesEnabledRequestWithBody generates requests for SetSubscriptionTypesEnabled with any type of body
func NewSetSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTopicsRequest generates requests for GetTopics
func NewGetTopicsRequest(server string, tenant string, namespace string, params *GetTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/topics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Mode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadNamespaceRequest generates requests for UnloadNamespace
func NewUnloadNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/unload", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnsubscribeNamespaceRequest generates requests for UnsubscribeNamespace
func NewUnsubscribeNamespaceRequest(server string, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/unsubscribe/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNamespaceBundleRequest generates requests for DeleteNamespaceBundle
func NewDeleteNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBundleBacklogRequest generates requests for ClearNamespaceBundleBacklog
func NewClearNamespaceBundleBacklogRequest(server string, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/clearBacklog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBundleBacklogForSubscriptionRequest generates requests for ClearNamespaceBundleBacklogForSubscription
func NewClearNamespaceBundleBacklogForSubscriptionRequest(server string, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/clearBacklog/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSplitNamespaceBundleRequest calls the generic SplitNamespaceBundle builder with application/json body
func NewSplitNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSplitNamespaceBundleRequestWithBody(server, tenant, namespace, bundle, params, "application/json", bodyReader)
}

// NewSplitNamespaceBundleRequestWithBody generates requests for SplitNamespaceBundle with any type of body
func NewSplitNamespaceBundleRequestWithBody(server string, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/split", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Unload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unload", runtime.ParamLocationQuery, *params.Unload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SplitAlgorithmName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splitAlgorithmName", runtime.ParamLocationQuery, *params.SplitAlgorithmName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTopicHashPositionsRequest generates requests for GetTopicHashPositions
func NewGetTopicHashPositionsRequest(server string, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/topicHashPositions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Topics != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topics", runtime.ParamLocationQuery, *params.Topics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadNamespaceBundleRequest generates requests for UnloadNamespaceBundle
func NewUnloadNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnsubscribeNamespaceBundleRequest generates requests for UnsubscribeNamespaceBundle
func NewUnsubscribeNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/unsubscribe/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListRequest generates requests for GetList
func NewGetListRequest(server string, tenant string, namespace string, params *GetListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Bundle != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundle", runtime.ParamLocationQuery, *params.Bundle); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPartitionedTopicListRequest generates requests for GetPartitionedTopicList
func NewGetPartitionedTopicListRequest(server string, tenant string, namespace string, params *GetPartitionedTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/partitioned", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListFromBundleRequest generates requests for GetListFromBundle
func NewGetListFromBundleRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTopicRequest generates requests for DeleteTopic
func NewDeleteTopicRequest(server string, tenant string, namespace string, topic string, params *DeleteTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNonPartitionedTopicRequestWithBody generates requests for CreateNonPartitionedTopic with any type of body
func NewCreateNonPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireMessagesForAllSubscriptionsRequest generates requests for ExpireMessagesForAllSubscriptions
func NewExpireMessagesForAllSubscriptionsRequest(server string, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/all_subscription/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBacklogRequest generates requests for GetBacklog
func NewGetBacklogRequest(server string, tenant string, namespace string, topic string, params *GetBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveBacklogQuotaRequest generates requests for RemoveBacklogQuota
func NewRemoveBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBacklogQuotaRequest generates requests for SetBacklogQuota
func NewSetBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *SetBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBacklogQuotaMapRequest generates requests for GetBacklogQuotaMap
func NewGetBacklogQuotaMapRequest(server string, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuotaMap", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBacklogSizeByMessageIdRequest generates requests for GetBacklogSizeByMessageId
func NewGetBacklogSizeByMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompactionStatusRequest generates requests for CompactionStatus
func NewCompactionStatusRequest(server string, tenant string, namespace string, topic string, params *CompactionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompactRequest generates requests for Compact
func NewCompactRequest(server string, tenant string, namespace string, topic string, params *CompactParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveCompactionThresholdRequest generates requests for RemoveCompactionThreshold
func NewRemoveCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompactionThresholdRequest generates requests for GetCompactionThreshold
func NewGetCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *GetCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCompactionThresholdRequestWithBody generates requests for SetCompactionThreshold with any type of body
func NewSetCompactionThresholdRequestWithBody(server string, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateMissedPartitionsRequest generates requests for CreateMissedPartitions
func NewCreateMissedPartitionsRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/createMissedPartitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveDeduplicationRequest generates requests for RemoveDeduplication
func NewRemoveDeduplicationRequest(server string, tenant string, namespace string, topic string, params *RemoveDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeduplicationRequest generates requests for GetDeduplication
func NewGetDeduplicationRequest(server string, tenant string, namespace string, topic string, params *GetDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDeduplicationRequestWithBody generates requests for SetDeduplication with any type of body
func NewSetDeduplicationRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeduplicationSnapshotIntervalRequest generates requests for DeleteDeduplicationSnapshotInterval
func NewDeleteDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeduplicationSnapshotIntervalRequest generates requests for GetDeduplicationSnapshotInterval
func NewGetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDeduplicationSnapshotIntervalRequestWithBody generates requests for SetDeduplicationSnapshotInterval with any type of body
func NewSetDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDelayedDeliveryPoliciesRequest generates requests for DeleteDelayedDeliveryPolicies
func NewDeleteDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDelayedDeliveryPoliciesRequest generates requests for GetDelayedDeliveryPolicies
func NewGetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDelayedDeliveryPoliciesRequestWithBody generates requests for SetDelayedDeliveryPolicies with any type of body
func NewSetDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveDispatchRateRequest generates requests for RemoveDispatchRate
func NewRemoveDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDispatchRateRequest generates requests for GetDispatchRate
func NewGetDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDispatchRateRequestWithBody generates requests for SetDispatchRate with any type of body
func NewSetDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveEntryFiltersRequest generates requests for RemoveEntryFilters
func NewRemoveEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryFiltersRequest generates requests for GetEntryFilters
func NewGetEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *GetEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetEntryFiltersRequestWithBody generates requests for SetEntryFilters with any type of body
func NewSetEntryFiltersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExamineMessageRequest generates requests for ExamineMessage
func NewExamineMessageRequest(server string, tenant string, namespace string, topic string, params *ExamineMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/examinemessage", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InitialPosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "initialPosition", runtime.ParamLocationQuery, *params.InitialPosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MessagePosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messagePosition", runtime.ParamLocationQuery, *params.MessagePosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInactiveTopicPoliciesRequest generates requests for DeleteInactiveTopicPolicies
func NewDeleteInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInactiveTopicPoliciesRequest generates requests for GetInactiveTopicPolicies
func NewGetInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetInactiveTopicPoliciesRequestWithBody generates requests for SetInactiveTopicPolicies with any type of body
func NewSetInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetManagedLedgerInfoRequest generates requests for GetManagedLedgerInfo
func NewGetManagedLedgerInfoRequest(server string, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/internal-info", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInternalStatsRequest generates requests for GetInternalStats
func NewGetInternalStatsRequest(server string, tenant string, namespace string, topic string, params *GetInternalStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLastMessageIdRequest generates requests for GetLastMessageId
func NewGetLastMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetLastMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/lastMessageId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessageByIdRequest generates requests for GetMessageById
func NewGetMessageByIdRequest(server string, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "ledgerId", runtime.ParamLocationPath, ledgerId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "entryId", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/ledger/%s/entry/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveMaxConsumersRequest generates requests for RemoveMaxConsumers
func NewRemoveMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxConsumersRequest generates requests for GetMaxConsumers
func NewGetMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *GetMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxConsumersRequestWithBody generates requests for SetMaxConsumers with any type of body
func NewSetMaxConsumersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxConsumersPerSubscriptionRequest generates requests for RemoveMaxConsumersPerSubscription
func NewRemoveMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxConsumersPerSubscriptionRequest generates requests for GetMaxConsumersPerSubscription
func NewGetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxConsumersPerSubscriptionRequestWithBody generates requests for SetMaxConsumersPerSubscription with any type of body
func NewSetMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxMessageSizeRequest generates requests for RemoveMaxMessageSize
func NewRemoveMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxMessageSizeRequest generates requests for GetMaxMessageSize
func NewGetMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxMessageSizeRequestWithBody generates requests for SetMaxMessageSize with any type of body
func NewSetMaxMessageSizeRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxProducersRequest generates requests for RemoveMaxProducers
func NewRemoveMaxProducersRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxProducersRequest generates requests for GetMaxProducers
func NewGetMaxProducersRequest(server string, tenant string, namespace string, topic string, params *GetMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxProducersRequestWithBody generates requests for SetMaxProducers with any type of body
func NewSetMaxProducersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxSubscriptionsPerTopicRequest generates requests for RemoveMaxSubscriptionsPerTopic
func NewRemoveMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxSubscriptionsPerTopicRequest generates requests for GetMaxSubscriptionsPerTopic
func NewGetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxSubscriptionsPerTopicRequestWithBody generates requests for SetMaxSubscriptionsPerTopic with any type of body
func NewSetMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMaxUnackedMessagesOnConsumerRequest generates requests for DeleteMaxUnackedMessagesOnConsumer
func NewDeleteMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxUnackedMessagesOnConsumerRequest generates requests for GetMaxUnackedMessagesOnConsumer
func NewGetMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxUnackedMessagesOnConsumerRequestWithBody generates requests for SetMaxUnackedMessagesOnConsumer with any type of body
func NewSetMaxUnackedMessagesOnConsumerRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMaxUnackedMessagesOnSubscriptionRequest generates requests for DeleteMaxUnackedMessagesOnSubscription
func NewDeleteMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxUnackedMessagesOnSubscriptionRequest generates requests for GetMaxUnackedMessagesOnSubscription
func NewGetMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxUnackedMessagesOnSubscriptionRequestWithBody generates requests for SetMaxUnackedMessagesOnSubscription with any type of body
func NewSetMaxUnackedMessagesOnSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMessageTTLRequest generates requests for RemoveMessageTTL
func NewRemoveMessageTTLRequest(server string, tenant string, namespace string, topic string, params *RemoveMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessageTTLRequest generates requests for GetMessageTTL
func NewGetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *GetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMessageTTLRequest generates requests for SetMessageTTL
func NewSetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *SetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageTTL", runtime.ParamLocationQuery, params.MessageTTL); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessageIdByTimestampRequest generates requests for GetMessageIdByTimestamp
func NewGetMessageIdByTimestampRequest(server string, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageid/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOffloadStatusRequest generates requests for OffloadStatus
func NewOffloadStatusRequest(server string, tenant string, namespace string, topic string, params *OffloadStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerOffloadRequest generates requests for TriggerOffload
func NewTriggerOffloadRequest(server string, tenant string, namespace string, topic string, params *TriggerOffloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveOffloadPoliciesRequest generates requests for RemoveOffloadPolicies
func NewRemoveOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOffloadPoliciesRequest generates requests for GetOffloadPolicies
func NewGetOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOffloadPoliciesRequestWithBody generates requests for SetOffloadPolicies with any type of body
func NewSetOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPartitionedStatsRequest generates requests for GetPartitionedStats
func NewGetPartitionedStatsRequest(server string, tenant string, namespace string, topic string, params *GetPartitionedStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitioned-stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPartition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPartition", runtime.ParamLocationQuery, *params.PerPartition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePartitionedTopicRequest generates requests for DeletePartitionedTopic
func NewDeletePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPartitionedMetadataRequest generates requests for GetPartitionedMetadata
func NewGetPartitionedMetadataRequest(server string, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CheckAllowAutoCreation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkAllowAutoCreation", runtime.ParamLocationQuery, *params.CheckAllowAutoCreation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePartitionedTopicRequestWithBody generates requests for UpdatePartitionedTopic with any type of body
func NewUpdatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateLocalTopicOnly", runtime.ParamLocationQuery, *params.UpdateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePartitionedTopicRequestWithBody generates requests for CreatePartitionedTopic with any type of body
func NewCreatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createLocalTopicOnly", runtime.ParamLocationQuery, *params.CreateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPermissionsOnTopicRequest generates requests for GetPermissionsOnTopic
func NewGetPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsOnTopicRequest generates requests for RevokePermissionsOnTopic
func NewRevokePermissionsOnTopicRequest(server string, tenant string, namespace string, topic string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGrantPermissionsOnTopicRequestWithBody generates requests for GrantPermissionsOnTopic with any type of body
func NewGrantPermissionsOnTopicRequestWithBody(server string, tenant string, namespace string, topic string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistenceRequest generates requests for RemovePersistence
func NewRemovePersistenceRequest(server string, tenant string, namespace string, topic string, params *RemovePersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistenceRequest generates requests for GetPersistence
func NewGetPersistenceRequest(server string, tenant string, namespace string, topic string, params *GetPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistenceRequestWithBody generates requests for SetPersistence with any type of body
func NewSetPersistenceRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePropertiesRequest generates requests for RemoveProperties
func NewRemovePropertiesRequest(server string, tenant string, namespace string, topic string, params *RemovePropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Key != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPropertiesRequest generates requests for GetProperties
func NewGetPropertiesRequest(server string, tenant string, namespace string, topic string, params *GetPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePropertiesRequestWithBody generates requests for UpdateProperties with any type of body
func NewUpdatePropertiesRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePublishRateRequest generates requests for RemovePublishRate
func NewRemovePublishRateRequest(server string, tenant string, namespace string, topic string, params *RemovePublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublishRateRequest generates requests for GetPublishRate
func NewGetPublishRateRequest(server string, tenant string, namespace string, topic string, params *GetPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPublishRateRequestWithBody generates requests for SetPublishRate with any type of body
func NewSetPublishRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveReplicationClustersRequest generates requests for RemoveReplicationClusters
func NewRemoveReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReplicationClustersRequest generates requests for GetReplicationClusters
func NewGetReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *GetReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReplicationClustersRequestWithBody generates requests for SetReplicationClusters with any type of body
func NewSetReplicationClustersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveReplicatorDispatchRateRequest generates requests for RemoveReplicatorDispatchRate
func NewRemoveReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReplicatorDispatchRateRequest generates requests for GetReplicatorDispatchRate
func NewGetReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReplicatorDispatchRateRequestWithBody generates requests for SetReplicatorDispatchRate with any type of body
func NewSetReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRetentionRequest generates requests for RemoveRetention
func NewRemoveRetentionRequest(server string, tenant string, namespace string, topic string, params *RemoveRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRetentionRequest generates requests for GetRetention
func NewGetRetentionRequest(server string, tenant string, namespace string, topic string, params *GetRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRetentionRequestWithBody generates requests for SetRetention with any type of body
func NewSetRetentionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSchemaCompatibilityStrategyRequestWithBody generates requests for RemoveSchemaCompatibilityStrategy with any type of body
func NewRemoveSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaCompatibilityStrategyRequest generates requests for GetSchemaCompatibilityStrategy
func NewGetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaCompatibilityStrategyRequestWithBody generates requests for SetSchemaCompatibilityStrategy with any type of body
func NewSetSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaValidationEnforcedRequest generates requests for GetSchemaValidationEnforced
func NewGetSchemaValidationEnforcedRequest(server string, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaValidationEnforcedRequestWithBody generates requests for SetSchemaValidationEnforced with any type of body
func NewSetSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShadowTopicsRequest generates requests for DeleteShadowTopics
func NewDeleteShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShadowTopicsRequest generates requests for GetShadowTopics
func NewGetShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *GetShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetShadowTopicsRequestWithBody generates requests for SetShadowTopics with any type of body
func NewSetShadowTopicsRequestWithBody(server string, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, tenant string, namespace string, topic string, params *GetStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveSubscribeRateRequestWithBody generates requests for RemoveSubscribeRate with any type of body
func NewRemoveSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscribeRateRequest generates requests for GetSubscribeRate
func NewGetSubscribeRateRequest(server string, tenant string, namespace string, topic string, params *GetSubscribeRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscribeRateRequestWithBody generates requests for SetSubscribeRate with any type of body
func NewSetSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnalyzeSubscriptionBacklogRequestWithBody generates requests for AnalyzeSubscriptionBacklog with any type of body
func NewAnalyzeSubscriptionBacklogRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/analyzeBacklog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireTopicMessagesRequestWithBody generates requests for ExpireTopicMessages with any type of body
func NewExpireTopicMessagesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/expireMessages", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireTopicMessagesRequest generates requests for ExpireTopicMessages
func NewExpireTopicMessagesRequest(server string, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPeekNthMessageRequest generates requests for PeekNthMessage
func NewPeekNthMessageRequest(server string, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "messagePosition", runtime.ParamLocationPath, messagePosition)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/position/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionPropertiesRequest generates requests for GetSubscriptionProperties
func NewGetSubscriptionPropertiesRequest(server string, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubscriptionPropertiesRequestWithBody generates requests for UpdateSubscriptionProperties with any type of body
func NewUpdateSubscriptionPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReplicatedSubscriptionStatusRequest generates requests for GetReplicatedSubscriptionStatus
func NewGetReplicatedSubscriptionStatusRequest(server string, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReplicatedSubscriptionStatusRequestWithBody generates requests for SetReplicatedSubscriptionStatus with any type of body
func NewSetReplicatedSubscriptionStatusRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetCursorOnPositionRequestWithBody generates requests for ResetCursorOnPosition with any type of body
func NewResetCursorOnPositionRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/resetcursor", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetCursorRequest generates requests for ResetCursor
func NewResetCursorRequest(server string, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/resetcursor/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipMessagesRequest generates requests for SkipMessages
func NewSkipMessagesRequest(server string, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "numMessages", runtime.ParamLocationPath, numMessages)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/skip/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipAllMessagesRequest generates requests for SkipAllMessages
func NewSkipAllMessagesRequest(server string, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/skip_all", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscriptionName", runtime.ParamLocationPath, subscriptionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Replicated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replicated", runtime.ParamLocationQuery, *params.Replicated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubscriptionDispatchRateRequest generates requests for RemoveSubscriptionDispatchRate
func NewRemoveSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionDispatchRateRequest generates requests for GetSubscriptionDispatchRate
func NewGetSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionDispatchRateRequestWithBody generates requests for SetSubscriptionDispatchRate with any type of body
func NewSetSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubscriptionTypesEnabledRequest generates requests for RemoveSubscriptionTypesEnabled
func NewRemoveSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionTypesEnabledRequest generates requests for GetSubscriptionTypesEnabled
func NewGetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionTypesEnabledRequestWithBody generates requests for SetSubscriptionTypesEnabled with any type of body
func NewSetSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionsRequest generates requests for GetSubscriptions
func NewGetSubscriptionsRequest(server string, tenant string, namespace string, topic string, params *GetSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateRequest generates requests for Terminate
func NewTerminateRequest(server string, tenant string, namespace string, topic string, params *TerminateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/terminate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminatePartitionedTopicRequest generates requests for TerminatePartitionedTopic
func NewTerminatePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/terminate/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTruncateTopicRequest generates requests for TruncateTopic
func NewTruncateTopicRequest(server string, tenant string, namespace string, topic string, params *TruncateTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/truncate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadTopicRequest generates requests for UnloadTopic
func NewUnloadTopicRequest(server string, tenant string, namespace string, topic string, params *UnloadTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveSubscriptionLevelDispatchRateRequest generates requests for RemoveSubscriptionLevelDispatchRate
func NewRemoveSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionLevelDispatchRateRequest generates requests for GetSubscriptionLevelDispatchRate
func NewGetSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionLevelDispatchRateRequestWithBody generates requests for SetSubscriptionLevelDispatchRate with any type of body
func NewSetSubscriptionLevelDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetListRequest generates requests for GetList
func NewGetListRequest(server string, tenant string, namespace string, params *GetListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Bundle != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundle", runtime.ParamLocationQuery, *params.Bundle); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPartitionedTopicListRequest generates requests for GetPartitionedTopicList
func NewGetPartitionedTopicListRequest(server string, tenant string, namespace string, params *GetPartitionedTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/partitioned", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTopicRequest generates requests for DeleteTopic
func NewDeleteTopicRequest(server string, tenant string, namespace string, topic string, params *DeleteTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNonPartitionedTopicRequestWithBody generates requests for CreateNonPartitionedTopic with any type of body
func NewCreateNonPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireMessagesForAllSubscriptionsRequest generates requests for ExpireMessagesForAllSubscriptions
func NewExpireMessagesForAllSubscriptionsRequest(server string, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/all_subscription/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBacklogRequest generates requests for GetBacklog
func NewGetBacklogRequest(server string, tenant string, namespace string, topic string, params *GetBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveBacklogQuotaRequest generates requests for RemoveBacklogQuota
func NewRemoveBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBacklogQuotaRequest generates requests for SetBacklogQuota
func NewSetBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *SetBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBacklogQuotaMapRequest generates requests for GetBacklogQuotaMap
func NewGetBacklogQuotaMapRequest(server string, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuotaMap", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBacklogSizeByMessageIdRequest generates requests for GetBacklogSizeByMessageId
func NewGetBacklogSizeByMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompactionStatusRequest generates requests for CompactionStatus
func NewCompactionStatusRequest(server string, tenant string, namespace string, topic string, params *CompactionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompactRequest generates requests for Compact
func NewCompactRequest(server string, tenant string, namespace string, topic string, params *CompactParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveCompactionThresholdRequest generates requests for RemoveCompactionThreshold
func NewRemoveCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompactionThresholdRequest generates requests for GetCompactionThreshold
func NewGetCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *GetCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCompactionThresholdRequestWithBody generates requests for SetCompactionThreshold with any type of body
func NewSetCompactionThresholdRequestWithBody(server string, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateMissedPartitionsRequest generates requests for CreateMissedPartitions
func NewCreateMissedPartitionsRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/createMissedPartitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveDeduplicationRequest generates requests for RemoveDeduplication
func NewRemoveDeduplicationRequest(server string, tenant string, namespace string, topic string, params *RemoveDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeduplicationRequest generates requests for GetDeduplication
func NewGetDeduplicationRequest(server string, tenant string, namespace string, topic string, params *GetDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDeduplicationRequestWithBody generates requests for SetDeduplication with any type of body
func NewSetDeduplicationRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeduplicationSnapshotIntervalRequest generates requests for DeleteDeduplicationSnapshotInterval
func NewDeleteDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeduplicationSnapshotIntervalRequest generates requests for GetDeduplicationSnapshotInterval
func NewGetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDeduplicationSnapshotIntervalRequestWithBody generates requests for SetDeduplicationSnapshotInterval with any type of body
func NewSetDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDelayedDeliveryPoliciesRequest generates requests for DeleteDelayedDeliveryPolicies
func NewDeleteDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDelayedDeliveryPoliciesRequest generates requests for GetDelayedDeliveryPolicies
func NewGetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDelayedDeliveryPoliciesRequestWithBody generates requests for SetDelayedDeliveryPolicies with any type of body
func NewSetDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveDispatchRateRequest generates requests for RemoveDispatchRate
func NewRemoveDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDispatchRateRequest generates requests for GetDispatchRate
func NewGetDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDispatchRateRequestWithBody generates requests for SetDispatchRate with any type of body
func NewSetDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveEntryFiltersRequest generates requests for RemoveEntryFilters
func NewRemoveEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryFiltersRequest generates requests for GetEntryFilters
func NewGetEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *GetEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetEntryFiltersRequestWithBody generates requests for SetEntryFilters with any type of body
func NewSetEntryFiltersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExamineMessageRequest generates requests for ExamineMessage
func NewExamineMessageRequest(server string, tenant string, namespace string, topic string, params *ExamineMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/examinemessage", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InitialPosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "initialPosition", runtime.ParamLocationQuery, *params.InitialPosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MessagePosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messagePosition", runtime.ParamLocationQuery, *params.MessagePosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInactiveTopicPoliciesRequest generates requests for DeleteInactiveTopicPolicies
func NewDeleteInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInactiveTopicPoliciesRequest generates requests for GetInactiveTopicPolicies
func NewGetInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetInactiveTopicPoliciesRequestWithBody generates requests for SetInactiveTopicPolicies with any type of body
func NewSetInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetManagedLedgerInfoRequest generates requests for GetManagedLedgerInfo
func NewGetManagedLedgerInfoRequest(server string, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/internal-info", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInternalStatsRequest generates requests for GetInternalStats
func NewGetInternalStatsRequest(server string, tenant string, namespace string, topic string, params *GetInternalStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLastMessageIdRequest generates requests for GetLastMessageId
func NewGetLastMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetLastMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/lastMessageId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessageByIdRequest generates requests for GetMessageById
func NewGetMessageByIdRequest(server string, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "ledgerId", runtime.ParamLocationPath, ledgerId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "entryId", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/ledger/%s/entry/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveMaxConsumersRequest generates requests for RemoveMaxConsumers
func NewRemoveMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxConsumersRequest generates requests for GetMaxConsumers
func NewGetMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *GetMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxConsumersRequestWithBody generates requests for SetMaxConsumers with any type of body
func NewSetMaxConsumersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxConsumersPerSubscriptionRequest generates requests for RemoveMaxConsumersPerSubscription
func NewRemoveMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxConsumersPerSubscriptionRequest generates requests for GetMaxConsumersPerSubscription
func NewGetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxConsumersPerSubscriptionRequestWithBody generates requests for SetMaxConsumersPerSubscription with any type of body
func NewSetMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxMessageSizeRequest generates requests for RemoveMaxMessageSize
func NewRemoveMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxMessageSizeRequest generates requests for GetMaxMessageSize
func NewGetMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxMessageSizeRequestWithBody generates requests for SetMaxMessageSize with any type of body
func NewSetMaxMessageSizeRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxProducersRequest generates requests for RemoveMaxProducers
func NewRemoveMaxProducersRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxProducersRequest generates requests for GetMaxProducers
func NewGetMaxProducersRequest(server string, tenant string, namespace string, topic string, params *GetMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxProducersRequestWithBody generates requests for SetMaxProducers with any type of body
func NewSetMaxProducersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMaxSubscriptionsPerTopicRequest generates requests for RemoveMaxSubscriptionsPerTopic
func NewRemoveMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxSubscriptionsPerTopicRequest generates requests for GetMaxSubscriptionsPerTopic
func NewGetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxSubscriptionsPerTopicRequestWithBody generates requests for SetMaxSubscriptionsPerTopic with any type of body
func NewSetMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMaxUnackedMessagesOnConsumerRequest generates requests for DeleteMaxUnackedMessagesOnConsumer
func NewDeleteMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxUnackedMessagesOnConsumerRequest generates requests for GetMaxUnackedMessagesOnConsumer
func NewGetMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxUnackedMessagesOnConsumerRequestWithBody generates requests for SetMaxUnackedMessagesOnConsumer with any type of body
func NewSetMaxUnackedMessagesOnConsumerRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMaxUnackedMessagesOnSubscriptionRequest generates requests for DeleteMaxUnackedMessagesOnSubscription
func NewDeleteMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaxUnackedMessagesOnSubscriptionRequest generates requests for GetMaxUnackedMessagesOnSubscription
func NewGetMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMaxUnackedMessagesOnSubscriptionRequestWithBody generates requests for SetMaxUnackedMessagesOnSubscription with any type of body
func NewSetMaxUnackedMessagesOnSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMessageTTLRequest generates requests for RemoveMessageTTL
func NewRemoveMessageTTLRequest(server string, tenant string, namespace string, topic string, params *RemoveMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessageTTLRequest generates requests for GetMessageTTL
func NewGetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *GetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMessageTTLRequest generates requests for SetMessageTTL
func NewSetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *SetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageTTL", runtime.ParamLocationQuery, params.MessageTTL); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessageIdByTimestampRequest generates requests for GetMessageIdByTimestamp
func NewGetMessageIdByTimestampRequest(server string, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageid/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOffloadStatusRequest generates requests for OffloadStatus
func NewOffloadStatusRequest(server string, tenant string, namespace string, topic string, params *OffloadStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerOffloadRequest generates requests for TriggerOffload
func NewTriggerOffloadRequest(server string, tenant string, namespace string, topic string, params *TriggerOffloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveOffloadPoliciesRequest generates requests for RemoveOffloadPolicies
func NewRemoveOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOffloadPoliciesRequest generates requests for GetOffloadPolicies
func NewGetOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOffloadPoliciesRequestWithBody generates requests for SetOffloadPolicies with any type of body
func NewSetOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPartitionedStatsRequest generates requests for GetPartitionedStats
func NewGetPartitionedStatsRequest(server string, tenant string, namespace string, topic string, params *GetPartitionedStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitioned-stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPartition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPartition", runtime.ParamLocationQuery, *params.PerPartition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePartitionedTopicRequest generates requests for DeletePartitionedTopic
func NewDeletePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPartitionedMetadataRequest generates requests for GetPartitionedMetadata
func NewGetPartitionedMetadataRequest(server string, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CheckAllowAutoCreation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkAllowAutoCreation", runtime.ParamLocationQuery, *params.CheckAllowAutoCreation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePartitionedTopicRequestWithBody generates requests for UpdatePartitionedTopic with any type of body
func NewUpdatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateLocalTopicOnly", runtime.ParamLocationQuery, *params.UpdateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePartitionedTopicRequestWithBody generates requests for CreatePartitionedTopic with any type of body
func NewCreatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createLocalTopicOnly", runtime.ParamLocationQuery, *params.CreateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPermissionsOnTopicRequest generates requests for GetPermissionsOnTopic
func NewGetPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsOnTopicRequest generates requests for RevokePermissionsOnTopic
func NewRevokePermissionsOnTopicRequest(server string, tenant string, namespace string, topic string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGrantPermissionsOnTopicRequestWithBody generates requests for GrantPermissionsOnTopic with any type of body
func NewGrantPermissionsOnTopicRequestWithBody(server string, tenant string, namespace string, topic string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistenceRequest generates requests for RemovePersistence
func NewRemovePersistenceRequest(server string, tenant string, namespace string, topic string, params *RemovePersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistenceRequest generates requests for GetPersistence
func NewGetPersistenceRequest(server string, tenant string, namespace string, topic string, params *GetPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistenceRequestWithBody generates requests for SetPersistence with any type of body
func NewSetPersistenceRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePropertiesRequest generates requests for RemoveProperties
func NewRemovePropertiesRequest(server string, tenant string, namespace string, topic string, params *RemovePropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Key != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPropertiesRequest generates requests for GetProperties
func NewGetPropertiesRequest(server string, tenant string, namespace string, topic string, params *GetPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePropertiesRequestWithBody generates requests for UpdateProperties with any type of body
func NewUpdatePropertiesRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePublishRateRequest generates requests for RemovePublishRate
func NewRemovePublishRateRequest(server string, tenant string, namespace string, topic string, params *RemovePublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublishRateRequest generates requests for GetPublishRate
func NewGetPublishRateRequest(server string, tenant string, namespace string, topic string, params *GetPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPublishRateRequestWithBody generates requests for SetPublishRate with any type of body
func NewSetPublishRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveReplicationClustersRequest generates requests for RemoveReplicationClusters
func NewRemoveReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReplicationClustersRequest generates requests for GetReplicationClusters
func NewGetReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *GetReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReplicationClustersRequestWithBody generates requests for SetReplicationClusters with any type of body
func NewSetReplicationClustersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveReplicatorDispatchRateRequest generates requests for RemoveReplicatorDispatchRate
func NewRemoveReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReplicatorDispatchRateRequest generates requests for GetReplicatorDispatchRate
func NewGetReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReplicatorDispatchRateRequestWithBody generates requests for SetReplicatorDispatchRate with any type of body
func NewSetReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRetentionRequest generates requests for RemoveRetention
func NewRemoveRetentionRequest(server string, tenant string, namespace string, topic string, params *RemoveRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRetentionRequest generates requests for GetRetention
func NewGetRetentionRequest(server string, tenant string, namespace string, topic string, params *GetRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRetentionRequestWithBody generates requests for SetRetention with any type of body
func NewSetRetentionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSchemaCompatibilityStrategyRequestWithBody generates requests for RemoveSchemaCompatibilityStrategy with any type of body
func NewRemoveSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaCompatibilityStrategyRequest generates requests for GetSchemaCompatibilityStrategy
func NewGetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaCompatibilityStrategyRequestWithBody generates requests for SetSchemaCompatibilityStrategy with any type of body
func NewSetSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaValidationEnforcedRequest generates requests for GetSchemaValidationEnforced
func NewGetSchemaValidationEnforcedRequest(server string, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaValidationEnforcedRequestWithBody generates requests for SetSchemaValidationEnforced with any type of body
func NewSetSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShadowTopicsRequest generates requests for DeleteShadowTopics
func NewDeleteShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShadowTopicsRequest generates requests for GetShadowTopics
func NewGetShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *GetShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetShadowTopicsRequestWithBody generates requests for SetShadowTopics with any type of body
func NewSetShadowTopicsRequestWithBody(server string, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, tenant string, namespace string, topic string, params *GetStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveSubscribeRateRequestWithBody generates requests for RemoveSubscribeRate with any type of body
func NewRemoveSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscribeRateRequest generates requests for GetSubscribeRate
func NewGetSubscribeRateRequest(server string, tenant string, namespace string, topic string, params *GetSubscribeRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscribeRateRequestWithBody generates requests for SetSubscribeRate with any type of body
func NewSetSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnalyzeSubscriptionBacklogRequestWithBody generates requests for AnalyzeSubscriptionBacklog with any type of body
func NewAnalyzeSubscriptionBacklogRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/analyzeBacklog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireTopicMessagesRequestWithBody generates requests for ExpireTopicMessages with any type of body
func NewExpireTopicMessagesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/expireMessages", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireTopicMessagesRequest generates requests for ExpireTopicMessages
func NewExpireTopicMessagesRequest(server string, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPeekNthMessageRequest generates requests for PeekNthMessage
func NewPeekNthMessageRequest(server string, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "messagePosition", runtime.ParamLocationPath, messagePosition)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/position/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionPropertiesRequest generates requests for GetSubscriptionProperties
func NewGetSubscriptionPropertiesRequest(server string, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubscriptionPropertiesRequestWithBody generates requests for UpdateSubscriptionProperties with any type of body
func NewUpdateSubscriptionPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReplicatedSubscriptionStatusRequest generates requests for GetReplicatedSubscriptionStatus
func NewGetReplicatedSubscriptionStatusRequest(server string, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReplicatedSubscriptionStatusRequestWithBody generates requests for SetReplicatedSubscriptionStatus with any type of body
func NewSetReplicatedSubscriptionStatusRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetCursorOnPositionRequestWithBody generates requests for ResetCursorOnPosition with any type of body
func NewResetCursorOnPositionRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/resetcursor", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetCursorRequest generates requests for ResetCursor
func NewResetCursorRequest(server string, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/resetcursor/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipMessagesRequest generates requests for SkipMessages
func NewSkipMessagesRequest(server string, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "numMessages", runtime.ParamLocationPath, numMessages)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/skip/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipAllMessagesRequest generates requests for SkipAllMessages
func NewSkipAllMessagesRequest(server string, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/skip_all", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscriptionName", runtime.ParamLocationPath, subscriptionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Replicated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replicated", runtime.ParamLocationQuery, *params.Replicated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubscriptionDispatchRateRequest generates requests for RemoveSubscriptionDispatchRate
func NewRemoveSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionDispatchRateRequest generates requests for GetSubscriptionDispatchRate
func NewGetSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionDispatchRateRequestWithBody generates requests for SetSubscriptionDispatchRate with any type of body
func NewSetSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubscriptionTypesEnabledRequest generates requests for RemoveSubscriptionTypesEnabled
func NewRemoveSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionTypesEnabledRequest generates requests for GetSubscriptionTypesEnabled
func NewGetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionTypesEnabledRequestWithBody generates requests for SetSubscriptionTypesEnabled with any type of body
func NewSetSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionsRequest generates requests for GetSubscriptions
func NewGetSubscriptionsRequest(server string, tenant string, namespace string, topic string, params *GetSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateRequest generates requests for Terminate
func NewTerminateRequest(server string, tenant string, namespace string, topic string, params *TerminateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/terminate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminatePartitionedTopicRequest generates requests for TerminatePartitionedTopic
func NewTerminatePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/terminate/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTruncateTopicRequest generates requests for TruncateTopic
func NewTruncateTopicRequest(server string, tenant string, namespace string, topic string, params *TruncateTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/truncate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadTopicRequest generates requests for UnloadTopic
func NewUnloadTopicRequest(server string, tenant string, namespace string, topic string, params *UnloadTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveSubscriptionLevelDispatchRateRequest generates requests for RemoveSubscriptionLevelDispatchRate
func NewRemoveSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionLevelDispatchRateRequest generates requests for GetSubscriptionLevelDispatchRate
func NewGetSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSubscriptionLevelDispatchRateRequestWithBody generates requests for SetSubscriptionLevelDispatchRate with any type of body
func NewSetSubscriptionLevelDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultResourceQuotaRequest generates requests for GetDefaultResourceQuota
func NewGetDefaultResourceQuotaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultResourceQuotaRequest calls the generic SetDefaultResourceQuota builder with application/json body
func NewSetDefaultResourceQuotaRequest(server string, body SetDefaultResourceQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDefaultResourceQuotaRequestWithBody(server, "application/json", bodyReader)
}

// NewSetDefaultResourceQuotaRequestWithBody generates requests for SetDefaultResourceQuota with any type of body
func NewSetDefaultResourceQuotaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceBundleResourceQuotaRequest generates requests for RemoveNamespaceBundleResourceQuota
func NewRemoveNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceBundleResourceQuotaRequest generates requests for GetNamespaceBundleResourceQuota
func NewGetNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceBundleResourceQuotaRequest calls the generic SetNamespaceBundleResourceQuota builder with application/json body
func NewSetNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceBundleResourceQuotaRequestWithBody(server, tenant, namespace, bundle, "application/json", bodyReader)
}

// NewSetNamespaceBundleResourceQuotaRequestWithBody generates requests for SetNamespaceBundleResourceQuota with any type of body
func NewSetNamespaceBundleResourceQuotaRequestWithBody(server string, tenant string, namespace string, bundle string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourceGroupsRequest generates requests for GetResourceGroups
func NewGetResourceGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteResourceGroupRequest generates requests for DeleteResourceGroup
func NewDeleteResourceGroupRequest(server string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceGroupRequest generates requests for GetResourceGroup
func NewGetResourceGroupRequest(server string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateResourceGroupRequest calls the generic CreateOrUpdateResourceGroup builder with application/json body
func NewCreateOrUpdateResourceGroupRequest(server string, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateResourceGroupRequestWithBody(server, resourcegroup, "application/json", bodyReader)
}

// NewCreateOrUpdateResourceGroupRequestWithBody generates requests for CreateOrUpdateResourceGroup with any type of body
func NewCreateOrUpdateResourceGroupRequestWithBody(server string, resourcegroup string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestCompatibilityRequest calls the generic TestCompatibility builder with application/json body
func NewTestCompatibilityRequest(server string, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestCompatibilityRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewTestCompatibilityRequestWithBody generates requests for TestCompatibility with any type of body
func NewTestCompatibilityRequestWithBody(server string, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/compatibility", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSchemaRequest generates requests for DeleteSchema
func NewDeleteSchemaRequest(server string, tenant string, namespace string, topic string, params *DeleteSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemaRequest generates requests for GetSchema
func NewGetSchemaRequest(server string, tenant string, namespace string, topic string, params *GetSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchemaRequest calls the generic PostSchema builder with application/json body
func NewPostSchemaRequest(server string, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSchemaRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewPostSchemaRequestWithBody generates requests for PostSchema with any type of body
func NewPostSchemaRequestWithBody(server string, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaRequest generates requests for GetSchema
func NewGetSchemaRequest(server string, tenant string, namespace string, topic string, version string, params *GetSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSchemasRequest generates requests for GetAllSchemas
func NewGetAllSchemasRequest(server string, tenant string, namespace string, topic string, params *GetAllSchemasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schemas", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionBySchemaRequest calls the generic GetVersionBySchema builder with application/json body
func NewGetVersionBySchemaRequest(server string, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetVersionBySchemaRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewGetVersionBySchemaRequestWithBody generates requests for GetVersionBySchema with any type of body
func NewGetVersionBySchemaRequestWithBody(server string, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/version", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTenantsRequest generates requests for GetTenants
func NewGetTenantsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTenantRequest generates requests for DeleteTenant
func NewDeleteTenantRequest(server string, tenant string, params *DeleteTenantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantAdminRequest generates requests for GetTenantAdmin
func NewGetTenantAdminRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTenantRequest calls the generic UpdateTenant builder with application/json body
func NewUpdateTenantRequest(server string, tenant string, body UpdateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTenantRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewUpdateTenantRequestWithBody generates requests for UpdateTenant with any type of body
func NewUpdateTenantRequestWithBody(server string, tenant string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTenantRequest calls the generic CreateTenant builder with application/json body
func NewCreateTenantRequest(server string, tenant string, body CreateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTenantRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewCreateTenantRequestWithBody generates requests for CreateTenant with any type of body
func NewCreateTenantRequestWithBody(server string, tenant string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker-stats/functionsmetrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsRequest generates requests for GetMetrics
func NewGetMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker-stats/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssignmentsRequest generates requests for GetAssignments
func NewGetAssignmentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/assignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterLeaderRequest generates requests for GetClusterLeader
func NewGetClusterLeaderRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster/leader")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsLeaderReadyRequest generates requests for IsLeaderReady
func NewIsLeaderReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster/leader/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectorsListRequest generates requests for GetConnectorsList
func NewGetConnectorsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDrainStatusRequest generates requests for GetDrainStatus
func NewGetDrainStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDrainRequest generates requests for Drain
func NewDrainRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDrainStatusFromLeaderRequest generates requests for GetDrainStatusFromLeader
func NewGetDrainStatusFromLeaderRequest(server string, params *GetDrainStatusFromLeaderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/leader/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.WorkerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workerId", runtime.ParamLocationQuery, *params.WorkerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDrainAtLeaderRequest generates requests for DrainAtLeader
func NewDrainAtLeaderRequest(server string, params *DrainAtLeaderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/leader/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.WorkerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workerId", runtime.ParamLocationQuery, *params.WorkerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebalanceRequest generates requests for Rebalance
func NewRebalanceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/rebalance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllBookies request
	GetAllBookiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllBookiesResponse, error)

	// GetBookiesRackInfo request
	GetBookiesRackInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBookiesRackInfoResponse, error)

	// DeleteBookieRackInfo request
	DeleteBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*DeleteBookieRackInfoResponse, error)

	// GetBookieRackInfo request
	GetBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*GetBookieRackInfoResponse, error)

	// UpdateBookieRackInfo request
	UpdateBookieRackInfoWithResponse(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*UpdateBookieRackInfoResponse, error)

	// GetAllocatorStats request
	GetAllocatorStatsWithResponse(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*GetAllocatorStatsResponse, error)

	// GetPendingBookieOpsStats request
	GetPendingBookieOpsStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingBookieOpsStatsResponse, error)

	// GetBrokerResourceAvailability request
	GetBrokerResourceAvailabilityWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBrokerResourceAvailabilityResponse, error)

	// GetLoadReport request
	GetLoadReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoadReportResponse, error)

	// GetMBeans request
	GetMBeansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMBeansResponse, error)

	// GetMetrics request
	GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error)

	// GetTopics2 request
	GetTopics2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopics2Response, error)

	// GetActiveBrokers request
	GetActiveBrokersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActiveBrokersResponse, error)

	// BacklogQuotaCheck request
	BacklogQuotaCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BacklogQuotaCheckResponse, error)

	// GetDynamicConfigurationName request
	GetDynamicConfigurationNameWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDynamicConfigurationNameResponse, error)

	// GetRuntimeConfiguration request
	GetRuntimeConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeConfigurationResponse, error)

	// GetAllDynamicConfigurations request
	GetAllDynamicConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDynamicConfigurationsResponse, error)

	// DeleteDynamicConfiguration request
	DeleteDynamicConfigurationWithResponse(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*DeleteDynamicConfigurationResponse, error)

	// UpdateDynamicConfiguration request
	UpdateDynamicConfigurationWithResponse(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*UpdateDynamicConfigurationResponse, error)

	// HealthCheck request
	HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// GetInternalConfigurationData request
	GetInternalConfigurationDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInternalConfigurationDataResponse, error)

	// GetLeaderBroker request
	GetLeaderBrokerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeaderBrokerResponse, error)

	// IsReady request
	IsReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsReadyResponse, error)

	// ShutDownBrokerGracefully request
	ShutDownBrokerGracefullyWithResponse(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*ShutDownBrokerGracefullyResponse, error)

	// Version request
	VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error)

	// GetOwnedNamespaces request
	GetOwnedNamespacesWithResponse(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*GetOwnedNamespacesResponse, error)

	// GetActiveBrokers request
	GetActiveBrokersWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetActiveBrokersResponse, error)

	// GetClusters request
	GetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClustersResponse, error)

	// DeleteCluster request
	DeleteClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetCluster request
	GetClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateCluster request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// CreateCluster request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// GetFailureDomains request
	GetFailureDomainsWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetFailureDomainsResponse, error)

	// DeleteFailureDomain request
	DeleteFailureDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*DeleteFailureDomainResponse, error)

	// GetDomain request
	GetDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*GetDomainResponse, error)

	// SetFailureDomain request with any body
	SetFailureDomainWithBodyWithResponse(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFailureDomainResponse, error)

	// GetNamespaceIsolationPolicies request
	GetNamespaceIsolationPoliciesWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPoliciesResponse, error)

	// GetBrokersWithNamespaceIsolationPolicy request
	GetBrokersWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetBrokersWithNamespaceIsolationPolicyResponse, error)

	// GetBrokerWithNamespaceIsolationPolicy request
	GetBrokerWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*GetBrokerWithNamespaceIsolationPolicyResponse, error)

	// DeleteNamespaceIsolationPolicy request
	DeleteNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*DeleteNamespaceIsolationPolicyResponse, error)

	// GetNamespaceIsolationPolicy request
	GetNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPolicyResponse, error)

	// SetNamespaceIsolationPolicy request with any body
	SetNamespaceIsolationPolicyWithBodyWithResponse(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceIsolationPolicyResponse, error)

	// GetPeerCluster request
	GetPeerClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetPeerClusterResponse, error)

	// SetPeerClusterNames request with any body
	SetPeerClusterNamesWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPeerClusterNamesResponse, error)

	// GetAntiAffinityNamespaces request
	GetAntiAffinityNamespacesWithResponse(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*GetAntiAffinityNamespacesResponse, error)

	// DeleteBookieAffinityGroup request
	DeleteBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*DeleteBookieAffinityGroupResponse, error)

	// GetBookieAffinityGroup request
	GetBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*GetBookieAffinityGroupResponse, error)

	// GetTenantNamespaces request
	GetTenantNamespacesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantNamespacesResponse, error)

	// DeleteNamespace request
	DeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceResponse, error)

	// GetPolicies request
	GetPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPoliciesResponse, error)

	// CreateNamespace request with any body
	CreateNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error)

	CreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error)

	// RemoveNamespaceAntiAffinityGroup request
	RemoveNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceAntiAffinityGroupResponse, error)

	// GetNamespaceAntiAffinityGroup request
	GetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceAntiAffinityGroupResponse, error)

	// SetNamespaceAntiAffinityGroup request with any body
	SetNamespaceAntiAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error)

	SetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error)

	// RemoveAutoSubscriptionCreation request
	RemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoSubscriptionCreationResponse, error)

	// GetAutoSubscriptionCreation request
	GetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoSubscriptionCreationResponse, error)

	// SetAutoSubscriptionCreation request with any body
	SetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error)

	SetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error)

	// RemoveAutoTopicCreation request
	RemoveAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoTopicCreationResponse, error)

	// GetAutoTopicCreation request
	GetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoTopicCreationResponse, error)

	// SetAutoTopicCreation request with any body
	SetAutoTopicCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error)

	SetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error)

	// RemoveBacklogQuota request
	RemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveBacklogQuotaResponse, error)

	// SetBacklogQuota request with any body
	SetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error)

	SetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, body SetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error)

	// GetBacklogQuotaMap request
	GetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBacklogQuotaMapResponse, error)

	// GetBundlesData request
	GetBundlesDataWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBundlesDataResponse, error)

	// ClearNamespaceBacklog request
	ClearNamespaceBacklogWithResponse(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogResponse, error)

	// ClearNamespaceBacklogForSubscription request
	ClearNamespaceBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogForSubscriptionResponse, error)

	// DeleteCompactionThreshold request
	DeleteCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteCompactionThresholdResponse, error)

	// GetCompactionThreshold request
	GetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetCompactionThresholdResponse, error)

	// SetCompactionThreshold request with any body
	SetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error)

	SetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error)

	// RemoveDeduplication request
	RemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveDeduplicationResponse, error)

	// GetDeduplication request
	GetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDeduplicationResponse, error)

	// ModifyDeduplication request with any body
	ModifyDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error)

	ModifyDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error)

	// GetDeduplicationSnapshotInterval request
	GetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDeduplicationSnapshotIntervalResponse, error)

	// SetDeduplicationSnapshotInterval request with any body
	SetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error)

	SetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, body SetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error)

	// RemoveDelayedDeliveryPolicies request
	RemoveDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveDelayedDeliveryPoliciesResponse, error)

	// GetDelayedDeliveryPolicies request
	GetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDelayedDeliveryPoliciesResponse, error)

	// SetDelayedDeliveryPolicies request with any body
	SetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error)

	SetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error)

	// DeleteDispatchRate request
	DeleteDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteDispatchRateResponse, error)

	// GetDispatchRate request
	GetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDispatchRateResponse, error)

	// SetDispatchRate request with any body
	SetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error)

	SetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error)

	// GetEncryptionRequired request
	GetEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetEncryptionRequiredResponse, error)

	// ModifyEncryptionRequired request with any body
	ModifyEncryptionRequiredWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error)

	ModifyEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error)

	// RemoveNamespaceEntryFilters request
	RemoveNamespaceEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceEntryFiltersResponse, error)

	// GetEntryFiltersPerTopic request
	GetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetEntryFiltersPerTopicResponse, error)

	// SetEntryFiltersPerTopic request with any body
	SetEntryFiltersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error)

	SetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error)

	// RemoveInactiveTopicPolicies request
	RemoveInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveInactiveTopicPoliciesResponse, error)

	// GetInactiveTopicPolicies request
	GetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetInactiveTopicPoliciesResponse, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error)

	SetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error)

	// GetIsAllowAutoUpdateSchema request
	GetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetIsAllowAutoUpdateSchemaResponse, error)

	// SetIsAllowAutoUpdateSchema request with any body
	SetIsAllowAutoUpdateSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error)

	SetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error)

	// RemoveMaxConsumersPerSubscription request
	RemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerSubscriptionResponse, error)

	// GetMaxConsumersPerSubscription request
	GetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerSubscriptionResponse, error)

	// SetMaxConsumersPerSubscription request with any body
	SetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error)

	SetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error)

	// RemoveMaxConsumersPerTopic request
	RemoveMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerTopicResponse, error)

	// GetMaxConsumersPerTopic request
	GetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerTopicResponse, error)

	// SetMaxConsumersPerTopic request with any body
	SetMaxConsumersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerTopicResponse, error)

	SetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerTopicResponse, error)

	// RemoveMaxProducersPerTopic request
	RemoveMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxProducersPerTopicResponse, error)

	// GetMaxProducersPerTopic request
	GetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxProducersPerTopicResponse, error)

	// SetMaxProducersPerTopic request with any body
	SetMaxProducersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxProducersPerTopicResponse, error)

	SetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxProducersPerTopicResponse, error)

	// RemoveMaxSubscriptionsPerTopic request
	RemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxSubscriptionsPerTopicResponse, error)

	// GetMaxSubscriptionsPerTopic request
	GetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxSubscriptionsPerTopicResponse, error)

	// SetMaxSubscriptionsPerTopic request with any body
	SetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error)

	SetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error)

	// SetInactiveTopicPolicies request
	SetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error)

	// GetMaxTopicsPerNamespace request
	GetMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxTopicsPerNamespaceResponse, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error)

	SetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error)

	// RemoveMaxUnackedmessagesPerConsumer request
	RemoveMaxUnackedmessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxUnackedmessagesPerConsumerResponse, error)

	// GetMaxUnackedMessagesPerConsumer request
	GetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesPerConsumerResponse, error)

	// SetMaxUnackedMessagesPerConsumer request with any body
	SetMaxUnackedMessagesPerConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerConsumerResponse, error)

	SetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerConsumerResponse, error)

	// RemoveMaxUnackedmessagesPerSubscription request
	RemoveMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxUnackedmessagesPerSubscriptionResponse, error)

	// GetMaxUnackedmessagesPerSubscription request
	GetMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxUnackedmessagesPerSubscriptionResponse, error)

	// SetMaxUnackedMessagesPerSubscription request with any body
	SetMaxUnackedMessagesPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerSubscriptionResponse, error)

	SetMaxUnackedMessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerSubscriptionResponse, error)

	// RemoveNamespaceMessageTTL request
	RemoveNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMessageTTLResponse, error)

	// GetNamespaceMessageTTL request
	GetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMessageTTLResponse, error)

	// SetNamespaceMessageTTL request with any body
	SetNamespaceMessageTTLWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error)

	SetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error)

	// ClearOffloadDeletionLag request
	ClearOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearOffloadDeletionLagResponse, error)

	// GetOffloadDeletionLag request
	GetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetOffloadDeletionLagResponse, error)

	// SetOffloadDeletionLag request with any body
	SetOffloadDeletionLagWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadDeletionLagResponse, error)

	SetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, body SetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOffloadDeletionLagResponse, error)

	// GetOffloadPolicies request
	GetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetOffloadPoliciesResponse, error)

	// SetOffloadPolicies request with any body
	SetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error)

	SetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error)

	// GetOffloadThreshold request
	GetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetOffloadThresholdResponse, error)

	// SetOffloadThreshold request with any body
	SetOffloadThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadThresholdResponse, error)

	SetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOffloadThresholdResponse, error)

	// GetPermissions request
	GetPermissionsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionsResponse, error)

	// GetPermissionOnSubscription request
	GetPermissionOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionOnSubscriptionResponse, error)

	// RevokePermissionsOnNamespace request
	RevokePermissionsOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnNamespaceResponse, error)

	// GrantPermissionOnNamespace request with any body
	GrantPermissionOnNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error)

	GrantPermissionOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error)

	// DeletePersistence request
	DeletePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeletePersistenceResponse, error)

	// GetPersistence request
	GetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPersistenceResponse, error)

	// SetPersistence request with any body
	SetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error)

	SetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, body SetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error)

	// SetBookieAffinityGroup request with any body
	SetBookieAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error)

	SetBookieAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error)

	// ClearProperties request
	ClearPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearPropertiesResponse, error)

	// GetProperties request
	GetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPropertiesResponse, error)

	// SetProperties request with any body
	SetPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error)

	SetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error)

	// RemoveProperty request
	RemovePropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*RemovePropertyResponse, error)

	// GetProperty request
	GetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*GetPropertyResponse, error)

	// SetProperty request
	SetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*SetPropertyResponse, error)

	// RemoveOffloadPolicies request
	RemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveOffloadPoliciesResponse, error)

	// GetNamespaceReplicationClusters request
	GetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceReplicationClustersResponse, error)

	// SetNamespaceReplicationClusters request with any body
	SetNamespaceReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error)

	SetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error)

	// RemoveReplicatorDispatchRate request
	RemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveReplicatorDispatchRateResponse, error)

	// GetReplicatorDispatchRate request
	GetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetReplicatorDispatchRateResponse, error)

	// SetReplicatorDispatchRate request with any body
	SetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error)

	SetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error)

	// RemoveNamespaceResourceGroup request
	RemoveNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceResourceGroupResponse, error)

	// GetNamespaceResourceGroup request
	GetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceResourceGroupResponse, error)

	// SetNamespaceResourceGroup request
	SetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*SetNamespaceResourceGroupResponse, error)

	// RemoveRetention request with any body
	RemoveRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error)

	RemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, body RemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error)

	// GetRetention request
	GetRetentionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetRetentionResponse, error)

	// SetRetention request with any body
	SetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error)

	SetRetentionWithResponse(ctx context.Context, tenant string, namespace string, body SetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error)

	// ScanOffloadedLedgers request
	ScanOffloadedLedgersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ScanOffloadedLedgersResponse, error)

	// GetSchemaAutoUpdateCompatibilityStrategy request
	GetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	// SetSchemaAutoUpdateCompatibilityStrategy request with any body
	SetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	SetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	// GetSchemaCompatibilityStrategy request
	GetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSchemaCompatibilityStrategyResponse, error)

	// SetSchemaCompatibilityStrategy request with any body
	SetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error)

	SetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error)

	// GetSchemaValidtionEnforced request
	GetSchemaValidtionEnforcedWithResponse(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidtionEnforcedResponse, error)

	// SetSchemaValidationEnforced request with any body
	SetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error)

	SetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error)

	// DeleteSubscribeRate request
	DeleteSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscribeRateResponse, error)

	// GetSubscribeRate request
	GetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscribeRateResponse, error)

	// SetSubscribeRate request with any body
	SetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error)

	SetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error)

	// GetSubscriptionAuthMode request
	GetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionAuthModeResponse, error)

	// SetSubscriptionAuthMode request with any body
	SetSubscriptionAuthModeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionAuthModeResponse, error)

	SetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionAuthModeResponse, error)

	// DeleteSubscriptionDispatchRate request
	DeleteSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscriptionDispatchRateResponse, error)

	// GetSubscriptionDispatchRate request
	GetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionDispatchRateResponse, error)

	// SetSubscriptionDispatchRate request with any body
	SetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error)

	SetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error)

	// RemoveSubscriptionExpirationTime request
	RemoveSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionExpirationTimeResponse, error)

	// GetSubscriptionExpirationTime request
	GetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionExpirationTimeResponse, error)

	// SetSubscriptionExpirationTime request with any body
	SetSubscriptionExpirationTimeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionExpirationTimeResponse, error)

	SetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionExpirationTimeResponse, error)

	// RemoveSubscriptionTypesEnabled request
	RemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionTypesEnabledResponse, error)

	// GetSubscriptionTypesEnabled request
	GetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionTypesEnabledResponse, error)

	// SetSubscriptionTypesEnabled request with any body
	SetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error)

	SetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error)

	// GetTopics request
	GetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*GetTopicsResponse, error)

	// UnloadNamespace request
	UnloadNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*UnloadNamespaceResponse, error)

	// UnsubscribeNamespace request
	UnsubscribeNamespaceWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceResponse, error)

	// DeleteNamespaceBundle request
	DeleteNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceBundleResponse, error)

	// ClearNamespaceBundleBacklog request
	ClearNamespaceBundleBacklogWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogResponse, error)

	// ClearNamespaceBundleBacklogForSubscription request
	ClearNamespaceBundleBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogForSubscriptionResponse, error)

	// SplitNamespaceBundle request with any body
	SplitNamespaceBundleWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error)

	SplitNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error)

	// GetTopicHashPositions request
	GetTopicHashPositionsWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*GetTopicHashPositionsResponse, error)

	// UnloadNamespaceBundle request
	UnloadNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnloadNamespaceBundleResponse, error)

	// UnsubscribeNamespaceBundle request
	UnsubscribeNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceBundleResponse, error)

	// GetList request
	GetListWithResponse(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*GetListResponse, error)

	// GetPartitionedTopicList request
	GetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetPartitionedTopicListResponse, error)

	// GetListFromBundle request
	GetListFromBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetListFromBundleResponse, error)

	// DeleteTopic request
	DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error)

	// CreateNonPartitionedTopic request with any body
	CreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPartitionedTopicResponse, error)

	// ExpireMessagesForAllSubscriptions request
	ExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpireMessagesForAllSubscriptionsResponse, error)

	// GetBacklog request
	GetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*GetBacklogResponse, error)

	// RemoveBacklogQuota request
	RemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveBacklogQuotaResponse, error)

	// SetBacklogQuota request
	SetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error)

	// GetBacklogQuotaMap request
	GetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetBacklogQuotaMapResponse, error)

	// GetBacklogSizeByMessageId request
	GetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetBacklogSizeByMessageIdResponse, error)

	// CompactionStatus request
	CompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*CompactionStatusResponse, error)

	// Compact request
	CompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*CompactResponse, error)

	// RemoveCompactionThreshold request
	RemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemoveCompactionThresholdResponse, error)

	// GetCompactionThreshold request
	GetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetCompactionThresholdResponse, error)

	// SetCompactionThreshold request with any body
	SetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error)

	// CreateMissedPartitions request
	CreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreateMissedPartitionsResponse, error)

	// RemoveDeduplication request
	RemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*RemoveDeduplicationResponse, error)

	// GetDeduplication request
	GetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*GetDeduplicationResponse, error)

	// SetDeduplication request with any body
	SetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationResponse, error)

	// DeleteDeduplicationSnapshotInterval request
	DeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeleteDeduplicationSnapshotIntervalResponse, error)

	// GetDeduplicationSnapshotInterval request
	GetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetDeduplicationSnapshotIntervalResponse, error)

	// SetDeduplicationSnapshotInterval request with any body
	SetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error)

	// DeleteDelayedDeliveryPolicies request
	DeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteDelayedDeliveryPoliciesResponse, error)

	// GetDelayedDeliveryPolicies request
	GetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetDelayedDeliveryPoliciesResponse, error)

	// SetDelayedDeliveryPolicies request with any body
	SetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error)

	// RemoveDispatchRate request
	RemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveDispatchRateResponse, error)

	// GetDispatchRate request
	GetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*GetDispatchRateResponse, error)

	// SetDispatchRate request with any body
	SetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error)

	// RemoveEntryFilters request
	RemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemoveEntryFiltersResponse, error)

	// GetEntryFilters request
	GetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetEntryFiltersResponse, error)

	// SetEntryFilters request with any body
	SetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersResponse, error)

	// ExamineMessage request
	ExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*ExamineMessageResponse, error)

	// DeleteInactiveTopicPolicies request
	DeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteInactiveTopicPoliciesResponse, error)

	// GetInactiveTopicPolicies request
	GetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetInactiveTopicPoliciesResponse, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error)

	// GetManagedLedgerInfo request
	GetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetManagedLedgerInfoResponse, error)

	// GetInternalStats request
	GetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*GetInternalStatsResponse, error)

	// GetLastMessageId request
	GetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetLastMessageIdResponse, error)

	// GetMessageById request
	GetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*GetMessageByIdResponse, error)

	// RemoveMaxConsumers request
	RemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersResponse, error)

	// GetMaxConsumers request
	GetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersResponse, error)

	// SetMaxConsumers request with any body
	SetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersResponse, error)

	// RemoveMaxConsumersPerSubscription request
	RemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerSubscriptionResponse, error)

	// GetMaxConsumersPerSubscription request
	GetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerSubscriptionResponse, error)

	// SetMaxConsumersPerSubscription request with any body
	SetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error)

	// RemoveMaxMessageSize request
	RemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemoveMaxMessageSizeResponse, error)

	// GetMaxMessageSize request
	GetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetMaxMessageSizeResponse, error)

	// SetMaxMessageSize request with any body
	SetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxMessageSizeResponse, error)

	// RemoveMaxProducers request
	RemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*RemoveMaxProducersResponse, error)

	// GetMaxProducers request
	GetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*GetMaxProducersResponse, error)

	// SetMaxProducers request with any body
	SetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxProducersResponse, error)

	// RemoveMaxSubscriptionsPerTopic request
	RemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemoveMaxSubscriptionsPerTopicResponse, error)

	// GetMaxSubscriptionsPerTopic request
	GetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetMaxSubscriptionsPerTopicResponse, error)

	// SetMaxSubscriptionsPerTopic request with any body
	SetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error)

	// DeleteMaxUnackedMessagesOnConsumer request
	DeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnConsumerResponse, error)

	// GetMaxUnackedMessagesOnConsumer request
	GetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnConsumerResponse, error)

	// SetMaxUnackedMessagesOnConsumer request with any body
	SetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnConsumerResponse, error)

	// DeleteMaxUnackedMessagesOnSubscription request
	DeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnSubscriptionResponse, error)

	// GetMaxUnackedMessagesOnSubscription request
	GetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnSubscriptionResponse, error)

	// SetMaxUnackedMessagesOnSubscription request with any body
	SetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnSubscriptionResponse, error)

	// RemoveMessageTTL request
	RemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*RemoveMessageTTLResponse, error)

	// GetMessageTTL request
	GetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*GetMessageTTLResponse, error)

	// SetMessageTTL request
	SetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*SetMessageTTLResponse, error)

	// GetMessageIdByTimestamp request
	GetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetMessageIdByTimestampResponse, error)

	// OffloadStatus request
	OffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*OffloadStatusResponse, error)

	// TriggerOffload request
	TriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*TriggerOffloadResponse, error)

	// RemoveOffloadPolicies request
	RemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemoveOffloadPoliciesResponse, error)

	// GetOffloadPolicies request
	GetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetOffloadPoliciesResponse, error)

	// SetOffloadPolicies request with any body
	SetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error)

	// GetPartitionedStats request
	GetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetPartitionedStatsResponse, error)

	// DeletePartitionedTopic request
	DeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeletePartitionedTopicResponse, error)

	// GetPartitionedMetadata request
	GetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetPartitionedMetadataResponse, error)

	// UpdatePartitionedTopic request with any body
	UpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePartitionedTopicResponse, error)

	// CreatePartitionedTopic request with any body
	CreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePartitionedTopicResponse, error)

	// GetPermissionsOnTopic request
	GetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetPermissionsOnTopicResponse, error)

	// RevokePermissionsOnTopic request
	RevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnTopicResponse, error)

	// GrantPermissionsOnTopic request with any body
	GrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionsOnTopicResponse, error)

	// RemovePersistence request
	RemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*RemovePersistenceResponse, error)

	// GetPersistence request
	GetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*GetPersistenceResponse, error)

	// SetPersistence request with any body
	SetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error)

	// RemoveProperties request
	RemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*RemovePropertiesResponse, error)

	// GetProperties request
	GetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*GetPropertiesResponse, error)

	// UpdateProperties request with any body
	UpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error)

	// RemovePublishRate request
	RemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*RemovePublishRateResponse, error)

	// GetPublishRate request
	GetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*GetPublishRateResponse, error)

	// SetPublishRate request with any body
	SetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPublishRateResponse, error)

	// RemoveReplicationClusters request
	RemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemoveReplicationClustersResponse, error)

	// GetReplicationClusters request
	GetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetReplicationClustersResponse, error)

	// SetReplicationClusters request with any body
	SetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicationClustersResponse, error)

	// RemoveReplicatorDispatchRate request
	RemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveReplicatorDispatchRateResponse, error)

	// GetReplicatorDispatchRate request
	GetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetReplicatorDispatchRateResponse, error)

	// SetReplicatorDispatchRate request with any body
	SetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error)

	// RemoveRetention request
	RemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error)

	// GetRetention request
	GetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*GetRetentionResponse, error)

	// SetRetention request with any body
	SetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error)

	// RemoveSchemaCompatibilityStrategy request with any body
	RemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSchemaCompatibilityStrategyResponse, error)

	// GetSchemaCompatibilityStrategy request
	GetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetSchemaCompatibilityStrategyResponse, error)

	// SetSchemaCompatibilityStrategy request with any body
	SetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error)

	// GetSchemaValidationEnforced request
	GetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidationEnforcedResponse, error)

	// SetSchemaValidationEnforced request with any body
	SetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error)

	// DeleteShadowTopics request
	DeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeleteShadowTopicsResponse, error)

	// GetShadowTopics request
	GetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetShadowTopicsResponse, error)

	// SetShadowTopics request with any body
	SetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetShadowTopicsResponse, error)

	// GetStats request
	GetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// RemoveSubscribeRate request with any body
	RemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSubscribeRateResponse, error)

	// GetSubscribeRate request
	GetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetSubscribeRateResponse, error)

	// SetSubscribeRate request with any body
	SetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error)

	// DeleteSubscription request
	DeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// AnalyzeSubscriptionBacklog request with any body
	AnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzeSubscriptionBacklogResponse, error)

	// ExpireTopicMessages request with any body
	ExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error)

	// ExpireTopicMessages request
	ExpireTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error)

	// PeekNthMessage request
	PeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*PeekNthMessageResponse, error)

	// GetSubscriptionProperties request
	GetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetSubscriptionPropertiesResponse, error)

	// UpdateSubscriptionProperties request with any body
	UpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionPropertiesResponse, error)

	// GetReplicatedSubscriptionStatus request
	GetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetReplicatedSubscriptionStatusResponse, error)

	// SetReplicatedSubscriptionStatus request with any body
	SetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatedSubscriptionStatusResponse, error)

	// ResetCursorOnPosition request with any body
	ResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetCursorOnPositionResponse, error)

	// ResetCursor request
	ResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*ResetCursorResponse, error)

	// SkipMessages request
	SkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*SkipMessagesResponse, error)

	// SkipAllMessages request
	SkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipAllMessagesResponse, error)

	// CreateSubscription request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// RemoveSubscriptionDispatchRate request
	RemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionDispatchRateResponse, error)

	// GetSubscriptionDispatchRate request
	GetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionDispatchRateResponse, error)

	// SetSubscriptionDispatchRate request with any body
	SetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error)

	// RemoveSubscriptionTypesEnabled request
	RemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionTypesEnabledResponse, error)

	// GetSubscriptionTypesEnabled request
	GetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetSubscriptionTypesEnabledResponse, error)

	// SetSubscriptionTypesEnabled request with any body
	SetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error)

	// GetSubscriptions request
	GetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error)

	// Terminate request
	TerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*TerminateResponse, error)

	// TerminatePartitionedTopic request
	TerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminatePartitionedTopicResponse, error)

	// TruncateTopic request
	TruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*TruncateTopicResponse, error)

	// UnloadTopic request
	UnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*UnloadTopicResponse, error)

	// RemoveSubscriptionLevelDispatchRate request
	RemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionLevelDispatchRateResponse, error)

	// GetSubscriptionLevelDispatchRate request
	GetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionLevelDispatchRateResponse, error)

	// SetSubscriptionLevelDispatchRate request with any body
	SetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionLevelDispatchRateResponse, error)

	// GetList request
	GetListWithResponse(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*GetListResponse, error)

	// GetPartitionedTopicList request
	GetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetPartitionedTopicListResponse, error)

	// DeleteTopic request
	DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error)

	// CreateNonPartitionedTopic request with any body
	CreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPartitionedTopicResponse, error)

	// ExpireMessagesForAllSubscriptions request
	ExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpireMessagesForAllSubscriptionsResponse, error)

	// GetBacklog request
	GetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*GetBacklogResponse, error)

	// RemoveBacklogQuota request
	RemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveBacklogQuotaResponse, error)

	// SetBacklogQuota request
	SetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error)

	// GetBacklogQuotaMap request
	GetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetBacklogQuotaMapResponse, error)

	// GetBacklogSizeByMessageId request
	GetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetBacklogSizeByMessageIdResponse, error)

	// CompactionStatus request
	CompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*CompactionStatusResponse, error)

	// Compact request
	CompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*CompactResponse, error)

	// RemoveCompactionThreshold request
	RemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemoveCompactionThresholdResponse, error)

	// GetCompactionThreshold request
	GetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetCompactionThresholdResponse, error)

	// SetCompactionThreshold request with any body
	SetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error)

	// CreateMissedPartitions request
	CreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreateMissedPartitionsResponse, error)

	// RemoveDeduplication request
	RemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*RemoveDeduplicationResponse, error)

	// GetDeduplication request
	GetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*GetDeduplicationResponse, error)

	// SetDeduplication request with any body
	SetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationResponse, error)

	// DeleteDeduplicationSnapshotInterval request
	DeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeleteDeduplicationSnapshotIntervalResponse, error)

	// GetDeduplicationSnapshotInterval request
	GetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetDeduplicationSnapshotIntervalResponse, error)

	// SetDeduplicationSnapshotInterval request with any body
	SetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error)

	// DeleteDelayedDeliveryPolicies request
	DeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteDelayedDeliveryPoliciesResponse, error)

	// GetDelayedDeliveryPolicies request
	GetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetDelayedDeliveryPoliciesResponse, error)

	// SetDelayedDeliveryPolicies request with any body
	SetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error)

	// RemoveDispatchRate request
	RemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveDispatchRateResponse, error)

	// GetDispatchRate request
	GetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*GetDispatchRateResponse, error)

	// SetDispatchRate request with any body
	SetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error)

	// RemoveEntryFilters request
	RemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemoveEntryFiltersResponse, error)

	// GetEntryFilters request
	GetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetEntryFiltersResponse, error)

	// SetEntryFilters request with any body
	SetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersResponse, error)

	// ExamineMessage request
	ExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*ExamineMessageResponse, error)

	// DeleteInactiveTopicPolicies request
	DeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteInactiveTopicPoliciesResponse, error)

	// GetInactiveTopicPolicies request
	GetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetInactiveTopicPoliciesResponse, error)

	// SetInactiveTopicPolicies request with any body
	SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error)

	// GetManagedLedgerInfo request
	GetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetManagedLedgerInfoResponse, error)

	// GetInternalStats request
	GetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*GetInternalStatsResponse, error)

	// GetLastMessageId request
	GetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetLastMessageIdResponse, error)

	// GetMessageById request
	GetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*GetMessageByIdResponse, error)

	// RemoveMaxConsumers request
	RemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersResponse, error)

	// GetMaxConsumers request
	GetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersResponse, error)

	// SetMaxConsumers request with any body
	SetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersResponse, error)

	// RemoveMaxConsumersPerSubscription request
	RemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerSubscriptionResponse, error)

	// GetMaxConsumersPerSubscription request
	GetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerSubscriptionResponse, error)

	// SetMaxConsumersPerSubscription request with any body
	SetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error)

	// RemoveMaxMessageSize request
	RemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemoveMaxMessageSizeResponse, error)

	// GetMaxMessageSize request
	GetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetMaxMessageSizeResponse, error)

	// SetMaxMessageSize request with any body
	SetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxMessageSizeResponse, error)

	// RemoveMaxProducers request
	RemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*RemoveMaxProducersResponse, error)

	// GetMaxProducers request
	GetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*GetMaxProducersResponse, error)

	// SetMaxProducers request with any body
	SetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxProducersResponse, error)

	// RemoveMaxSubscriptionsPerTopic request
	RemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemoveMaxSubscriptionsPerTopicResponse, error)

	// GetMaxSubscriptionsPerTopic request
	GetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetMaxSubscriptionsPerTopicResponse, error)

	// SetMaxSubscriptionsPerTopic request with any body
	SetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error)

	// DeleteMaxUnackedMessagesOnConsumer request
	DeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnConsumerResponse, error)

	// GetMaxUnackedMessagesOnConsumer request
	GetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnConsumerResponse, error)

	// SetMaxUnackedMessagesOnConsumer request with any body
	SetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnConsumerResponse, error)

	// DeleteMaxUnackedMessagesOnSubscription request
	DeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnSubscriptionResponse, error)

	// GetMaxUnackedMessagesOnSubscription request
	GetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnSubscriptionResponse, error)

	// SetMaxUnackedMessagesOnSubscription request with any body
	SetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnSubscriptionResponse, error)

	// RemoveMessageTTL request
	RemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*RemoveMessageTTLResponse, error)

	// GetMessageTTL request
	GetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*GetMessageTTLResponse, error)

	// SetMessageTTL request
	SetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*SetMessageTTLResponse, error)

	// GetMessageIdByTimestamp request
	GetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetMessageIdByTimestampResponse, error)

	// OffloadStatus request
	OffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*OffloadStatusResponse, error)

	// TriggerOffload request
	TriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*TriggerOffloadResponse, error)

	// RemoveOffloadPolicies request
	RemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemoveOffloadPoliciesResponse, error)

	// GetOffloadPolicies request
	GetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetOffloadPoliciesResponse, error)

	// SetOffloadPolicies request with any body
	SetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error)

	// GetPartitionedStats request
	GetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetPartitionedStatsResponse, error)

	// DeletePartitionedTopic request
	DeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeletePartitionedTopicResponse, error)

	// GetPartitionedMetadata request
	GetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetPartitionedMetadataResponse, error)

	// UpdatePartitionedTopic request with any body
	UpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePartitionedTopicResponse, error)

	// CreatePartitionedTopic request with any body
	CreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePartitionedTopicResponse, error)

	// GetPermissionsOnTopic request
	GetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetPermissionsOnTopicResponse, error)

	// RevokePermissionsOnTopic request
	RevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnTopicResponse, error)

	// GrantPermissionsOnTopic request with any body
	GrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionsOnTopicResponse, error)

	// RemovePersistence request
	RemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*RemovePersistenceResponse, error)

	// GetPersistence request
	GetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*GetPersistenceResponse, error)

	// SetPersistence request with any body
	SetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error)

	// RemoveProperties request
	RemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*RemovePropertiesResponse, error)

	// GetProperties request
	GetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*GetPropertiesResponse, error)

	// UpdateProperties request with any body
	UpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error)

	// RemovePublishRate request
	RemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*RemovePublishRateResponse, error)

	// GetPublishRate request
	GetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*GetPublishRateResponse, error)

	// SetPublishRate request with any body
	SetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPublishRateResponse, error)

	// RemoveReplicationClusters request
	RemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemoveReplicationClustersResponse, error)

	// GetReplicationClusters request
	GetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetReplicationClustersResponse, error)

	// SetReplicationClusters request with any body
	SetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicationClustersResponse, error)

	// RemoveReplicatorDispatchRate request
	RemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveReplicatorDispatchRateResponse, error)

	// GetReplicatorDispatchRate request
	GetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetReplicatorDispatchRateResponse, error)

	// SetReplicatorDispatchRate request with any body
	SetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error)

	// RemoveRetention request
	RemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error)

	// GetRetention request
	GetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*GetRetentionResponse, error)

	// SetRetention request with any body
	SetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error)

	// RemoveSchemaCompatibilityStrategy request with any body
	RemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSchemaCompatibilityStrategyResponse, error)

	// GetSchemaCompatibilityStrategy request
	GetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetSchemaCompatibilityStrategyResponse, error)

	// SetSchemaCompatibilityStrategy request with any body
	SetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error)

	// GetSchemaValidationEnforced request
	GetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidationEnforcedResponse, error)

	// SetSchemaValidationEnforced request with any body
	SetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error)

	// DeleteShadowTopics request
	DeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeleteShadowTopicsResponse, error)

	// GetShadowTopics request
	GetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetShadowTopicsResponse, error)

	// SetShadowTopics request with any body
	SetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetShadowTopicsResponse, error)

	// GetStats request
	GetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// RemoveSubscribeRate request with any body
	RemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSubscribeRateResponse, error)

	// GetSubscribeRate request
	GetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetSubscribeRateResponse, error)

	// SetSubscribeRate request with any body
	SetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error)

	// DeleteSubscription request
	DeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// AnalyzeSubscriptionBacklog request with any body
	AnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzeSubscriptionBacklogResponse, error)

	// ExpireTopicMessages request with any body
	ExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error)

	// ExpireTopicMessages request
	ExpireTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error)

	// PeekNthMessage request
	PeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*PeekNthMessageResponse, error)

	// GetSubscriptionProperties request
	GetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetSubscriptionPropertiesResponse, error)

	// UpdateSubscriptionProperties request with any body
	UpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionPropertiesResponse, error)

	// GetReplicatedSubscriptionStatus request
	GetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetReplicatedSubscriptionStatusResponse, error)

	// SetReplicatedSubscriptionStatus request with any body
	SetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatedSubscriptionStatusResponse, error)

	// ResetCursorOnPosition request with any body
	ResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetCursorOnPositionResponse, error)

	// ResetCursor request
	ResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*ResetCursorResponse, error)

	// SkipMessages request
	SkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*SkipMessagesResponse, error)

	// SkipAllMessages request
	SkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipAllMessagesResponse, error)

	// CreateSubscription request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// RemoveSubscriptionDispatchRate request
	RemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionDispatchRateResponse, error)

	// GetSubscriptionDispatchRate request
	GetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionDispatchRateResponse, error)

	// SetSubscriptionDispatchRate request with any body
	SetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error)

	// RemoveSubscriptionTypesEnabled request
	RemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionTypesEnabledResponse, error)

	// GetSubscriptionTypesEnabled request
	GetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetSubscriptionTypesEnabledResponse, error)

	// SetSubscriptionTypesEnabled request with any body
	SetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error)

	// GetSubscriptions request
	GetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error)

	// Terminate request
	TerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*TerminateResponse, error)

	// TerminatePartitionedTopic request
	TerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminatePartitionedTopicResponse, error)

	// TruncateTopic request
	TruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*TruncateTopicResponse, error)

	// UnloadTopic request
	UnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*UnloadTopicResponse, error)

	// RemoveSubscriptionLevelDispatchRate request
	RemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionLevelDispatchRateResponse, error)

	// GetSubscriptionLevelDispatchRate request
	GetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionLevelDispatchRateResponse, error)

	// SetSubscriptionLevelDispatchRate request with any body
	SetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionLevelDispatchRateResponse, error)

	// GetDefaultResourceQuota request
	GetDefaultResourceQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultResourceQuotaResponse, error)

	// SetDefaultResourceQuota request with any body
	SetDefaultResourceQuotaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error)

	SetDefaultResourceQuotaWithResponse(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error)

	// RemoveNamespaceBundleResourceQuota request
	RemoveNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*RemoveNamespaceBundleResourceQuotaResponse, error)

	// GetNamespaceBundleResourceQuota request
	GetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetNamespaceBundleResourceQuotaResponse, error)

	// SetNamespaceBundleResourceQuota request with any body
	SetNamespaceBundleResourceQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error)

	SetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error)

	// GetResourceGroups request
	GetResourceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourceGroupsResponse, error)

	// DeleteResourceGroup request
	DeleteResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*DeleteResourceGroupResponse, error)

	// GetResourceGroup request
	GetResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*GetResourceGroupResponse, error)

	// CreateOrUpdateResourceGroup request with any body
	CreateOrUpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error)

	CreateOrUpdateResourceGroupWithResponse(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error)

	// TestCompatibility request with any body
	TestCompatibilityWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error)

	TestCompatibilityWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error)

	// DeleteSchema request
	DeleteSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResponse, error)

	// GetSchema request
	GetSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*GetSchemaResponse, error)

	// PostSchema request with any body
	PostSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error)

	PostSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error)

	// GetSchema request
	GetSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*GetSchemaResponse, error)

	// GetAllSchemas request
	GetAllSchemasWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*GetAllSchemasResponse, error)

	// GetVersionBySchema request with any body
	GetVersionBySchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error)

	GetVersionBySchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error)

	// GetTenants request
	GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error)

	// DeleteTenant request
	DeleteTenantWithResponse(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error)

	// GetTenantAdmin request
	GetTenantAdminWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantAdminResponse, error)

	// UpdateTenant request with any body
	UpdateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	UpdateTenantWithResponse(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	// CreateTenant request with any body
	CreateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	CreateTenantWithResponse(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	// GetStats request
	GetStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetMetrics request
	GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error)

	// GetAssignments request
	GetAssignmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAssignmentsResponse, error)

	// GetCluster request
	GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// GetClusterLeader request
	GetClusterLeaderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterLeaderResponse, error)

	// IsLeaderReady request
	IsLeaderReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsLeaderReadyResponse, error)

	// GetConnectorsList request
	GetConnectorsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectorsListResponse, error)

	// GetDrainStatus request
	GetDrainStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDrainStatusResponse, error)

	// Drain request
	DrainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DrainResponse, error)

	// GetDrainStatusFromLeader request
	GetDrainStatusFromLeaderWithResponse(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*GetDrainStatusFromLeaderResponse, error)

	// DrainAtLeader request
	DrainAtLeaderWithResponse(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*DrainAtLeaderResponse, error)

	// Rebalance request
	RebalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RebalanceResponse, error)
}

type GetAllBookiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookiesClusterInfo
}

// Status returns HTTPResponse.Status
func (r GetAllBookiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBookiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookiesRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]struct {
			AdditionalProperties map[string]BookieInfo `json:"-"`
		} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBookiesRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookiesRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookieInfo
}

// Status returns HTTPResponse.Status
func (r GetBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllocatorStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllocatorStats
}

// Status returns HTTPResponse.Status
func (r GetAllocatorStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllocatorStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingBookieOpsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]PendingBookieOpsStats `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPendingBookieOpsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingBookieOpsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrokerResourceAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]ResourceUnit `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBrokerResourceAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrokerResourceAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoadReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadReport
}

// Status returns HTTPResponse.Status
func (r GetLoadReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoadReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMBeansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r GetMBeansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMBeansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r GetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopics2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OutputStream
}

// Status returns HTTPResponse.Status
func (r GetTopics2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopics2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActiveBrokersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetActiveBrokersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActiveBrokersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BacklogQuotaCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BacklogQuotaCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BacklogQuotaCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDynamicConfigurationNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDynamicConfigurationNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDynamicConfigurationNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRuntimeConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDynamicConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAllDynamicConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDynamicConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDynamicConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDynamicConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDynamicConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDynamicConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateDynamicConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDynamicConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInternalConfigurationDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternalConfigurationData
}

// Status returns HTTPResponse.Status
func (r GetInternalConfigurationDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInternalConfigurationDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaderBrokerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrokerInfo
}

// Status returns HTTPResponse.Status
func (r GetLeaderBrokerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaderBrokerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IsReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShutDownBrokerGracefullyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ShutDownBrokerGracefullyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShutDownBrokerGracefullyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r VersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOwnedNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]NamespaceOwnershipStatus `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOwnedNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOwnedNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActiveBrokersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetActiveBrokersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActiveBrokersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterData
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFailureDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]FailureDomain `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFailureDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFailureDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFailureDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFailureDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFailureDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FailureDomain
}

// Status returns HTTPResponse.Status
func (r GetDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetFailureDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetFailureDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetFailureDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceIsolationPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]NamespaceIsolationData `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNamespaceIsolationPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceIsolationPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrokersWithNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BrokerNamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r GetBrokersWithNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrokersWithNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrokerWithNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrokerNamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r GetBrokerWithNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrokerWithNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r GetNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetPeerClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPeerClusterNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPeerClusterNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPeerClusterNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAntiAffinityNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetAntiAffinityNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAntiAffinityNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookieAffinityGroupData
}

// Status returns HTTPResponse.Status
func (r GetBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTenantNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policies
}

// Status returns HTTPResponse.Status
func (r GetPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBundlesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBundlesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundlesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBacklogForSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBacklogForSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBacklogForSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEncryptionRequiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEncryptionRequiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEncryptionRequiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyEncryptionRequiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyEncryptionRequiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyEncryptionRequiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryFiltersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEntryFiltersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryFiltersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEntryFiltersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetEntryFiltersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEntryFiltersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIsAllowAutoUpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIsAllowAutoUpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIsAllowAutoUpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIsAllowAutoUpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetIsAllowAutoUpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIsAllowAutoUpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxTopicsPerNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxTopicsPerNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxTopicsPerNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxUnackedmessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxUnackedmessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxUnackedmessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxUnackedMessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxUnackedMessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxUnackedMessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxUnackedMessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxUnackedMessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxUnackedMessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxUnackedmessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxUnackedmessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxUnackedmessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxUnackedmessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxUnackedmessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxUnackedmessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxUnackedMessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxUnackedMessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxUnackedMessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOffloadThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOffloadThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOffloadThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOffloadThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetOffloadThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOffloadThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPermissionOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsOnNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsOnNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsOnNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantPermissionOnNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GrantPermissionOnNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantPermissionOnNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetNamespaceReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScanOffloadedLedgersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScanOffloadedLedgersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScanOffloadedLedgersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaAutoUpdateCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetSchemaAutoUpdateCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaAutoUpdateCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaAutoUpdateCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaAutoUpdateCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaAutoUpdateCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaValidtionEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaValidtionEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaValidtionEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionAuthModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionAuthModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionAuthModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionAuthModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionAuthModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionAuthModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsubscribeNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnsubscribeNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsubscribeNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBundleBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBundleBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBundleBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBundleBacklogForSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBundleBacklogForSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBundleBacklogForSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SplitNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SplitNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SplitNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopicHashPositionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTopicHashPositionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopicHashPositionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsubscribeNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnsubscribeNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsubscribeNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartitionedTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetPartitionedTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartitionedTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListFromBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetListFromBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListFromBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNonPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNonPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNonPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireMessagesForAllSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireMessagesForAllSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireMessagesForAllSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBacklogSizeByMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBacklogSizeByMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBacklogSizeByMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompactionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompactionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompactionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMissedPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateMissedPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMissedPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExamineMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExamineMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExamineMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManagedLedgerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetManagedLedgerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManagedLedgerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInternalStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetInternalStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInternalStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLastMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMessageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageIdByTimestampResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMessageIdByTimestampResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageIdByTimestampResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OffloadStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OffloadStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OffloadStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerOffloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TriggerOffloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerOffloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartitionedStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPartitionedStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartitionedStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartitionedMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPartitionedMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartitionedMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GrantPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnalyzeSubscriptionBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AnalyzeSubscriptionBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnalyzeSubscriptionBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PeekNthMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PeekNthMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PeekNthMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetCursorOnPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetCursorOnPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetCursorOnPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetCursorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetCursorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetCursorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipAllMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipAllMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipAllMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TruncateTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TruncateTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TruncateTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartitionedTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetPartitionedTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartitionedTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNonPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNonPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNonPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireMessagesForAllSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireMessagesForAllSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireMessagesForAllSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBacklogSizeByMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBacklogSizeByMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBacklogSizeByMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompactionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompactionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompactionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMissedPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateMissedPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMissedPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExamineMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExamineMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExamineMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManagedLedgerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetManagedLedgerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManagedLedgerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInternalStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetInternalStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInternalStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLastMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLastMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLastMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMessageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageIdByTimestampResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMessageIdByTimestampResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageIdByTimestampResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OffloadStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OffloadStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OffloadStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerOffloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TriggerOffloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerOffloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartitionedStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPartitionedStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartitionedStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPartitionedMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPartitionedMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPartitionedMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GrantPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnalyzeSubscriptionBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AnalyzeSubscriptionBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnalyzeSubscriptionBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PeekNthMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PeekNthMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PeekNthMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetCursorOnPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetCursorOnPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetCursorOnPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetCursorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetCursorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetCursorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipAllMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipAllMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipAllMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TruncateTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TruncateTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TruncateTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetDefaultResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r SetDefaultResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetResourceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceGroup
}

// Status returns HTTPResponse.Status
func (r GetResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestCompatibilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IsCompatibilityResponse
}

// Status returns HTTPResponse.Status
func (r TestCompatibilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestCompatibilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteSchemaResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchemaResponse
}

// Status returns HTTPResponse.Status
func (r GetSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostSchemaResponse
}

// Status returns HTTPResponse.Status
func (r PostSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchemaResponse
}

// Status returns HTTPResponse.Status
func (r GetSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllVersionsSchemaResponse
}

// Status returns HTTPResponse.Status
func (r GetAllSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionBySchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LongSchemaVersion
}

// Status returns HTTPResponse.Status
func (r GetVersionBySchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionBySchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTenantAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerFunctionInstanceStats
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r GetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerInfo
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkerInfo
}

// Status returns HTTPResponse.Status
func (r GetClusterLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsLeaderReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IsLeaderReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsLeaderReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetConnectorsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDrainStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDrainStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDrainStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DrainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DrainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DrainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDrainStatusFromLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDrainStatusFromLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDrainStatusFromLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DrainAtLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DrainAtLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DrainAtLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RebalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllBookiesWithResponse request returning *GetAllBookiesResponse
func (c *ClientWithResponses) GetAllBookiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllBookiesResponse, error) {
	rsp, err := c.GetAllBookies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBookiesResponse(rsp)
}

// GetBookiesRackInfoWithResponse request returning *GetBookiesRackInfoResponse
func (c *ClientWithResponses) GetBookiesRackInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBookiesRackInfoResponse, error) {
	rsp, err := c.GetBookiesRackInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookiesRackInfoResponse(rsp)
}

// DeleteBookieRackInfoWithResponse request returning *DeleteBookieRackInfoResponse
func (c *ClientWithResponses) DeleteBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*DeleteBookieRackInfoResponse, error) {
	rsp, err := c.DeleteBookieRackInfo(ctx, bookie, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBookieRackInfoResponse(rsp)
}

// GetBookieRackInfoWithResponse request returning *GetBookieRackInfoResponse
func (c *ClientWithResponses) GetBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*GetBookieRackInfoResponse, error) {
	rsp, err := c.GetBookieRackInfo(ctx, bookie, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookieRackInfoResponse(rsp)
}

// UpdateBookieRackInfoWithResponse request returning *UpdateBookieRackInfoResponse
func (c *ClientWithResponses) UpdateBookieRackInfoWithResponse(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*UpdateBookieRackInfoResponse, error) {
	rsp, err := c.UpdateBookieRackInfo(ctx, bookie, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBookieRackInfoResponse(rsp)
}

// GetAllocatorStatsWithResponse request returning *GetAllocatorStatsResponse
func (c *ClientWithResponses) GetAllocatorStatsWithResponse(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*GetAllocatorStatsResponse, error) {
	rsp, err := c.GetAllocatorStats(ctx, allocator, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllocatorStatsResponse(rsp)
}

// GetPendingBookieOpsStatsWithResponse request returning *GetPendingBookieOpsStatsResponse
func (c *ClientWithResponses) GetPendingBookieOpsStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingBookieOpsStatsResponse, error) {
	rsp, err := c.GetPendingBookieOpsStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingBookieOpsStatsResponse(rsp)
}

// GetBrokerResourceAvailabilityWithResponse request returning *GetBrokerResourceAvailabilityResponse
func (c *ClientWithResponses) GetBrokerResourceAvailabilityWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBrokerResourceAvailabilityResponse, error) {
	rsp, err := c.GetBrokerResourceAvailability(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrokerResourceAvailabilityResponse(rsp)
}

// GetLoadReportWithResponse request returning *GetLoadReportResponse
func (c *ClientWithResponses) GetLoadReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoadReportResponse, error) {
	rsp, err := c.GetLoadReport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoadReportResponse(rsp)
}

// GetMBeansWithResponse request returning *GetMBeansResponse
func (c *ClientWithResponses) GetMBeansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMBeansResponse, error) {
	rsp, err := c.GetMBeans(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMBeansResponse(rsp)
}

// GetMetricsWithResponse request returning *GetMetricsResponse
func (c *ClientWithResponses) GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

// GetTopics2WithResponse request returning *GetTopics2Response
func (c *ClientWithResponses) GetTopics2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopics2Response, error) {
	rsp, err := c.GetTopics2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopics2Response(rsp)
}

// GetActiveBrokersWithResponse request returning *GetActiveBrokersResponse
func (c *ClientWithResponses) GetActiveBrokersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActiveBrokersResponse, error) {
	rsp, err := c.GetActiveBrokers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActiveBrokersResponse(rsp)
}

// BacklogQuotaCheckWithResponse request returning *BacklogQuotaCheckResponse
func (c *ClientWithResponses) BacklogQuotaCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BacklogQuotaCheckResponse, error) {
	rsp, err := c.BacklogQuotaCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBacklogQuotaCheckResponse(rsp)
}

// GetDynamicConfigurationNameWithResponse request returning *GetDynamicConfigurationNameResponse
func (c *ClientWithResponses) GetDynamicConfigurationNameWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDynamicConfigurationNameResponse, error) {
	rsp, err := c.GetDynamicConfigurationName(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDynamicConfigurationNameResponse(rsp)
}

// GetRuntimeConfigurationWithResponse request returning *GetRuntimeConfigurationResponse
func (c *ClientWithResponses) GetRuntimeConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeConfigurationResponse, error) {
	rsp, err := c.GetRuntimeConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeConfigurationResponse(rsp)
}

// GetAllDynamicConfigurationsWithResponse request returning *GetAllDynamicConfigurationsResponse
func (c *ClientWithResponses) GetAllDynamicConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDynamicConfigurationsResponse, error) {
	rsp, err := c.GetAllDynamicConfigurations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDynamicConfigurationsResponse(rsp)
}

// DeleteDynamicConfigurationWithResponse request returning *DeleteDynamicConfigurationResponse
func (c *ClientWithResponses) DeleteDynamicConfigurationWithResponse(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*DeleteDynamicConfigurationResponse, error) {
	rsp, err := c.DeleteDynamicConfiguration(ctx, configName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDynamicConfigurationResponse(rsp)
}

// UpdateDynamicConfigurationWithResponse request returning *UpdateDynamicConfigurationResponse
func (c *ClientWithResponses) UpdateDynamicConfigurationWithResponse(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*UpdateDynamicConfigurationResponse, error) {
	rsp, err := c.UpdateDynamicConfiguration(ctx, configName, configValue, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDynamicConfigurationResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// GetInternalConfigurationDataWithResponse request returning *GetInternalConfigurationDataResponse
func (c *ClientWithResponses) GetInternalConfigurationDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInternalConfigurationDataResponse, error) {
	rsp, err := c.GetInternalConfigurationData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInternalConfigurationDataResponse(rsp)
}

// GetLeaderBrokerWithResponse request returning *GetLeaderBrokerResponse
func (c *ClientWithResponses) GetLeaderBrokerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeaderBrokerResponse, error) {
	rsp, err := c.GetLeaderBroker(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaderBrokerResponse(rsp)
}

// IsReadyWithResponse request returning *IsReadyResponse
func (c *ClientWithResponses) IsReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsReadyResponse, error) {
	rsp, err := c.IsReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsReadyResponse(rsp)
}

// ShutDownBrokerGracefullyWithResponse request returning *ShutDownBrokerGracefullyResponse
func (c *ClientWithResponses) ShutDownBrokerGracefullyWithResponse(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*ShutDownBrokerGracefullyResponse, error) {
	rsp, err := c.ShutDownBrokerGracefully(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShutDownBrokerGracefullyResponse(rsp)
}

// VersionWithResponse request returning *VersionResponse
func (c *ClientWithResponses) VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error) {
	rsp, err := c.Version(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionResponse(rsp)
}

// GetOwnedNamespacesWithResponse request returning *GetOwnedNamespacesResponse
func (c *ClientWithResponses) GetOwnedNamespacesWithResponse(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*GetOwnedNamespacesResponse, error) {
	rsp, err := c.GetOwnedNamespaces(ctx, clusterName, brokerWebserviceurl, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOwnedNamespacesResponse(rsp)
}

// GetActiveBrokersWithResponse request returning *GetActiveBrokersResponse
func (c *ClientWithResponses) GetActiveBrokersWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetActiveBrokersResponse, error) {
	rsp, err := c.GetActiveBrokers(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActiveBrokersResponse(rsp)
}

// GetClustersWithResponse request returning *GetClustersResponse
func (c *ClientWithResponses) GetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClustersResponse, error) {
	rsp, err := c.GetClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClustersResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// GetFailureDomainsWithResponse request returning *GetFailureDomainsResponse
func (c *ClientWithResponses) GetFailureDomainsWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetFailureDomainsResponse, error) {
	rsp, err := c.GetFailureDomains(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFailureDomainsResponse(rsp)
}

// DeleteFailureDomainWithResponse request returning *DeleteFailureDomainResponse
func (c *ClientWithResponses) DeleteFailureDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*DeleteFailureDomainResponse, error) {
	rsp, err := c.DeleteFailureDomain(ctx, cluster, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFailureDomainResponse(rsp)
}

// GetDomainWithResponse request returning *GetDomainResponse
func (c *ClientWithResponses) GetDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*GetDomainResponse, error) {
	rsp, err := c.GetDomain(ctx, cluster, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainResponse(rsp)
}

// SetFailureDomainWithBodyWithResponse request with arbitrary body returning *SetFailureDomainResponse
func (c *ClientWithResponses) SetFailureDomainWithBodyWithResponse(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFailureDomainResponse, error) {
	rsp, err := c.SetFailureDomainWithBody(ctx, cluster, domainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFailureDomainResponse(rsp)
}

// GetNamespaceIsolationPoliciesWithResponse request returning *GetNamespaceIsolationPoliciesResponse
func (c *ClientWithResponses) GetNamespaceIsolationPoliciesWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPoliciesResponse, error) {
	rsp, err := c.GetNamespaceIsolationPolicies(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceIsolationPoliciesResponse(rsp)
}

// GetBrokersWithNamespaceIsolationPolicyWithResponse request returning *GetBrokersWithNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) GetBrokersWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetBrokersWithNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.GetBrokersWithNamespaceIsolationPolicy(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrokersWithNamespaceIsolationPolicyResponse(rsp)
}

// GetBrokerWithNamespaceIsolationPolicyWithResponse request returning *GetBrokerWithNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) GetBrokerWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*GetBrokerWithNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.GetBrokerWithNamespaceIsolationPolicy(ctx, cluster, broker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrokerWithNamespaceIsolationPolicyResponse(rsp)
}

// DeleteNamespaceIsolationPolicyWithResponse request returning *DeleteNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) DeleteNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*DeleteNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.DeleteNamespaceIsolationPolicy(ctx, cluster, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceIsolationPolicyResponse(rsp)
}

// GetNamespaceIsolationPolicyWithResponse request returning *GetNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) GetNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.GetNamespaceIsolationPolicy(ctx, cluster, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceIsolationPolicyResponse(rsp)
}

// SetNamespaceIsolationPolicyWithBodyWithResponse request with arbitrary body returning *SetNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) SetNamespaceIsolationPolicyWithBodyWithResponse(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.SetNamespaceIsolationPolicyWithBody(ctx, cluster, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceIsolationPolicyResponse(rsp)
}

// GetPeerClusterWithResponse request returning *GetPeerClusterResponse
func (c *ClientWithResponses) GetPeerClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetPeerClusterResponse, error) {
	rsp, err := c.GetPeerCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerClusterResponse(rsp)
}

// SetPeerClusterNamesWithBodyWithResponse request with arbitrary body returning *SetPeerClusterNamesResponse
func (c *ClientWithResponses) SetPeerClusterNamesWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPeerClusterNamesResponse, error) {
	rsp, err := c.SetPeerClusterNamesWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPeerClusterNamesResponse(rsp)
}

// GetAntiAffinityNamespacesWithResponse request returning *GetAntiAffinityNamespacesResponse
func (c *ClientWithResponses) GetAntiAffinityNamespacesWithResponse(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*GetAntiAffinityNamespacesResponse, error) {
	rsp, err := c.GetAntiAffinityNamespaces(ctx, cluster, group, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAntiAffinityNamespacesResponse(rsp)
}

// DeleteBookieAffinityGroupWithResponse request returning *DeleteBookieAffinityGroupResponse
func (c *ClientWithResponses) DeleteBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*DeleteBookieAffinityGroupResponse, error) {
	rsp, err := c.DeleteBookieAffinityGroup(ctx, property, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBookieAffinityGroupResponse(rsp)
}

// GetBookieAffinityGroupWithResponse request returning *GetBookieAffinityGroupResponse
func (c *ClientWithResponses) GetBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*GetBookieAffinityGroupResponse, error) {
	rsp, err := c.GetBookieAffinityGroup(ctx, property, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookieAffinityGroupResponse(rsp)
}

// GetTenantNamespacesWithResponse request returning *GetTenantNamespacesResponse
func (c *ClientWithResponses) GetTenantNamespacesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantNamespacesResponse, error) {
	rsp, err := c.GetTenantNamespaces(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantNamespacesResponse(rsp)
}

// DeleteNamespaceWithResponse request returning *DeleteNamespaceResponse
func (c *ClientWithResponses) DeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceResponse, error) {
	rsp, err := c.DeleteNamespace(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceResponse(rsp)
}

// GetPoliciesWithResponse request returning *GetPoliciesResponse
func (c *ClientWithResponses) GetPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPoliciesResponse, error) {
	rsp, err := c.GetPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPoliciesResponse(rsp)
}

// CreateNamespaceWithBodyWithResponse request with arbitrary body returning *CreateNamespaceResponse
func (c *ClientWithResponses) CreateNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error) {
	rsp, err := c.CreateNamespaceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceResponse(rsp)
}

func (c *ClientWithResponses) CreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error) {
	rsp, err := c.CreateNamespace(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceResponse(rsp)
}

// RemoveNamespaceAntiAffinityGroupWithResponse request returning *RemoveNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) RemoveNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.RemoveNamespaceAntiAffinityGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceAntiAffinityGroupResponse(rsp)
}

// GetNamespaceAntiAffinityGroupWithResponse request returning *GetNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) GetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.GetNamespaceAntiAffinityGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceAntiAffinityGroupResponse(rsp)
}

// SetNamespaceAntiAffinityGroupWithBodyWithResponse request with arbitrary body returning *SetNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) SetNamespaceAntiAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.SetNamespaceAntiAffinityGroupWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceAntiAffinityGroupResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.SetNamespaceAntiAffinityGroup(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceAntiAffinityGroupResponse(rsp)
}

// RemoveAutoSubscriptionCreationWithResponse request returning *RemoveAutoSubscriptionCreationResponse
func (c *ClientWithResponses) RemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoSubscriptionCreationResponse, error) {
	rsp, err := c.RemoveAutoSubscriptionCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAutoSubscriptionCreationResponse(rsp)
}

// GetAutoSubscriptionCreationWithResponse request returning *GetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) GetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.GetAutoSubscriptionCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoSubscriptionCreationResponse(rsp)
}

// SetAutoSubscriptionCreationWithBodyWithResponse request with arbitrary body returning *SetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) SetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.SetAutoSubscriptionCreationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoSubscriptionCreationResponse(rsp)
}

func (c *ClientWithResponses) SetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.SetAutoSubscriptionCreation(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoSubscriptionCreationResponse(rsp)
}

// RemoveAutoTopicCreationWithResponse request returning *RemoveAutoTopicCreationResponse
func (c *ClientWithResponses) RemoveAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoTopicCreationResponse, error) {
	rsp, err := c.RemoveAutoTopicCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAutoTopicCreationResponse(rsp)
}

// GetAutoTopicCreationWithResponse request returning *GetAutoTopicCreationResponse
func (c *ClientWithResponses) GetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoTopicCreationResponse, error) {
	rsp, err := c.GetAutoTopicCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoTopicCreationResponse(rsp)
}

// SetAutoTopicCreationWithBodyWithResponse request with arbitrary body returning *SetAutoTopicCreationResponse
func (c *ClientWithResponses) SetAutoTopicCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error) {
	rsp, err := c.SetAutoTopicCreationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoTopicCreationResponse(rsp)
}

func (c *ClientWithResponses) SetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error) {
	rsp, err := c.SetAutoTopicCreation(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoTopicCreationResponse(rsp)
}

// RemoveBacklogQuotaWithResponse request returning *RemoveBacklogQuotaResponse
func (c *ClientWithResponses) RemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveBacklogQuotaResponse, error) {
	rsp, err := c.RemoveBacklogQuota(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveBacklogQuotaResponse(rsp)
}

// SetBacklogQuotaWithBodyWithResponse request with arbitrary body returning *SetBacklogQuotaResponse
func (c *ClientWithResponses) SetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error) {
	rsp, err := c.SetBacklogQuotaWithBody(ctx, tenant, namespace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBacklogQuotaResponse(rsp)
}

func (c *ClientWithResponses) SetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *SetBacklogQuotaParams, body SetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error) {
	rsp, err := c.SetBacklogQuota(ctx, tenant, namespace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBacklogQuotaResponse(rsp)
}

// GetBacklogQuotaMapWithResponse request returning *GetBacklogQuotaMapResponse
func (c *ClientWithResponses) GetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBacklogQuotaMapResponse, error) {
	rsp, err := c.GetBacklogQuotaMap(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBacklogQuotaMapResponse(rsp)
}

// GetBundlesDataWithResponse request returning *GetBundlesDataResponse
func (c *ClientWithResponses) GetBundlesDataWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBundlesDataResponse, error) {
	rsp, err := c.GetBundlesData(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundlesDataResponse(rsp)
}

// ClearNamespaceBacklogWithResponse request returning *ClearNamespaceBacklogResponse
func (c *ClientWithResponses) ClearNamespaceBacklogWithResponse(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogResponse, error) {
	rsp, err := c.ClearNamespaceBacklog(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBacklogResponse(rsp)
}

// ClearNamespaceBacklogForSubscriptionWithResponse request returning *ClearNamespaceBacklogForSubscriptionResponse
func (c *ClientWithResponses) ClearNamespaceBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogForSubscriptionResponse, error) {
	rsp, err := c.ClearNamespaceBacklogForSubscription(ctx, tenant, namespace, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBacklogForSubscriptionResponse(rsp)
}

// DeleteCompactionThresholdWithResponse request returning *DeleteCompactionThresholdResponse
func (c *ClientWithResponses) DeleteCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteCompactionThresholdResponse, error) {
	rsp, err := c.DeleteCompactionThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCompactionThresholdResponse(rsp)
}

// GetCompactionThresholdWithResponse request returning *GetCompactionThresholdResponse
func (c *ClientWithResponses) GetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetCompactionThresholdResponse, error) {
	rsp, err := c.GetCompactionThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompactionThresholdResponse(rsp)
}

// SetCompactionThresholdWithBodyWithResponse request with arbitrary body returning *SetCompactionThresholdResponse
func (c *ClientWithResponses) SetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error) {
	rsp, err := c.SetCompactionThresholdWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCompactionThresholdResponse(rsp)
}

func (c *ClientWithResponses) SetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error) {
	rsp, err := c.SetCompactionThreshold(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCompactionThresholdResponse(rsp)
}

// RemoveDeduplicationWithResponse request returning *RemoveDeduplicationResponse
func (c *ClientWithResponses) RemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveDeduplicationResponse, error) {
	rsp, err := c.RemoveDeduplication(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDeduplicationResponse(rsp)
}

// GetDeduplicationWithResponse request returning *GetDeduplicationResponse
func (c *ClientWithResponses) GetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDeduplicationResponse, error) {
	rsp, err := c.GetDeduplication(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeduplicationResponse(rsp)
}

// ModifyDeduplicationWithBodyWithResponse request with arbitrary body returning *ModifyDeduplicationResponse
func (c *ClientWithResponses) ModifyDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error) {
	rsp, err := c.ModifyDeduplicationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyDeduplicationResponse(rsp)
}

func (c *ClientWithResponses) ModifyDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error) {
	rsp, err := c.ModifyDeduplication(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyDeduplicationResponse(rsp)
}

// GetDeduplicationSnapshotIntervalWithResponse request returning *GetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) GetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.GetDeduplicationSnapshotInterval(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeduplicationSnapshotIntervalResponse(rsp)
}

// SetDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *SetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) SetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDeduplicationSnapshotIntervalResponse(rsp)
}

func (c *ClientWithResponses) SetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, body SetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetDeduplicationSnapshotInterval(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDeduplicationSnapshotIntervalResponse(rsp)
}

// RemoveDelayedDeliveryPoliciesWithResponse request returning *RemoveDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) RemoveDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.RemoveDelayedDeliveryPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDelayedDeliveryPoliciesResponse(rsp)
}

// GetDelayedDeliveryPoliciesWithResponse request returning *GetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) GetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.GetDelayedDeliveryPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDelayedDeliveryPoliciesResponse(rsp)
}

// SetDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *SetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) SetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDelayedDeliveryPoliciesResponse(rsp)
}

func (c *ClientWithResponses) SetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetDelayedDeliveryPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDelayedDeliveryPoliciesResponse(rsp)
}

// DeleteDispatchRateWithResponse request returning *DeleteDispatchRateResponse
func (c *ClientWithResponses) DeleteDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteDispatchRateResponse, error) {
	rsp, err := c.DeleteDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDispatchRateResponse(rsp)
}

// GetDispatchRateWithResponse request returning *GetDispatchRateResponse
func (c *ClientWithResponses) GetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetDispatchRateResponse, error) {
	rsp, err := c.GetDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDispatchRateResponse(rsp)
}

// SetDispatchRateWithBodyWithResponse request with arbitrary body returning *SetDispatchRateResponse
func (c *ClientWithResponses) SetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error) {
	rsp, err := c.SetDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) SetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error) {
	rsp, err := c.SetDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDispatchRateResponse(rsp)
}

// GetEncryptionRequiredWithResponse request returning *GetEncryptionRequiredResponse
func (c *ClientWithResponses) GetEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetEncryptionRequiredResponse, error) {
	rsp, err := c.GetEncryptionRequired(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEncryptionRequiredResponse(rsp)
}

// ModifyEncryptionRequiredWithBodyWithResponse request with arbitrary body returning *ModifyEncryptionRequiredResponse
func (c *ClientWithResponses) ModifyEncryptionRequiredWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error) {
	rsp, err := c.ModifyEncryptionRequiredWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyEncryptionRequiredResponse(rsp)
}

func (c *ClientWithResponses) ModifyEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error) {
	rsp, err := c.ModifyEncryptionRequired(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyEncryptionRequiredResponse(rsp)
}

// RemoveNamespaceEntryFiltersWithResponse request returning *RemoveNamespaceEntryFiltersResponse
func (c *ClientWithResponses) RemoveNamespaceEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceEntryFiltersResponse, error) {
	rsp, err := c.RemoveNamespaceEntryFilters(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceEntryFiltersResponse(rsp)
}

// GetEntryFiltersPerTopicWithResponse request returning *GetEntryFiltersPerTopicResponse
func (c *ClientWithResponses) GetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.GetEntryFiltersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryFiltersPerTopicResponse(rsp)
}

// SetEntryFiltersPerTopicWithBodyWithResponse request with arbitrary body returning *SetEntryFiltersPerTopicResponse
func (c *ClientWithResponses) SetEntryFiltersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.SetEntryFiltersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEntryFiltersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.SetEntryFiltersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEntryFiltersPerTopicResponse(rsp)
}

// RemoveInactiveTopicPoliciesWithResponse request returning *RemoveInactiveTopicPoliciesResponse
func (c *ClientWithResponses) RemoveInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveInactiveTopicPoliciesResponse, error) {
	rsp, err := c.RemoveInactiveTopicPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveInactiveTopicPoliciesResponse(rsp)
}

// GetInactiveTopicPoliciesWithResponse request returning *GetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) GetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.GetInactiveTopicPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInactiveTopicPoliciesResponse(rsp)
}

// SetInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *SetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetInactiveTopicPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInactiveTopicPoliciesResponse(rsp)
}

func (c *ClientWithResponses) SetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetInactiveTopicPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInactiveTopicPoliciesResponse(rsp)
}

// GetIsAllowAutoUpdateSchemaWithResponse request returning *GetIsAllowAutoUpdateSchemaResponse
func (c *ClientWithResponses) GetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.GetIsAllowAutoUpdateSchema(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIsAllowAutoUpdateSchemaResponse(rsp)
}

// SetIsAllowAutoUpdateSchemaWithBodyWithResponse request with arbitrary body returning *SetIsAllowAutoUpdateSchemaResponse
func (c *ClientWithResponses) SetIsAllowAutoUpdateSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.SetIsAllowAutoUpdateSchemaWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIsAllowAutoUpdateSchemaResponse(rsp)
}

func (c *ClientWithResponses) SetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.SetIsAllowAutoUpdateSchema(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIsAllowAutoUpdateSchemaResponse(rsp)
}

// RemoveMaxConsumersPerSubscriptionWithResponse request returning *RemoveMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) RemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.RemoveMaxConsumersPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxConsumersPerSubscriptionResponse(rsp)
}

// GetMaxConsumersPerSubscriptionWithResponse request returning *GetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) GetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.GetMaxConsumersPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxConsumersPerSubscriptionResponse(rsp)
}

// SetMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) SetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersPerSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) SetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetMaxConsumersPerSubscription(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersPerSubscriptionResponse(rsp)
}

// RemoveMaxConsumersPerTopicWithResponse request returning *RemoveMaxConsumersPerTopicResponse
func (c *ClientWithResponses) RemoveMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerTopicResponse, error) {
	rsp, err := c.RemoveMaxConsumersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxConsumersPerTopicResponse(rsp)
}

// GetMaxConsumersPerTopicWithResponse request returning *GetMaxConsumersPerTopicResponse
func (c *ClientWithResponses) GetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerTopicResponse, error) {
	rsp, err := c.GetMaxConsumersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxConsumersPerTopicResponse(rsp)
}

// SetMaxConsumersPerTopicWithBodyWithResponse request with arbitrary body returning *SetMaxConsumersPerTopicResponse
func (c *ClientWithResponses) SetMaxConsumersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerTopicResponse, error) {
	rsp, err := c.SetMaxConsumersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerTopicResponse, error) {
	rsp, err := c.SetMaxConsumersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersPerTopicResponse(rsp)
}

// RemoveMaxProducersPerTopicWithResponse request returning *RemoveMaxProducersPerTopicResponse
func (c *ClientWithResponses) RemoveMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxProducersPerTopicResponse, error) {
	rsp, err := c.RemoveMaxProducersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxProducersPerTopicResponse(rsp)
}

// GetMaxProducersPerTopicWithResponse request returning *GetMaxProducersPerTopicResponse
func (c *ClientWithResponses) GetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxProducersPerTopicResponse, error) {
	rsp, err := c.GetMaxProducersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxProducersPerTopicResponse(rsp)
}

// SetMaxProducersPerTopicWithBodyWithResponse request with arbitrary body returning *SetMaxProducersPerTopicResponse
func (c *ClientWithResponses) SetMaxProducersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxProducersPerTopicResponse, error) {
	rsp, err := c.SetMaxProducersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxProducersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxProducersPerTopicResponse, error) {
	rsp, err := c.SetMaxProducersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxProducersPerTopicResponse(rsp)
}

// RemoveMaxSubscriptionsPerTopicWithResponse request returning *RemoveMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) RemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.RemoveMaxSubscriptionsPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxSubscriptionsPerTopicResponse(rsp)
}

// GetMaxSubscriptionsPerTopicWithResponse request returning *GetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) GetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.GetMaxSubscriptionsPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxSubscriptionsPerTopicResponse(rsp)
}

// SetMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *SetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) SetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxSubscriptionsPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetMaxSubscriptionsPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxSubscriptionsPerTopicResponse(rsp)
}

// SetInactiveTopicPoliciesWithResponse request returning *SetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetInactiveTopicPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInactiveTopicPoliciesResponse(rsp)
}

// GetMaxTopicsPerNamespaceWithResponse request returning *GetMaxTopicsPerNamespaceResponse
func (c *ClientWithResponses) GetMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.GetMaxTopicsPerNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxTopicsPerNamespaceResponse(rsp)
}

// SetInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *SetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetInactiveTopicPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInactiveTopicPoliciesResponse(rsp)
}

func (c *ClientWithResponses) SetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetInactiveTopicPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInactiveTopicPoliciesResponse(rsp)
}

// RemoveMaxUnackedmessagesPerConsumerWithResponse request returning *RemoveMaxUnackedmessagesPerConsumerResponse
func (c *ClientWithResponses) RemoveMaxUnackedmessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxUnackedmessagesPerConsumerResponse, error) {
	rsp, err := c.RemoveMaxUnackedmessagesPerConsumer(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxUnackedmessagesPerConsumerResponse(rsp)
}

// GetMaxUnackedMessagesPerConsumerWithResponse request returning *GetMaxUnackedMessagesPerConsumerResponse
func (c *ClientWithResponses) GetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.GetMaxUnackedMessagesPerConsumer(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxUnackedMessagesPerConsumerResponse(rsp)
}

// SetMaxUnackedMessagesPerConsumerWithBodyWithResponse request with arbitrary body returning *SetMaxUnackedMessagesPerConsumerResponse
func (c *ClientWithResponses) SetMaxUnackedMessagesPerConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesPerConsumerWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesPerConsumerResponse(rsp)
}

func (c *ClientWithResponses) SetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesPerConsumer(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesPerConsumerResponse(rsp)
}

// RemoveMaxUnackedmessagesPerSubscriptionWithResponse request returning *RemoveMaxUnackedmessagesPerSubscriptionResponse
func (c *ClientWithResponses) RemoveMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMaxUnackedmessagesPerSubscriptionResponse, error) {
	rsp, err := c.RemoveMaxUnackedmessagesPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxUnackedmessagesPerSubscriptionResponse(rsp)
}

// GetMaxUnackedmessagesPerSubscriptionWithResponse request returning *GetMaxUnackedmessagesPerSubscriptionResponse
func (c *ClientWithResponses) GetMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetMaxUnackedmessagesPerSubscriptionResponse, error) {
	rsp, err := c.GetMaxUnackedmessagesPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxUnackedmessagesPerSubscriptionResponse(rsp)
}

// SetMaxUnackedMessagesPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetMaxUnackedMessagesPerSubscriptionResponse
func (c *ClientWithResponses) SetMaxUnackedMessagesPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerSubscriptionResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesPerSubscriptionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesPerSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) SetMaxUnackedMessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesPerSubscriptionResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesPerSubscription(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesPerSubscriptionResponse(rsp)
}

// RemoveNamespaceMessageTTLWithResponse request returning *RemoveNamespaceMessageTTLResponse
func (c *ClientWithResponses) RemoveNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMessageTTLResponse, error) {
	rsp, err := c.RemoveNamespaceMessageTTL(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMessageTTLResponse(rsp)
}

// GetNamespaceMessageTTLWithResponse request returning *GetNamespaceMessageTTLResponse
func (c *ClientWithResponses) GetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMessageTTLResponse, error) {
	rsp, err := c.GetNamespaceMessageTTL(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMessageTTLResponse(rsp)
}

// SetNamespaceMessageTTLWithBodyWithResponse request with arbitrary body returning *SetNamespaceMessageTTLResponse
func (c *ClientWithResponses) SetNamespaceMessageTTLWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error) {
	rsp, err := c.SetNamespaceMessageTTLWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMessageTTLResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error) {
	rsp, err := c.SetNamespaceMessageTTL(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMessageTTLResponse(rsp)
}

// ClearOffloadDeletionLagWithResponse request returning *ClearOffloadDeletionLagResponse
func (c *ClientWithResponses) ClearOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearOffloadDeletionLagResponse, error) {
	rsp, err := c.ClearOffloadDeletionLag(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearOffloadDeletionLagResponse(rsp)
}

// GetOffloadDeletionLagWithResponse request returning *GetOffloadDeletionLagResponse
func (c *ClientWithResponses) GetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetOffloadDeletionLagResponse, error) {
	rsp, err := c.GetOffloadDeletionLag(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOffloadDeletionLagResponse(rsp)
}

// SetOffloadDeletionLagWithBodyWithResponse request with arbitrary body returning *SetOffloadDeletionLagResponse
func (c *ClientWithResponses) SetOffloadDeletionLagWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadDeletionLagResponse, error) {
	rsp, err := c.SetOffloadDeletionLagWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadDeletionLagResponse(rsp)
}

func (c *ClientWithResponses) SetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, body SetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOffloadDeletionLagResponse, error) {
	rsp, err := c.SetOffloadDeletionLag(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadDeletionLagResponse(rsp)
}

// GetOffloadPoliciesWithResponse request returning *GetOffloadPoliciesResponse
func (c *ClientWithResponses) GetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetOffloadPoliciesResponse, error) {
	rsp, err := c.GetOffloadPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOffloadPoliciesResponse(rsp)
}

// SetOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *SetOffloadPoliciesResponse
func (c *ClientWithResponses) SetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error) {
	rsp, err := c.SetOffloadPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadPoliciesResponse(rsp)
}

func (c *ClientWithResponses) SetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error) {
	rsp, err := c.SetOffloadPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadPoliciesResponse(rsp)
}

// GetOffloadThresholdWithResponse request returning *GetOffloadThresholdResponse
func (c *ClientWithResponses) GetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetOffloadThresholdResponse, error) {
	rsp, err := c.GetOffloadThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOffloadThresholdResponse(rsp)
}

// SetOffloadThresholdWithBodyWithResponse request with arbitrary body returning *SetOffloadThresholdResponse
func (c *ClientWithResponses) SetOffloadThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadThresholdResponse, error) {
	rsp, err := c.SetOffloadThresholdWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadThresholdResponse(rsp)
}

func (c *ClientWithResponses) SetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOffloadThresholdResponse, error) {
	rsp, err := c.SetOffloadThreshold(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadThresholdResponse(rsp)
}

// GetPermissionsWithResponse request returning *GetPermissionsResponse
func (c *ClientWithResponses) GetPermissionsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionsResponse, error) {
	rsp, err := c.GetPermissions(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsResponse(rsp)
}

// GetPermissionOnSubscriptionWithResponse request returning *GetPermissionOnSubscriptionResponse
func (c *ClientWithResponses) GetPermissionOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionOnSubscriptionResponse, error) {
	rsp, err := c.GetPermissionOnSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionOnSubscriptionResponse(rsp)
}

// RevokePermissionsOnNamespaceWithResponse request returning *RevokePermissionsOnNamespaceResponse
func (c *ClientWithResponses) RevokePermissionsOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnNamespaceResponse, error) {
	rsp, err := c.RevokePermissionsOnNamespace(ctx, tenant, namespace, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsOnNamespaceResponse(rsp)
}

// GrantPermissionOnNamespaceWithBodyWithResponse request with arbitrary body returning *GrantPermissionOnNamespaceResponse
func (c *ClientWithResponses) GrantPermissionOnNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error) {
	rsp, err := c.GrantPermissionOnNamespaceWithBody(ctx, tenant, namespace, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantPermissionOnNamespaceResponse(rsp)
}

func (c *ClientWithResponses) GrantPermissionOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error) {
	rsp, err := c.GrantPermissionOnNamespace(ctx, tenant, namespace, role, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantPermissionOnNamespaceResponse(rsp)
}

// DeletePersistenceWithResponse request returning *DeletePersistenceResponse
func (c *ClientWithResponses) DeletePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeletePersistenceResponse, error) {
	rsp, err := c.DeletePersistence(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistenceResponse(rsp)
}

// GetPersistenceWithResponse request returning *GetPersistenceResponse
func (c *ClientWithResponses) GetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPersistenceResponse, error) {
	rsp, err := c.GetPersistence(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistenceResponse(rsp)
}

// SetPersistenceWithBodyWithResponse request with arbitrary body returning *SetPersistenceResponse
func (c *ClientWithResponses) SetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error) {
	rsp, err := c.SetPersistenceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistenceResponse(rsp)
}

func (c *ClientWithResponses) SetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, body SetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error) {
	rsp, err := c.SetPersistence(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistenceResponse(rsp)
}

// SetBookieAffinityGroupWithBodyWithResponse request with arbitrary body returning *SetBookieAffinityGroupResponse
func (c *ClientWithResponses) SetBookieAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error) {
	rsp, err := c.SetBookieAffinityGroupWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBookieAffinityGroupResponse(rsp)
}

func (c *ClientWithResponses) SetBookieAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error) {
	rsp, err := c.SetBookieAffinityGroup(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBookieAffinityGroupResponse(rsp)
}

// ClearPropertiesWithResponse request returning *ClearPropertiesResponse
func (c *ClientWithResponses) ClearPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearPropertiesResponse, error) {
	rsp, err := c.ClearProperties(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearPropertiesResponse(rsp)
}

// GetPropertiesWithResponse request returning *GetPropertiesResponse
func (c *ClientWithResponses) GetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPropertiesResponse, error) {
	rsp, err := c.GetProperties(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPropertiesResponse(rsp)
}

// SetPropertiesWithBodyWithResponse request with arbitrary body returning *SetPropertiesResponse
func (c *ClientWithResponses) SetPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error) {
	rsp, err := c.SetPropertiesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPropertiesResponse(rsp)
}

func (c *ClientWithResponses) SetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error) {
	rsp, err := c.SetProperties(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPropertiesResponse(rsp)
}

// RemovePropertyWithResponse request returning *RemovePropertyResponse
func (c *ClientWithResponses) RemovePropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*RemovePropertyResponse, error) {
	rsp, err := c.RemoveProperty(ctx, tenant, namespace, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePropertyResponse(rsp)
}

// GetPropertyWithResponse request returning *GetPropertyResponse
func (c *ClientWithResponses) GetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*GetPropertyResponse, error) {
	rsp, err := c.GetProperty(ctx, tenant, namespace, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPropertyResponse(rsp)
}

// SetPropertyWithResponse request returning *SetPropertyResponse
func (c *ClientWithResponses) SetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*SetPropertyResponse, error) {
	rsp, err := c.SetProperty(ctx, tenant, namespace, key, value, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPropertyResponse(rsp)
}

// RemoveOffloadPoliciesWithResponse request returning *RemoveOffloadPoliciesResponse
func (c *ClientWithResponses) RemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveOffloadPoliciesResponse, error) {
	rsp, err := c.RemoveOffloadPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOffloadPoliciesResponse(rsp)
}

// GetNamespaceReplicationClustersWithResponse request returning *GetNamespaceReplicationClustersResponse
func (c *ClientWithResponses) GetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.GetNamespaceReplicationClusters(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceReplicationClustersResponse(rsp)
}

// SetNamespaceReplicationClustersWithBodyWithResponse request with arbitrary body returning *SetNamespaceReplicationClustersResponse
func (c *ClientWithResponses) SetNamespaceReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.SetNamespaceReplicationClustersWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceReplicationClustersResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.SetNamespaceReplicationClusters(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceReplicationClustersResponse(rsp)
}

// RemoveReplicatorDispatchRateWithResponse request returning *RemoveReplicatorDispatchRateResponse
func (c *ClientWithResponses) RemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveReplicatorDispatchRateResponse, error) {
	rsp, err := c.RemoveReplicatorDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveReplicatorDispatchRateResponse(rsp)
}

// GetReplicatorDispatchRateWithResponse request returning *GetReplicatorDispatchRateResponse
func (c *ClientWithResponses) GetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetReplicatorDispatchRateResponse, error) {
	rsp, err := c.GetReplicatorDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicatorDispatchRateResponse(rsp)
}

// SetReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *SetReplicatorDispatchRateResponse
func (c *ClientWithResponses) SetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetReplicatorDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicatorDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) SetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetReplicatorDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicatorDispatchRateResponse(rsp)
}

// RemoveNamespaceResourceGroupWithResponse request returning *RemoveNamespaceResourceGroupResponse
func (c *ClientWithResponses) RemoveNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceResourceGroupResponse, error) {
	rsp, err := c.RemoveNamespaceResourceGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceResourceGroupResponse(rsp)
}

// GetNamespaceResourceGroupWithResponse request returning *GetNamespaceResourceGroupResponse
func (c *ClientWithResponses) GetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceResourceGroupResponse, error) {
	rsp, err := c.GetNamespaceResourceGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceResourceGroupResponse(rsp)
}

// SetNamespaceResourceGroupWithResponse request returning *SetNamespaceResourceGroupResponse
func (c *ClientWithResponses) SetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*SetNamespaceResourceGroupResponse, error) {
	rsp, err := c.SetNamespaceResourceGroup(ctx, tenant, namespace, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceResourceGroupResponse(rsp)
}

// RemoveRetentionWithBodyWithResponse request with arbitrary body returning *RemoveRetentionResponse
func (c *ClientWithResponses) RemoveRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error) {
	rsp, err := c.RemoveRetentionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRetentionResponse(rsp)
}

func (c *ClientWithResponses) RemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, body RemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error) {
	rsp, err := c.RemoveRetention(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRetentionResponse(rsp)
}

// GetRetentionWithResponse request returning *GetRetentionResponse
func (c *ClientWithResponses) GetRetentionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetRetentionResponse, error) {
	rsp, err := c.GetRetention(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRetentionResponse(rsp)
}

// SetRetentionWithBodyWithResponse request with arbitrary body returning *SetRetentionResponse
func (c *ClientWithResponses) SetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error) {
	rsp, err := c.SetRetentionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRetentionResponse(rsp)
}

func (c *ClientWithResponses) SetRetentionWithResponse(ctx context.Context, tenant string, namespace string, body SetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error) {
	rsp, err := c.SetRetention(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRetentionResponse(rsp)
}

// ScanOffloadedLedgersWithResponse request returning *ScanOffloadedLedgersResponse
func (c *ClientWithResponses) ScanOffloadedLedgersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ScanOffloadedLedgersResponse, error) {
	rsp, err := c.ScanOffloadedLedgers(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScanOffloadedLedgersResponse(rsp)
}

// GetSchemaAutoUpdateCompatibilityStrategyWithResponse request returning *GetSchemaAutoUpdateCompatibilityStrategyResponse
func (c *ClientWithResponses) GetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.GetSchemaAutoUpdateCompatibilityStrategy(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

// SetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetSchemaAutoUpdateCompatibilityStrategyResponse
func (c *ClientWithResponses) SetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

func (c *ClientWithResponses) SetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaAutoUpdateCompatibilityStrategy(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

// GetSchemaCompatibilityStrategyWithResponse request returning *GetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) GetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.GetSchemaCompatibilityStrategy(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaCompatibilityStrategyResponse(rsp)
}

// SetSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) SetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaCompatibilityStrategyResponse(rsp)
}

func (c *ClientWithResponses) SetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaCompatibilityStrategy(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaCompatibilityStrategyResponse(rsp)
}

// GetSchemaValidtionEnforcedWithResponse request returning *GetSchemaValidtionEnforcedResponse
func (c *ClientWithResponses) GetSchemaValidtionEnforcedWithResponse(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidtionEnforcedResponse, error) {
	rsp, err := c.GetSchemaValidtionEnforced(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaValidtionEnforcedResponse(rsp)
}

// SetSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *SetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) SetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetSchemaValidationEnforcedWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaValidationEnforcedResponse(rsp)
}

func (c *ClientWithResponses) SetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetSchemaValidationEnforced(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaValidationEnforcedResponse(rsp)
}

// DeleteSubscribeRateWithResponse request returning *DeleteSubscribeRateResponse
func (c *ClientWithResponses) DeleteSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscribeRateResponse, error) {
	rsp, err := c.DeleteSubscribeRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscribeRateResponse(rsp)
}

// GetSubscribeRateWithResponse request returning *GetSubscribeRateResponse
func (c *ClientWithResponses) GetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscribeRateResponse, error) {
	rsp, err := c.GetSubscribeRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscribeRateResponse(rsp)
}

// SetSubscribeRateWithBodyWithResponse request with arbitrary body returning *SetSubscribeRateResponse
func (c *ClientWithResponses) SetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error) {
	rsp, err := c.SetSubscribeRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscribeRateResponse(rsp)
}

func (c *ClientWithResponses) SetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error) {
	rsp, err := c.SetSubscribeRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscribeRateResponse(rsp)
}

// GetSubscriptionAuthModeWithResponse request returning *GetSubscriptionAuthModeResponse
func (c *ClientWithResponses) GetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionAuthModeResponse, error) {
	rsp, err := c.GetSubscriptionAuthMode(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionAuthModeResponse(rsp)
}

// SetSubscriptionAuthModeWithBodyWithResponse request with arbitrary body returning *SetSubscriptionAuthModeResponse
func (c *ClientWithResponses) SetSubscriptionAuthModeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionAuthModeResponse, error) {
	rsp, err := c.SetSubscriptionAuthModeWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionAuthModeResponse(rsp)
}

func (c *ClientWithResponses) SetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionAuthModeResponse, error) {
	rsp, err := c.SetSubscriptionAuthMode(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionAuthModeResponse(rsp)
}

// DeleteSubscriptionDispatchRateWithResponse request returning *DeleteSubscriptionDispatchRateResponse
func (c *ClientWithResponses) DeleteSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscriptionDispatchRateResponse, error) {
	rsp, err := c.DeleteSubscriptionDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionDispatchRateResponse(rsp)
}

// GetSubscriptionDispatchRateWithResponse request returning *GetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) GetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.GetSubscriptionDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionDispatchRateResponse(rsp)
}

// SetSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *SetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) SetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetSubscriptionDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) SetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetSubscriptionDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionDispatchRateResponse(rsp)
}

// RemoveSubscriptionExpirationTimeWithResponse request returning *RemoveSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) RemoveSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.RemoveSubscriptionExpirationTime(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionExpirationTimeResponse(rsp)
}

// GetSubscriptionExpirationTimeWithResponse request returning *GetSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) GetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.GetSubscriptionExpirationTime(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionExpirationTimeResponse(rsp)
}

// SetSubscriptionExpirationTimeWithBodyWithResponse request with arbitrary body returning *SetSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) SetSubscriptionExpirationTimeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.SetSubscriptionExpirationTimeWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionExpirationTimeResponse(rsp)
}

func (c *ClientWithResponses) SetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.SetSubscriptionExpirationTime(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionExpirationTimeResponse(rsp)
}

// RemoveSubscriptionTypesEnabledWithResponse request returning *RemoveSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) RemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.RemoveSubscriptionTypesEnabled(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionTypesEnabledResponse(rsp)
}

// GetSubscriptionTypesEnabledWithResponse request returning *GetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) GetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.GetSubscriptionTypesEnabled(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionTypesEnabledResponse(rsp)
}

// SetSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *SetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) SetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionTypesEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, body SetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetSubscriptionTypesEnabled(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionTypesEnabledResponse(rsp)
}

// GetTopicsWithResponse request returning *GetTopicsResponse
func (c *ClientWithResponses) GetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*GetTopicsResponse, error) {
	rsp, err := c.GetTopics(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopicsResponse(rsp)
}

// UnloadNamespaceWithResponse request returning *UnloadNamespaceResponse
func (c *ClientWithResponses) UnloadNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*UnloadNamespaceResponse, error) {
	rsp, err := c.UnloadNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadNamespaceResponse(rsp)
}

// UnsubscribeNamespaceWithResponse request returning *UnsubscribeNamespaceResponse
func (c *ClientWithResponses) UnsubscribeNamespaceWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceResponse, error) {
	rsp, err := c.UnsubscribeNamespace(ctx, tenant, namespace, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeNamespaceResponse(rsp)
}

// DeleteNamespaceBundleWithResponse request returning *DeleteNamespaceBundleResponse
func (c *ClientWithResponses) DeleteNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceBundleResponse, error) {
	rsp, err := c.DeleteNamespaceBundle(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceBundleResponse(rsp)
}

// ClearNamespaceBundleBacklogWithResponse request returning *ClearNamespaceBundleBacklogResponse
func (c *ClientWithResponses) ClearNamespaceBundleBacklogWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogResponse, error) {
	rsp, err := c.ClearNamespaceBundleBacklog(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBundleBacklogResponse(rsp)
}

// ClearNamespaceBundleBacklogForSubscriptionWithResponse request returning *ClearNamespaceBundleBacklogForSubscriptionResponse
func (c *ClientWithResponses) ClearNamespaceBundleBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogForSubscriptionResponse, error) {
	rsp, err := c.ClearNamespaceBundleBacklogForSubscription(ctx, tenant, namespace, bundle, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBundleBacklogForSubscriptionResponse(rsp)
}

// SplitNamespaceBundleWithBodyWithResponse request with arbitrary body returning *SplitNamespaceBundleResponse
func (c *ClientWithResponses) SplitNamespaceBundleWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error) {
	rsp, err := c.SplitNamespaceBundleWithBody(ctx, tenant, namespace, bundle, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSplitNamespaceBundleResponse(rsp)
}

func (c *ClientWithResponses) SplitNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error) {
	rsp, err := c.SplitNamespaceBundle(ctx, tenant, namespace, bundle, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSplitNamespaceBundleResponse(rsp)
}

// GetTopicHashPositionsWithResponse request returning *GetTopicHashPositionsResponse
func (c *ClientWithResponses) GetTopicHashPositionsWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*GetTopicHashPositionsResponse, error) {
	rsp, err := c.GetTopicHashPositions(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopicHashPositionsResponse(rsp)
}

// UnloadNamespaceBundleWithResponse request returning *UnloadNamespaceBundleResponse
func (c *ClientWithResponses) UnloadNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnloadNamespaceBundleResponse, error) {
	rsp, err := c.UnloadNamespaceBundle(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadNamespaceBundleResponse(rsp)
}

// UnsubscribeNamespaceBundleWithResponse request returning *UnsubscribeNamespaceBundleResponse
func (c *ClientWithResponses) UnsubscribeNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceBundleResponse, error) {
	rsp, err := c.UnsubscribeNamespaceBundle(ctx, tenant, namespace, bundle, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeNamespaceBundleResponse(rsp)
}

// GetListWithResponse request returning *GetListResponse
func (c *ClientWithResponses) GetListWithResponse(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*GetListResponse, error) {
	rsp, err := c.GetList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListResponse(rsp)
}

// GetPartitionedTopicListWithResponse request returning *GetPartitionedTopicListResponse
func (c *ClientWithResponses) GetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetPartitionedTopicListResponse, error) {
	rsp, err := c.GetPartitionedTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartitionedTopicListResponse(rsp)
}

// GetListFromBundleWithResponse request returning *GetListFromBundleResponse
func (c *ClientWithResponses) GetListFromBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetListFromBundleResponse, error) {
	rsp, err := c.GetListFromBundle(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListFromBundleResponse(rsp)
}

// DeleteTopicWithResponse request returning *DeleteTopicResponse
func (c *ClientWithResponses) DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error) {
	rsp, err := c.DeleteTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTopicResponse(rsp)
}

// CreateNonPartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreateNonPartitionedTopicResponse
func (c *ClientWithResponses) CreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPartitionedTopicResponse, error) {
	rsp, err := c.CreateNonPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNonPartitionedTopicResponse(rsp)
}

// ExpireMessagesForAllSubscriptionsWithResponse request returning *ExpireMessagesForAllSubscriptionsResponse
func (c *ClientWithResponses) ExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpireMessagesForAllSubscriptionsResponse, error) {
	rsp, err := c.ExpireMessagesForAllSubscriptions(ctx, tenant, namespace, topic, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireMessagesForAllSubscriptionsResponse(rsp)
}

// GetBacklogWithResponse request returning *GetBacklogResponse
func (c *ClientWithResponses) GetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*GetBacklogResponse, error) {
	rsp, err := c.GetBacklog(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBacklogResponse(rsp)
}

// RemoveBacklogQuotaWithResponse request returning *RemoveBacklogQuotaResponse
func (c *ClientWithResponses) RemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveBacklogQuotaResponse, error) {
	rsp, err := c.RemoveBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveBacklogQuotaResponse(rsp)
}

// SetBacklogQuotaWithResponse request returning *SetBacklogQuotaResponse
func (c *ClientWithResponses) SetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error) {
	rsp, err := c.SetBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBacklogQuotaResponse(rsp)
}

// GetBacklogQuotaMapWithResponse request returning *GetBacklogQuotaMapResponse
func (c *ClientWithResponses) GetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetBacklogQuotaMapResponse, error) {
	rsp, err := c.GetBacklogQuotaMap(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBacklogQuotaMapResponse(rsp)
}

// GetBacklogSizeByMessageIdWithResponse request returning *GetBacklogSizeByMessageIdResponse
func (c *ClientWithResponses) GetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetBacklogSizeByMessageIdResponse, error) {
	rsp, err := c.GetBacklogSizeByMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBacklogSizeByMessageIdResponse(rsp)
}

// CompactionStatusWithResponse request returning *CompactionStatusResponse
func (c *ClientWithResponses) CompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*CompactionStatusResponse, error) {
	rsp, err := c.CompactionStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompactionStatusResponse(rsp)
}

// CompactWithResponse request returning *CompactResponse
func (c *ClientWithResponses) CompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*CompactResponse, error) {
	rsp, err := c.Compact(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompactResponse(rsp)
}

// RemoveCompactionThresholdWithResponse request returning *RemoveCompactionThresholdResponse
func (c *ClientWithResponses) RemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemoveCompactionThresholdResponse, error) {
	rsp, err := c.RemoveCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveCompactionThresholdResponse(rsp)
}

// GetCompactionThresholdWithResponse request returning *GetCompactionThresholdResponse
func (c *ClientWithResponses) GetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetCompactionThresholdResponse, error) {
	rsp, err := c.GetCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompactionThresholdResponse(rsp)
}

// SetCompactionThresholdWithBodyWithResponse request with arbitrary body returning *SetCompactionThresholdResponse
func (c *ClientWithResponses) SetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error) {
	rsp, err := c.SetCompactionThresholdWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCompactionThresholdResponse(rsp)
}

// CreateMissedPartitionsWithResponse request returning *CreateMissedPartitionsResponse
func (c *ClientWithResponses) CreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreateMissedPartitionsResponse, error) {
	rsp, err := c.CreateMissedPartitions(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMissedPartitionsResponse(rsp)
}

// RemoveDeduplicationWithResponse request returning *RemoveDeduplicationResponse
func (c *ClientWithResponses) RemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*RemoveDeduplicationResponse, error) {
	rsp, err := c.RemoveDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDeduplicationResponse(rsp)
}

// GetDeduplicationWithResponse request returning *GetDeduplicationResponse
func (c *ClientWithResponses) GetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*GetDeduplicationResponse, error) {
	rsp, err := c.GetDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeduplicationResponse(rsp)
}

// SetDeduplicationWithBodyWithResponse request with arbitrary body returning *SetDeduplicationResponse
func (c *ClientWithResponses) SetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationResponse, error) {
	rsp, err := c.SetDeduplicationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDeduplicationResponse(rsp)
}

// DeleteDeduplicationSnapshotIntervalWithResponse request returning *DeleteDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) DeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeleteDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.DeleteDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeduplicationSnapshotIntervalResponse(rsp)
}

// GetDeduplicationSnapshotIntervalWithResponse request returning *GetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) GetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.GetDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeduplicationSnapshotIntervalResponse(rsp)
}

// SetDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *SetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) SetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDeduplicationSnapshotIntervalResponse(rsp)
}

// DeleteDelayedDeliveryPoliciesWithResponse request returning *DeleteDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) DeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.DeleteDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDelayedDeliveryPoliciesResponse(rsp)
}

// GetDelayedDeliveryPoliciesWithResponse request returning *GetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) GetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.GetDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDelayedDeliveryPoliciesResponse(rsp)
}

// SetDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *SetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) SetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDelayedDeliveryPoliciesResponse(rsp)
}

// RemoveDispatchRateWithResponse request returning *RemoveDispatchRateResponse
func (c *ClientWithResponses) RemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveDispatchRateResponse, error) {
	rsp, err := c.RemoveDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDispatchRateResponse(rsp)
}

// GetDispatchRateWithResponse request returning *GetDispatchRateResponse
func (c *ClientWithResponses) GetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*GetDispatchRateResponse, error) {
	rsp, err := c.GetDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDispatchRateResponse(rsp)
}

// SetDispatchRateWithBodyWithResponse request with arbitrary body returning *SetDispatchRateResponse
func (c *ClientWithResponses) SetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error) {
	rsp, err := c.SetDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDispatchRateResponse(rsp)
}

// RemoveEntryFiltersWithResponse request returning *RemoveEntryFiltersResponse
func (c *ClientWithResponses) RemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemoveEntryFiltersResponse, error) {
	rsp, err := c.RemoveEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveEntryFiltersResponse(rsp)
}

// GetEntryFiltersWithResponse request returning *GetEntryFiltersResponse
func (c *ClientWithResponses) GetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetEntryFiltersResponse, error) {
	rsp, err := c.GetEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryFiltersResponse(rsp)
}

// SetEntryFiltersWithBodyWithResponse request with arbitrary body returning *SetEntryFiltersResponse
func (c *ClientWithResponses) SetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersResponse, error) {
	rsp, err := c.SetEntryFiltersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEntryFiltersResponse(rsp)
}

// ExamineMessageWithResponse request returning *ExamineMessageResponse
func (c *ClientWithResponses) ExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*ExamineMessageResponse, error) {
	rsp, err := c.ExamineMessage(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExamineMessageResponse(rsp)
}

// DeleteInactiveTopicPoliciesWithResponse request returning *DeleteInactiveTopicPoliciesResponse
func (c *ClientWithResponses) DeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteInactiveTopicPoliciesResponse, error) {
	rsp, err := c.DeleteInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInactiveTopicPoliciesResponse(rsp)
}

// GetInactiveTopicPoliciesWithResponse request returning *GetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) GetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.GetInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInactiveTopicPoliciesResponse(rsp)
}

// SetInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *SetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetInactiveTopicPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInactiveTopicPoliciesResponse(rsp)
}

// GetManagedLedgerInfoWithResponse request returning *GetManagedLedgerInfoResponse
func (c *ClientWithResponses) GetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetManagedLedgerInfoResponse, error) {
	rsp, err := c.GetManagedLedgerInfo(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManagedLedgerInfoResponse(rsp)
}

// GetInternalStatsWithResponse request returning *GetInternalStatsResponse
func (c *ClientWithResponses) GetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*GetInternalStatsResponse, error) {
	rsp, err := c.GetInternalStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInternalStatsResponse(rsp)
}

// GetLastMessageIdWithResponse request returning *GetLastMessageIdResponse
func (c *ClientWithResponses) GetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetLastMessageIdResponse, error) {
	rsp, err := c.GetLastMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastMessageIdResponse(rsp)
}

// GetMessageByIdWithResponse request returning *GetMessageByIdResponse
func (c *ClientWithResponses) GetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*GetMessageByIdResponse, error) {
	rsp, err := c.GetMessageById(ctx, tenant, namespace, topic, ledgerId, entryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageByIdResponse(rsp)
}

// RemoveMaxConsumersWithResponse request returning *RemoveMaxConsumersResponse
func (c *ClientWithResponses) RemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersResponse, error) {
	rsp, err := c.RemoveMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxConsumersResponse(rsp)
}

// GetMaxConsumersWithResponse request returning *GetMaxConsumersResponse
func (c *ClientWithResponses) GetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersResponse, error) {
	rsp, err := c.GetMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxConsumersResponse(rsp)
}

// SetMaxConsumersWithBodyWithResponse request with arbitrary body returning *SetMaxConsumersResponse
func (c *ClientWithResponses) SetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersResponse, error) {
	rsp, err := c.SetMaxConsumersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersResponse(rsp)
}

// RemoveMaxConsumersPerSubscriptionWithResponse request returning *RemoveMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) RemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.RemoveMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxConsumersPerSubscriptionResponse(rsp)
}

// GetMaxConsumersPerSubscriptionWithResponse request returning *GetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) GetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.GetMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxConsumersPerSubscriptionResponse(rsp)
}

// SetMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) SetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersPerSubscriptionResponse(rsp)
}

// RemoveMaxMessageSizeWithResponse request returning *RemoveMaxMessageSizeResponse
func (c *ClientWithResponses) RemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemoveMaxMessageSizeResponse, error) {
	rsp, err := c.RemoveMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxMessageSizeResponse(rsp)
}

// GetMaxMessageSizeWithResponse request returning *GetMaxMessageSizeResponse
func (c *ClientWithResponses) GetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetMaxMessageSizeResponse, error) {
	rsp, err := c.GetMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxMessageSizeResponse(rsp)
}

// SetMaxMessageSizeWithBodyWithResponse request with arbitrary body returning *SetMaxMessageSizeResponse
func (c *ClientWithResponses) SetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxMessageSizeResponse, error) {
	rsp, err := c.SetMaxMessageSizeWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxMessageSizeResponse(rsp)
}

// RemoveMaxProducersWithResponse request returning *RemoveMaxProducersResponse
func (c *ClientWithResponses) RemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*RemoveMaxProducersResponse, error) {
	rsp, err := c.RemoveMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxProducersResponse(rsp)
}

// GetMaxProducersWithResponse request returning *GetMaxProducersResponse
func (c *ClientWithResponses) GetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*GetMaxProducersResponse, error) {
	rsp, err := c.GetMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxProducersResponse(rsp)
}

// SetMaxProducersWithBodyWithResponse request with arbitrary body returning *SetMaxProducersResponse
func (c *ClientWithResponses) SetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxProducersResponse, error) {
	rsp, err := c.SetMaxProducersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxProducersResponse(rsp)
}

// RemoveMaxSubscriptionsPerTopicWithResponse request returning *RemoveMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) RemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemoveMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.RemoveMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxSubscriptionsPerTopicResponse(rsp)
}

// GetMaxSubscriptionsPerTopicWithResponse request returning *GetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) GetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.GetMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxSubscriptionsPerTopicResponse(rsp)
}

// SetMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *SetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) SetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxSubscriptionsPerTopicResponse(rsp)
}

// DeleteMaxUnackedMessagesOnConsumerWithResponse request returning *DeleteMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) DeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.DeleteMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMaxUnackedMessagesOnConsumerResponse(rsp)
}

// GetMaxUnackedMessagesOnConsumerWithResponse request returning *GetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) GetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.GetMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// SetMaxUnackedMessagesOnConsumerWithBodyWithResponse request with arbitrary body returning *SetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) SetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesOnConsumerWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// DeleteMaxUnackedMessagesOnSubscriptionWithResponse request returning *DeleteMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) DeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.DeleteMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// GetMaxUnackedMessagesOnSubscriptionWithResponse request returning *GetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) GetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.GetMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// SetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with arbitrary body returning *SetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) SetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesOnSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// RemoveMessageTTLWithResponse request returning *RemoveMessageTTLResponse
func (c *ClientWithResponses) RemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*RemoveMessageTTLResponse, error) {
	rsp, err := c.RemoveMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMessageTTLResponse(rsp)
}

// GetMessageTTLWithResponse request returning *GetMessageTTLResponse
func (c *ClientWithResponses) GetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*GetMessageTTLResponse, error) {
	rsp, err := c.GetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageTTLResponse(rsp)
}

// SetMessageTTLWithResponse request returning *SetMessageTTLResponse
func (c *ClientWithResponses) SetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*SetMessageTTLResponse, error) {
	rsp, err := c.SetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMessageTTLResponse(rsp)
}

// GetMessageIdByTimestampWithResponse request returning *GetMessageIdByTimestampResponse
func (c *ClientWithResponses) GetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetMessageIdByTimestampResponse, error) {
	rsp, err := c.GetMessageIdByTimestamp(ctx, tenant, namespace, topic, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageIdByTimestampResponse(rsp)
}

// OffloadStatusWithResponse request returning *OffloadStatusResponse
func (c *ClientWithResponses) OffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*OffloadStatusResponse, error) {
	rsp, err := c.OffloadStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOffloadStatusResponse(rsp)
}

// TriggerOffloadWithResponse request returning *TriggerOffloadResponse
func (c *ClientWithResponses) TriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*TriggerOffloadResponse, error) {
	rsp, err := c.TriggerOffload(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerOffloadResponse(rsp)
}

// RemoveOffloadPoliciesWithResponse request returning *RemoveOffloadPoliciesResponse
func (c *ClientWithResponses) RemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemoveOffloadPoliciesResponse, error) {
	rsp, err := c.RemoveOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOffloadPoliciesResponse(rsp)
}

// GetOffloadPoliciesWithResponse request returning *GetOffloadPoliciesResponse
func (c *ClientWithResponses) GetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetOffloadPoliciesResponse, error) {
	rsp, err := c.GetOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOffloadPoliciesResponse(rsp)
}

// SetOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *SetOffloadPoliciesResponse
func (c *ClientWithResponses) SetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error) {
	rsp, err := c.SetOffloadPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadPoliciesResponse(rsp)
}

// GetPartitionedStatsWithResponse request returning *GetPartitionedStatsResponse
func (c *ClientWithResponses) GetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetPartitionedStatsResponse, error) {
	rsp, err := c.GetPartitionedStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartitionedStatsResponse(rsp)
}

// DeletePartitionedTopicWithResponse request returning *DeletePartitionedTopicResponse
func (c *ClientWithResponses) DeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeletePartitionedTopicResponse, error) {
	rsp, err := c.DeletePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePartitionedTopicResponse(rsp)
}

// GetPartitionedMetadataWithResponse request returning *GetPartitionedMetadataResponse
func (c *ClientWithResponses) GetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetPartitionedMetadataResponse, error) {
	rsp, err := c.GetPartitionedMetadata(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartitionedMetadataResponse(rsp)
}

// UpdatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *UpdatePartitionedTopicResponse
func (c *ClientWithResponses) UpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePartitionedTopicResponse, error) {
	rsp, err := c.UpdatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePartitionedTopicResponse(rsp)
}

// CreatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreatePartitionedTopicResponse
func (c *ClientWithResponses) CreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePartitionedTopicResponse, error) {
	rsp, err := c.CreatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePartitionedTopicResponse(rsp)
}

// GetPermissionsOnTopicWithResponse request returning *GetPermissionsOnTopicResponse
func (c *ClientWithResponses) GetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetPermissionsOnTopicResponse, error) {
	rsp, err := c.GetPermissionsOnTopic(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsOnTopicResponse(rsp)
}

// RevokePermissionsOnTopicWithResponse request returning *RevokePermissionsOnTopicResponse
func (c *ClientWithResponses) RevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnTopicResponse, error) {
	rsp, err := c.RevokePermissionsOnTopic(ctx, tenant, namespace, topic, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsOnTopicResponse(rsp)
}

// GrantPermissionsOnTopicWithBodyWithResponse request with arbitrary body returning *GrantPermissionsOnTopicResponse
func (c *ClientWithResponses) GrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionsOnTopicResponse, error) {
	rsp, err := c.GrantPermissionsOnTopicWithBody(ctx, tenant, namespace, topic, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantPermissionsOnTopicResponse(rsp)
}

// RemovePersistenceWithResponse request returning *RemovePersistenceResponse
func (c *ClientWithResponses) RemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*RemovePersistenceResponse, error) {
	rsp, err := c.RemovePersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistenceResponse(rsp)
}

// GetPersistenceWithResponse request returning *GetPersistenceResponse
func (c *ClientWithResponses) GetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*GetPersistenceResponse, error) {
	rsp, err := c.GetPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistenceResponse(rsp)
}

// SetPersistenceWithBodyWithResponse request with arbitrary body returning *SetPersistenceResponse
func (c *ClientWithResponses) SetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error) {
	rsp, err := c.SetPersistenceWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistenceResponse(rsp)
}

// RemovePropertiesWithResponse request returning *RemovePropertiesResponse
func (c *ClientWithResponses) RemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*RemovePropertiesResponse, error) {
	rsp, err := c.RemoveProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePropertiesResponse(rsp)
}

// GetPropertiesWithResponse request returning *GetPropertiesResponse
func (c *ClientWithResponses) GetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*GetPropertiesResponse, error) {
	rsp, err := c.GetProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPropertiesResponse(rsp)
}

// UpdatePropertiesWithBodyWithResponse request with arbitrary body returning *UpdatePropertiesResponse
func (c *ClientWithResponses) UpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error) {
	rsp, err := c.UpdatePropertiesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePropertiesResponse(rsp)
}

// RemovePublishRateWithResponse request returning *RemovePublishRateResponse
func (c *ClientWithResponses) RemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*RemovePublishRateResponse, error) {
	rsp, err := c.RemovePublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePublishRateResponse(rsp)
}

// GetPublishRateWithResponse request returning *GetPublishRateResponse
func (c *ClientWithResponses) GetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*GetPublishRateResponse, error) {
	rsp, err := c.GetPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublishRateResponse(rsp)
}

// SetPublishRateWithBodyWithResponse request with arbitrary body returning *SetPublishRateResponse
func (c *ClientWithResponses) SetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPublishRateResponse, error) {
	rsp, err := c.SetPublishRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPublishRateResponse(rsp)
}

// RemoveReplicationClustersWithResponse request returning *RemoveReplicationClustersResponse
func (c *ClientWithResponses) RemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemoveReplicationClustersResponse, error) {
	rsp, err := c.RemoveReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveReplicationClustersResponse(rsp)
}

// GetReplicationClustersWithResponse request returning *GetReplicationClustersResponse
func (c *ClientWithResponses) GetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetReplicationClustersResponse, error) {
	rsp, err := c.GetReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicationClustersResponse(rsp)
}

// SetReplicationClustersWithBodyWithResponse request with arbitrary body returning *SetReplicationClustersResponse
func (c *ClientWithResponses) SetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicationClustersResponse, error) {
	rsp, err := c.SetReplicationClustersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicationClustersResponse(rsp)
}

// RemoveReplicatorDispatchRateWithResponse request returning *RemoveReplicatorDispatchRateResponse
func (c *ClientWithResponses) RemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveReplicatorDispatchRateResponse, error) {
	rsp, err := c.RemoveReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveReplicatorDispatchRateResponse(rsp)
}

// GetReplicatorDispatchRateWithResponse request returning *GetReplicatorDispatchRateResponse
func (c *ClientWithResponses) GetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetReplicatorDispatchRateResponse, error) {
	rsp, err := c.GetReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicatorDispatchRateResponse(rsp)
}

// SetReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *SetReplicatorDispatchRateResponse
func (c *ClientWithResponses) SetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetReplicatorDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicatorDispatchRateResponse(rsp)
}

// RemoveRetentionWithResponse request returning *RemoveRetentionResponse
func (c *ClientWithResponses) RemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error) {
	rsp, err := c.RemoveRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRetentionResponse(rsp)
}

// GetRetentionWithResponse request returning *GetRetentionResponse
func (c *ClientWithResponses) GetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*GetRetentionResponse, error) {
	rsp, err := c.GetRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRetentionResponse(rsp)
}

// SetRetentionWithBodyWithResponse request with arbitrary body returning *SetRetentionResponse
func (c *ClientWithResponses) SetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error) {
	rsp, err := c.SetRetentionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRetentionResponse(rsp)
}

// RemoveSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *RemoveSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) RemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.RemoveSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSchemaCompatibilityStrategyResponse(rsp)
}

// GetSchemaCompatibilityStrategyWithResponse request returning *GetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) GetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.GetSchemaCompatibilityStrategy(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaCompatibilityStrategyResponse(rsp)
}

// SetSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) SetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaCompatibilityStrategyResponse(rsp)
}

// GetSchemaValidationEnforcedWithResponse request returning *GetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) GetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.GetSchemaValidationEnforced(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaValidationEnforcedResponse(rsp)
}

// SetSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *SetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) SetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetSchemaValidationEnforcedWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaValidationEnforcedResponse(rsp)
}

// DeleteShadowTopicsWithResponse request returning *DeleteShadowTopicsResponse
func (c *ClientWithResponses) DeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeleteShadowTopicsResponse, error) {
	rsp, err := c.DeleteShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShadowTopicsResponse(rsp)
}

// GetShadowTopicsWithResponse request returning *GetShadowTopicsResponse
func (c *ClientWithResponses) GetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetShadowTopicsResponse, error) {
	rsp, err := c.GetShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShadowTopicsResponse(rsp)
}

// SetShadowTopicsWithBodyWithResponse request with arbitrary body returning *SetShadowTopicsResponse
func (c *ClientWithResponses) SetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetShadowTopicsResponse, error) {
	rsp, err := c.SetShadowTopicsWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetShadowTopicsResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// RemoveSubscribeRateWithBodyWithResponse request with arbitrary body returning *RemoveSubscribeRateResponse
func (c *ClientWithResponses) RemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSubscribeRateResponse, error) {
	rsp, err := c.RemoveSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscribeRateResponse(rsp)
}

// GetSubscribeRateWithResponse request returning *GetSubscribeRateResponse
func (c *ClientWithResponses) GetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetSubscribeRateResponse, error) {
	rsp, err := c.GetSubscribeRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscribeRateResponse(rsp)
}

// SetSubscribeRateWithBodyWithResponse request with arbitrary body returning *SetSubscribeRateResponse
func (c *ClientWithResponses) SetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error) {
	rsp, err := c.SetSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscribeRateResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// AnalyzeSubscriptionBacklogWithBodyWithResponse request with arbitrary body returning *AnalyzeSubscriptionBacklogResponse
func (c *ClientWithResponses) AnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzeSubscriptionBacklogResponse, error) {
	rsp, err := c.AnalyzeSubscriptionBacklogWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnalyzeSubscriptionBacklogResponse(rsp)
}

// ExpireTopicMessagesWithBodyWithResponse request with arbitrary body returning *ExpireTopicMessagesResponse
func (c *ClientWithResponses) ExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error) {
	rsp, err := c.ExpireTopicMessagesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireTopicMessagesResponse(rsp)
}

// ExpireTopicMessagesWithResponse request returning *ExpireTopicMessagesResponse
func (c *ClientWithResponses) ExpireTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error) {
	rsp, err := c.ExpireTopicMessages(ctx, tenant, namespace, topic, subName, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireTopicMessagesResponse(rsp)
}

// PeekNthMessageWithResponse request returning *PeekNthMessageResponse
func (c *ClientWithResponses) PeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*PeekNthMessageResponse, error) {
	rsp, err := c.PeekNthMessage(ctx, tenant, namespace, topic, subName, messagePosition, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePeekNthMessageResponse(rsp)
}

// GetSubscriptionPropertiesWithResponse request returning *GetSubscriptionPropertiesResponse
func (c *ClientWithResponses) GetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetSubscriptionPropertiesResponse, error) {
	rsp, err := c.GetSubscriptionProperties(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionPropertiesResponse(rsp)
}

// UpdateSubscriptionPropertiesWithBodyWithResponse request with arbitrary body returning *UpdateSubscriptionPropertiesResponse
func (c *ClientWithResponses) UpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionPropertiesResponse, error) {
	rsp, err := c.UpdateSubscriptionPropertiesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubscriptionPropertiesResponse(rsp)
}

// GetReplicatedSubscriptionStatusWithResponse request returning *GetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) GetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.GetReplicatedSubscriptionStatus(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicatedSubscriptionStatusResponse(rsp)
}

// SetReplicatedSubscriptionStatusWithBodyWithResponse request with arbitrary body returning *SetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) SetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.SetReplicatedSubscriptionStatusWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicatedSubscriptionStatusResponse(rsp)
}

// ResetCursorOnPositionWithBodyWithResponse request with arbitrary body returning *ResetCursorOnPositionResponse
func (c *ClientWithResponses) ResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetCursorOnPositionResponse, error) {
	rsp, err := c.ResetCursorOnPositionWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetCursorOnPositionResponse(rsp)
}

// ResetCursorWithResponse request returning *ResetCursorResponse
func (c *ClientWithResponses) ResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*ResetCursorResponse, error) {
	rsp, err := c.ResetCursor(ctx, tenant, namespace, topic, subName, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetCursorResponse(rsp)
}

// SkipMessagesWithResponse request returning *SkipMessagesResponse
func (c *ClientWithResponses) SkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*SkipMessagesResponse, error) {
	rsp, err := c.SkipMessages(ctx, tenant, namespace, topic, subName, numMessages, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipMessagesResponse(rsp)
}

// SkipAllMessagesWithResponse request returning *SkipAllMessagesResponse
func (c *ClientWithResponses) SkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipAllMessagesResponse, error) {
	rsp, err := c.SkipAllMessages(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipAllMessagesResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, tenant, namespace, topic, subscriptionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// RemoveSubscriptionDispatchRateWithResponse request returning *RemoveSubscriptionDispatchRateResponse
func (c *ClientWithResponses) RemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionDispatchRateResponse, error) {
	rsp, err := c.RemoveSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionDispatchRateResponse(rsp)
}

// GetSubscriptionDispatchRateWithResponse request returning *GetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) GetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.GetSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionDispatchRateResponse(rsp)
}

// SetSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *SetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) SetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetSubscriptionDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionDispatchRateResponse(rsp)
}

// RemoveSubscriptionTypesEnabledWithResponse request returning *RemoveSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) RemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.RemoveSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionTypesEnabledResponse(rsp)
}

// GetSubscriptionTypesEnabledWithResponse request returning *GetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) GetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.GetSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionTypesEnabledResponse(rsp)
}

// SetSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *SetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) SetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionTypesEnabledResponse(rsp)
}

// GetSubscriptionsWithResponse request returning *GetSubscriptionsResponse
func (c *ClientWithResponses) GetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error) {
	rsp, err := c.GetSubscriptions(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsResponse(rsp)
}

// TerminateWithResponse request returning *TerminateResponse
func (c *ClientWithResponses) TerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*TerminateResponse, error) {
	rsp, err := c.Terminate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateResponse(rsp)
}

// TerminatePartitionedTopicWithResponse request returning *TerminatePartitionedTopicResponse
func (c *ClientWithResponses) TerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminatePartitionedTopicResponse, error) {
	rsp, err := c.TerminatePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminatePartitionedTopicResponse(rsp)
}

// TruncateTopicWithResponse request returning *TruncateTopicResponse
func (c *ClientWithResponses) TruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*TruncateTopicResponse, error) {
	rsp, err := c.TruncateTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTruncateTopicResponse(rsp)
}

// UnloadTopicWithResponse request returning *UnloadTopicResponse
func (c *ClientWithResponses) UnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*UnloadTopicResponse, error) {
	rsp, err := c.UnloadTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadTopicResponse(rsp)
}

// RemoveSubscriptionLevelDispatchRateWithResponse request returning *RemoveSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) RemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.RemoveSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionLevelDispatchRateResponse(rsp)
}

// GetSubscriptionLevelDispatchRateWithResponse request returning *GetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) GetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.GetSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionLevelDispatchRateResponse(rsp)
}

// SetSubscriptionLevelDispatchRateWithBodyWithResponse request with arbitrary body returning *SetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) SetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.SetSubscriptionLevelDispatchRateWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionLevelDispatchRateResponse(rsp)
}

// GetListWithResponse request returning *GetListResponse
func (c *ClientWithResponses) GetListWithResponse(ctx context.Context, tenant string, namespace string, params *GetListParams, reqEditors ...RequestEditorFn) (*GetListResponse, error) {
	rsp, err := c.GetList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListResponse(rsp)
}

// GetPartitionedTopicListWithResponse request returning *GetPartitionedTopicListResponse
func (c *ClientWithResponses) GetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetPartitionedTopicListResponse, error) {
	rsp, err := c.GetPartitionedTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartitionedTopicListResponse(rsp)
}

// DeleteTopicWithResponse request returning *DeleteTopicResponse
func (c *ClientWithResponses) DeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteTopicParams, reqEditors ...RequestEditorFn) (*DeleteTopicResponse, error) {
	rsp, err := c.DeleteTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTopicResponse(rsp)
}

// CreateNonPartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreateNonPartitionedTopicResponse
func (c *ClientWithResponses) CreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPartitionedTopicResponse, error) {
	rsp, err := c.CreateNonPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNonPartitionedTopicResponse(rsp)
}

// ExpireMessagesForAllSubscriptionsWithResponse request returning *ExpireMessagesForAllSubscriptionsResponse
func (c *ClientWithResponses) ExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpireMessagesForAllSubscriptionsResponse, error) {
	rsp, err := c.ExpireMessagesForAllSubscriptions(ctx, tenant, namespace, topic, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireMessagesForAllSubscriptionsResponse(rsp)
}

// GetBacklogWithResponse request returning *GetBacklogResponse
func (c *ClientWithResponses) GetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogParams, reqEditors ...RequestEditorFn) (*GetBacklogResponse, error) {
	rsp, err := c.GetBacklog(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBacklogResponse(rsp)
}

// RemoveBacklogQuotaWithResponse request returning *RemoveBacklogQuotaResponse
func (c *ClientWithResponses) RemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveBacklogQuotaResponse, error) {
	rsp, err := c.RemoveBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveBacklogQuotaResponse(rsp)
}

// SetBacklogQuotaWithResponse request returning *SetBacklogQuotaResponse
func (c *ClientWithResponses) SetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetBacklogQuotaResponse, error) {
	rsp, err := c.SetBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBacklogQuotaResponse(rsp)
}

// GetBacklogQuotaMapWithResponse request returning *GetBacklogQuotaMapResponse
func (c *ClientWithResponses) GetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetBacklogQuotaMapResponse, error) {
	rsp, err := c.GetBacklogQuotaMap(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBacklogQuotaMapResponse(rsp)
}

// GetBacklogSizeByMessageIdWithResponse request returning *GetBacklogSizeByMessageIdResponse
func (c *ClientWithResponses) GetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetBacklogSizeByMessageIdResponse, error) {
	rsp, err := c.GetBacklogSizeByMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBacklogSizeByMessageIdResponse(rsp)
}

// CompactionStatusWithResponse request returning *CompactionStatusResponse
func (c *ClientWithResponses) CompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactionStatusParams, reqEditors ...RequestEditorFn) (*CompactionStatusResponse, error) {
	rsp, err := c.CompactionStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompactionStatusResponse(rsp)
}

// CompactWithResponse request returning *CompactResponse
func (c *ClientWithResponses) CompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactParams, reqEditors ...RequestEditorFn) (*CompactResponse, error) {
	rsp, err := c.Compact(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompactResponse(rsp)
}

// RemoveCompactionThresholdWithResponse request returning *RemoveCompactionThresholdResponse
func (c *ClientWithResponses) RemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemoveCompactionThresholdResponse, error) {
	rsp, err := c.RemoveCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveCompactionThresholdResponse(rsp)
}

// GetCompactionThresholdWithResponse request returning *GetCompactionThresholdResponse
func (c *ClientWithResponses) GetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetCompactionThresholdResponse, error) {
	rsp, err := c.GetCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompactionThresholdResponse(rsp)
}

// SetCompactionThresholdWithBodyWithResponse request with arbitrary body returning *SetCompactionThresholdResponse
func (c *ClientWithResponses) SetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCompactionThresholdResponse, error) {
	rsp, err := c.SetCompactionThresholdWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCompactionThresholdResponse(rsp)
}

// CreateMissedPartitionsWithResponse request returning *CreateMissedPartitionsResponse
func (c *ClientWithResponses) CreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreateMissedPartitionsResponse, error) {
	rsp, err := c.CreateMissedPartitions(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMissedPartitionsResponse(rsp)
}

// RemoveDeduplicationWithResponse request returning *RemoveDeduplicationResponse
func (c *ClientWithResponses) RemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*RemoveDeduplicationResponse, error) {
	rsp, err := c.RemoveDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDeduplicationResponse(rsp)
}

// GetDeduplicationWithResponse request returning *GetDeduplicationResponse
func (c *ClientWithResponses) GetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationParams, reqEditors ...RequestEditorFn) (*GetDeduplicationResponse, error) {
	rsp, err := c.GetDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeduplicationResponse(rsp)
}

// SetDeduplicationWithBodyWithResponse request with arbitrary body returning *SetDeduplicationResponse
func (c *ClientWithResponses) SetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationResponse, error) {
	rsp, err := c.SetDeduplicationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDeduplicationResponse(rsp)
}

// DeleteDeduplicationSnapshotIntervalWithResponse request returning *DeleteDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) DeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeleteDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.DeleteDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeduplicationSnapshotIntervalResponse(rsp)
}

// GetDeduplicationSnapshotIntervalWithResponse request returning *GetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) GetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.GetDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeduplicationSnapshotIntervalResponse(rsp)
}

// SetDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *SetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) SetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDeduplicationSnapshotIntervalResponse(rsp)
}

// DeleteDelayedDeliveryPoliciesWithResponse request returning *DeleteDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) DeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.DeleteDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDelayedDeliveryPoliciesResponse(rsp)
}

// GetDelayedDeliveryPoliciesWithResponse request returning *GetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) GetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.GetDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDelayedDeliveryPoliciesResponse(rsp)
}

// SetDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *SetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) SetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDelayedDeliveryPoliciesResponse(rsp)
}

// RemoveDispatchRateWithResponse request returning *RemoveDispatchRateResponse
func (c *ClientWithResponses) RemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveDispatchRateResponse, error) {
	rsp, err := c.RemoveDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDispatchRateResponse(rsp)
}

// GetDispatchRateWithResponse request returning *GetDispatchRateResponse
func (c *ClientWithResponses) GetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetDispatchRateParams, reqEditors ...RequestEditorFn) (*GetDispatchRateResponse, error) {
	rsp, err := c.GetDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDispatchRateResponse(rsp)
}

// SetDispatchRateWithBodyWithResponse request with arbitrary body returning *SetDispatchRateResponse
func (c *ClientWithResponses) SetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDispatchRateResponse, error) {
	rsp, err := c.SetDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDispatchRateResponse(rsp)
}

// RemoveEntryFiltersWithResponse request returning *RemoveEntryFiltersResponse
func (c *ClientWithResponses) RemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemoveEntryFiltersResponse, error) {
	rsp, err := c.RemoveEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveEntryFiltersResponse(rsp)
}

// GetEntryFiltersWithResponse request returning *GetEntryFiltersResponse
func (c *ClientWithResponses) GetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetEntryFiltersResponse, error) {
	rsp, err := c.GetEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryFiltersResponse(rsp)
}

// SetEntryFiltersWithBodyWithResponse request with arbitrary body returning *SetEntryFiltersResponse
func (c *ClientWithResponses) SetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersResponse, error) {
	rsp, err := c.SetEntryFiltersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEntryFiltersResponse(rsp)
}

// ExamineMessageWithResponse request returning *ExamineMessageResponse
func (c *ClientWithResponses) ExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExamineMessageParams, reqEditors ...RequestEditorFn) (*ExamineMessageResponse, error) {
	rsp, err := c.ExamineMessage(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExamineMessageResponse(rsp)
}

// DeleteInactiveTopicPoliciesWithResponse request returning *DeleteInactiveTopicPoliciesResponse
func (c *ClientWithResponses) DeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteInactiveTopicPoliciesResponse, error) {
	rsp, err := c.DeleteInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInactiveTopicPoliciesResponse(rsp)
}

// GetInactiveTopicPoliciesWithResponse request returning *GetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) GetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.GetInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInactiveTopicPoliciesResponse(rsp)
}

// SetInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *SetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetInactiveTopicPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetInactiveTopicPoliciesResponse(rsp)
}

// GetManagedLedgerInfoWithResponse request returning *GetManagedLedgerInfoResponse
func (c *ClientWithResponses) GetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetManagedLedgerInfoResponse, error) {
	rsp, err := c.GetManagedLedgerInfo(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManagedLedgerInfoResponse(rsp)
}

// GetInternalStatsWithResponse request returning *GetInternalStatsResponse
func (c *ClientWithResponses) GetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetInternalStatsParams, reqEditors ...RequestEditorFn) (*GetInternalStatsResponse, error) {
	rsp, err := c.GetInternalStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInternalStatsResponse(rsp)
}

// GetLastMessageIdWithResponse request returning *GetLastMessageIdResponse
func (c *ClientWithResponses) GetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetLastMessageIdResponse, error) {
	rsp, err := c.GetLastMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLastMessageIdResponse(rsp)
}

// GetMessageByIdWithResponse request returning *GetMessageByIdResponse
func (c *ClientWithResponses) GetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetMessageByIdParams, reqEditors ...RequestEditorFn) (*GetMessageByIdResponse, error) {
	rsp, err := c.GetMessageById(ctx, tenant, namespace, topic, ledgerId, entryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageByIdResponse(rsp)
}

// RemoveMaxConsumersWithResponse request returning *RemoveMaxConsumersResponse
func (c *ClientWithResponses) RemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersResponse, error) {
	rsp, err := c.RemoveMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxConsumersResponse(rsp)
}

// GetMaxConsumersWithResponse request returning *GetMaxConsumersResponse
func (c *ClientWithResponses) GetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersResponse, error) {
	rsp, err := c.GetMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxConsumersResponse(rsp)
}

// SetMaxConsumersWithBodyWithResponse request with arbitrary body returning *SetMaxConsumersResponse
func (c *ClientWithResponses) SetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersResponse, error) {
	rsp, err := c.SetMaxConsumersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersResponse(rsp)
}

// RemoveMaxConsumersPerSubscriptionWithResponse request returning *RemoveMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) RemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemoveMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.RemoveMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxConsumersPerSubscriptionResponse(rsp)
}

// GetMaxConsumersPerSubscriptionWithResponse request returning *GetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) GetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.GetMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxConsumersPerSubscriptionResponse(rsp)
}

// SetMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) SetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxConsumersPerSubscriptionResponse(rsp)
}

// RemoveMaxMessageSizeWithResponse request returning *RemoveMaxMessageSizeResponse
func (c *ClientWithResponses) RemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemoveMaxMessageSizeResponse, error) {
	rsp, err := c.RemoveMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxMessageSizeResponse(rsp)
}

// GetMaxMessageSizeWithResponse request returning *GetMaxMessageSizeResponse
func (c *ClientWithResponses) GetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetMaxMessageSizeResponse, error) {
	rsp, err := c.GetMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxMessageSizeResponse(rsp)
}

// SetMaxMessageSizeWithBodyWithResponse request with arbitrary body returning *SetMaxMessageSizeResponse
func (c *ClientWithResponses) SetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxMessageSizeResponse, error) {
	rsp, err := c.SetMaxMessageSizeWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxMessageSizeResponse(rsp)
}

// RemoveMaxProducersWithResponse request returning *RemoveMaxProducersResponse
func (c *ClientWithResponses) RemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*RemoveMaxProducersResponse, error) {
	rsp, err := c.RemoveMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxProducersResponse(rsp)
}

// GetMaxProducersWithResponse request returning *GetMaxProducersResponse
func (c *ClientWithResponses) GetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxProducersParams, reqEditors ...RequestEditorFn) (*GetMaxProducersResponse, error) {
	rsp, err := c.GetMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxProducersResponse(rsp)
}

// SetMaxProducersWithBodyWithResponse request with arbitrary body returning *SetMaxProducersResponse
func (c *ClientWithResponses) SetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxProducersResponse, error) {
	rsp, err := c.SetMaxProducersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxProducersResponse(rsp)
}

// RemoveMaxSubscriptionsPerTopicWithResponse request returning *RemoveMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) RemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemoveMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.RemoveMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMaxSubscriptionsPerTopicResponse(rsp)
}

// GetMaxSubscriptionsPerTopicWithResponse request returning *GetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) GetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.GetMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxSubscriptionsPerTopicResponse(rsp)
}

// SetMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *SetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) SetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxSubscriptionsPerTopicResponse(rsp)
}

// DeleteMaxUnackedMessagesOnConsumerWithResponse request returning *DeleteMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) DeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.DeleteMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMaxUnackedMessagesOnConsumerResponse(rsp)
}

// GetMaxUnackedMessagesOnConsumerWithResponse request returning *GetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) GetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.GetMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// SetMaxUnackedMessagesOnConsumerWithBodyWithResponse request with arbitrary body returning *SetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) SetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesOnConsumerWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// DeleteMaxUnackedMessagesOnSubscriptionWithResponse request returning *DeleteMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) DeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.DeleteMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// GetMaxUnackedMessagesOnSubscriptionWithResponse request returning *GetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) GetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.GetMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// SetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with arbitrary body returning *SetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) SetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.SetMaxUnackedMessagesOnSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// RemoveMessageTTLWithResponse request returning *RemoveMessageTTLResponse
func (c *ClientWithResponses) RemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*RemoveMessageTTLResponse, error) {
	rsp, err := c.RemoveMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMessageTTLResponse(rsp)
}

// GetMessageTTLWithResponse request returning *GetMessageTTLResponse
func (c *ClientWithResponses) GetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetMessageTTLParams, reqEditors ...RequestEditorFn) (*GetMessageTTLResponse, error) {
	rsp, err := c.GetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageTTLResponse(rsp)
}

// SetMessageTTLWithResponse request returning *SetMessageTTLResponse
func (c *ClientWithResponses) SetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetMessageTTLParams, reqEditors ...RequestEditorFn) (*SetMessageTTLResponse, error) {
	rsp, err := c.SetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMessageTTLResponse(rsp)
}

// GetMessageIdByTimestampWithResponse request returning *GetMessageIdByTimestampResponse
func (c *ClientWithResponses) GetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetMessageIdByTimestampResponse, error) {
	rsp, err := c.GetMessageIdByTimestamp(ctx, tenant, namespace, topic, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageIdByTimestampResponse(rsp)
}

// OffloadStatusWithResponse request returning *OffloadStatusResponse
func (c *ClientWithResponses) OffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadStatusParams, reqEditors ...RequestEditorFn) (*OffloadStatusResponse, error) {
	rsp, err := c.OffloadStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOffloadStatusResponse(rsp)
}

// TriggerOffloadWithResponse request returning *TriggerOffloadResponse
func (c *ClientWithResponses) TriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerOffloadParams, reqEditors ...RequestEditorFn) (*TriggerOffloadResponse, error) {
	rsp, err := c.TriggerOffload(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerOffloadResponse(rsp)
}

// RemoveOffloadPoliciesWithResponse request returning *RemoveOffloadPoliciesResponse
func (c *ClientWithResponses) RemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemoveOffloadPoliciesResponse, error) {
	rsp, err := c.RemoveOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOffloadPoliciesResponse(rsp)
}

// GetOffloadPoliciesWithResponse request returning *GetOffloadPoliciesResponse
func (c *ClientWithResponses) GetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetOffloadPoliciesResponse, error) {
	rsp, err := c.GetOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOffloadPoliciesResponse(rsp)
}

// SetOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *SetOffloadPoliciesResponse
func (c *ClientWithResponses) SetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOffloadPoliciesResponse, error) {
	rsp, err := c.SetOffloadPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOffloadPoliciesResponse(rsp)
}

// GetPartitionedStatsWithResponse request returning *GetPartitionedStatsResponse
func (c *ClientWithResponses) GetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetPartitionedStatsResponse, error) {
	rsp, err := c.GetPartitionedStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartitionedStatsResponse(rsp)
}

// DeletePartitionedTopicWithResponse request returning *DeletePartitionedTopicResponse
func (c *ClientWithResponses) DeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeletePartitionedTopicResponse, error) {
	rsp, err := c.DeletePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePartitionedTopicResponse(rsp)
}

// GetPartitionedMetadataWithResponse request returning *GetPartitionedMetadataResponse
func (c *ClientWithResponses) GetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetPartitionedMetadataResponse, error) {
	rsp, err := c.GetPartitionedMetadata(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPartitionedMetadataResponse(rsp)
}

// UpdatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *UpdatePartitionedTopicResponse
func (c *ClientWithResponses) UpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePartitionedTopicResponse, error) {
	rsp, err := c.UpdatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePartitionedTopicResponse(rsp)
}

// CreatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreatePartitionedTopicResponse
func (c *ClientWithResponses) CreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePartitionedTopicResponse, error) {
	rsp, err := c.CreatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePartitionedTopicResponse(rsp)
}

// GetPermissionsOnTopicWithResponse request returning *GetPermissionsOnTopicResponse
func (c *ClientWithResponses) GetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetPermissionsOnTopicResponse, error) {
	rsp, err := c.GetPermissionsOnTopic(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsOnTopicResponse(rsp)
}

// RevokePermissionsOnTopicWithResponse request returning *RevokePermissionsOnTopicResponse
func (c *ClientWithResponses) RevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnTopicResponse, error) {
	rsp, err := c.RevokePermissionsOnTopic(ctx, tenant, namespace, topic, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsOnTopicResponse(rsp)
}

// GrantPermissionsOnTopicWithBodyWithResponse request with arbitrary body returning *GrantPermissionsOnTopicResponse
func (c *ClientWithResponses) GrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionsOnTopicResponse, error) {
	rsp, err := c.GrantPermissionsOnTopicWithBody(ctx, tenant, namespace, topic, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantPermissionsOnTopicResponse(rsp)
}

// RemovePersistenceWithResponse request returning *RemovePersistenceResponse
func (c *ClientWithResponses) RemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistenceParams, reqEditors ...RequestEditorFn) (*RemovePersistenceResponse, error) {
	rsp, err := c.RemovePersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistenceResponse(rsp)
}

// GetPersistenceWithResponse request returning *GetPersistenceResponse
func (c *ClientWithResponses) GetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistenceParams, reqEditors ...RequestEditorFn) (*GetPersistenceResponse, error) {
	rsp, err := c.GetPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistenceResponse(rsp)
}

// SetPersistenceWithBodyWithResponse request with arbitrary body returning *SetPersistenceResponse
func (c *ClientWithResponses) SetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistenceResponse, error) {
	rsp, err := c.SetPersistenceWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistenceResponse(rsp)
}

// RemovePropertiesWithResponse request returning *RemovePropertiesResponse
func (c *ClientWithResponses) RemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePropertiesParams, reqEditors ...RequestEditorFn) (*RemovePropertiesResponse, error) {
	rsp, err := c.RemoveProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePropertiesResponse(rsp)
}

// GetPropertiesWithResponse request returning *GetPropertiesResponse
func (c *ClientWithResponses) GetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPropertiesParams, reqEditors ...RequestEditorFn) (*GetPropertiesResponse, error) {
	rsp, err := c.GetProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPropertiesResponse(rsp)
}

// UpdatePropertiesWithBodyWithResponse request with arbitrary body returning *UpdatePropertiesResponse
func (c *ClientWithResponses) UpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePropertiesResponse, error) {
	rsp, err := c.UpdatePropertiesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePropertiesResponse(rsp)
}

// RemovePublishRateWithResponse request returning *RemovePublishRateResponse
func (c *ClientWithResponses) RemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePublishRateParams, reqEditors ...RequestEditorFn) (*RemovePublishRateResponse, error) {
	rsp, err := c.RemovePublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePublishRateResponse(rsp)
}

// GetPublishRateWithResponse request returning *GetPublishRateResponse
func (c *ClientWithResponses) GetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPublishRateParams, reqEditors ...RequestEditorFn) (*GetPublishRateResponse, error) {
	rsp, err := c.GetPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublishRateResponse(rsp)
}

// SetPublishRateWithBodyWithResponse request with arbitrary body returning *SetPublishRateResponse
func (c *ClientWithResponses) SetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPublishRateResponse, error) {
	rsp, err := c.SetPublishRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPublishRateResponse(rsp)
}

// RemoveReplicationClustersWithResponse request returning *RemoveReplicationClustersResponse
func (c *ClientWithResponses) RemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemoveReplicationClustersResponse, error) {
	rsp, err := c.RemoveReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveReplicationClustersResponse(rsp)
}

// GetReplicationClustersWithResponse request returning *GetReplicationClustersResponse
func (c *ClientWithResponses) GetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetReplicationClustersResponse, error) {
	rsp, err := c.GetReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicationClustersResponse(rsp)
}

// SetReplicationClustersWithBodyWithResponse request with arbitrary body returning *SetReplicationClustersResponse
func (c *ClientWithResponses) SetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicationClustersResponse, error) {
	rsp, err := c.SetReplicationClustersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicationClustersResponse(rsp)
}

// RemoveReplicatorDispatchRateWithResponse request returning *RemoveReplicatorDispatchRateResponse
func (c *ClientWithResponses) RemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveReplicatorDispatchRateResponse, error) {
	rsp, err := c.RemoveReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveReplicatorDispatchRateResponse(rsp)
}

// GetReplicatorDispatchRateWithResponse request returning *GetReplicatorDispatchRateResponse
func (c *ClientWithResponses) GetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetReplicatorDispatchRateResponse, error) {
	rsp, err := c.GetReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicatorDispatchRateResponse(rsp)
}

// SetReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *SetReplicatorDispatchRateResponse
func (c *ClientWithResponses) SetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetReplicatorDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicatorDispatchRateResponse(rsp)
}

// RemoveRetentionWithResponse request returning *RemoveRetentionResponse
func (c *ClientWithResponses) RemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveRetentionParams, reqEditors ...RequestEditorFn) (*RemoveRetentionResponse, error) {
	rsp, err := c.RemoveRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRetentionResponse(rsp)
}

// GetRetentionWithResponse request returning *GetRetentionResponse
func (c *ClientWithResponses) GetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetRetentionParams, reqEditors ...RequestEditorFn) (*GetRetentionResponse, error) {
	rsp, err := c.GetRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRetentionResponse(rsp)
}

// SetRetentionWithBodyWithResponse request with arbitrary body returning *SetRetentionResponse
func (c *ClientWithResponses) SetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRetentionResponse, error) {
	rsp, err := c.SetRetentionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRetentionResponse(rsp)
}

// RemoveSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *RemoveSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) RemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.RemoveSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSchemaCompatibilityStrategyResponse(rsp)
}

// GetSchemaCompatibilityStrategyWithResponse request returning *GetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) GetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.GetSchemaCompatibilityStrategy(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaCompatibilityStrategyResponse(rsp)
}

// SetSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) SetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaCompatibilityStrategyResponse(rsp)
}

// GetSchemaValidationEnforcedWithResponse request returning *GetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) GetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.GetSchemaValidationEnforced(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaValidationEnforcedResponse(rsp)
}

// SetSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *SetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) SetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetSchemaValidationEnforcedWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaValidationEnforcedResponse(rsp)
}

// DeleteShadowTopicsWithResponse request returning *DeleteShadowTopicsResponse
func (c *ClientWithResponses) DeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeleteShadowTopicsResponse, error) {
	rsp, err := c.DeleteShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShadowTopicsResponse(rsp)
}

// GetShadowTopicsWithResponse request returning *GetShadowTopicsResponse
func (c *ClientWithResponses) GetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetShadowTopicsResponse, error) {
	rsp, err := c.GetShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShadowTopicsResponse(rsp)
}

// SetShadowTopicsWithBodyWithResponse request with arbitrary body returning *SetShadowTopicsResponse
func (c *ClientWithResponses) SetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetShadowTopicsResponse, error) {
	rsp, err := c.SetShadowTopicsWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetShadowTopicsResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// RemoveSubscribeRateWithBodyWithResponse request with arbitrary body returning *RemoveSubscribeRateResponse
func (c *ClientWithResponses) RemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSubscribeRateResponse, error) {
	rsp, err := c.RemoveSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscribeRateResponse(rsp)
}

// GetSubscribeRateWithResponse request returning *GetSubscribeRateResponse
func (c *ClientWithResponses) GetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetSubscribeRateResponse, error) {
	rsp, err := c.GetSubscribeRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscribeRateResponse(rsp)
}

// SetSubscribeRateWithBodyWithResponse request with arbitrary body returning *SetSubscribeRateResponse
func (c *ClientWithResponses) SetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscribeRateResponse, error) {
	rsp, err := c.SetSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscribeRateResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// AnalyzeSubscriptionBacklogWithBodyWithResponse request with arbitrary body returning *AnalyzeSubscriptionBacklogResponse
func (c *ClientWithResponses) AnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzeSubscriptionBacklogResponse, error) {
	rsp, err := c.AnalyzeSubscriptionBacklogWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnalyzeSubscriptionBacklogResponse(rsp)
}

// ExpireTopicMessagesWithBodyWithResponse request with arbitrary body returning *ExpireTopicMessagesResponse
func (c *ClientWithResponses) ExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error) {
	rsp, err := c.ExpireTopicMessagesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireTopicMessagesResponse(rsp)
}

// ExpireTopicMessagesWithResponse request returning *ExpireTopicMessagesResponse
func (c *ClientWithResponses) ExpireTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireTopicMessagesParams, reqEditors ...RequestEditorFn) (*ExpireTopicMessagesResponse, error) {
	rsp, err := c.ExpireTopicMessages(ctx, tenant, namespace, topic, subName, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireTopicMessagesResponse(rsp)
}

// PeekNthMessageWithResponse request returning *PeekNthMessageResponse
func (c *ClientWithResponses) PeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNthMessageParams, reqEditors ...RequestEditorFn) (*PeekNthMessageResponse, error) {
	rsp, err := c.PeekNthMessage(ctx, tenant, namespace, topic, subName, messagePosition, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePeekNthMessageResponse(rsp)
}

// GetSubscriptionPropertiesWithResponse request returning *GetSubscriptionPropertiesResponse
func (c *ClientWithResponses) GetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetSubscriptionPropertiesResponse, error) {
	rsp, err := c.GetSubscriptionProperties(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionPropertiesResponse(rsp)
}

// UpdateSubscriptionPropertiesWithBodyWithResponse request with arbitrary body returning *UpdateSubscriptionPropertiesResponse
func (c *ClientWithResponses) UpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionPropertiesResponse, error) {
	rsp, err := c.UpdateSubscriptionPropertiesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubscriptionPropertiesResponse(rsp)
}

// GetReplicatedSubscriptionStatusWithResponse request returning *GetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) GetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.GetReplicatedSubscriptionStatus(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReplicatedSubscriptionStatusResponse(rsp)
}

// SetReplicatedSubscriptionStatusWithBodyWithResponse request with arbitrary body returning *SetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) SetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.SetReplicatedSubscriptionStatusWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReplicatedSubscriptionStatusResponse(rsp)
}

// ResetCursorOnPositionWithBodyWithResponse request with arbitrary body returning *ResetCursorOnPositionResponse
func (c *ClientWithResponses) ResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetCursorOnPositionResponse, error) {
	rsp, err := c.ResetCursorOnPositionWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetCursorOnPositionResponse(rsp)
}

// ResetCursorWithResponse request returning *ResetCursorResponse
func (c *ClientWithResponses) ResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetCursorParams, reqEditors ...RequestEditorFn) (*ResetCursorResponse, error) {
	rsp, err := c.ResetCursor(ctx, tenant, namespace, topic, subName, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetCursorResponse(rsp)
}

// SkipMessagesWithResponse request returning *SkipMessagesResponse
func (c *ClientWithResponses) SkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipMessagesParams, reqEditors ...RequestEditorFn) (*SkipMessagesResponse, error) {
	rsp, err := c.SkipMessages(ctx, tenant, namespace, topic, subName, numMessages, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipMessagesResponse(rsp)
}

// SkipAllMessagesWithResponse request returning *SkipAllMessagesResponse
func (c *ClientWithResponses) SkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipAllMessagesResponse, error) {
	rsp, err := c.SkipAllMessages(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipAllMessagesResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, tenant, namespace, topic, subscriptionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// RemoveSubscriptionDispatchRateWithResponse request returning *RemoveSubscriptionDispatchRateResponse
func (c *ClientWithResponses) RemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionDispatchRateResponse, error) {
	rsp, err := c.RemoveSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionDispatchRateResponse(rsp)
}

// GetSubscriptionDispatchRateWithResponse request returning *GetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) GetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.GetSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionDispatchRateResponse(rsp)
}

// SetSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *SetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) SetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetSubscriptionDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionDispatchRateResponse(rsp)
}

// RemoveSubscriptionTypesEnabledWithResponse request returning *RemoveSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) RemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.RemoveSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionTypesEnabledResponse(rsp)
}

// GetSubscriptionTypesEnabledWithResponse request returning *GetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) GetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.GetSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionTypesEnabledResponse(rsp)
}

// SetSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *SetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) SetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionTypesEnabledResponse(rsp)
}

// GetSubscriptionsWithResponse request returning *GetSubscriptionsResponse
func (c *ClientWithResponses) GetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error) {
	rsp, err := c.GetSubscriptions(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsResponse(rsp)
}

// TerminateWithResponse request returning *TerminateResponse
func (c *ClientWithResponses) TerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateParams, reqEditors ...RequestEditorFn) (*TerminateResponse, error) {
	rsp, err := c.Terminate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateResponse(rsp)
}

// TerminatePartitionedTopicWithResponse request returning *TerminatePartitionedTopicResponse
func (c *ClientWithResponses) TerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminatePartitionedTopicResponse, error) {
	rsp, err := c.TerminatePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminatePartitionedTopicResponse(rsp)
}

// TruncateTopicWithResponse request returning *TruncateTopicResponse
func (c *ClientWithResponses) TruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncateTopicParams, reqEditors ...RequestEditorFn) (*TruncateTopicResponse, error) {
	rsp, err := c.TruncateTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTruncateTopicResponse(rsp)
}

// UnloadTopicWithResponse request returning *UnloadTopicResponse
func (c *ClientWithResponses) UnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadTopicParams, reqEditors ...RequestEditorFn) (*UnloadTopicResponse, error) {
	rsp, err := c.UnloadTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadTopicResponse(rsp)
}

// RemoveSubscriptionLevelDispatchRateWithResponse request returning *RemoveSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) RemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.RemoveSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionLevelDispatchRateResponse(rsp)
}

// GetSubscriptionLevelDispatchRateWithResponse request returning *GetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) GetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.GetSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionLevelDispatchRateResponse(rsp)
}

// SetSubscriptionLevelDispatchRateWithBodyWithResponse request with arbitrary body returning *SetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) SetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.SetSubscriptionLevelDispatchRateWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSubscriptionLevelDispatchRateResponse(rsp)
}

// GetDefaultResourceQuotaWithResponse request returning *GetDefaultResourceQuotaResponse
func (c *ClientWithResponses) GetDefaultResourceQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultResourceQuotaResponse, error) {
	rsp, err := c.GetDefaultResourceQuota(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultResourceQuotaResponse(rsp)
}

// SetDefaultResourceQuotaWithBodyWithResponse request with arbitrary body returning *SetDefaultResourceQuotaResponse
func (c *ClientWithResponses) SetDefaultResourceQuotaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error) {
	rsp, err := c.SetDefaultResourceQuotaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultResourceQuotaResponse(rsp)
}

func (c *ClientWithResponses) SetDefaultResourceQuotaWithResponse(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error) {
	rsp, err := c.SetDefaultResourceQuota(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultResourceQuotaResponse(rsp)
}

// RemoveNamespaceBundleResourceQuotaWithResponse request returning *RemoveNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) RemoveNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*RemoveNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.RemoveNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceBundleResourceQuotaResponse(rsp)
}

// GetNamespaceBundleResourceQuotaWithResponse request returning *GetNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) GetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.GetNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceBundleResourceQuotaResponse(rsp)
}

// SetNamespaceBundleResourceQuotaWithBodyWithResponse request with arbitrary body returning *SetNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) SetNamespaceBundleResourceQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.SetNamespaceBundleResourceQuotaWithBody(ctx, tenant, namespace, bundle, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceBundleResourceQuotaResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.SetNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceBundleResourceQuotaResponse(rsp)
}

// GetResourceGroupsWithResponse request returning *GetResourceGroupsResponse
func (c *ClientWithResponses) GetResourceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourceGroupsResponse, error) {
	rsp, err := c.GetResourceGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceGroupsResponse(rsp)
}

// DeleteResourceGroupWithResponse request returning *DeleteResourceGroupResponse
func (c *ClientWithResponses) DeleteResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*DeleteResourceGroupResponse, error) {
	rsp, err := c.DeleteResourceGroup(ctx, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceGroupResponse(rsp)
}

// GetResourceGroupWithResponse request returning *GetResourceGroupResponse
func (c *ClientWithResponses) GetResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*GetResourceGroupResponse, error) {
	rsp, err := c.GetResourceGroup(ctx, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceGroupResponse(rsp)
}

// CreateOrUpdateResourceGroupWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateResourceGroupResponse
func (c *ClientWithResponses) CreateOrUpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error) {
	rsp, err := c.CreateOrUpdateResourceGroupWithBody(ctx, resourcegroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateResourceGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateResourceGroupWithResponse(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error) {
	rsp, err := c.CreateOrUpdateResourceGroup(ctx, resourcegroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateResourceGroupResponse(rsp)
}

// TestCompatibilityWithBodyWithResponse request with arbitrary body returning *TestCompatibilityResponse
func (c *ClientWithResponses) TestCompatibilityWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error) {
	rsp, err := c.TestCompatibilityWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestCompatibilityResponse(rsp)
}

func (c *ClientWithResponses) TestCompatibilityWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error) {
	rsp, err := c.TestCompatibility(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestCompatibilityResponse(rsp)
}

// DeleteSchemaWithResponse request returning *DeleteSchemaResponse
func (c *ClientWithResponses) DeleteSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResponse, error) {
	rsp, err := c.DeleteSchema(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSchemaResponse(rsp)
}

// GetSchemaWithResponse request returning *GetSchemaResponse
func (c *ClientWithResponses) GetSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*GetSchemaResponse, error) {
	rsp, err := c.GetSchema(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaResponse(rsp)
}

// PostSchemaWithBodyWithResponse request with arbitrary body returning *PostSchemaResponse
func (c *ClientWithResponses) PostSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error) {
	rsp, err := c.PostSchemaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemaResponse(rsp)
}

func (c *ClientWithResponses) PostSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error) {
	rsp, err := c.PostSchema(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemaResponse(rsp)
}

// GetSchemaWithResponse request returning *GetSchemaResponse
func (c *ClientWithResponses) GetSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaParams, reqEditors ...RequestEditorFn) (*GetSchemaResponse, error) {
	rsp, err := c.GetSchema(ctx, tenant, namespace, topic, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaResponse(rsp)
}

// GetAllSchemasWithResponse request returning *GetAllSchemasResponse
func (c *ClientWithResponses) GetAllSchemasWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*GetAllSchemasResponse, error) {
	rsp, err := c.GetAllSchemas(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSchemasResponse(rsp)
}

// GetVersionBySchemaWithBodyWithResponse request with arbitrary body returning *GetVersionBySchemaResponse
func (c *ClientWithResponses) GetVersionBySchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error) {
	rsp, err := c.GetVersionBySchemaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionBySchemaResponse(rsp)
}

func (c *ClientWithResponses) GetVersionBySchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error) {
	rsp, err := c.GetVersionBySchema(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionBySchemaResponse(rsp)
}

// GetTenantsWithResponse request returning *GetTenantsResponse
func (c *ClientWithResponses) GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error) {
	rsp, err := c.GetTenants(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantsResponse(rsp)
}

// DeleteTenantWithResponse request returning *DeleteTenantResponse
func (c *ClientWithResponses) DeleteTenantWithResponse(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error) {
	rsp, err := c.DeleteTenant(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTenantResponse(rsp)
}

// GetTenantAdminWithResponse request returning *GetTenantAdminResponse
func (c *ClientWithResponses) GetTenantAdminWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantAdminResponse, error) {
	rsp, err := c.GetTenantAdmin(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantAdminResponse(rsp)
}

// UpdateTenantWithBodyWithResponse request with arbitrary body returning *UpdateTenantResponse
func (c *ClientWithResponses) UpdateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenantWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

func (c *ClientWithResponses) UpdateTenantWithResponse(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenant(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

// CreateTenantWithBodyWithResponse request with arbitrary body returning *CreateTenantResponse
func (c *ClientWithResponses) CreateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenantWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

func (c *ClientWithResponses) CreateTenantWithResponse(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenant(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetMetricsWithResponse request returning *GetMetricsResponse
func (c *ClientWithResponses) GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

// GetAssignmentsWithResponse request returning *GetAssignmentsResponse
func (c *ClientWithResponses) GetAssignmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAssignmentsResponse, error) {
	rsp, err := c.GetAssignments(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssignmentsResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// GetClusterLeaderWithResponse request returning *GetClusterLeaderResponse
func (c *ClientWithResponses) GetClusterLeaderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterLeaderResponse, error) {
	rsp, err := c.GetClusterLeader(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterLeaderResponse(rsp)
}

// IsLeaderReadyWithResponse request returning *IsLeaderReadyResponse
func (c *ClientWithResponses) IsLeaderReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsLeaderReadyResponse, error) {
	rsp, err := c.IsLeaderReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsLeaderReadyResponse(rsp)
}

// GetConnectorsListWithResponse request returning *GetConnectorsListResponse
func (c *ClientWithResponses) GetConnectorsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectorsListResponse, error) {
	rsp, err := c.GetConnectorsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorsListResponse(rsp)
}

// GetDrainStatusWithResponse request returning *GetDrainStatusResponse
func (c *ClientWithResponses) GetDrainStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDrainStatusResponse, error) {
	rsp, err := c.GetDrainStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDrainStatusResponse(rsp)
}

// DrainWithResponse request returning *DrainResponse
func (c *ClientWithResponses) DrainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DrainResponse, error) {
	rsp, err := c.Drain(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDrainResponse(rsp)
}

// GetDrainStatusFromLeaderWithResponse request returning *GetDrainStatusFromLeaderResponse
func (c *ClientWithResponses) GetDrainStatusFromLeaderWithResponse(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*GetDrainStatusFromLeaderResponse, error) {
	rsp, err := c.GetDrainStatusFromLeader(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDrainStatusFromLeaderResponse(rsp)
}

// DrainAtLeaderWithResponse request returning *DrainAtLeaderResponse
func (c *ClientWithResponses) DrainAtLeaderWithResponse(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*DrainAtLeaderResponse, error) {
	rsp, err := c.DrainAtLeader(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDrainAtLeaderResponse(rsp)
}

// RebalanceWithResponse request returning *RebalanceResponse
func (c *ClientWithResponses) RebalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RebalanceResponse, error) {
	rsp, err := c.Rebalance(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebalanceResponse(rsp)
}

// ParseGetAllBookiesResponse parses an HTTP response from a GetAllBookiesWithResponse call
func ParseGetAllBookiesResponse(rsp *http.Response) (*GetAllBookiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBookiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookiesClusterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBookiesRackInfoResponse parses an HTTP response from a GetBookiesRackInfoWithResponse call
func ParseGetBookiesRackInfoResponse(rsp *http.Response) (*GetBookiesRackInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookiesRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]struct {
				AdditionalProperties map[string]BookieInfo `json:"-"`
			} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBookieRackInfoResponse parses an HTTP response from a DeleteBookieRackInfoWithResponse call
func ParseDeleteBookieRackInfoResponse(rsp *http.Response) (*DeleteBookieRackInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBookieRackInfoResponse parses an HTTP response from a GetBookieRackInfoWithResponse call
func ParseGetBookieRackInfoResponse(rsp *http.Response) (*GetBookieRackInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookieInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBookieRackInfoResponse parses an HTTP response from a UpdateBookieRackInfoWithResponse call
func ParseUpdateBookieRackInfoResponse(rsp *http.Response) (*UpdateBookieRackInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAllocatorStatsResponse parses an HTTP response from a GetAllocatorStatsWithResponse call
func ParseGetAllocatorStatsResponse(rsp *http.Response) (*GetAllocatorStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllocatorStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllocatorStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPendingBookieOpsStatsResponse parses an HTTP response from a GetPendingBookieOpsStatsWithResponse call
func ParseGetPendingBookieOpsStatsResponse(rsp *http.Response) (*GetPendingBookieOpsStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingBookieOpsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]PendingBookieOpsStats `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBrokerResourceAvailabilityResponse parses an HTTP response from a GetBrokerResourceAvailabilityWithResponse call
func ParseGetBrokerResourceAvailabilityResponse(rsp *http.Response) (*GetBrokerResourceAvailabilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrokerResourceAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]ResourceUnit `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLoadReportResponse parses an HTTP response from a GetLoadReportWithResponse call
func ParseGetLoadReportResponse(rsp *http.Response) (*GetLoadReportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoadReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMBeansResponse parses an HTTP response from a GetMBeansWithResponse call
func ParseGetMBeansResponse(rsp *http.Response) (*GetMBeansResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMBeansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMetricsResponse parses an HTTP response from a GetMetricsWithResponse call
func ParseGetMetricsResponse(rsp *http.Response) (*GetMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopics2Response parses an HTTP response from a GetTopics2WithResponse call
func ParseGetTopics2Response(rsp *http.Response) (*GetTopics2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopics2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OutputStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActiveBrokersResponse parses an HTTP response from a GetActiveBrokersWithResponse call
func ParseGetActiveBrokersResponse(rsp *http.Response) (*GetActiveBrokersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActiveBrokersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBacklogQuotaCheckResponse parses an HTTP response from a BacklogQuotaCheckWithResponse call
func ParseBacklogQuotaCheckResponse(rsp *http.Response) (*BacklogQuotaCheckResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BacklogQuotaCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDynamicConfigurationNameResponse parses an HTTP response from a GetDynamicConfigurationNameWithResponse call
func ParseGetDynamicConfigurationNameResponse(rsp *http.Response) (*GetDynamicConfigurationNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDynamicConfigurationNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuntimeConfigurationResponse parses an HTTP response from a GetRuntimeConfigurationWithResponse call
func ParseGetRuntimeConfigurationResponse(rsp *http.Response) (*GetRuntimeConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAllDynamicConfigurationsResponse parses an HTTP response from a GetAllDynamicConfigurationsWithResponse call
func ParseGetAllDynamicConfigurationsResponse(rsp *http.Response) (*GetAllDynamicConfigurationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDynamicConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDynamicConfigurationResponse parses an HTTP response from a DeleteDynamicConfigurationWithResponse call
func ParseDeleteDynamicConfigurationResponse(rsp *http.Response) (*DeleteDynamicConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDynamicConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateDynamicConfigurationResponse parses an HTTP response from a UpdateDynamicConfigurationWithResponse call
func ParseUpdateDynamicConfigurationResponse(rsp *http.Response) (*UpdateDynamicConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDynamicConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInternalConfigurationDataResponse parses an HTTP response from a GetInternalConfigurationDataWithResponse call
func ParseGetInternalConfigurationDataResponse(rsp *http.Response) (*GetInternalConfigurationDataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInternalConfigurationDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternalConfigurationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeaderBrokerResponse parses an HTTP response from a GetLeaderBrokerWithResponse call
func ParseGetLeaderBrokerResponse(rsp *http.Response) (*GetLeaderBrokerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaderBrokerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrokerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsReadyResponse parses an HTTP response from a IsReadyWithResponse call
func ParseIsReadyResponse(rsp *http.Response) (*IsReadyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseShutDownBrokerGracefullyResponse parses an HTTP response from a ShutDownBrokerGracefullyWithResponse call
func ParseShutDownBrokerGracefullyResponse(rsp *http.Response) (*ShutDownBrokerGracefullyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShutDownBrokerGracefullyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVersionResponse parses an HTTP response from a VersionWithResponse call
func ParseVersionResponse(rsp *http.Response) (*VersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOwnedNamespacesResponse parses an HTTP response from a GetOwnedNamespacesWithResponse call
func ParseGetOwnedNamespacesResponse(rsp *http.Response) (*GetOwnedNamespacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOwnedNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]NamespaceOwnershipStatus `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActiveBrokersResponse parses an HTTP response from a GetActiveBrokersWithResponse call
func ParseGetActiveBrokersResponse(rsp *http.Response) (*GetActiveBrokersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActiveBrokersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClustersResponse parses an HTTP response from a GetClustersWithResponse call
func ParseGetClustersResponse(rsp *http.Response) (*GetClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFailureDomainsResponse parses an HTTP response from a GetFailureDomainsWithResponse call
func ParseGetFailureDomainsResponse(rsp *http.Response) (*GetFailureDomainsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFailureDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]FailureDomain `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFailureDomainResponse parses an HTTP response from a DeleteFailureDomainWithResponse call
func ParseDeleteFailureDomainResponse(rsp *http.Response) (*DeleteFailureDomainResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFailureDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDomainResponse parses an HTTP response from a GetDomainWithResponse call
func ParseGetDomainResponse(rsp *http.Response) (*GetDomainResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FailureDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetFailureDomainResponse parses an HTTP response from a SetFailureDomainWithResponse call
func ParseSetFailureDomainResponse(rsp *http.Response) (*SetFailureDomainResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetFailureDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceIsolationPoliciesResponse parses an HTTP response from a GetNamespaceIsolationPoliciesWithResponse call
func ParseGetNamespaceIsolationPoliciesResponse(rsp *http.Response) (*GetNamespaceIsolationPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceIsolationPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]NamespaceIsolationData `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBrokersWithNamespaceIsolationPolicyResponse parses an HTTP response from a GetBrokersWithNamespaceIsolationPolicyWithResponse call
func ParseGetBrokersWithNamespaceIsolationPolicyResponse(rsp *http.Response) (*GetBrokersWithNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrokersWithNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BrokerNamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBrokerWithNamespaceIsolationPolicyResponse parses an HTTP response from a GetBrokerWithNamespaceIsolationPolicyWithResponse call
func ParseGetBrokerWithNamespaceIsolationPolicyResponse(rsp *http.Response) (*GetBrokerWithNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrokerWithNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrokerNamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNamespaceIsolationPolicyResponse parses an HTTP response from a DeleteNamespaceIsolationPolicyWithResponse call
func ParseDeleteNamespaceIsolationPolicyResponse(rsp *http.Response) (*DeleteNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceIsolationPolicyResponse parses an HTTP response from a GetNamespaceIsolationPolicyWithResponse call
func ParseGetNamespaceIsolationPolicyResponse(rsp *http.Response) (*GetNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceIsolationPolicyResponse parses an HTTP response from a SetNamespaceIsolationPolicyWithResponse call
func ParseSetNamespaceIsolationPolicyResponse(rsp *http.Response) (*SetNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPeerClusterResponse parses an HTTP response from a GetPeerClusterWithResponse call
func ParseGetPeerClusterResponse(rsp *http.Response) (*GetPeerClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetPeerClusterNamesResponse parses an HTTP response from a SetPeerClusterNamesWithResponse call
func ParseSetPeerClusterNamesResponse(rsp *http.Response) (*SetPeerClusterNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPeerClusterNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAntiAffinityNamespacesResponse parses an HTTP response from a GetAntiAffinityNamespacesWithResponse call
func ParseGetAntiAffinityNamespacesResponse(rsp *http.Response) (*GetAntiAffinityNamespacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAntiAffinityNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBookieAffinityGroupResponse parses an HTTP response from a DeleteBookieAffinityGroupWithResponse call
func ParseDeleteBookieAffinityGroupResponse(rsp *http.Response) (*DeleteBookieAffinityGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBookieAffinityGroupResponse parses an HTTP response from a GetBookieAffinityGroupWithResponse call
func ParseGetBookieAffinityGroupResponse(rsp *http.Response) (*GetBookieAffinityGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookieAffinityGroupData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTenantNamespacesResponse parses an HTTP response from a GetTenantNamespacesWithResponse call
func ParseGetTenantNamespacesResponse(rsp *http.Response) (*GetTenantNamespacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNamespaceResponse parses an HTTP response from a DeleteNamespaceWithResponse call
func ParseDeleteNamespaceResponse(rsp *http.Response) (*DeleteNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPoliciesResponse parses an HTTP response from a GetPoliciesWithResponse call
func ParseGetPoliciesResponse(rsp *http.Response) (*GetPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNamespaceResponse parses an HTTP response from a CreateNamespaceWithResponse call
func ParseCreateNamespaceResponse(rsp *http.Response) (*CreateNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceAntiAffinityGroupResponse parses an HTTP response from a RemoveNamespaceAntiAffinityGroupWithResponse call
func ParseRemoveNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*RemoveNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceAntiAffinityGroupResponse parses an HTTP response from a GetNamespaceAntiAffinityGroupWithResponse call
func ParseGetNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*GetNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceAntiAffinityGroupResponse parses an HTTP response from a SetNamespaceAntiAffinityGroupWithResponse call
func ParseSetNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*SetNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveAutoSubscriptionCreationResponse parses an HTTP response from a RemoveAutoSubscriptionCreationWithResponse call
func ParseRemoveAutoSubscriptionCreationResponse(rsp *http.Response) (*RemoveAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAutoSubscriptionCreationResponse parses an HTTP response from a GetAutoSubscriptionCreationWithResponse call
func ParseGetAutoSubscriptionCreationResponse(rsp *http.Response) (*GetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetAutoSubscriptionCreationResponse parses an HTTP response from a SetAutoSubscriptionCreationWithResponse call
func ParseSetAutoSubscriptionCreationResponse(rsp *http.Response) (*SetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveAutoTopicCreationResponse parses an HTTP response from a RemoveAutoTopicCreationWithResponse call
func ParseRemoveAutoTopicCreationResponse(rsp *http.Response) (*RemoveAutoTopicCreationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAutoTopicCreationResponse parses an HTTP response from a GetAutoTopicCreationWithResponse call
func ParseGetAutoTopicCreationResponse(rsp *http.Response) (*GetAutoTopicCreationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetAutoTopicCreationResponse parses an HTTP response from a SetAutoTopicCreationWithResponse call
func ParseSetAutoTopicCreationResponse(rsp *http.Response) (*SetAutoTopicCreationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveBacklogQuotaResponse parses an HTTP response from a RemoveBacklogQuotaWithResponse call
func ParseRemoveBacklogQuotaResponse(rsp *http.Response) (*RemoveBacklogQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetBacklogQuotaResponse parses an HTTP response from a SetBacklogQuotaWithResponse call
func ParseSetBacklogQuotaResponse(rsp *http.Response) (*SetBacklogQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBacklogQuotaMapResponse parses an HTTP response from a GetBacklogQuotaMapWithResponse call
func ParseGetBacklogQuotaMapResponse(rsp *http.Response) (*GetBacklogQuotaMapResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBundlesDataResponse parses an HTTP response from a GetBundlesDataWithResponse call
func ParseGetBundlesDataResponse(rsp *http.Response) (*GetBundlesDataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundlesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBacklogResponse parses an HTTP response from a ClearNamespaceBacklogWithResponse call
func ParseClearNamespaceBacklogResponse(rsp *http.Response) (*ClearNamespaceBacklogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBacklogForSubscriptionResponse parses an HTTP response from a ClearNamespaceBacklogForSubscriptionWithResponse call
func ParseClearNamespaceBacklogForSubscriptionResponse(rsp *http.Response) (*ClearNamespaceBacklogForSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBacklogForSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCompactionThresholdResponse parses an HTTP response from a DeleteCompactionThresholdWithResponse call
func ParseDeleteCompactionThresholdResponse(rsp *http.Response) (*DeleteCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCompactionThresholdResponse parses an HTTP response from a GetCompactionThresholdWithResponse call
func ParseGetCompactionThresholdResponse(rsp *http.Response) (*GetCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetCompactionThresholdResponse parses an HTTP response from a SetCompactionThresholdWithResponse call
func ParseSetCompactionThresholdResponse(rsp *http.Response) (*SetCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveDeduplicationResponse parses an HTTP response from a RemoveDeduplicationWithResponse call
func ParseRemoveDeduplicationResponse(rsp *http.Response) (*RemoveDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeduplicationResponse parses an HTTP response from a GetDeduplicationWithResponse call
func ParseGetDeduplicationResponse(rsp *http.Response) (*GetDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyDeduplicationResponse parses an HTTP response from a ModifyDeduplicationWithResponse call
func ParseModifyDeduplicationResponse(rsp *http.Response) (*ModifyDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeduplicationSnapshotIntervalResponse parses an HTTP response from a GetDeduplicationSnapshotIntervalWithResponse call
func ParseGetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*GetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDeduplicationSnapshotIntervalResponse parses an HTTP response from a SetDeduplicationSnapshotIntervalWithResponse call
func ParseSetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*SetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveDelayedDeliveryPoliciesResponse parses an HTTP response from a RemoveDelayedDeliveryPoliciesWithResponse call
func ParseRemoveDelayedDeliveryPoliciesResponse(rsp *http.Response) (*RemoveDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDelayedDeliveryPoliciesResponse parses an HTTP response from a GetDelayedDeliveryPoliciesWithResponse call
func ParseGetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*GetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDelayedDeliveryPoliciesResponse parses an HTTP response from a SetDelayedDeliveryPoliciesWithResponse call
func ParseSetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*SetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDispatchRateResponse parses an HTTP response from a DeleteDispatchRateWithResponse call
func ParseDeleteDispatchRateResponse(rsp *http.Response) (*DeleteDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDispatchRateResponse parses an HTTP response from a GetDispatchRateWithResponse call
func ParseGetDispatchRateResponse(rsp *http.Response) (*GetDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDispatchRateResponse parses an HTTP response from a SetDispatchRateWithResponse call
func ParseSetDispatchRateResponse(rsp *http.Response) (*SetDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEncryptionRequiredResponse parses an HTTP response from a GetEncryptionRequiredWithResponse call
func ParseGetEncryptionRequiredResponse(rsp *http.Response) (*GetEncryptionRequiredResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEncryptionRequiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyEncryptionRequiredResponse parses an HTTP response from a ModifyEncryptionRequiredWithResponse call
func ParseModifyEncryptionRequiredResponse(rsp *http.Response) (*ModifyEncryptionRequiredResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyEncryptionRequiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceEntryFiltersResponse parses an HTTP response from a RemoveNamespaceEntryFiltersWithResponse call
func ParseRemoveNamespaceEntryFiltersResponse(rsp *http.Response) (*RemoveNamespaceEntryFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEntryFiltersPerTopicResponse parses an HTTP response from a GetEntryFiltersPerTopicWithResponse call
func ParseGetEntryFiltersPerTopicResponse(rsp *http.Response) (*GetEntryFiltersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntryFiltersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetEntryFiltersPerTopicResponse parses an HTTP response from a SetEntryFiltersPerTopicWithResponse call
func ParseSetEntryFiltersPerTopicResponse(rsp *http.Response) (*SetEntryFiltersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEntryFiltersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveInactiveTopicPoliciesResponse parses an HTTP response from a RemoveInactiveTopicPoliciesWithResponse call
func ParseRemoveInactiveTopicPoliciesResponse(rsp *http.Response) (*RemoveInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInactiveTopicPoliciesResponse parses an HTTP response from a GetInactiveTopicPoliciesWithResponse call
func ParseGetInactiveTopicPoliciesResponse(rsp *http.Response) (*GetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetInactiveTopicPoliciesResponse parses an HTTP response from a SetInactiveTopicPoliciesWithResponse call
func ParseSetInactiveTopicPoliciesResponse(rsp *http.Response) (*SetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIsAllowAutoUpdateSchemaResponse parses an HTTP response from a GetIsAllowAutoUpdateSchemaWithResponse call
func ParseGetIsAllowAutoUpdateSchemaResponse(rsp *http.Response) (*GetIsAllowAutoUpdateSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIsAllowAutoUpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetIsAllowAutoUpdateSchemaResponse parses an HTTP response from a SetIsAllowAutoUpdateSchemaWithResponse call
func ParseSetIsAllowAutoUpdateSchemaResponse(rsp *http.Response) (*SetIsAllowAutoUpdateSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIsAllowAutoUpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxConsumersPerSubscriptionResponse parses an HTTP response from a RemoveMaxConsumersPerSubscriptionWithResponse call
func ParseRemoveMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*RemoveMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxConsumersPerSubscriptionResponse parses an HTTP response from a GetMaxConsumersPerSubscriptionWithResponse call
func ParseGetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*GetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxConsumersPerSubscriptionResponse parses an HTTP response from a SetMaxConsumersPerSubscriptionWithResponse call
func ParseSetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*SetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxConsumersPerTopicResponse parses an HTTP response from a RemoveMaxConsumersPerTopicWithResponse call
func ParseRemoveMaxConsumersPerTopicResponse(rsp *http.Response) (*RemoveMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxConsumersPerTopicResponse parses an HTTP response from a GetMaxConsumersPerTopicWithResponse call
func ParseGetMaxConsumersPerTopicResponse(rsp *http.Response) (*GetMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxConsumersPerTopicResponse parses an HTTP response from a SetMaxConsumersPerTopicWithResponse call
func ParseSetMaxConsumersPerTopicResponse(rsp *http.Response) (*SetMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxProducersPerTopicResponse parses an HTTP response from a RemoveMaxProducersPerTopicWithResponse call
func ParseRemoveMaxProducersPerTopicResponse(rsp *http.Response) (*RemoveMaxProducersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxProducersPerTopicResponse parses an HTTP response from a GetMaxProducersPerTopicWithResponse call
func ParseGetMaxProducersPerTopicResponse(rsp *http.Response) (*GetMaxProducersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxProducersPerTopicResponse parses an HTTP response from a SetMaxProducersPerTopicWithResponse call
func ParseSetMaxProducersPerTopicResponse(rsp *http.Response) (*SetMaxProducersPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxSubscriptionsPerTopicResponse parses an HTTP response from a RemoveMaxSubscriptionsPerTopicWithResponse call
func ParseRemoveMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*RemoveMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxSubscriptionsPerTopicResponse parses an HTTP response from a GetMaxSubscriptionsPerTopicWithResponse call
func ParseGetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*GetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxSubscriptionsPerTopicResponse parses an HTTP response from a SetMaxSubscriptionsPerTopicWithResponse call
func ParseSetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*SetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetInactiveTopicPoliciesResponse parses an HTTP response from a SetInactiveTopicPoliciesWithResponse call
func ParseSetInactiveTopicPoliciesResponse(rsp *http.Response) (*SetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxTopicsPerNamespaceResponse parses an HTTP response from a GetMaxTopicsPerNamespaceWithResponse call
func ParseGetMaxTopicsPerNamespaceResponse(rsp *http.Response) (*GetMaxTopicsPerNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxTopicsPerNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetInactiveTopicPoliciesResponse parses an HTTP response from a SetInactiveTopicPoliciesWithResponse call
func ParseSetInactiveTopicPoliciesResponse(rsp *http.Response) (*SetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxUnackedmessagesPerConsumerResponse parses an HTTP response from a RemoveMaxUnackedmessagesPerConsumerWithResponse call
func ParseRemoveMaxUnackedmessagesPerConsumerResponse(rsp *http.Response) (*RemoveMaxUnackedmessagesPerConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxUnackedmessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxUnackedMessagesPerConsumerResponse parses an HTTP response from a GetMaxUnackedMessagesPerConsumerWithResponse call
func ParseGetMaxUnackedMessagesPerConsumerResponse(rsp *http.Response) (*GetMaxUnackedMessagesPerConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxUnackedMessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxUnackedMessagesPerConsumerResponse parses an HTTP response from a SetMaxUnackedMessagesPerConsumerWithResponse call
func ParseSetMaxUnackedMessagesPerConsumerResponse(rsp *http.Response) (*SetMaxUnackedMessagesPerConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxUnackedMessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxUnackedmessagesPerSubscriptionResponse parses an HTTP response from a RemoveMaxUnackedmessagesPerSubscriptionWithResponse call
func ParseRemoveMaxUnackedmessagesPerSubscriptionResponse(rsp *http.Response) (*RemoveMaxUnackedmessagesPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxUnackedmessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxUnackedmessagesPerSubscriptionResponse parses an HTTP response from a GetMaxUnackedmessagesPerSubscriptionWithResponse call
func ParseGetMaxUnackedmessagesPerSubscriptionResponse(rsp *http.Response) (*GetMaxUnackedmessagesPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxUnackedmessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxUnackedMessagesPerSubscriptionResponse parses an HTTP response from a SetMaxUnackedMessagesPerSubscriptionWithResponse call
func ParseSetMaxUnackedMessagesPerSubscriptionResponse(rsp *http.Response) (*SetMaxUnackedMessagesPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxUnackedMessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMessageTTLResponse parses an HTTP response from a RemoveNamespaceMessageTTLWithResponse call
func ParseRemoveNamespaceMessageTTLResponse(rsp *http.Response) (*RemoveNamespaceMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMessageTTLResponse parses an HTTP response from a GetNamespaceMessageTTLWithResponse call
func ParseGetNamespaceMessageTTLResponse(rsp *http.Response) (*GetNamespaceMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceMessageTTLResponse parses an HTTP response from a SetNamespaceMessageTTLWithResponse call
func ParseSetNamespaceMessageTTLResponse(rsp *http.Response) (*SetNamespaceMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearOffloadDeletionLagResponse parses an HTTP response from a ClearOffloadDeletionLagWithResponse call
func ParseClearOffloadDeletionLagResponse(rsp *http.Response) (*ClearOffloadDeletionLagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOffloadDeletionLagResponse parses an HTTP response from a GetOffloadDeletionLagWithResponse call
func ParseGetOffloadDeletionLagResponse(rsp *http.Response) (*GetOffloadDeletionLagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetOffloadDeletionLagResponse parses an HTTP response from a SetOffloadDeletionLagWithResponse call
func ParseSetOffloadDeletionLagResponse(rsp *http.Response) (*SetOffloadDeletionLagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOffloadPoliciesResponse parses an HTTP response from a GetOffloadPoliciesWithResponse call
func ParseGetOffloadPoliciesResponse(rsp *http.Response) (*GetOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetOffloadPoliciesResponse parses an HTTP response from a SetOffloadPoliciesWithResponse call
func ParseSetOffloadPoliciesResponse(rsp *http.Response) (*SetOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOffloadThresholdResponse parses an HTTP response from a GetOffloadThresholdWithResponse call
func ParseGetOffloadThresholdResponse(rsp *http.Response) (*GetOffloadThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOffloadThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetOffloadThresholdResponse parses an HTTP response from a SetOffloadThresholdWithResponse call
func ParseSetOffloadThresholdResponse(rsp *http.Response) (*SetOffloadThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOffloadThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPermissionsResponse parses an HTTP response from a GetPermissionsWithResponse call
func ParseGetPermissionsResponse(rsp *http.Response) (*GetPermissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPermissionOnSubscriptionResponse parses an HTTP response from a GetPermissionOnSubscriptionWithResponse call
func ParseGetPermissionOnSubscriptionResponse(rsp *http.Response) (*GetPermissionOnSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokePermissionsOnNamespaceResponse parses an HTTP response from a RevokePermissionsOnNamespaceWithResponse call
func ParseRevokePermissionsOnNamespaceResponse(rsp *http.Response) (*RevokePermissionsOnNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsOnNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGrantPermissionOnNamespaceResponse parses an HTTP response from a GrantPermissionOnNamespaceWithResponse call
func ParseGrantPermissionOnNamespaceResponse(rsp *http.Response) (*GrantPermissionOnNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantPermissionOnNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistenceResponse parses an HTTP response from a DeletePersistenceWithResponse call
func ParseDeletePersistenceResponse(rsp *http.Response) (*DeletePersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistenceResponse parses an HTTP response from a GetPersistenceWithResponse call
func ParseGetPersistenceResponse(rsp *http.Response) (*GetPersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistenceResponse parses an HTTP response from a SetPersistenceWithResponse call
func ParseSetPersistenceResponse(rsp *http.Response) (*SetPersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetBookieAffinityGroupResponse parses an HTTP response from a SetBookieAffinityGroupWithResponse call
func ParseSetBookieAffinityGroupResponse(rsp *http.Response) (*SetBookieAffinityGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearPropertiesResponse parses an HTTP response from a ClearPropertiesWithResponse call
func ParseClearPropertiesResponse(rsp *http.Response) (*ClearPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPropertiesResponse parses an HTTP response from a GetPropertiesWithResponse call
func ParseGetPropertiesResponse(rsp *http.Response) (*GetPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPropertiesResponse parses an HTTP response from a SetPropertiesWithResponse call
func ParseSetPropertiesResponse(rsp *http.Response) (*SetPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePropertyResponse parses an HTTP response from a RemovePropertyWithResponse call
func ParseRemovePropertyResponse(rsp *http.Response) (*RemovePropertyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPropertyResponse parses an HTTP response from a GetPropertyWithResponse call
func ParseGetPropertyResponse(rsp *http.Response) (*GetPropertyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPropertyResponse parses an HTTP response from a SetPropertyWithResponse call
func ParseSetPropertyResponse(rsp *http.Response) (*SetPropertyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveOffloadPoliciesResponse parses an HTTP response from a RemoveOffloadPoliciesWithResponse call
func ParseRemoveOffloadPoliciesResponse(rsp *http.Response) (*RemoveOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceReplicationClustersResponse parses an HTTP response from a GetNamespaceReplicationClustersWithResponse call
func ParseGetNamespaceReplicationClustersResponse(rsp *http.Response) (*GetNamespaceReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceReplicationClustersResponse parses an HTTP response from a SetNamespaceReplicationClustersWithResponse call
func ParseSetNamespaceReplicationClustersResponse(rsp *http.Response) (*SetNamespaceReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveReplicatorDispatchRateResponse parses an HTTP response from a RemoveReplicatorDispatchRateWithResponse call
func ParseRemoveReplicatorDispatchRateResponse(rsp *http.Response) (*RemoveReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplicatorDispatchRateResponse parses an HTTP response from a GetReplicatorDispatchRateWithResponse call
func ParseGetReplicatorDispatchRateResponse(rsp *http.Response) (*GetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetReplicatorDispatchRateResponse parses an HTTP response from a SetReplicatorDispatchRateWithResponse call
func ParseSetReplicatorDispatchRateResponse(rsp *http.Response) (*SetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceResourceGroupResponse parses an HTTP response from a RemoveNamespaceResourceGroupWithResponse call
func ParseRemoveNamespaceResourceGroupResponse(rsp *http.Response) (*RemoveNamespaceResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceResourceGroupResponse parses an HTTP response from a GetNamespaceResourceGroupWithResponse call
func ParseGetNamespaceResourceGroupResponse(rsp *http.Response) (*GetNamespaceResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceResourceGroupResponse parses an HTTP response from a SetNamespaceResourceGroupWithResponse call
func ParseSetNamespaceResourceGroupResponse(rsp *http.Response) (*SetNamespaceResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveRetentionResponse parses an HTTP response from a RemoveRetentionWithResponse call
func ParseRemoveRetentionResponse(rsp *http.Response) (*RemoveRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRetentionResponse parses an HTTP response from a GetRetentionWithResponse call
func ParseGetRetentionResponse(rsp *http.Response) (*GetRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetRetentionResponse parses an HTTP response from a SetRetentionWithResponse call
func ParseSetRetentionResponse(rsp *http.Response) (*SetRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseScanOffloadedLedgersResponse parses an HTTP response from a ScanOffloadedLedgersWithResponse call
func ParseScanOffloadedLedgersResponse(rsp *http.Response) (*ScanOffloadedLedgersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScanOffloadedLedgersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaAutoUpdateCompatibilityStrategyResponse parses an HTTP response from a GetSchemaAutoUpdateCompatibilityStrategyWithResponse call
func ParseGetSchemaAutoUpdateCompatibilityStrategyResponse(rsp *http.Response) (*GetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaAutoUpdateCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetSchemaAutoUpdateCompatibilityStrategyResponse parses an HTTP response from a SetSchemaAutoUpdateCompatibilityStrategyWithResponse call
func ParseSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp *http.Response) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaAutoUpdateCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaCompatibilityStrategyResponse parses an HTTP response from a GetSchemaCompatibilityStrategyWithResponse call
func ParseGetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*GetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSchemaCompatibilityStrategyResponse parses an HTTP response from a SetSchemaCompatibilityStrategyWithResponse call
func ParseSetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*SetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaValidtionEnforcedResponse parses an HTTP response from a GetSchemaValidtionEnforcedWithResponse call
func ParseGetSchemaValidtionEnforcedResponse(rsp *http.Response) (*GetSchemaValidtionEnforcedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaValidtionEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSchemaValidationEnforcedResponse parses an HTTP response from a SetSchemaValidationEnforcedWithResponse call
func ParseSetSchemaValidationEnforcedResponse(rsp *http.Response) (*SetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubscribeRateResponse parses an HTTP response from a DeleteSubscribeRateWithResponse call
func ParseDeleteSubscribeRateResponse(rsp *http.Response) (*DeleteSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscribeRateResponse parses an HTTP response from a GetSubscribeRateWithResponse call
func ParseGetSubscribeRateResponse(rsp *http.Response) (*GetSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscribeRateResponse parses an HTTP response from a SetSubscribeRateWithResponse call
func ParseSetSubscribeRateResponse(rsp *http.Response) (*SetSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionAuthModeResponse parses an HTTP response from a GetSubscriptionAuthModeWithResponse call
func ParseGetSubscriptionAuthModeResponse(rsp *http.Response) (*GetSubscriptionAuthModeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionAuthModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionAuthModeResponse parses an HTTP response from a SetSubscriptionAuthModeWithResponse call
func ParseSetSubscriptionAuthModeResponse(rsp *http.Response) (*SetSubscriptionAuthModeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionAuthModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubscriptionDispatchRateResponse parses an HTTP response from a DeleteSubscriptionDispatchRateWithResponse call
func ParseDeleteSubscriptionDispatchRateResponse(rsp *http.Response) (*DeleteSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionDispatchRateResponse parses an HTTP response from a GetSubscriptionDispatchRateWithResponse call
func ParseGetSubscriptionDispatchRateResponse(rsp *http.Response) (*GetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionDispatchRateResponse parses an HTTP response from a SetSubscriptionDispatchRateWithResponse call
func ParseSetSubscriptionDispatchRateResponse(rsp *http.Response) (*SetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionExpirationTimeResponse parses an HTTP response from a RemoveSubscriptionExpirationTimeWithResponse call
func ParseRemoveSubscriptionExpirationTimeResponse(rsp *http.Response) (*RemoveSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionExpirationTimeResponse parses an HTTP response from a GetSubscriptionExpirationTimeWithResponse call
func ParseGetSubscriptionExpirationTimeResponse(rsp *http.Response) (*GetSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionExpirationTimeResponse parses an HTTP response from a SetSubscriptionExpirationTimeWithResponse call
func ParseSetSubscriptionExpirationTimeResponse(rsp *http.Response) (*SetSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionTypesEnabledResponse parses an HTTP response from a RemoveSubscriptionTypesEnabledWithResponse call
func ParseRemoveSubscriptionTypesEnabledResponse(rsp *http.Response) (*RemoveSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionTypesEnabledResponse parses an HTTP response from a GetSubscriptionTypesEnabledWithResponse call
func ParseGetSubscriptionTypesEnabledResponse(rsp *http.Response) (*GetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionTypesEnabledResponse parses an HTTP response from a SetSubscriptionTypesEnabledWithResponse call
func ParseSetSubscriptionTypesEnabledResponse(rsp *http.Response) (*SetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTopicsResponse parses an HTTP response from a GetTopicsWithResponse call
func ParseGetTopicsResponse(rsp *http.Response) (*GetTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnloadNamespaceResponse parses an HTTP response from a UnloadNamespaceWithResponse call
func ParseUnloadNamespaceResponse(rsp *http.Response) (*UnloadNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnsubscribeNamespaceResponse parses an HTTP response from a UnsubscribeNamespaceWithResponse call
func ParseUnsubscribeNamespaceResponse(rsp *http.Response) (*UnsubscribeNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsubscribeNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNamespaceBundleResponse parses an HTTP response from a DeleteNamespaceBundleWithResponse call
func ParseDeleteNamespaceBundleResponse(rsp *http.Response) (*DeleteNamespaceBundleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBundleBacklogResponse parses an HTTP response from a ClearNamespaceBundleBacklogWithResponse call
func ParseClearNamespaceBundleBacklogResponse(rsp *http.Response) (*ClearNamespaceBundleBacklogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBundleBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBundleBacklogForSubscriptionResponse parses an HTTP response from a ClearNamespaceBundleBacklogForSubscriptionWithResponse call
func ParseClearNamespaceBundleBacklogForSubscriptionResponse(rsp *http.Response) (*ClearNamespaceBundleBacklogForSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBundleBacklogForSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSplitNamespaceBundleResponse parses an HTTP response from a SplitNamespaceBundleWithResponse call
func ParseSplitNamespaceBundleResponse(rsp *http.Response) (*SplitNamespaceBundleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SplitNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTopicHashPositionsResponse parses an HTTP response from a GetTopicHashPositionsWithResponse call
func ParseGetTopicHashPositionsResponse(rsp *http.Response) (*GetTopicHashPositionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopicHashPositionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnloadNamespaceBundleResponse parses an HTTP response from a UnloadNamespaceBundleWithResponse call
func ParseUnloadNamespaceBundleResponse(rsp *http.Response) (*UnloadNamespaceBundleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnsubscribeNamespaceBundleResponse parses an HTTP response from a UnsubscribeNamespaceBundleWithResponse call
func ParseUnsubscribeNamespaceBundleResponse(rsp *http.Response) (*UnsubscribeNamespaceBundleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsubscribeNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetListResponse parses an HTTP response from a GetListWithResponse call
func ParseGetListResponse(rsp *http.Response) (*GetListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPartitionedTopicListResponse parses an HTTP response from a GetPartitionedTopicListWithResponse call
func ParseGetPartitionedTopicListResponse(rsp *http.Response) (*GetPartitionedTopicListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartitionedTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetListFromBundleResponse parses an HTTP response from a GetListFromBundleWithResponse call
func ParseGetListFromBundleResponse(rsp *http.Response) (*GetListFromBundleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListFromBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTopicResponse parses an HTTP response from a DeleteTopicWithResponse call
func ParseDeleteTopicResponse(rsp *http.Response) (*DeleteTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNonPartitionedTopicResponse parses an HTTP response from a CreateNonPartitionedTopicWithResponse call
func ParseCreateNonPartitionedTopicResponse(rsp *http.Response) (*CreateNonPartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNonPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireMessagesForAllSubscriptionsResponse parses an HTTP response from a ExpireMessagesForAllSubscriptionsWithResponse call
func ParseExpireMessagesForAllSubscriptionsResponse(rsp *http.Response) (*ExpireMessagesForAllSubscriptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireMessagesForAllSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBacklogResponse parses an HTTP response from a GetBacklogWithResponse call
func ParseGetBacklogResponse(rsp *http.Response) (*GetBacklogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveBacklogQuotaResponse parses an HTTP response from a RemoveBacklogQuotaWithResponse call
func ParseRemoveBacklogQuotaResponse(rsp *http.Response) (*RemoveBacklogQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetBacklogQuotaResponse parses an HTTP response from a SetBacklogQuotaWithResponse call
func ParseSetBacklogQuotaResponse(rsp *http.Response) (*SetBacklogQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBacklogQuotaMapResponse parses an HTTP response from a GetBacklogQuotaMapWithResponse call
func ParseGetBacklogQuotaMapResponse(rsp *http.Response) (*GetBacklogQuotaMapResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBacklogSizeByMessageIdResponse parses an HTTP response from a GetBacklogSizeByMessageIdWithResponse call
func ParseGetBacklogSizeByMessageIdResponse(rsp *http.Response) (*GetBacklogSizeByMessageIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBacklogSizeByMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompactionStatusResponse parses an HTTP response from a CompactionStatusWithResponse call
func ParseCompactionStatusResponse(rsp *http.Response) (*CompactionStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompactionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompactResponse parses an HTTP response from a CompactWithResponse call
func ParseCompactResponse(rsp *http.Response) (*CompactResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveCompactionThresholdResponse parses an HTTP response from a RemoveCompactionThresholdWithResponse call
func ParseRemoveCompactionThresholdResponse(rsp *http.Response) (*RemoveCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCompactionThresholdResponse parses an HTTP response from a GetCompactionThresholdWithResponse call
func ParseGetCompactionThresholdResponse(rsp *http.Response) (*GetCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetCompactionThresholdResponse parses an HTTP response from a SetCompactionThresholdWithResponse call
func ParseSetCompactionThresholdResponse(rsp *http.Response) (*SetCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateMissedPartitionsResponse parses an HTTP response from a CreateMissedPartitionsWithResponse call
func ParseCreateMissedPartitionsResponse(rsp *http.Response) (*CreateMissedPartitionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMissedPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveDeduplicationResponse parses an HTTP response from a RemoveDeduplicationWithResponse call
func ParseRemoveDeduplicationResponse(rsp *http.Response) (*RemoveDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeduplicationResponse parses an HTTP response from a GetDeduplicationWithResponse call
func ParseGetDeduplicationResponse(rsp *http.Response) (*GetDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDeduplicationResponse parses an HTTP response from a SetDeduplicationWithResponse call
func ParseSetDeduplicationResponse(rsp *http.Response) (*SetDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDeduplicationSnapshotIntervalResponse parses an HTTP response from a DeleteDeduplicationSnapshotIntervalWithResponse call
func ParseDeleteDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*DeleteDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeduplicationSnapshotIntervalResponse parses an HTTP response from a GetDeduplicationSnapshotIntervalWithResponse call
func ParseGetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*GetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDeduplicationSnapshotIntervalResponse parses an HTTP response from a SetDeduplicationSnapshotIntervalWithResponse call
func ParseSetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*SetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDelayedDeliveryPoliciesResponse parses an HTTP response from a DeleteDelayedDeliveryPoliciesWithResponse call
func ParseDeleteDelayedDeliveryPoliciesResponse(rsp *http.Response) (*DeleteDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDelayedDeliveryPoliciesResponse parses an HTTP response from a GetDelayedDeliveryPoliciesWithResponse call
func ParseGetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*GetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDelayedDeliveryPoliciesResponse parses an HTTP response from a SetDelayedDeliveryPoliciesWithResponse call
func ParseSetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*SetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveDispatchRateResponse parses an HTTP response from a RemoveDispatchRateWithResponse call
func ParseRemoveDispatchRateResponse(rsp *http.Response) (*RemoveDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDispatchRateResponse parses an HTTP response from a GetDispatchRateWithResponse call
func ParseGetDispatchRateResponse(rsp *http.Response) (*GetDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDispatchRateResponse parses an HTTP response from a SetDispatchRateWithResponse call
func ParseSetDispatchRateResponse(rsp *http.Response) (*SetDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveEntryFiltersResponse parses an HTTP response from a RemoveEntryFiltersWithResponse call
func ParseRemoveEntryFiltersResponse(rsp *http.Response) (*RemoveEntryFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEntryFiltersResponse parses an HTTP response from a GetEntryFiltersWithResponse call
func ParseGetEntryFiltersResponse(rsp *http.Response) (*GetEntryFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetEntryFiltersResponse parses an HTTP response from a SetEntryFiltersWithResponse call
func ParseSetEntryFiltersResponse(rsp *http.Response) (*SetEntryFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExamineMessageResponse parses an HTTP response from a ExamineMessageWithResponse call
func ParseExamineMessageResponse(rsp *http.Response) (*ExamineMessageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExamineMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInactiveTopicPoliciesResponse parses an HTTP response from a DeleteInactiveTopicPoliciesWithResponse call
func ParseDeleteInactiveTopicPoliciesResponse(rsp *http.Response) (*DeleteInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInactiveTopicPoliciesResponse parses an HTTP response from a GetInactiveTopicPoliciesWithResponse call
func ParseGetInactiveTopicPoliciesResponse(rsp *http.Response) (*GetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetInactiveTopicPoliciesResponse parses an HTTP response from a SetInactiveTopicPoliciesWithResponse call
func ParseSetInactiveTopicPoliciesResponse(rsp *http.Response) (*SetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetManagedLedgerInfoResponse parses an HTTP response from a GetManagedLedgerInfoWithResponse call
func ParseGetManagedLedgerInfoResponse(rsp *http.Response) (*GetManagedLedgerInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManagedLedgerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInternalStatsResponse parses an HTTP response from a GetInternalStatsWithResponse call
func ParseGetInternalStatsResponse(rsp *http.Response) (*GetInternalStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInternalStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLastMessageIdResponse parses an HTTP response from a GetLastMessageIdWithResponse call
func ParseGetLastMessageIdResponse(rsp *http.Response) (*GetLastMessageIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMessageByIdResponse parses an HTTP response from a GetMessageByIdWithResponse call
func ParseGetMessageByIdResponse(rsp *http.Response) (*GetMessageByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxConsumersResponse parses an HTTP response from a RemoveMaxConsumersWithResponse call
func ParseRemoveMaxConsumersResponse(rsp *http.Response) (*RemoveMaxConsumersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxConsumersResponse parses an HTTP response from a GetMaxConsumersWithResponse call
func ParseGetMaxConsumersResponse(rsp *http.Response) (*GetMaxConsumersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxConsumersResponse parses an HTTP response from a SetMaxConsumersWithResponse call
func ParseSetMaxConsumersResponse(rsp *http.Response) (*SetMaxConsumersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxConsumersPerSubscriptionResponse parses an HTTP response from a RemoveMaxConsumersPerSubscriptionWithResponse call
func ParseRemoveMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*RemoveMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxConsumersPerSubscriptionResponse parses an HTTP response from a GetMaxConsumersPerSubscriptionWithResponse call
func ParseGetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*GetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxConsumersPerSubscriptionResponse parses an HTTP response from a SetMaxConsumersPerSubscriptionWithResponse call
func ParseSetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*SetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxMessageSizeResponse parses an HTTP response from a RemoveMaxMessageSizeWithResponse call
func ParseRemoveMaxMessageSizeResponse(rsp *http.Response) (*RemoveMaxMessageSizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxMessageSizeResponse parses an HTTP response from a GetMaxMessageSizeWithResponse call
func ParseGetMaxMessageSizeResponse(rsp *http.Response) (*GetMaxMessageSizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxMessageSizeResponse parses an HTTP response from a SetMaxMessageSizeWithResponse call
func ParseSetMaxMessageSizeResponse(rsp *http.Response) (*SetMaxMessageSizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxProducersResponse parses an HTTP response from a RemoveMaxProducersWithResponse call
func ParseRemoveMaxProducersResponse(rsp *http.Response) (*RemoveMaxProducersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxProducersResponse parses an HTTP response from a GetMaxProducersWithResponse call
func ParseGetMaxProducersResponse(rsp *http.Response) (*GetMaxProducersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxProducersResponse parses an HTTP response from a SetMaxProducersWithResponse call
func ParseSetMaxProducersResponse(rsp *http.Response) (*SetMaxProducersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxSubscriptionsPerTopicResponse parses an HTTP response from a RemoveMaxSubscriptionsPerTopicWithResponse call
func ParseRemoveMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*RemoveMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxSubscriptionsPerTopicResponse parses an HTTP response from a GetMaxSubscriptionsPerTopicWithResponse call
func ParseGetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*GetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxSubscriptionsPerTopicResponse parses an HTTP response from a SetMaxSubscriptionsPerTopicWithResponse call
func ParseSetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*SetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a DeleteMaxUnackedMessagesOnConsumerWithResponse call
func ParseDeleteMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*DeleteMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a GetMaxUnackedMessagesOnConsumerWithResponse call
func ParseGetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*GetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a SetMaxUnackedMessagesOnConsumerWithResponse call
func ParseSetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*SetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a DeleteMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*DeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a GetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseGetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*GetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a SetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseSetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*SetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMessageTTLResponse parses an HTTP response from a RemoveMessageTTLWithResponse call
func ParseRemoveMessageTTLResponse(rsp *http.Response) (*RemoveMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMessageTTLResponse parses an HTTP response from a GetMessageTTLWithResponse call
func ParseGetMessageTTLResponse(rsp *http.Response) (*GetMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMessageTTLResponse parses an HTTP response from a SetMessageTTLWithResponse call
func ParseSetMessageTTLResponse(rsp *http.Response) (*SetMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMessageIdByTimestampResponse parses an HTTP response from a GetMessageIdByTimestampWithResponse call
func ParseGetMessageIdByTimestampResponse(rsp *http.Response) (*GetMessageIdByTimestampResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageIdByTimestampResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOffloadStatusResponse parses an HTTP response from a OffloadStatusWithResponse call
func ParseOffloadStatusResponse(rsp *http.Response) (*OffloadStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OffloadStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTriggerOffloadResponse parses an HTTP response from a TriggerOffloadWithResponse call
func ParseTriggerOffloadResponse(rsp *http.Response) (*TriggerOffloadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerOffloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveOffloadPoliciesResponse parses an HTTP response from a RemoveOffloadPoliciesWithResponse call
func ParseRemoveOffloadPoliciesResponse(rsp *http.Response) (*RemoveOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOffloadPoliciesResponse parses an HTTP response from a GetOffloadPoliciesWithResponse call
func ParseGetOffloadPoliciesResponse(rsp *http.Response) (*GetOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetOffloadPoliciesResponse parses an HTTP response from a SetOffloadPoliciesWithResponse call
func ParseSetOffloadPoliciesResponse(rsp *http.Response) (*SetOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPartitionedStatsResponse parses an HTTP response from a GetPartitionedStatsWithResponse call
func ParseGetPartitionedStatsResponse(rsp *http.Response) (*GetPartitionedStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartitionedStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePartitionedTopicResponse parses an HTTP response from a DeletePartitionedTopicWithResponse call
func ParseDeletePartitionedTopicResponse(rsp *http.Response) (*DeletePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPartitionedMetadataResponse parses an HTTP response from a GetPartitionedMetadataWithResponse call
func ParseGetPartitionedMetadataResponse(rsp *http.Response) (*GetPartitionedMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartitionedMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePartitionedTopicResponse parses an HTTP response from a UpdatePartitionedTopicWithResponse call
func ParseUpdatePartitionedTopicResponse(rsp *http.Response) (*UpdatePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePartitionedTopicResponse parses an HTTP response from a CreatePartitionedTopicWithResponse call
func ParseCreatePartitionedTopicResponse(rsp *http.Response) (*CreatePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPermissionsOnTopicResponse parses an HTTP response from a GetPermissionsOnTopicWithResponse call
func ParseGetPermissionsOnTopicResponse(rsp *http.Response) (*GetPermissionsOnTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokePermissionsOnTopicResponse parses an HTTP response from a RevokePermissionsOnTopicWithResponse call
func ParseRevokePermissionsOnTopicResponse(rsp *http.Response) (*RevokePermissionsOnTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGrantPermissionsOnTopicResponse parses an HTTP response from a GrantPermissionsOnTopicWithResponse call
func ParseGrantPermissionsOnTopicResponse(rsp *http.Response) (*GrantPermissionsOnTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistenceResponse parses an HTTP response from a RemovePersistenceWithResponse call
func ParseRemovePersistenceResponse(rsp *http.Response) (*RemovePersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistenceResponse parses an HTTP response from a GetPersistenceWithResponse call
func ParseGetPersistenceResponse(rsp *http.Response) (*GetPersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistenceResponse parses an HTTP response from a SetPersistenceWithResponse call
func ParseSetPersistenceResponse(rsp *http.Response) (*SetPersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePropertiesResponse parses an HTTP response from a RemovePropertiesWithResponse call
func ParseRemovePropertiesResponse(rsp *http.Response) (*RemovePropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPropertiesResponse parses an HTTP response from a GetPropertiesWithResponse call
func ParseGetPropertiesResponse(rsp *http.Response) (*GetPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePropertiesResponse parses an HTTP response from a UpdatePropertiesWithResponse call
func ParseUpdatePropertiesResponse(rsp *http.Response) (*UpdatePropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePublishRateResponse parses an HTTP response from a RemovePublishRateWithResponse call
func ParseRemovePublishRateResponse(rsp *http.Response) (*RemovePublishRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPublishRateResponse parses an HTTP response from a GetPublishRateWithResponse call
func ParseGetPublishRateResponse(rsp *http.Response) (*GetPublishRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPublishRateResponse parses an HTTP response from a SetPublishRateWithResponse call
func ParseSetPublishRateResponse(rsp *http.Response) (*SetPublishRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveReplicationClustersResponse parses an HTTP response from a RemoveReplicationClustersWithResponse call
func ParseRemoveReplicationClustersResponse(rsp *http.Response) (*RemoveReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplicationClustersResponse parses an HTTP response from a GetReplicationClustersWithResponse call
func ParseGetReplicationClustersResponse(rsp *http.Response) (*GetReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetReplicationClustersResponse parses an HTTP response from a SetReplicationClustersWithResponse call
func ParseSetReplicationClustersResponse(rsp *http.Response) (*SetReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveReplicatorDispatchRateResponse parses an HTTP response from a RemoveReplicatorDispatchRateWithResponse call
func ParseRemoveReplicatorDispatchRateResponse(rsp *http.Response) (*RemoveReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplicatorDispatchRateResponse parses an HTTP response from a GetReplicatorDispatchRateWithResponse call
func ParseGetReplicatorDispatchRateResponse(rsp *http.Response) (*GetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetReplicatorDispatchRateResponse parses an HTTP response from a SetReplicatorDispatchRateWithResponse call
func ParseSetReplicatorDispatchRateResponse(rsp *http.Response) (*SetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveRetentionResponse parses an HTTP response from a RemoveRetentionWithResponse call
func ParseRemoveRetentionResponse(rsp *http.Response) (*RemoveRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRetentionResponse parses an HTTP response from a GetRetentionWithResponse call
func ParseGetRetentionResponse(rsp *http.Response) (*GetRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetRetentionResponse parses an HTTP response from a SetRetentionWithResponse call
func ParseSetRetentionResponse(rsp *http.Response) (*SetRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSchemaCompatibilityStrategyResponse parses an HTTP response from a RemoveSchemaCompatibilityStrategyWithResponse call
func ParseRemoveSchemaCompatibilityStrategyResponse(rsp *http.Response) (*RemoveSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaCompatibilityStrategyResponse parses an HTTP response from a GetSchemaCompatibilityStrategyWithResponse call
func ParseGetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*GetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSchemaCompatibilityStrategyResponse parses an HTTP response from a SetSchemaCompatibilityStrategyWithResponse call
func ParseSetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*SetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaValidationEnforcedResponse parses an HTTP response from a GetSchemaValidationEnforcedWithResponse call
func ParseGetSchemaValidationEnforcedResponse(rsp *http.Response) (*GetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSchemaValidationEnforcedResponse parses an HTTP response from a SetSchemaValidationEnforcedWithResponse call
func ParseSetSchemaValidationEnforcedResponse(rsp *http.Response) (*SetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteShadowTopicsResponse parses an HTTP response from a DeleteShadowTopicsWithResponse call
func ParseDeleteShadowTopicsResponse(rsp *http.Response) (*DeleteShadowTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetShadowTopicsResponse parses an HTTP response from a GetShadowTopicsWithResponse call
func ParseGetShadowTopicsResponse(rsp *http.Response) (*GetShadowTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetShadowTopicsResponse parses an HTTP response from a SetShadowTopicsWithResponse call
func ParseSetShadowTopicsResponse(rsp *http.Response) (*SetShadowTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscribeRateResponse parses an HTTP response from a RemoveSubscribeRateWithResponse call
func ParseRemoveSubscribeRateResponse(rsp *http.Response) (*RemoveSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscribeRateResponse parses an HTTP response from a GetSubscribeRateWithResponse call
func ParseGetSubscribeRateResponse(rsp *http.Response) (*GetSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscribeRateResponse parses an HTTP response from a SetSubscribeRateWithResponse call
func ParseSetSubscribeRateResponse(rsp *http.Response) (*SetSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAnalyzeSubscriptionBacklogResponse parses an HTTP response from a AnalyzeSubscriptionBacklogWithResponse call
func ParseAnalyzeSubscriptionBacklogResponse(rsp *http.Response) (*AnalyzeSubscriptionBacklogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyzeSubscriptionBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireTopicMessagesResponse parses an HTTP response from a ExpireTopicMessagesWithResponse call
func ParseExpireTopicMessagesResponse(rsp *http.Response) (*ExpireTopicMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireTopicMessagesResponse parses an HTTP response from a ExpireTopicMessagesWithResponse call
func ParseExpireTopicMessagesResponse(rsp *http.Response) (*ExpireTopicMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePeekNthMessageResponse parses an HTTP response from a PeekNthMessageWithResponse call
func ParsePeekNthMessageResponse(rsp *http.Response) (*PeekNthMessageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PeekNthMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionPropertiesResponse parses an HTTP response from a GetSubscriptionPropertiesWithResponse call
func ParseGetSubscriptionPropertiesResponse(rsp *http.Response) (*GetSubscriptionPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateSubscriptionPropertiesResponse parses an HTTP response from a UpdateSubscriptionPropertiesWithResponse call
func ParseUpdateSubscriptionPropertiesResponse(rsp *http.Response) (*UpdateSubscriptionPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplicatedSubscriptionStatusResponse parses an HTTP response from a GetReplicatedSubscriptionStatusWithResponse call
func ParseGetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*GetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetReplicatedSubscriptionStatusResponse parses an HTTP response from a SetReplicatedSubscriptionStatusWithResponse call
func ParseSetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*SetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetCursorOnPositionResponse parses an HTTP response from a ResetCursorOnPositionWithResponse call
func ParseResetCursorOnPositionResponse(rsp *http.Response) (*ResetCursorOnPositionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetCursorOnPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetCursorResponse parses an HTTP response from a ResetCursorWithResponse call
func ParseResetCursorResponse(rsp *http.Response) (*ResetCursorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetCursorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipMessagesResponse parses an HTTP response from a SkipMessagesWithResponse call
func ParseSkipMessagesResponse(rsp *http.Response) (*SkipMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipAllMessagesResponse parses an HTTP response from a SkipAllMessagesWithResponse call
func ParseSkipAllMessagesResponse(rsp *http.Response) (*SkipAllMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipAllMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionDispatchRateResponse parses an HTTP response from a RemoveSubscriptionDispatchRateWithResponse call
func ParseRemoveSubscriptionDispatchRateResponse(rsp *http.Response) (*RemoveSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionDispatchRateResponse parses an HTTP response from a GetSubscriptionDispatchRateWithResponse call
func ParseGetSubscriptionDispatchRateResponse(rsp *http.Response) (*GetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionDispatchRateResponse parses an HTTP response from a SetSubscriptionDispatchRateWithResponse call
func ParseSetSubscriptionDispatchRateResponse(rsp *http.Response) (*SetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionTypesEnabledResponse parses an HTTP response from a RemoveSubscriptionTypesEnabledWithResponse call
func ParseRemoveSubscriptionTypesEnabledResponse(rsp *http.Response) (*RemoveSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionTypesEnabledResponse parses an HTTP response from a GetSubscriptionTypesEnabledWithResponse call
func ParseGetSubscriptionTypesEnabledResponse(rsp *http.Response) (*GetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionTypesEnabledResponse parses an HTTP response from a SetSubscriptionTypesEnabledWithResponse call
func ParseSetSubscriptionTypesEnabledResponse(rsp *http.Response) (*SetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionsResponse parses an HTTP response from a GetSubscriptionsWithResponse call
func ParseGetSubscriptionsResponse(rsp *http.Response) (*GetSubscriptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminateResponse parses an HTTP response from a TerminateWithResponse call
func ParseTerminateResponse(rsp *http.Response) (*TerminateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminatePartitionedTopicResponse parses an HTTP response from a TerminatePartitionedTopicWithResponse call
func ParseTerminatePartitionedTopicResponse(rsp *http.Response) (*TerminatePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTruncateTopicResponse parses an HTTP response from a TruncateTopicWithResponse call
func ParseTruncateTopicResponse(rsp *http.Response) (*TruncateTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TruncateTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnloadTopicResponse parses an HTTP response from a UnloadTopicWithResponse call
func ParseUnloadTopicResponse(rsp *http.Response) (*UnloadTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionLevelDispatchRateResponse parses an HTTP response from a RemoveSubscriptionLevelDispatchRateWithResponse call
func ParseRemoveSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*RemoveSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionLevelDispatchRateResponse parses an HTTP response from a GetSubscriptionLevelDispatchRateWithResponse call
func ParseGetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*GetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionLevelDispatchRateResponse parses an HTTP response from a SetSubscriptionLevelDispatchRateWithResponse call
func ParseSetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*SetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetListResponse parses an HTTP response from a GetListWithResponse call
func ParseGetListResponse(rsp *http.Response) (*GetListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPartitionedTopicListResponse parses an HTTP response from a GetPartitionedTopicListWithResponse call
func ParseGetPartitionedTopicListResponse(rsp *http.Response) (*GetPartitionedTopicListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartitionedTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTopicResponse parses an HTTP response from a DeleteTopicWithResponse call
func ParseDeleteTopicResponse(rsp *http.Response) (*DeleteTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNonPartitionedTopicResponse parses an HTTP response from a CreateNonPartitionedTopicWithResponse call
func ParseCreateNonPartitionedTopicResponse(rsp *http.Response) (*CreateNonPartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNonPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireMessagesForAllSubscriptionsResponse parses an HTTP response from a ExpireMessagesForAllSubscriptionsWithResponse call
func ParseExpireMessagesForAllSubscriptionsResponse(rsp *http.Response) (*ExpireMessagesForAllSubscriptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireMessagesForAllSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBacklogResponse parses an HTTP response from a GetBacklogWithResponse call
func ParseGetBacklogResponse(rsp *http.Response) (*GetBacklogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveBacklogQuotaResponse parses an HTTP response from a RemoveBacklogQuotaWithResponse call
func ParseRemoveBacklogQuotaResponse(rsp *http.Response) (*RemoveBacklogQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetBacklogQuotaResponse parses an HTTP response from a SetBacklogQuotaWithResponse call
func ParseSetBacklogQuotaResponse(rsp *http.Response) (*SetBacklogQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBacklogQuotaMapResponse parses an HTTP response from a GetBacklogQuotaMapWithResponse call
func ParseGetBacklogQuotaMapResponse(rsp *http.Response) (*GetBacklogQuotaMapResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBacklogSizeByMessageIdResponse parses an HTTP response from a GetBacklogSizeByMessageIdWithResponse call
func ParseGetBacklogSizeByMessageIdResponse(rsp *http.Response) (*GetBacklogSizeByMessageIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBacklogSizeByMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompactionStatusResponse parses an HTTP response from a CompactionStatusWithResponse call
func ParseCompactionStatusResponse(rsp *http.Response) (*CompactionStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompactionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompactResponse parses an HTTP response from a CompactWithResponse call
func ParseCompactResponse(rsp *http.Response) (*CompactResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveCompactionThresholdResponse parses an HTTP response from a RemoveCompactionThresholdWithResponse call
func ParseRemoveCompactionThresholdResponse(rsp *http.Response) (*RemoveCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCompactionThresholdResponse parses an HTTP response from a GetCompactionThresholdWithResponse call
func ParseGetCompactionThresholdResponse(rsp *http.Response) (*GetCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetCompactionThresholdResponse parses an HTTP response from a SetCompactionThresholdWithResponse call
func ParseSetCompactionThresholdResponse(rsp *http.Response) (*SetCompactionThresholdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateMissedPartitionsResponse parses an HTTP response from a CreateMissedPartitionsWithResponse call
func ParseCreateMissedPartitionsResponse(rsp *http.Response) (*CreateMissedPartitionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMissedPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveDeduplicationResponse parses an HTTP response from a RemoveDeduplicationWithResponse call
func ParseRemoveDeduplicationResponse(rsp *http.Response) (*RemoveDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeduplicationResponse parses an HTTP response from a GetDeduplicationWithResponse call
func ParseGetDeduplicationResponse(rsp *http.Response) (*GetDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDeduplicationResponse parses an HTTP response from a SetDeduplicationWithResponse call
func ParseSetDeduplicationResponse(rsp *http.Response) (*SetDeduplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDeduplicationSnapshotIntervalResponse parses an HTTP response from a DeleteDeduplicationSnapshotIntervalWithResponse call
func ParseDeleteDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*DeleteDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeduplicationSnapshotIntervalResponse parses an HTTP response from a GetDeduplicationSnapshotIntervalWithResponse call
func ParseGetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*GetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDeduplicationSnapshotIntervalResponse parses an HTTP response from a SetDeduplicationSnapshotIntervalWithResponse call
func ParseSetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*SetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDelayedDeliveryPoliciesResponse parses an HTTP response from a DeleteDelayedDeliveryPoliciesWithResponse call
func ParseDeleteDelayedDeliveryPoliciesResponse(rsp *http.Response) (*DeleteDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDelayedDeliveryPoliciesResponse parses an HTTP response from a GetDelayedDeliveryPoliciesWithResponse call
func ParseGetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*GetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDelayedDeliveryPoliciesResponse parses an HTTP response from a SetDelayedDeliveryPoliciesWithResponse call
func ParseSetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*SetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveDispatchRateResponse parses an HTTP response from a RemoveDispatchRateWithResponse call
func ParseRemoveDispatchRateResponse(rsp *http.Response) (*RemoveDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDispatchRateResponse parses an HTTP response from a GetDispatchRateWithResponse call
func ParseGetDispatchRateResponse(rsp *http.Response) (*GetDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetDispatchRateResponse parses an HTTP response from a SetDispatchRateWithResponse call
func ParseSetDispatchRateResponse(rsp *http.Response) (*SetDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveEntryFiltersResponse parses an HTTP response from a RemoveEntryFiltersWithResponse call
func ParseRemoveEntryFiltersResponse(rsp *http.Response) (*RemoveEntryFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEntryFiltersResponse parses an HTTP response from a GetEntryFiltersWithResponse call
func ParseGetEntryFiltersResponse(rsp *http.Response) (*GetEntryFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetEntryFiltersResponse parses an HTTP response from a SetEntryFiltersWithResponse call
func ParseSetEntryFiltersResponse(rsp *http.Response) (*SetEntryFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExamineMessageResponse parses an HTTP response from a ExamineMessageWithResponse call
func ParseExamineMessageResponse(rsp *http.Response) (*ExamineMessageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExamineMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInactiveTopicPoliciesResponse parses an HTTP response from a DeleteInactiveTopicPoliciesWithResponse call
func ParseDeleteInactiveTopicPoliciesResponse(rsp *http.Response) (*DeleteInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInactiveTopicPoliciesResponse parses an HTTP response from a GetInactiveTopicPoliciesWithResponse call
func ParseGetInactiveTopicPoliciesResponse(rsp *http.Response) (*GetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetInactiveTopicPoliciesResponse parses an HTTP response from a SetInactiveTopicPoliciesWithResponse call
func ParseSetInactiveTopicPoliciesResponse(rsp *http.Response) (*SetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetManagedLedgerInfoResponse parses an HTTP response from a GetManagedLedgerInfoWithResponse call
func ParseGetManagedLedgerInfoResponse(rsp *http.Response) (*GetManagedLedgerInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManagedLedgerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInternalStatsResponse parses an HTTP response from a GetInternalStatsWithResponse call
func ParseGetInternalStatsResponse(rsp *http.Response) (*GetInternalStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInternalStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLastMessageIdResponse parses an HTTP response from a GetLastMessageIdWithResponse call
func ParseGetLastMessageIdResponse(rsp *http.Response) (*GetLastMessageIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLastMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMessageByIdResponse parses an HTTP response from a GetMessageByIdWithResponse call
func ParseGetMessageByIdResponse(rsp *http.Response) (*GetMessageByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxConsumersResponse parses an HTTP response from a RemoveMaxConsumersWithResponse call
func ParseRemoveMaxConsumersResponse(rsp *http.Response) (*RemoveMaxConsumersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxConsumersResponse parses an HTTP response from a GetMaxConsumersWithResponse call
func ParseGetMaxConsumersResponse(rsp *http.Response) (*GetMaxConsumersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxConsumersResponse parses an HTTP response from a SetMaxConsumersWithResponse call
func ParseSetMaxConsumersResponse(rsp *http.Response) (*SetMaxConsumersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxConsumersPerSubscriptionResponse parses an HTTP response from a RemoveMaxConsumersPerSubscriptionWithResponse call
func ParseRemoveMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*RemoveMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxConsumersPerSubscriptionResponse parses an HTTP response from a GetMaxConsumersPerSubscriptionWithResponse call
func ParseGetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*GetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxConsumersPerSubscriptionResponse parses an HTTP response from a SetMaxConsumersPerSubscriptionWithResponse call
func ParseSetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*SetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxMessageSizeResponse parses an HTTP response from a RemoveMaxMessageSizeWithResponse call
func ParseRemoveMaxMessageSizeResponse(rsp *http.Response) (*RemoveMaxMessageSizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxMessageSizeResponse parses an HTTP response from a GetMaxMessageSizeWithResponse call
func ParseGetMaxMessageSizeResponse(rsp *http.Response) (*GetMaxMessageSizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxMessageSizeResponse parses an HTTP response from a SetMaxMessageSizeWithResponse call
func ParseSetMaxMessageSizeResponse(rsp *http.Response) (*SetMaxMessageSizeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxProducersResponse parses an HTTP response from a RemoveMaxProducersWithResponse call
func ParseRemoveMaxProducersResponse(rsp *http.Response) (*RemoveMaxProducersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxProducersResponse parses an HTTP response from a GetMaxProducersWithResponse call
func ParseGetMaxProducersResponse(rsp *http.Response) (*GetMaxProducersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxProducersResponse parses an HTTP response from a SetMaxProducersWithResponse call
func ParseSetMaxProducersResponse(rsp *http.Response) (*SetMaxProducersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMaxSubscriptionsPerTopicResponse parses an HTTP response from a RemoveMaxSubscriptionsPerTopicWithResponse call
func ParseRemoveMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*RemoveMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxSubscriptionsPerTopicResponse parses an HTTP response from a GetMaxSubscriptionsPerTopicWithResponse call
func ParseGetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*GetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxSubscriptionsPerTopicResponse parses an HTTP response from a SetMaxSubscriptionsPerTopicWithResponse call
func ParseSetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*SetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a DeleteMaxUnackedMessagesOnConsumerWithResponse call
func ParseDeleteMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*DeleteMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a GetMaxUnackedMessagesOnConsumerWithResponse call
func ParseGetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*GetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a SetMaxUnackedMessagesOnConsumerWithResponse call
func ParseSetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*SetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a DeleteMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*DeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a GetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseGetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*GetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a SetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseSetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*SetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMessageTTLResponse parses an HTTP response from a RemoveMessageTTLWithResponse call
func ParseRemoveMessageTTLResponse(rsp *http.Response) (*RemoveMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMessageTTLResponse parses an HTTP response from a GetMessageTTLWithResponse call
func ParseGetMessageTTLResponse(rsp *http.Response) (*GetMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetMessageTTLResponse parses an HTTP response from a SetMessageTTLWithResponse call
func ParseSetMessageTTLResponse(rsp *http.Response) (*SetMessageTTLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMessageIdByTimestampResponse parses an HTTP response from a GetMessageIdByTimestampWithResponse call
func ParseGetMessageIdByTimestampResponse(rsp *http.Response) (*GetMessageIdByTimestampResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageIdByTimestampResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOffloadStatusResponse parses an HTTP response from a OffloadStatusWithResponse call
func ParseOffloadStatusResponse(rsp *http.Response) (*OffloadStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OffloadStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTriggerOffloadResponse parses an HTTP response from a TriggerOffloadWithResponse call
func ParseTriggerOffloadResponse(rsp *http.Response) (*TriggerOffloadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerOffloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveOffloadPoliciesResponse parses an HTTP response from a RemoveOffloadPoliciesWithResponse call
func ParseRemoveOffloadPoliciesResponse(rsp *http.Response) (*RemoveOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOffloadPoliciesResponse parses an HTTP response from a GetOffloadPoliciesWithResponse call
func ParseGetOffloadPoliciesResponse(rsp *http.Response) (*GetOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetOffloadPoliciesResponse parses an HTTP response from a SetOffloadPoliciesWithResponse call
func ParseSetOffloadPoliciesResponse(rsp *http.Response) (*SetOffloadPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPartitionedStatsResponse parses an HTTP response from a GetPartitionedStatsWithResponse call
func ParseGetPartitionedStatsResponse(rsp *http.Response) (*GetPartitionedStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartitionedStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePartitionedTopicResponse parses an HTTP response from a DeletePartitionedTopicWithResponse call
func ParseDeletePartitionedTopicResponse(rsp *http.Response) (*DeletePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPartitionedMetadataResponse parses an HTTP response from a GetPartitionedMetadataWithResponse call
func ParseGetPartitionedMetadataResponse(rsp *http.Response) (*GetPartitionedMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPartitionedMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePartitionedTopicResponse parses an HTTP response from a UpdatePartitionedTopicWithResponse call
func ParseUpdatePartitionedTopicResponse(rsp *http.Response) (*UpdatePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePartitionedTopicResponse parses an HTTP response from a CreatePartitionedTopicWithResponse call
func ParseCreatePartitionedTopicResponse(rsp *http.Response) (*CreatePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPermissionsOnTopicResponse parses an HTTP response from a GetPermissionsOnTopicWithResponse call
func ParseGetPermissionsOnTopicResponse(rsp *http.Response) (*GetPermissionsOnTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokePermissionsOnTopicResponse parses an HTTP response from a RevokePermissionsOnTopicWithResponse call
func ParseRevokePermissionsOnTopicResponse(rsp *http.Response) (*RevokePermissionsOnTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGrantPermissionsOnTopicResponse parses an HTTP response from a GrantPermissionsOnTopicWithResponse call
func ParseGrantPermissionsOnTopicResponse(rsp *http.Response) (*GrantPermissionsOnTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistenceResponse parses an HTTP response from a RemovePersistenceWithResponse call
func ParseRemovePersistenceResponse(rsp *http.Response) (*RemovePersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistenceResponse parses an HTTP response from a GetPersistenceWithResponse call
func ParseGetPersistenceResponse(rsp *http.Response) (*GetPersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistenceResponse parses an HTTP response from a SetPersistenceWithResponse call
func ParseSetPersistenceResponse(rsp *http.Response) (*SetPersistenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePropertiesResponse parses an HTTP response from a RemovePropertiesWithResponse call
func ParseRemovePropertiesResponse(rsp *http.Response) (*RemovePropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPropertiesResponse parses an HTTP response from a GetPropertiesWithResponse call
func ParseGetPropertiesResponse(rsp *http.Response) (*GetPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePropertiesResponse parses an HTTP response from a UpdatePropertiesWithResponse call
func ParseUpdatePropertiesResponse(rsp *http.Response) (*UpdatePropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePublishRateResponse parses an HTTP response from a RemovePublishRateWithResponse call
func ParseRemovePublishRateResponse(rsp *http.Response) (*RemovePublishRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPublishRateResponse parses an HTTP response from a GetPublishRateWithResponse call
func ParseGetPublishRateResponse(rsp *http.Response) (*GetPublishRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPublishRateResponse parses an HTTP response from a SetPublishRateWithResponse call
func ParseSetPublishRateResponse(rsp *http.Response) (*SetPublishRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveReplicationClustersResponse parses an HTTP response from a RemoveReplicationClustersWithResponse call
func ParseRemoveReplicationClustersResponse(rsp *http.Response) (*RemoveReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplicationClustersResponse parses an HTTP response from a GetReplicationClustersWithResponse call
func ParseGetReplicationClustersResponse(rsp *http.Response) (*GetReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetReplicationClustersResponse parses an HTTP response from a SetReplicationClustersWithResponse call
func ParseSetReplicationClustersResponse(rsp *http.Response) (*SetReplicationClustersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveReplicatorDispatchRateResponse parses an HTTP response from a RemoveReplicatorDispatchRateWithResponse call
func ParseRemoveReplicatorDispatchRateResponse(rsp *http.Response) (*RemoveReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplicatorDispatchRateResponse parses an HTTP response from a GetReplicatorDispatchRateWithResponse call
func ParseGetReplicatorDispatchRateResponse(rsp *http.Response) (*GetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetReplicatorDispatchRateResponse parses an HTTP response from a SetReplicatorDispatchRateWithResponse call
func ParseSetReplicatorDispatchRateResponse(rsp *http.Response) (*SetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveRetentionResponse parses an HTTP response from a RemoveRetentionWithResponse call
func ParseRemoveRetentionResponse(rsp *http.Response) (*RemoveRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRetentionResponse parses an HTTP response from a GetRetentionWithResponse call
func ParseGetRetentionResponse(rsp *http.Response) (*GetRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetRetentionResponse parses an HTTP response from a SetRetentionWithResponse call
func ParseSetRetentionResponse(rsp *http.Response) (*SetRetentionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSchemaCompatibilityStrategyResponse parses an HTTP response from a RemoveSchemaCompatibilityStrategyWithResponse call
func ParseRemoveSchemaCompatibilityStrategyResponse(rsp *http.Response) (*RemoveSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaCompatibilityStrategyResponse parses an HTTP response from a GetSchemaCompatibilityStrategyWithResponse call
func ParseGetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*GetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSchemaCompatibilityStrategyResponse parses an HTTP response from a SetSchemaCompatibilityStrategyWithResponse call
func ParseSetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*SetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaValidationEnforcedResponse parses an HTTP response from a GetSchemaValidationEnforcedWithResponse call
func ParseGetSchemaValidationEnforcedResponse(rsp *http.Response) (*GetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSchemaValidationEnforcedResponse parses an HTTP response from a SetSchemaValidationEnforcedWithResponse call
func ParseSetSchemaValidationEnforcedResponse(rsp *http.Response) (*SetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteShadowTopicsResponse parses an HTTP response from a DeleteShadowTopicsWithResponse call
func ParseDeleteShadowTopicsResponse(rsp *http.Response) (*DeleteShadowTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetShadowTopicsResponse parses an HTTP response from a GetShadowTopicsWithResponse call
func ParseGetShadowTopicsResponse(rsp *http.Response) (*GetShadowTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetShadowTopicsResponse parses an HTTP response from a SetShadowTopicsWithResponse call
func ParseSetShadowTopicsResponse(rsp *http.Response) (*SetShadowTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscribeRateResponse parses an HTTP response from a RemoveSubscribeRateWithResponse call
func ParseRemoveSubscribeRateResponse(rsp *http.Response) (*RemoveSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscribeRateResponse parses an HTTP response from a GetSubscribeRateWithResponse call
func ParseGetSubscribeRateResponse(rsp *http.Response) (*GetSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscribeRateResponse parses an HTTP response from a SetSubscribeRateWithResponse call
func ParseSetSubscribeRateResponse(rsp *http.Response) (*SetSubscribeRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAnalyzeSubscriptionBacklogResponse parses an HTTP response from a AnalyzeSubscriptionBacklogWithResponse call
func ParseAnalyzeSubscriptionBacklogResponse(rsp *http.Response) (*AnalyzeSubscriptionBacklogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyzeSubscriptionBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireTopicMessagesResponse parses an HTTP response from a ExpireTopicMessagesWithResponse call
func ParseExpireTopicMessagesResponse(rsp *http.Response) (*ExpireTopicMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireTopicMessagesResponse parses an HTTP response from a ExpireTopicMessagesWithResponse call
func ParseExpireTopicMessagesResponse(rsp *http.Response) (*ExpireTopicMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePeekNthMessageResponse parses an HTTP response from a PeekNthMessageWithResponse call
func ParsePeekNthMessageResponse(rsp *http.Response) (*PeekNthMessageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PeekNthMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionPropertiesResponse parses an HTTP response from a GetSubscriptionPropertiesWithResponse call
func ParseGetSubscriptionPropertiesResponse(rsp *http.Response) (*GetSubscriptionPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateSubscriptionPropertiesResponse parses an HTTP response from a UpdateSubscriptionPropertiesWithResponse call
func ParseUpdateSubscriptionPropertiesResponse(rsp *http.Response) (*UpdateSubscriptionPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReplicatedSubscriptionStatusResponse parses an HTTP response from a GetReplicatedSubscriptionStatusWithResponse call
func ParseGetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*GetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetReplicatedSubscriptionStatusResponse parses an HTTP response from a SetReplicatedSubscriptionStatusWithResponse call
func ParseSetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*SetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetCursorOnPositionResponse parses an HTTP response from a ResetCursorOnPositionWithResponse call
func ParseResetCursorOnPositionResponse(rsp *http.Response) (*ResetCursorOnPositionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetCursorOnPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetCursorResponse parses an HTTP response from a ResetCursorWithResponse call
func ParseResetCursorResponse(rsp *http.Response) (*ResetCursorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetCursorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipMessagesResponse parses an HTTP response from a SkipMessagesWithResponse call
func ParseSkipMessagesResponse(rsp *http.Response) (*SkipMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipAllMessagesResponse parses an HTTP response from a SkipAllMessagesWithResponse call
func ParseSkipAllMessagesResponse(rsp *http.Response) (*SkipAllMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipAllMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionDispatchRateResponse parses an HTTP response from a RemoveSubscriptionDispatchRateWithResponse call
func ParseRemoveSubscriptionDispatchRateResponse(rsp *http.Response) (*RemoveSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionDispatchRateResponse parses an HTTP response from a GetSubscriptionDispatchRateWithResponse call
func ParseGetSubscriptionDispatchRateResponse(rsp *http.Response) (*GetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionDispatchRateResponse parses an HTTP response from a SetSubscriptionDispatchRateWithResponse call
func ParseSetSubscriptionDispatchRateResponse(rsp *http.Response) (*SetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionTypesEnabledResponse parses an HTTP response from a RemoveSubscriptionTypesEnabledWithResponse call
func ParseRemoveSubscriptionTypesEnabledResponse(rsp *http.Response) (*RemoveSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionTypesEnabledResponse parses an HTTP response from a GetSubscriptionTypesEnabledWithResponse call
func ParseGetSubscriptionTypesEnabledResponse(rsp *http.Response) (*GetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionTypesEnabledResponse parses an HTTP response from a SetSubscriptionTypesEnabledWithResponse call
func ParseSetSubscriptionTypesEnabledResponse(rsp *http.Response) (*SetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionsResponse parses an HTTP response from a GetSubscriptionsWithResponse call
func ParseGetSubscriptionsResponse(rsp *http.Response) (*GetSubscriptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminateResponse parses an HTTP response from a TerminateWithResponse call
func ParseTerminateResponse(rsp *http.Response) (*TerminateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminatePartitionedTopicResponse parses an HTTP response from a TerminatePartitionedTopicWithResponse call
func ParseTerminatePartitionedTopicResponse(rsp *http.Response) (*TerminatePartitionedTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTruncateTopicResponse parses an HTTP response from a TruncateTopicWithResponse call
func ParseTruncateTopicResponse(rsp *http.Response) (*TruncateTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TruncateTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnloadTopicResponse parses an HTTP response from a UnloadTopicWithResponse call
func ParseUnloadTopicResponse(rsp *http.Response) (*UnloadTopicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionLevelDispatchRateResponse parses an HTTP response from a RemoveSubscriptionLevelDispatchRateWithResponse call
func ParseRemoveSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*RemoveSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionLevelDispatchRateResponse parses an HTTP response from a GetSubscriptionLevelDispatchRateWithResponse call
func ParseGetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*GetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetSubscriptionLevelDispatchRateResponse parses an HTTP response from a SetSubscriptionLevelDispatchRateWithResponse call
func ParseSetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*SetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultResourceQuotaResponse parses an HTTP response from a GetDefaultResourceQuotaWithResponse call
func ParseGetDefaultResourceQuotaResponse(rsp *http.Response) (*GetDefaultResourceQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetDefaultResourceQuotaResponse parses an HTTP response from a SetDefaultResourceQuotaWithResponse call
func ParseSetDefaultResourceQuotaResponse(rsp *http.Response) (*SetDefaultResourceQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveNamespaceBundleResourceQuotaResponse parses an HTTP response from a RemoveNamespaceBundleResourceQuotaWithResponse call
func ParseRemoveNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*RemoveNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceBundleResourceQuotaResponse parses an HTTP response from a GetNamespaceBundleResourceQuotaWithResponse call
func ParseGetNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*GetNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceBundleResourceQuotaResponse parses an HTTP response from a SetNamespaceBundleResourceQuotaWithResponse call
func ParseSetNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*SetNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResourceGroupsResponse parses an HTTP response from a GetResourceGroupsWithResponse call
func ParseGetResourceGroupsResponse(rsp *http.Response) (*GetResourceGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteResourceGroupResponse parses an HTTP response from a DeleteResourceGroupWithResponse call
func ParseDeleteResourceGroupResponse(rsp *http.Response) (*DeleteResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResourceGroupResponse parses an HTTP response from a GetResourceGroupWithResponse call
func ParseGetResourceGroupResponse(rsp *http.Response) (*GetResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateResourceGroupResponse parses an HTTP response from a CreateOrUpdateResourceGroupWithResponse call
func ParseCreateOrUpdateResourceGroupResponse(rsp *http.Response) (*CreateOrUpdateResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestCompatibilityResponse parses an HTTP response from a TestCompatibilityWithResponse call
func ParseTestCompatibilityResponse(rsp *http.Response) (*TestCompatibilityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestCompatibilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IsCompatibilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSchemaResponse parses an HTTP response from a DeleteSchemaWithResponse call
func ParseDeleteSchemaResponse(rsp *http.Response) (*DeleteSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemaResponse parses an HTTP response from a GetSchemaWithResponse call
func ParseGetSchemaResponse(rsp *http.Response) (*GetSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostSchemaResponse parses an HTTP response from a PostSchemaWithResponse call
func ParsePostSchemaResponse(rsp *http.Response) (*PostSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemaResponse parses an HTTP response from a GetSchemaWithResponse call
func ParseGetSchemaResponse(rsp *http.Response) (*GetSchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllSchemasResponse parses an HTTP response from a GetAllSchemasWithResponse call
func ParseGetAllSchemasResponse(rsp *http.Response) (*GetAllSchemasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllVersionsSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVersionBySchemaResponse parses an HTTP response from a GetVersionBySchemaWithResponse call
func ParseGetVersionBySchemaResponse(rsp *http.Response) (*GetVersionBySchemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionBySchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LongSchemaVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTenantsResponse parses an HTTP response from a GetTenantsWithResponse call
func ParseGetTenantsResponse(rsp *http.Response) (*GetTenantsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTenantResponse parses an HTTP response from a DeleteTenantWithResponse call
func ParseDeleteTenantResponse(rsp *http.Response) (*DeleteTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTenantAdminResponse parses an HTTP response from a GetTenantAdminWithResponse call
func ParseGetTenantAdminResponse(rsp *http.Response) (*GetTenantAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateTenantResponse parses an HTTP response from a UpdateTenantWithResponse call
func ParseUpdateTenantResponse(rsp *http.Response) (*UpdateTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTenantResponse parses an HTTP response from a CreateTenantWithResponse call
func ParseCreateTenantResponse(rsp *http.Response) (*CreateTenantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerFunctionInstanceStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMetricsResponse parses an HTTP response from a GetMetricsWithResponse call
func ParseGetMetricsResponse(rsp *http.Response) (*GetMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAssignmentsResponse parses an HTTP response from a GetAssignmentsWithResponse call
func ParseGetAssignmentsResponse(rsp *http.Response) (*GetAssignmentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClusterLeaderResponse parses an HTTP response from a GetClusterLeaderWithResponse call
func ParseGetClusterLeaderResponse(rsp *http.Response) (*GetClusterLeaderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsLeaderReadyResponse parses an HTTP response from a IsLeaderReadyWithResponse call
func ParseIsLeaderReadyResponse(rsp *http.Response) (*IsLeaderReadyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsLeaderReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConnectorsListResponse parses an HTTP response from a GetConnectorsListWithResponse call
func ParseGetConnectorsListResponse(rsp *http.Response) (*GetConnectorsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDrainStatusResponse parses an HTTP response from a GetDrainStatusWithResponse call
func ParseGetDrainStatusResponse(rsp *http.Response) (*GetDrainStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDrainStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDrainResponse parses an HTTP response from a DrainWithResponse call
func ParseDrainResponse(rsp *http.Response) (*DrainResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DrainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDrainStatusFromLeaderResponse parses an HTTP response from a GetDrainStatusFromLeaderWithResponse call
func ParseGetDrainStatusFromLeaderResponse(rsp *http.Response) (*GetDrainStatusFromLeaderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDrainStatusFromLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDrainAtLeaderResponse parses an HTTP response from a DrainAtLeaderWithResponse call
func ParseDrainAtLeaderResponse(rsp *http.Response) (*DrainAtLeaderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DrainAtLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRebalanceResponse parses an HTTP response from a RebalanceWithResponse call
func ParseRebalanceResponse(rsp *http.Response) (*RebalanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
