// Package coingekov3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package coingekov3

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// ConvertedDetails defines model for convertedDetails.
type ConvertedDetails struct {
	Btc                  *float64               `json:"btc,omitempty"`
	Eth                  *float64               `json:"eth,omitempty"`
	Usd                  *float64               `json:"usd,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Exchange defines model for exchange.
type Exchange struct {
	Country                     string                 `json:"country"`
	Description                 string                 `json:"description"`
	HasTradingIncentive         bool                   `json:"has_trading_incentive"`
	Id                          string                 `json:"id"`
	Image                       string                 `json:"image"`
	Name                        string                 `json:"name"`
	TradeVolume24hBtc           float64                `json:"trade_volume_24h_btc"`
	TradeVolume24hBtcNormalized float64                `json:"trade_volume_24h_btc_normalized"`
	TrustScore                  int32                  `json:"trust_score"`
	TrustScoreRank              int32                  `json:"trust_score_rank"`
	Url                         string                 `json:"url"`
	YearEstablished             int32                  `json:"year_established"`
	AdditionalProperties        map[string]interface{} `json:"-"`
}

// ExchangeDetails defines model for exchangeDetails.
type ExchangeDetails struct {
	AlertNotice                 string                 `json:"alert_notice"`
	Centralized                 bool                   `json:"centralized"`
	Country                     string                 `json:"country"`
	Description                 string                 `json:"description"`
	FacebookUrl                 string                 `json:"facebook_url"`
	HasTradingIncentive         bool                   `json:"has_trading_incentive"`
	Image                       string                 `json:"image"`
	Name                        string                 `json:"name"`
	OtherUrl1                   string                 `json:"other_url_1"`
	OtherUrl2                   string                 `json:"other_url_2"`
	PublicNotice                string                 `json:"public_notice"`
	RedditUrl                   string                 `json:"reddit_url"`
	SlackUrl                    string                 `json:"slack_url"`
	StatusUpdates               *[]StatusUpdate        `json:"status_updates,omitempty"`
	TelegramUrl                 string                 `json:"telegram_url"`
	Tickers                     *[]Ticker              `json:"tickers,omitempty"`
	TradeVolume24hBtc           float64                `json:"trade_volume_24h_btc"`
	TradeVolume24hBtcNormalized float64                `json:"trade_volume_24h_btc_normalized"`
	TrustScore                  int32                  `json:"trust_score"`
	TrustScoreRank              int32                  `json:"trust_score_rank"`
	TwitterHandle               string                 `json:"twitter_handle"`
	Url                         string                 `json:"url"`
	YearEstablished             int32                  `json:"year_established"`
	AdditionalProperties        map[string]interface{} `json:"-"`
}

// ExchangeIdName defines model for exchangeIdName.
type ExchangeIdName struct {
	Id                   string                 `json:"id"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Image defines model for image.
type Image struct {
	Large                string                 `json:"large"`
	Small                string                 `json:"small"`
	Thumb                string                 `json:"thumb"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Market defines model for market.
type Market struct {
	HasTradingIncentive  *bool                  `json:"has_trading_incentive,omitempty"`
	Identifier           *string                `json:"identifier,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Project defines model for project.
type Project struct {
	Id                   string                 `json:"id"`
	Image                Image                  `json:"image"`
	Name                 string                 `json:"name"`
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// StatusUpdate defines model for statusUpdate.
type StatusUpdate struct {
	Category             string                 `json:"category"`
	CreatedAt            string                 `json:"created_at"`
	Description          string                 `json:"description"`
	Pin                  bool                   `json:"pin"`
	Project              *Project               `json:"project,omitempty"`
	User                 string                 `json:"user"`
	UserTitle            string                 `json:"user_title"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Ticker defines model for ticker.
type Ticker struct {
	Base                   string                 `json:"base"`
	BidAskSpreadPercentage float64                `json:"bid_ask_spread_percentage"`
	CoinId                 string                 `json:"coin_id"`
	ConvertedLast          ConvertedDetails       `json:"converted_last"`
	ConvertedVolume        ConvertedDetails       `json:"converted_volume"`
	IsAnomaly              bool                   `json:"is_anomaly"`
	IsStale                bool                   `json:"is_stale"`
	Last                   float64                `json:"last"`
	LastFetchAt            string                 `json:"last_fetch_at"`
	LastTradedAt           string                 `json:"last_traded_at"`
	Market                 Market                 `json:"market"`
	Target                 string                 `json:"target"`
	TargetCoinId           string                 `json:"target_coin_id"`
	Timestamp              string                 `json:"timestamp"`
	TokenInfoUrl           *string                `json:"token_info_url,omitempty"`
	TradeUrl               string                 `json:"trade_url"`
	TrustScore             string                 `json:"trust_score"`
	Volume                 float64                `json:"volume"`
	AdditionalProperties   map[string]interface{} `json:"-"`
}

// GetCoinsCategoriesParams defines parameters for GetCoinsCategories.
type GetCoinsCategoriesParams struct {
	// valid values: <b>market_cap_desc (default), market_cap_asc, name_desc, name_asc, market_cap_change_24h_desc and market_cap_change_24h_asc</b>
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetCoinsListParams defines parameters for GetCoinsList.
type GetCoinsListParams struct {
	// flag to include platform contract addresses (eg. 0x.... for Ethereum based tokens).
	//  valid values: true, false
	IncludePlatform *bool `form:"include_platform,omitempty" json:"include_platform,omitempty"`
}

// GetCoinsMarketsParams defines parameters for GetCoinsMarkets.
type GetCoinsMarketsParams struct {
	// The target currency of market data (usd, eur, jpy, etc.)
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// The ids of the coin, comma separated crytocurrency symbols (base). refers to `/coins/list`.
	// <b>When left empty, returns numbers the coins observing the params `limit` and `start`</b>
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// filter by coin category. Refer to /coin/categories/list
	Category *string `form:"category,omitempty" json:"category,omitempty"`

	// valid values: <b>market_cap_desc, gecko_desc, gecko_asc, market_cap_asc, market_cap_desc, volume_asc, volume_desc, id_asc, id_desc</b>
	// sort results by field.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// valid values: 1..250
	//  Total results per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Include sparkline 7 days data (eg. true, false)
	Sparkline *bool `form:"sparkline,omitempty" json:"sparkline,omitempty"`

	// Include price change percentage in <b>1h, 24h, 7d, 14d, 30d, 200d, 1y</b> (eg. '`1h,24h,7d`' comma-separated, invalid values will be discarded)
	PriceChangePercentage *string `form:"price_change_percentage,omitempty" json:"price_change_percentage,omitempty"`
}

// GetCoinsIdParams defines parameters for GetCoinsId.
type GetCoinsIdParams struct {
	// Include all localized languages in response (true/false) <b>[default: true]</b>
	Localization *string `form:"localization,omitempty" json:"localization,omitempty"`

	// Include tickers data (true/false) <b>[default: true]</b>
	Tickers *bool `form:"tickers,omitempty" json:"tickers,omitempty"`

	// Include market_data (true/false) <b>[default: true]</b>
	MarketData *bool `form:"market_data,omitempty" json:"market_data,omitempty"`

	// Include community_data data (true/false) <b>[default: true]</b>
	CommunityData *bool `form:"community_data,omitempty" json:"community_data,omitempty"`

	// Include developer_data data (true/false) <b>[default: true]</b>
	DeveloperData *bool `form:"developer_data,omitempty" json:"developer_data,omitempty"`

	// Include sparkline 7 days data (eg. true, false) <b>[default: false]</b>
	Sparkline *bool `form:"sparkline,omitempty" json:"sparkline,omitempty"`
}

// GetCoinsIdContractContractAddressMarketChartParams defines parameters for GetCoinsIdContractContractAddressMarketChart.
type GetCoinsIdContractContractAddressMarketChartParams struct {
	// The target currency of market data (usd, eur, jpy, etc.)
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// Data up to number of days ago (eg. 1,14,30,max)
	Days string `form:"days" json:"days"`
}

// GetCoinsIdContractContractAddressMarketChartRangeParams defines parameters for GetCoinsIdContractContractAddressMarketChartRange.
type GetCoinsIdContractContractAddressMarketChartRangeParams struct {
	// The target currency of market data (usd, eur, jpy, etc.)
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// From date in UNIX Timestamp (eg. 1392577232)
	From string `form:"from" json:"from"`

	// To date in UNIX Timestamp (eg. 1422577232)
	To string `form:"to" json:"to"`
}

// GetCoinsIdHistoryParams defines parameters for GetCoinsIdHistory.
type GetCoinsIdHistoryParams struct {
	// The date of data snapshot in dd-mm-yyyy eg. 30-12-2017
	Date string `form:"date" json:"date"`

	// Set to false to exclude localized languages in response
	Localization *string `form:"localization,omitempty" json:"localization,omitempty"`
}

// GetCoinsIdMarketChartParams defines parameters for GetCoinsIdMarketChart.
type GetCoinsIdMarketChartParams struct {
	// The target currency of market data (usd, eur, jpy, etc.)
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// Data up to number of days ago (eg. 1,14,30,max)
	Days string `form:"days" json:"days"`

	// Data interval. Possible value: daily
	Interval *string `form:"interval,omitempty" json:"interval,omitempty"`
}

// GetCoinsIdMarketChartRangeParams defines parameters for GetCoinsIdMarketChartRange.
type GetCoinsIdMarketChartRangeParams struct {
	// The target currency of market data (usd, eur, jpy, etc.)
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// From date in UNIX Timestamp (eg. 1392577232)
	From string `form:"from" json:"from"`

	// To date in UNIX Timestamp (eg. 1422577232)
	To string `form:"to" json:"to"`
}

// GetCoinsIdOhlcParams defines parameters for GetCoinsIdOhlc.
type GetCoinsIdOhlcParams struct {
	// The target currency of market data (usd, eur, jpy, etc.)
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	//  Data up to number of days ago (1/7/14/30/90/180/365/max)
	Days string `form:"days" json:"days"`
}

// GetCoinsIdTickersParams defines parameters for GetCoinsIdTickers.
type GetCoinsIdTickersParams struct {
	// filter results by exchange_ids (ref: v3/exchanges/list)
	ExchangeIds *string `form:"exchange_ids,omitempty" json:"exchange_ids,omitempty"`

	// flag to show exchange_logo
	IncludeExchangeLogo *string `form:"include_exchange_logo,omitempty" json:"include_exchange_logo,omitempty"`

	// Page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// valid values: <b>trust_score_desc (default), trust_score_asc and volume_desc</b>
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// flag to show 2% orderbook depth. valid values: true, false
	Depth *string `form:"depth,omitempty" json:"depth,omitempty"`
}

// GetDerivativesParams defines parameters for GetDerivatives.
type GetDerivativesParams struct {
	// ['all', 'unexpired'] - expired to show unexpired tickers, all to list all tickers, defaults to unexpired
	IncludeTickers *string `form:"include_tickers,omitempty" json:"include_tickers,omitempty"`
}

// GetDerivativesExchangesParams defines parameters for GetDerivativesExchanges.
type GetDerivativesExchangesParams struct {
	// order results using following params name_asc，name_desc，open_interest_btc_asc，open_interest_btc_desc，trade_volume_24h_btc_asc，trade_volume_24h_btc_desc
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Total results per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetDerivativesExchangesIdParams defines parameters for GetDerivativesExchangesId.
type GetDerivativesExchangesIdParams struct {
	// ['all', 'unexpired'] - expired to show unexpired tickers, all to list all tickers, leave blank to omit tickers data in response
	IncludeTickers *string `form:"include_tickers,omitempty" json:"include_tickers,omitempty"`
}

// GetExchangesParams defines parameters for GetExchanges.
type GetExchangesParams struct {
	// Valid values: 1...250
	// Total results per page
	// Default value:: 100
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// page through results
	Page *string `form:"page,omitempty" json:"page,omitempty"`
}

// GetExchangesIdTickersParams defines parameters for GetExchangesIdTickers.
type GetExchangesIdTickersParams struct {
	// filter tickers by coin_ids (ref: v3/coins/list)
	CoinIds *string `form:"coin_ids,omitempty" json:"coin_ids,omitempty"`

	// flag to show exchange_logo
	IncludeExchangeLogo *string `form:"include_exchange_logo,omitempty" json:"include_exchange_logo,omitempty"`

	// Page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// flag to show 2% orderbook depth i.e., cost_to_move_up_usd and cost_to_move_down_usd
	Depth *string `form:"depth,omitempty" json:"depth,omitempty"`

	// valid values: <b>trust_score_desc (default), trust_score_asc and volume_desc</b>
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetExchangesIdVolumeChartParams defines parameters for GetExchangesIdVolumeChart.
type GetExchangesIdVolumeChartParams struct {
	//  Data up to number of days ago (eg. 1,14,30)
	Days int `form:"days" json:"days"`
}

// GetIndexesParams defines parameters for GetIndexes.
type GetIndexesParams struct {
	// Total results per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// GetSimplePriceParams defines parameters for GetSimplePrice.
type GetSimplePriceParams struct {
	// id of coins, comma-separated if querying more than 1 coin
	// *refers to <b>`coins/list`</b>
	Ids string `form:"ids" json:"ids"`

	// vs_currency of coins, comma-separated if querying more than 1 vs_currency
	// *refers to <b>`simple/supported_vs_currencies`</b>
	VsCurrencies string `form:"vs_currencies" json:"vs_currencies"`

	// <b>true/false</b> to include market_cap, <b>default: false</b>
	IncludeMarketCap *string `form:"include_market_cap,omitempty" json:"include_market_cap,omitempty"`

	// <b>true/false</b> to include 24hr_vol, <b>default: false</b>
	Include24hrVol *string `form:"include_24hr_vol,omitempty" json:"include_24hr_vol,omitempty"`

	// <b>true/false</b> to include 24hr_change, <b>default: false</b>
	Include24hrChange *string `form:"include_24hr_change,omitempty" json:"include_24hr_change,omitempty"`

	// <b>true/false</b> to include last_updated_at of price, <b>default: false</b>
	IncludeLastUpdatedAt *string `form:"include_last_updated_at,omitempty" json:"include_last_updated_at,omitempty"`
}

// GetSimpleTokenPriceIdParams defines parameters for GetSimpleTokenPriceId.
type GetSimpleTokenPriceIdParams struct {
	// The contract address of tokens, comma separated
	ContractAddresses string `form:"contract_addresses" json:"contract_addresses"`

	// vs_currency of coins, comma-separated if querying more than 1 vs_currency
	// *refers to <b>`simple/supported_vs_currencies`</b>
	VsCurrencies string `form:"vs_currencies" json:"vs_currencies"`

	// <b>true/false</b> to include market_cap, <b>default: false</b>
	IncludeMarketCap *string `form:"include_market_cap,omitempty" json:"include_market_cap,omitempty"`

	// <b>true/false</b> to include 24hr_vol, <b>default: false</b>
	Include24hrVol *string `form:"include_24hr_vol,omitempty" json:"include_24hr_vol,omitempty"`

	// <b>true/false</b> to include 24hr_change, <b>default: false</b>
	Include24hrChange *string `form:"include_24hr_change,omitempty" json:"include_24hr_change,omitempty"`

	// <b>true/false</b> to include last_updated_at of price, <b>default: false</b>
	IncludeLastUpdatedAt *string `form:"include_last_updated_at,omitempty" json:"include_last_updated_at,omitempty"`
}

// Getter for additional properties for ConvertedDetails. Returns the specified
// element and whether it was found
func (a ConvertedDetails) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConvertedDetails
func (a *ConvertedDetails) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConvertedDetails to handle AdditionalProperties
func (a *ConvertedDetails) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["btc"]; found {
		err = json.Unmarshal(raw, &a.Btc)
		if err != nil {
			return fmt.Errorf("error reading 'btc': %w", err)
		}
		delete(object, "btc")
	}

	if raw, found := object["eth"]; found {
		err = json.Unmarshal(raw, &a.Eth)
		if err != nil {
			return fmt.Errorf("error reading 'eth': %w", err)
		}
		delete(object, "eth")
	}

	if raw, found := object["usd"]; found {
		err = json.Unmarshal(raw, &a.Usd)
		if err != nil {
			return fmt.Errorf("error reading 'usd': %w", err)
		}
		delete(object, "usd")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConvertedDetails to handle AdditionalProperties
func (a ConvertedDetails) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Btc != nil {
		object["btc"], err = json.Marshal(a.Btc)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'btc': %w", err)
		}
	}

	if a.Eth != nil {
		object["eth"], err = json.Marshal(a.Eth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eth': %w", err)
		}
	}

	if a.Usd != nil {
		object["usd"], err = json.Marshal(a.Usd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'usd': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Exchange. Returns the specified
// element and whether it was found
func (a Exchange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Exchange
func (a *Exchange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Exchange to handle AdditionalProperties
func (a *Exchange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["country"]; found {
		err = json.Unmarshal(raw, &a.Country)
		if err != nil {
			return fmt.Errorf("error reading 'country': %w", err)
		}
		delete(object, "country")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["has_trading_incentive"]; found {
		err = json.Unmarshal(raw, &a.HasTradingIncentive)
		if err != nil {
			return fmt.Errorf("error reading 'has_trading_incentive': %w", err)
		}
		delete(object, "has_trading_incentive")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["image"]; found {
		err = json.Unmarshal(raw, &a.Image)
		if err != nil {
			return fmt.Errorf("error reading 'image': %w", err)
		}
		delete(object, "image")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["trade_volume_24h_btc"]; found {
		err = json.Unmarshal(raw, &a.TradeVolume24hBtc)
		if err != nil {
			return fmt.Errorf("error reading 'trade_volume_24h_btc': %w", err)
		}
		delete(object, "trade_volume_24h_btc")
	}

	if raw, found := object["trade_volume_24h_btc_normalized"]; found {
		err = json.Unmarshal(raw, &a.TradeVolume24hBtcNormalized)
		if err != nil {
			return fmt.Errorf("error reading 'trade_volume_24h_btc_normalized': %w", err)
		}
		delete(object, "trade_volume_24h_btc_normalized")
	}

	if raw, found := object["trust_score"]; found {
		err = json.Unmarshal(raw, &a.TrustScore)
		if err != nil {
			return fmt.Errorf("error reading 'trust_score': %w", err)
		}
		delete(object, "trust_score")
	}

	if raw, found := object["trust_score_rank"]; found {
		err = json.Unmarshal(raw, &a.TrustScoreRank)
		if err != nil {
			return fmt.Errorf("error reading 'trust_score_rank': %w", err)
		}
		delete(object, "trust_score_rank")
	}

	if raw, found := object["url"]; found {
		err = json.Unmarshal(raw, &a.Url)
		if err != nil {
			return fmt.Errorf("error reading 'url': %w", err)
		}
		delete(object, "url")
	}

	if raw, found := object["year_established"]; found {
		err = json.Unmarshal(raw, &a.YearEstablished)
		if err != nil {
			return fmt.Errorf("error reading 'year_established': %w", err)
		}
		delete(object, "year_established")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Exchange to handle AdditionalProperties
func (a Exchange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["country"], err = json.Marshal(a.Country)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'country': %w", err)
	}

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["has_trading_incentive"], err = json.Marshal(a.HasTradingIncentive)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'has_trading_incentive': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["image"], err = json.Marshal(a.Image)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'image': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["trade_volume_24h_btc"], err = json.Marshal(a.TradeVolume24hBtc)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trade_volume_24h_btc': %w", err)
	}

	object["trade_volume_24h_btc_normalized"], err = json.Marshal(a.TradeVolume24hBtcNormalized)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trade_volume_24h_btc_normalized': %w", err)
	}

	object["trust_score"], err = json.Marshal(a.TrustScore)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trust_score': %w", err)
	}

	object["trust_score_rank"], err = json.Marshal(a.TrustScoreRank)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trust_score_rank': %w", err)
	}

	object["url"], err = json.Marshal(a.Url)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'url': %w", err)
	}

	object["year_established"], err = json.Marshal(a.YearEstablished)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'year_established': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ExchangeDetails. Returns the specified
// element and whether it was found
func (a ExchangeDetails) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ExchangeDetails
func (a *ExchangeDetails) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ExchangeDetails to handle AdditionalProperties
func (a *ExchangeDetails) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["alert_notice"]; found {
		err = json.Unmarshal(raw, &a.AlertNotice)
		if err != nil {
			return fmt.Errorf("error reading 'alert_notice': %w", err)
		}
		delete(object, "alert_notice")
	}

	if raw, found := object["centralized"]; found {
		err = json.Unmarshal(raw, &a.Centralized)
		if err != nil {
			return fmt.Errorf("error reading 'centralized': %w", err)
		}
		delete(object, "centralized")
	}

	if raw, found := object["country"]; found {
		err = json.Unmarshal(raw, &a.Country)
		if err != nil {
			return fmt.Errorf("error reading 'country': %w", err)
		}
		delete(object, "country")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["facebook_url"]; found {
		err = json.Unmarshal(raw, &a.FacebookUrl)
		if err != nil {
			return fmt.Errorf("error reading 'facebook_url': %w", err)
		}
		delete(object, "facebook_url")
	}

	if raw, found := object["has_trading_incentive"]; found {
		err = json.Unmarshal(raw, &a.HasTradingIncentive)
		if err != nil {
			return fmt.Errorf("error reading 'has_trading_incentive': %w", err)
		}
		delete(object, "has_trading_incentive")
	}

	if raw, found := object["image"]; found {
		err = json.Unmarshal(raw, &a.Image)
		if err != nil {
			return fmt.Errorf("error reading 'image': %w", err)
		}
		delete(object, "image")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["other_url_1"]; found {
		err = json.Unmarshal(raw, &a.OtherUrl1)
		if err != nil {
			return fmt.Errorf("error reading 'other_url_1': %w", err)
		}
		delete(object, "other_url_1")
	}

	if raw, found := object["other_url_2"]; found {
		err = json.Unmarshal(raw, &a.OtherUrl2)
		if err != nil {
			return fmt.Errorf("error reading 'other_url_2': %w", err)
		}
		delete(object, "other_url_2")
	}

	if raw, found := object["public_notice"]; found {
		err = json.Unmarshal(raw, &a.PublicNotice)
		if err != nil {
			return fmt.Errorf("error reading 'public_notice': %w", err)
		}
		delete(object, "public_notice")
	}

	if raw, found := object["reddit_url"]; found {
		err = json.Unmarshal(raw, &a.RedditUrl)
		if err != nil {
			return fmt.Errorf("error reading 'reddit_url': %w", err)
		}
		delete(object, "reddit_url")
	}

	if raw, found := object["slack_url"]; found {
		err = json.Unmarshal(raw, &a.SlackUrl)
		if err != nil {
			return fmt.Errorf("error reading 'slack_url': %w", err)
		}
		delete(object, "slack_url")
	}

	if raw, found := object["status_updates"]; found {
		err = json.Unmarshal(raw, &a.StatusUpdates)
		if err != nil {
			return fmt.Errorf("error reading 'status_updates': %w", err)
		}
		delete(object, "status_updates")
	}

	if raw, found := object["telegram_url"]; found {
		err = json.Unmarshal(raw, &a.TelegramUrl)
		if err != nil {
			return fmt.Errorf("error reading 'telegram_url': %w", err)
		}
		delete(object, "telegram_url")
	}

	if raw, found := object["tickers"]; found {
		err = json.Unmarshal(raw, &a.Tickers)
		if err != nil {
			return fmt.Errorf("error reading 'tickers': %w", err)
		}
		delete(object, "tickers")
	}

	if raw, found := object["trade_volume_24h_btc"]; found {
		err = json.Unmarshal(raw, &a.TradeVolume24hBtc)
		if err != nil {
			return fmt.Errorf("error reading 'trade_volume_24h_btc': %w", err)
		}
		delete(object, "trade_volume_24h_btc")
	}

	if raw, found := object["trade_volume_24h_btc_normalized"]; found {
		err = json.Unmarshal(raw, &a.TradeVolume24hBtcNormalized)
		if err != nil {
			return fmt.Errorf("error reading 'trade_volume_24h_btc_normalized': %w", err)
		}
		delete(object, "trade_volume_24h_btc_normalized")
	}

	if raw, found := object["trust_score"]; found {
		err = json.Unmarshal(raw, &a.TrustScore)
		if err != nil {
			return fmt.Errorf("error reading 'trust_score': %w", err)
		}
		delete(object, "trust_score")
	}

	if raw, found := object["trust_score_rank"]; found {
		err = json.Unmarshal(raw, &a.TrustScoreRank)
		if err != nil {
			return fmt.Errorf("error reading 'trust_score_rank': %w", err)
		}
		delete(object, "trust_score_rank")
	}

	if raw, found := object["twitter_handle"]; found {
		err = json.Unmarshal(raw, &a.TwitterHandle)
		if err != nil {
			return fmt.Errorf("error reading 'twitter_handle': %w", err)
		}
		delete(object, "twitter_handle")
	}

	if raw, found := object["url"]; found {
		err = json.Unmarshal(raw, &a.Url)
		if err != nil {
			return fmt.Errorf("error reading 'url': %w", err)
		}
		delete(object, "url")
	}

	if raw, found := object["year_established"]; found {
		err = json.Unmarshal(raw, &a.YearEstablished)
		if err != nil {
			return fmt.Errorf("error reading 'year_established': %w", err)
		}
		delete(object, "year_established")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ExchangeDetails to handle AdditionalProperties
func (a ExchangeDetails) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["alert_notice"], err = json.Marshal(a.AlertNotice)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'alert_notice': %w", err)
	}

	object["centralized"], err = json.Marshal(a.Centralized)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'centralized': %w", err)
	}

	object["country"], err = json.Marshal(a.Country)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'country': %w", err)
	}

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["facebook_url"], err = json.Marshal(a.FacebookUrl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'facebook_url': %w", err)
	}

	object["has_trading_incentive"], err = json.Marshal(a.HasTradingIncentive)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'has_trading_incentive': %w", err)
	}

	object["image"], err = json.Marshal(a.Image)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'image': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["other_url_1"], err = json.Marshal(a.OtherUrl1)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'other_url_1': %w", err)
	}

	object["other_url_2"], err = json.Marshal(a.OtherUrl2)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'other_url_2': %w", err)
	}

	object["public_notice"], err = json.Marshal(a.PublicNotice)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'public_notice': %w", err)
	}

	object["reddit_url"], err = json.Marshal(a.RedditUrl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'reddit_url': %w", err)
	}

	object["slack_url"], err = json.Marshal(a.SlackUrl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'slack_url': %w", err)
	}

	if a.StatusUpdates != nil {
		object["status_updates"], err = json.Marshal(a.StatusUpdates)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status_updates': %w", err)
		}
	}

	object["telegram_url"], err = json.Marshal(a.TelegramUrl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'telegram_url': %w", err)
	}

	if a.Tickers != nil {
		object["tickers"], err = json.Marshal(a.Tickers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tickers': %w", err)
		}
	}

	object["trade_volume_24h_btc"], err = json.Marshal(a.TradeVolume24hBtc)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trade_volume_24h_btc': %w", err)
	}

	object["trade_volume_24h_btc_normalized"], err = json.Marshal(a.TradeVolume24hBtcNormalized)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trade_volume_24h_btc_normalized': %w", err)
	}

	object["trust_score"], err = json.Marshal(a.TrustScore)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trust_score': %w", err)
	}

	object["trust_score_rank"], err = json.Marshal(a.TrustScoreRank)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trust_score_rank': %w", err)
	}

	object["twitter_handle"], err = json.Marshal(a.TwitterHandle)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'twitter_handle': %w", err)
	}

	object["url"], err = json.Marshal(a.Url)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'url': %w", err)
	}

	object["year_established"], err = json.Marshal(a.YearEstablished)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'year_established': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ExchangeIdName. Returns the specified
// element and whether it was found
func (a ExchangeIdName) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ExchangeIdName
func (a *ExchangeIdName) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ExchangeIdName to handle AdditionalProperties
func (a *ExchangeIdName) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ExchangeIdName to handle AdditionalProperties
func (a ExchangeIdName) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Image. Returns the specified
// element and whether it was found
func (a Image) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Image
func (a *Image) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Image to handle AdditionalProperties
func (a *Image) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["large"]; found {
		err = json.Unmarshal(raw, &a.Large)
		if err != nil {
			return fmt.Errorf("error reading 'large': %w", err)
		}
		delete(object, "large")
	}

	if raw, found := object["small"]; found {
		err = json.Unmarshal(raw, &a.Small)
		if err != nil {
			return fmt.Errorf("error reading 'small': %w", err)
		}
		delete(object, "small")
	}

	if raw, found := object["thumb"]; found {
		err = json.Unmarshal(raw, &a.Thumb)
		if err != nil {
			return fmt.Errorf("error reading 'thumb': %w", err)
		}
		delete(object, "thumb")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Image to handle AdditionalProperties
func (a Image) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["large"], err = json.Marshal(a.Large)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'large': %w", err)
	}

	object["small"], err = json.Marshal(a.Small)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'small': %w", err)
	}

	object["thumb"], err = json.Marshal(a.Thumb)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'thumb': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Market. Returns the specified
// element and whether it was found
func (a Market) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Market
func (a *Market) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Market to handle AdditionalProperties
func (a *Market) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["has_trading_incentive"]; found {
		err = json.Unmarshal(raw, &a.HasTradingIncentive)
		if err != nil {
			return fmt.Errorf("error reading 'has_trading_incentive': %w", err)
		}
		delete(object, "has_trading_incentive")
	}

	if raw, found := object["identifier"]; found {
		err = json.Unmarshal(raw, &a.Identifier)
		if err != nil {
			return fmt.Errorf("error reading 'identifier': %w", err)
		}
		delete(object, "identifier")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Market to handle AdditionalProperties
func (a Market) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.HasTradingIncentive != nil {
		object["has_trading_incentive"], err = json.Marshal(a.HasTradingIncentive)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'has_trading_incentive': %w", err)
		}
	}

	if a.Identifier != nil {
		object["identifier"], err = json.Marshal(a.Identifier)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'identifier': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Project. Returns the specified
// element and whether it was found
func (a Project) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Project
func (a *Project) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Project to handle AdditionalProperties
func (a *Project) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["image"]; found {
		err = json.Unmarshal(raw, &a.Image)
		if err != nil {
			return fmt.Errorf("error reading 'image': %w", err)
		}
		delete(object, "image")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Project to handle AdditionalProperties
func (a Project) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["image"], err = json.Marshal(a.Image)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'image': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StatusUpdate. Returns the specified
// element and whether it was found
func (a StatusUpdate) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StatusUpdate
func (a *StatusUpdate) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StatusUpdate to handle AdditionalProperties
func (a *StatusUpdate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["category"]; found {
		err = json.Unmarshal(raw, &a.Category)
		if err != nil {
			return fmt.Errorf("error reading 'category': %w", err)
		}
		delete(object, "category")
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["pin"]; found {
		err = json.Unmarshal(raw, &a.Pin)
		if err != nil {
			return fmt.Errorf("error reading 'pin': %w", err)
		}
		delete(object, "pin")
	}

	if raw, found := object["project"]; found {
		err = json.Unmarshal(raw, &a.Project)
		if err != nil {
			return fmt.Errorf("error reading 'project': %w", err)
		}
		delete(object, "project")
	}

	if raw, found := object["user"]; found {
		err = json.Unmarshal(raw, &a.User)
		if err != nil {
			return fmt.Errorf("error reading 'user': %w", err)
		}
		delete(object, "user")
	}

	if raw, found := object["user_title"]; found {
		err = json.Unmarshal(raw, &a.UserTitle)
		if err != nil {
			return fmt.Errorf("error reading 'user_title': %w", err)
		}
		delete(object, "user_title")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StatusUpdate to handle AdditionalProperties
func (a StatusUpdate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["category"], err = json.Marshal(a.Category)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'category': %w", err)
	}

	object["created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["description"], err = json.Marshal(a.Description)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'description': %w", err)
	}

	object["pin"], err = json.Marshal(a.Pin)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pin': %w", err)
	}

	if a.Project != nil {
		object["project"], err = json.Marshal(a.Project)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project': %w", err)
		}
	}

	object["user"], err = json.Marshal(a.User)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'user': %w", err)
	}

	object["user_title"], err = json.Marshal(a.UserTitle)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'user_title': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Ticker. Returns the specified
// element and whether it was found
func (a Ticker) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Ticker
func (a *Ticker) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Ticker to handle AdditionalProperties
func (a *Ticker) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["base"]; found {
		err = json.Unmarshal(raw, &a.Base)
		if err != nil {
			return fmt.Errorf("error reading 'base': %w", err)
		}
		delete(object, "base")
	}

	if raw, found := object["bid_ask_spread_percentage"]; found {
		err = json.Unmarshal(raw, &a.BidAskSpreadPercentage)
		if err != nil {
			return fmt.Errorf("error reading 'bid_ask_spread_percentage': %w", err)
		}
		delete(object, "bid_ask_spread_percentage")
	}

	if raw, found := object["coin_id"]; found {
		err = json.Unmarshal(raw, &a.CoinId)
		if err != nil {
			return fmt.Errorf("error reading 'coin_id': %w", err)
		}
		delete(object, "coin_id")
	}

	if raw, found := object["converted_last"]; found {
		err = json.Unmarshal(raw, &a.ConvertedLast)
		if err != nil {
			return fmt.Errorf("error reading 'converted_last': %w", err)
		}
		delete(object, "converted_last")
	}

	if raw, found := object["converted_volume"]; found {
		err = json.Unmarshal(raw, &a.ConvertedVolume)
		if err != nil {
			return fmt.Errorf("error reading 'converted_volume': %w", err)
		}
		delete(object, "converted_volume")
	}

	if raw, found := object["is_anomaly"]; found {
		err = json.Unmarshal(raw, &a.IsAnomaly)
		if err != nil {
			return fmt.Errorf("error reading 'is_anomaly': %w", err)
		}
		delete(object, "is_anomaly")
	}

	if raw, found := object["is_stale"]; found {
		err = json.Unmarshal(raw, &a.IsStale)
		if err != nil {
			return fmt.Errorf("error reading 'is_stale': %w", err)
		}
		delete(object, "is_stale")
	}

	if raw, found := object["last"]; found {
		err = json.Unmarshal(raw, &a.Last)
		if err != nil {
			return fmt.Errorf("error reading 'last': %w", err)
		}
		delete(object, "last")
	}

	if raw, found := object["last_fetch_at"]; found {
		err = json.Unmarshal(raw, &a.LastFetchAt)
		if err != nil {
			return fmt.Errorf("error reading 'last_fetch_at': %w", err)
		}
		delete(object, "last_fetch_at")
	}

	if raw, found := object["last_traded_at"]; found {
		err = json.Unmarshal(raw, &a.LastTradedAt)
		if err != nil {
			return fmt.Errorf("error reading 'last_traded_at': %w", err)
		}
		delete(object, "last_traded_at")
	}

	if raw, found := object["market"]; found {
		err = json.Unmarshal(raw, &a.Market)
		if err != nil {
			return fmt.Errorf("error reading 'market': %w", err)
		}
		delete(object, "market")
	}

	if raw, found := object["target"]; found {
		err = json.Unmarshal(raw, &a.Target)
		if err != nil {
			return fmt.Errorf("error reading 'target': %w", err)
		}
		delete(object, "target")
	}

	if raw, found := object["target_coin_id"]; found {
		err = json.Unmarshal(raw, &a.TargetCoinId)
		if err != nil {
			return fmt.Errorf("error reading 'target_coin_id': %w", err)
		}
		delete(object, "target_coin_id")
	}

	if raw, found := object["timestamp"]; found {
		err = json.Unmarshal(raw, &a.Timestamp)
		if err != nil {
			return fmt.Errorf("error reading 'timestamp': %w", err)
		}
		delete(object, "timestamp")
	}

	if raw, found := object["token_info_url"]; found {
		err = json.Unmarshal(raw, &a.TokenInfoUrl)
		if err != nil {
			return fmt.Errorf("error reading 'token_info_url': %w", err)
		}
		delete(object, "token_info_url")
	}

	if raw, found := object["trade_url"]; found {
		err = json.Unmarshal(raw, &a.TradeUrl)
		if err != nil {
			return fmt.Errorf("error reading 'trade_url': %w", err)
		}
		delete(object, "trade_url")
	}

	if raw, found := object["trust_score"]; found {
		err = json.Unmarshal(raw, &a.TrustScore)
		if err != nil {
			return fmt.Errorf("error reading 'trust_score': %w", err)
		}
		delete(object, "trust_score")
	}

	if raw, found := object["volume"]; found {
		err = json.Unmarshal(raw, &a.Volume)
		if err != nil {
			return fmt.Errorf("error reading 'volume': %w", err)
		}
		delete(object, "volume")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Ticker to handle AdditionalProperties
func (a Ticker) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["base"], err = json.Marshal(a.Base)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'base': %w", err)
	}

	object["bid_ask_spread_percentage"], err = json.Marshal(a.BidAskSpreadPercentage)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'bid_ask_spread_percentage': %w", err)
	}

	object["coin_id"], err = json.Marshal(a.CoinId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'coin_id': %w", err)
	}

	object["converted_last"], err = json.Marshal(a.ConvertedLast)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'converted_last': %w", err)
	}

	object["converted_volume"], err = json.Marshal(a.ConvertedVolume)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'converted_volume': %w", err)
	}

	object["is_anomaly"], err = json.Marshal(a.IsAnomaly)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'is_anomaly': %w", err)
	}

	object["is_stale"], err = json.Marshal(a.IsStale)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'is_stale': %w", err)
	}

	object["last"], err = json.Marshal(a.Last)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'last': %w", err)
	}

	object["last_fetch_at"], err = json.Marshal(a.LastFetchAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'last_fetch_at': %w", err)
	}

	object["last_traded_at"], err = json.Marshal(a.LastTradedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'last_traded_at': %w", err)
	}

	object["market"], err = json.Marshal(a.Market)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'market': %w", err)
	}

	object["target"], err = json.Marshal(a.Target)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target': %w", err)
	}

	object["target_coin_id"], err = json.Marshal(a.TargetCoinId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target_coin_id': %w", err)
	}

	object["timestamp"], err = json.Marshal(a.Timestamp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'timestamp': %w", err)
	}

	if a.TokenInfoUrl != nil {
		object["token_info_url"], err = json.Marshal(a.TokenInfoUrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'token_info_url': %w", err)
		}
	}

	object["trade_url"], err = json.Marshal(a.TradeUrl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trade_url': %w", err)
	}

	object["trust_score"], err = json.Marshal(a.TrustScore)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trust_score': %w", err)
	}

	object["volume"], err = json.Marshal(a.Volume)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'volume': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAssetPlatforms request
	GetAssetPlatforms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsCategories request
	GetCoinsCategories(ctx context.Context, params *GetCoinsCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsCategoriesList request
	GetCoinsCategoriesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsList request
	GetCoinsList(ctx context.Context, params *GetCoinsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsMarkets request
	GetCoinsMarkets(ctx context.Context, params *GetCoinsMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsId request
	GetCoinsId(ctx context.Context, id string, params *GetCoinsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdContractContractAddress request
	GetCoinsIdContractContractAddress(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdContractContractAddressMarketChart request
	GetCoinsIdContractContractAddressMarketChart(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdContractContractAddressMarketChartRange request
	GetCoinsIdContractContractAddressMarketChartRange(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdHistory request
	GetCoinsIdHistory(ctx context.Context, id string, params *GetCoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdMarketChart request
	GetCoinsIdMarketChart(ctx context.Context, id string, params *GetCoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdMarketChartRange request
	GetCoinsIdMarketChartRange(ctx context.Context, id string, params *GetCoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdOhlc request
	GetCoinsIdOhlc(ctx context.Context, id string, params *GetCoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoinsIdTickers request
	GetCoinsIdTickers(ctx context.Context, id string, params *GetCoinsIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDerivatives request
	GetDerivatives(ctx context.Context, params *GetDerivativesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDerivativesExchanges request
	GetDerivativesExchanges(ctx context.Context, params *GetDerivativesExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDerivativesExchangesList request
	GetDerivativesExchangesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDerivativesExchangesId request
	GetDerivativesExchangesId(ctx context.Context, id string, params *GetDerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchangeRates request
	GetExchangeRates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchanges request
	GetExchanges(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchangesList request
	GetExchangesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchangesId request
	GetExchangesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchangesIdTickers request
	GetExchangesIdTickers(ctx context.Context, id string, params *GetExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchangesIdVolumeChart request
	GetExchangesIdVolumeChart(ctx context.Context, id string, params *GetExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobal request
	GetGlobal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndexes request
	GetIndexes(ctx context.Context, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndexesList request
	GetIndexesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIndexesMarketIdId request
	GetIndexesMarketIdId(ctx context.Context, marketId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPing request
	GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchTrending request
	GetSearchTrending(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimplePrice request
	GetSimplePrice(ctx context.Context, params *GetSimplePriceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimpleSupportedVsCurrencies request
	GetSimpleSupportedVsCurrencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimpleTokenPriceId request
	GetSimpleTokenPriceId(ctx context.Context, id string, params *GetSimpleTokenPriceIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAssetPlatforms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetPlatformsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsCategories(ctx context.Context, params *GetCoinsCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsCategoriesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsCategoriesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsList(ctx context.Context, params *GetCoinsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsMarkets(ctx context.Context, params *GetCoinsMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsMarketsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsId(ctx context.Context, id string, params *GetCoinsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdContractContractAddress(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdContractContractAddressRequest(c.Server, id, contractAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdContractContractAddressMarketChart(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdContractContractAddressMarketChartRequest(c.Server, id, contractAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdContractContractAddressMarketChartRange(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdContractContractAddressMarketChartRangeRequest(c.Server, id, contractAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdHistory(ctx context.Context, id string, params *GetCoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdHistoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdMarketChart(ctx context.Context, id string, params *GetCoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdMarketChartRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdMarketChartRange(ctx context.Context, id string, params *GetCoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdMarketChartRangeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdOhlc(ctx context.Context, id string, params *GetCoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdOhlcRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoinsIdTickers(ctx context.Context, id string, params *GetCoinsIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsIdTickersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDerivatives(ctx context.Context, params *GetDerivativesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDerivativesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDerivativesExchanges(ctx context.Context, params *GetDerivativesExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDerivativesExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDerivativesExchangesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDerivativesExchangesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDerivativesExchangesId(ctx context.Context, id string, params *GetDerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDerivativesExchangesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchangeRates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangeRatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchanges(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchangesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchangesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchangesIdTickers(ctx context.Context, id string, params *GetExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangesIdTickersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchangesIdVolumeChart(ctx context.Context, id string, params *GetExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangesIdVolumeChartRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndexes(ctx context.Context, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndexesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIndexesMarketIdId(ctx context.Context, marketId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIndexesMarketIdIdRequest(c.Server, marketId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchTrending(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchTrendingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimplePrice(ctx context.Context, params *GetSimplePriceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimplePriceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimpleSupportedVsCurrencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimpleSupportedVsCurrenciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimpleTokenPriceId(ctx context.Context, id string, params *GetSimpleTokenPriceIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimpleTokenPriceIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAssetPlatformsRequest generates requests for GetAssetPlatforms
func NewGetAssetPlatformsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/asset_platforms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsCategoriesRequest generates requests for GetCoinsCategories
func NewGetCoinsCategoriesRequest(server string, params *GetCoinsCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsCategoriesListRequest generates requests for GetCoinsCategoriesList
func NewGetCoinsCategoriesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/categories/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsListRequest generates requests for GetCoinsList
func NewGetCoinsListRequest(server string, params *GetCoinsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludePlatform != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_platform", runtime.ParamLocationQuery, *params.IncludePlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsMarketsRequest generates requests for GetCoinsMarkets
func NewGetCoinsMarketsRequest(server string, params *GetCoinsMarketsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/markets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Ids != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Category != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sparkline != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sparkline", runtime.ParamLocationQuery, *params.Sparkline); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PriceChangePercentage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_change_percentage", runtime.ParamLocationQuery, *params.PriceChangePercentage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdRequest generates requests for GetCoinsId
func NewGetCoinsIdRequest(server string, id string, params *GetCoinsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Localization != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "localization", runtime.ParamLocationQuery, *params.Localization); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tickers != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MarketData != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_data", runtime.ParamLocationQuery, *params.MarketData); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CommunityData != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_data", runtime.ParamLocationQuery, *params.CommunityData); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DeveloperData != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "developer_data", runtime.ParamLocationQuery, *params.DeveloperData); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sparkline != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sparkline", runtime.ParamLocationQuery, *params.Sparkline); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdContractContractAddressRequest generates requests for GetCoinsIdContractContractAddress
func NewGetCoinsIdContractContractAddressRequest(server string, id string, contractAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/contract/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdContractContractAddressMarketChartRequest generates requests for GetCoinsIdContractContractAddressMarketChart
func NewGetCoinsIdContractContractAddressMarketChartRequest(server string, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/contract/%s/market_chart/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdContractContractAddressMarketChartRangeRequest generates requests for GetCoinsIdContractContractAddressMarketChartRange
func NewGetCoinsIdContractContractAddressMarketChartRangeRequest(server string, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartRangeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/contract/%s/market_chart/range", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdHistoryRequest generates requests for GetCoinsIdHistory
func NewGetCoinsIdHistoryRequest(server string, id string, params *GetCoinsIdHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Localization != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "localization", runtime.ParamLocationQuery, *params.Localization); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdMarketChartRequest generates requests for GetCoinsIdMarketChart
func NewGetCoinsIdMarketChartRequest(server string, id string, params *GetCoinsIdMarketChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/market_chart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Interval != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdMarketChartRangeRequest generates requests for GetCoinsIdMarketChartRange
func NewGetCoinsIdMarketChartRangeRequest(server string, id string, params *GetCoinsIdMarketChartRangeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/market_chart/range", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdOhlcRequest generates requests for GetCoinsIdOhlc
func NewGetCoinsIdOhlcRequest(server string, id string, params *GetCoinsIdOhlcParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/ohlc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoinsIdTickersRequest generates requests for GetCoinsIdTickers
func NewGetCoinsIdTickersRequest(server string, id string, params *GetCoinsIdTickersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/tickers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExchangeIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange_ids", runtime.ParamLocationQuery, *params.ExchangeIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeExchangeLogo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_exchange_logo", runtime.ParamLocationQuery, *params.IncludeExchangeLogo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDerivativesRequest generates requests for GetDerivatives
func NewGetDerivativesRequest(server string, params *GetDerivativesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeTickers != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tickers", runtime.ParamLocationQuery, *params.IncludeTickers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDerivativesExchangesRequest generates requests for GetDerivativesExchanges
func NewGetDerivativesExchangesRequest(server string, params *GetDerivativesExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDerivativesExchangesListRequest generates requests for GetDerivativesExchangesList
func NewGetDerivativesExchangesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives/exchanges/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDerivativesExchangesIdRequest generates requests for GetDerivativesExchangesId
func NewGetDerivativesExchangesIdRequest(server string, id string, params *GetDerivativesExchangesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives/exchanges/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeTickers != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tickers", runtime.ParamLocationQuery, *params.IncludeTickers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExchangeRatesRequest generates requests for GetExchangeRates
func NewGetExchangeRatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchange_rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExchangesRequest generates requests for GetExchanges
func NewGetExchangesRequest(server string, params *GetExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExchangesListRequest generates requests for GetExchangesList
func NewGetExchangesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExchangesIdRequest generates requests for GetExchangesId
func NewGetExchangesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExchangesIdTickersRequest generates requests for GetExchangesIdTickers
func NewGetExchangesIdTickersRequest(server string, id string, params *GetExchangesIdTickersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/tickers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CoinIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "coin_ids", runtime.ParamLocationQuery, *params.CoinIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeExchangeLogo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_exchange_logo", runtime.ParamLocationQuery, *params.IncludeExchangeLogo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExchangesIdVolumeChartRequest generates requests for GetExchangesIdVolumeChart
func NewGetExchangesIdVolumeChartRequest(server string, id string, params *GetExchangesIdVolumeChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/volume_chart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalRequest generates requests for GetGlobal
func NewGetGlobalRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndexesRequest generates requests for GetIndexes
func NewGetIndexesRequest(server string, params *GetIndexesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndexesListRequest generates requests for GetIndexesList
func NewGetIndexesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIndexesMarketIdIdRequest generates requests for GetIndexesMarketIdId
func NewGetIndexesMarketIdIdRequest(server string, marketId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "market_id", runtime.ParamLocationPath, marketId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPingRequest generates requests for GetPing
func NewGetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchTrendingRequest generates requests for GetSearchTrending
func NewGetSearchTrendingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/trending")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimplePriceRequest generates requests for GetSimplePrice
func NewGetSimplePriceRequest(server string, params *GetSimplePriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/simple/price")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currencies", runtime.ParamLocationQuery, params.VsCurrencies); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.IncludeMarketCap != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_market_cap", runtime.ParamLocationQuery, *params.IncludeMarketCap); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include24hrVol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_vol", runtime.ParamLocationQuery, *params.Include24hrVol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include24hrChange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_change", runtime.ParamLocationQuery, *params.Include24hrChange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeLastUpdatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_last_updated_at", runtime.ParamLocationQuery, *params.IncludeLastUpdatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimpleSupportedVsCurrenciesRequest generates requests for GetSimpleSupportedVsCurrencies
func NewGetSimpleSupportedVsCurrenciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/simple/supported_vs_currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimpleTokenPriceIdRequest generates requests for GetSimpleTokenPriceId
func NewGetSimpleTokenPriceIdRequest(server string, id string, params *GetSimpleTokenPriceIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/simple/token_price/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contract_addresses", runtime.ParamLocationQuery, params.ContractAddresses); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currencies", runtime.ParamLocationQuery, params.VsCurrencies); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.IncludeMarketCap != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_market_cap", runtime.ParamLocationQuery, *params.IncludeMarketCap); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include24hrVol != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_vol", runtime.ParamLocationQuery, *params.Include24hrVol); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include24hrChange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_change", runtime.ParamLocationQuery, *params.Include24hrChange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeLastUpdatedAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_last_updated_at", runtime.ParamLocationQuery, *params.IncludeLastUpdatedAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAssetPlatforms request
	GetAssetPlatformsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAssetPlatformsResponse, error)

	// GetCoinsCategories request
	GetCoinsCategoriesWithResponse(ctx context.Context, params *GetCoinsCategoriesParams, reqEditors ...RequestEditorFn) (*GetCoinsCategoriesResponse, error)

	// GetCoinsCategoriesList request
	GetCoinsCategoriesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCoinsCategoriesListResponse, error)

	// GetCoinsList request
	GetCoinsListWithResponse(ctx context.Context, params *GetCoinsListParams, reqEditors ...RequestEditorFn) (*GetCoinsListResponse, error)

	// GetCoinsMarkets request
	GetCoinsMarketsWithResponse(ctx context.Context, params *GetCoinsMarketsParams, reqEditors ...RequestEditorFn) (*GetCoinsMarketsResponse, error)

	// GetCoinsId request
	GetCoinsIdWithResponse(ctx context.Context, id string, params *GetCoinsIdParams, reqEditors ...RequestEditorFn) (*GetCoinsIdResponse, error)

	// GetCoinsIdContractContractAddress request
	GetCoinsIdContractContractAddressWithResponse(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*GetCoinsIdContractContractAddressResponse, error)

	// GetCoinsIdContractContractAddressMarketChart request
	GetCoinsIdContractContractAddressMarketChartWithResponse(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*GetCoinsIdContractContractAddressMarketChartResponse, error)

	// GetCoinsIdContractContractAddressMarketChartRange request
	GetCoinsIdContractContractAddressMarketChartRangeWithResponse(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*GetCoinsIdContractContractAddressMarketChartRangeResponse, error)

	// GetCoinsIdHistory request
	GetCoinsIdHistoryWithResponse(ctx context.Context, id string, params *GetCoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*GetCoinsIdHistoryResponse, error)

	// GetCoinsIdMarketChart request
	GetCoinsIdMarketChartWithResponse(ctx context.Context, id string, params *GetCoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*GetCoinsIdMarketChartResponse, error)

	// GetCoinsIdMarketChartRange request
	GetCoinsIdMarketChartRangeWithResponse(ctx context.Context, id string, params *GetCoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*GetCoinsIdMarketChartRangeResponse, error)

	// GetCoinsIdOhlc request
	GetCoinsIdOhlcWithResponse(ctx context.Context, id string, params *GetCoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*GetCoinsIdOhlcResponse, error)

	// GetCoinsIdTickers request
	GetCoinsIdTickersWithResponse(ctx context.Context, id string, params *GetCoinsIdTickersParams, reqEditors ...RequestEditorFn) (*GetCoinsIdTickersResponse, error)

	// GetDerivatives request
	GetDerivativesWithResponse(ctx context.Context, params *GetDerivativesParams, reqEditors ...RequestEditorFn) (*GetDerivativesResponse, error)

	// GetDerivativesExchanges request
	GetDerivativesExchangesWithResponse(ctx context.Context, params *GetDerivativesExchangesParams, reqEditors ...RequestEditorFn) (*GetDerivativesExchangesResponse, error)

	// GetDerivativesExchangesList request
	GetDerivativesExchangesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDerivativesExchangesListResponse, error)

	// GetDerivativesExchangesId request
	GetDerivativesExchangesIdWithResponse(ctx context.Context, id string, params *GetDerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*GetDerivativesExchangesIdResponse, error)

	// GetExchangeRates request
	GetExchangeRatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExchangeRatesResponse, error)

	// GetExchanges request
	GetExchangesWithResponse(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*GetExchangesResponse, error)

	// GetExchangesList request
	GetExchangesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExchangesListResponse, error)

	// GetExchangesId request
	GetExchangesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetExchangesIdResponse, error)

	// GetExchangesIdTickers request
	GetExchangesIdTickersWithResponse(ctx context.Context, id string, params *GetExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*GetExchangesIdTickersResponse, error)

	// GetExchangesIdVolumeChart request
	GetExchangesIdVolumeChartWithResponse(ctx context.Context, id string, params *GetExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*GetExchangesIdVolumeChartResponse, error)

	// GetGlobal request
	GetGlobalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error)

	// GetIndexes request
	GetIndexesWithResponse(ctx context.Context, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*GetIndexesResponse, error)

	// GetIndexesList request
	GetIndexesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIndexesListResponse, error)

	// GetIndexesMarketIdId request
	GetIndexesMarketIdIdWithResponse(ctx context.Context, marketId string, id string, reqEditors ...RequestEditorFn) (*GetIndexesMarketIdIdResponse, error)

	// GetPing request
	GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPingResponse, error)

	// GetSearchTrending request
	GetSearchTrendingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchTrendingResponse, error)

	// GetSimplePrice request
	GetSimplePriceWithResponse(ctx context.Context, params *GetSimplePriceParams, reqEditors ...RequestEditorFn) (*GetSimplePriceResponse, error)

	// GetSimpleSupportedVsCurrencies request
	GetSimpleSupportedVsCurrenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSimpleSupportedVsCurrenciesResponse, error)

	// GetSimpleTokenPriceId request
	GetSimpleTokenPriceIdWithResponse(ctx context.Context, id string, params *GetSimpleTokenPriceIdParams, reqEditors ...RequestEditorFn) (*GetSimpleTokenPriceIdResponse, error)
}

type GetAssetPlatformsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAssetPlatformsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetPlatformsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsCategoriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsCategoriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsCategoriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsMarketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsMarketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsMarketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdContractContractAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdContractContractAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdContractContractAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdContractContractAddressMarketChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdContractContractAddressMarketChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdContractContractAddressMarketChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdContractContractAddressMarketChartRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdContractContractAddressMarketChartRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdContractContractAddressMarketChartRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdMarketChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdMarketChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdMarketChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdMarketChartRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdMarketChartRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdMarketChartRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdOhlcResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]float32
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdOhlcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdOhlcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoinsIdTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCoinsIdTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsIdTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDerivativesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDerivativesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDerivativesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDerivativesExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDerivativesExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDerivativesExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDerivativesExchangesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDerivativesExchangesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDerivativesExchangesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDerivativesExchangesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDerivativesExchangesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDerivativesExchangesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangeRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetExchangeRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangeRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Exchange
}

// Status returns HTTPResponse.Status
func (r GetExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ExchangeIdName
}

// Status returns HTTPResponse.Status
func (r GetExchangesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ExchangeDetails
}

// Status returns HTTPResponse.Status
func (r GetExchangesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangesIdTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetExchangesIdTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangesIdTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangesIdVolumeChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetExchangesIdVolumeChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangesIdVolumeChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndexesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIndexesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIndexesMarketIdIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIndexesMarketIdIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIndexesMarketIdIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchTrendingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSearchTrendingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchTrendingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimplePriceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSimplePriceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimplePriceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimpleSupportedVsCurrenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSimpleSupportedVsCurrenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimpleSupportedVsCurrenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimpleTokenPriceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSimpleTokenPriceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimpleTokenPriceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAssetPlatformsWithResponse request returning *GetAssetPlatformsResponse
func (c *ClientWithResponses) GetAssetPlatformsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAssetPlatformsResponse, error) {
	rsp, err := c.GetAssetPlatforms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetPlatformsResponse(rsp)
}

// GetCoinsCategoriesWithResponse request returning *GetCoinsCategoriesResponse
func (c *ClientWithResponses) GetCoinsCategoriesWithResponse(ctx context.Context, params *GetCoinsCategoriesParams, reqEditors ...RequestEditorFn) (*GetCoinsCategoriesResponse, error) {
	rsp, err := c.GetCoinsCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsCategoriesResponse(rsp)
}

// GetCoinsCategoriesListWithResponse request returning *GetCoinsCategoriesListResponse
func (c *ClientWithResponses) GetCoinsCategoriesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCoinsCategoriesListResponse, error) {
	rsp, err := c.GetCoinsCategoriesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsCategoriesListResponse(rsp)
}

// GetCoinsListWithResponse request returning *GetCoinsListResponse
func (c *ClientWithResponses) GetCoinsListWithResponse(ctx context.Context, params *GetCoinsListParams, reqEditors ...RequestEditorFn) (*GetCoinsListResponse, error) {
	rsp, err := c.GetCoinsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsListResponse(rsp)
}

// GetCoinsMarketsWithResponse request returning *GetCoinsMarketsResponse
func (c *ClientWithResponses) GetCoinsMarketsWithResponse(ctx context.Context, params *GetCoinsMarketsParams, reqEditors ...RequestEditorFn) (*GetCoinsMarketsResponse, error) {
	rsp, err := c.GetCoinsMarkets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsMarketsResponse(rsp)
}

// GetCoinsIdWithResponse request returning *GetCoinsIdResponse
func (c *ClientWithResponses) GetCoinsIdWithResponse(ctx context.Context, id string, params *GetCoinsIdParams, reqEditors ...RequestEditorFn) (*GetCoinsIdResponse, error) {
	rsp, err := c.GetCoinsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdResponse(rsp)
}

// GetCoinsIdContractContractAddressWithResponse request returning *GetCoinsIdContractContractAddressResponse
func (c *ClientWithResponses) GetCoinsIdContractContractAddressWithResponse(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*GetCoinsIdContractContractAddressResponse, error) {
	rsp, err := c.GetCoinsIdContractContractAddress(ctx, id, contractAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdContractContractAddressResponse(rsp)
}

// GetCoinsIdContractContractAddressMarketChartWithResponse request returning *GetCoinsIdContractContractAddressMarketChartResponse
func (c *ClientWithResponses) GetCoinsIdContractContractAddressMarketChartWithResponse(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*GetCoinsIdContractContractAddressMarketChartResponse, error) {
	rsp, err := c.GetCoinsIdContractContractAddressMarketChart(ctx, id, contractAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdContractContractAddressMarketChartResponse(rsp)
}

// GetCoinsIdContractContractAddressMarketChartRangeWithResponse request returning *GetCoinsIdContractContractAddressMarketChartRangeResponse
func (c *ClientWithResponses) GetCoinsIdContractContractAddressMarketChartRangeWithResponse(ctx context.Context, id string, contractAddress string, params *GetCoinsIdContractContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*GetCoinsIdContractContractAddressMarketChartRangeResponse, error) {
	rsp, err := c.GetCoinsIdContractContractAddressMarketChartRange(ctx, id, contractAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdContractContractAddressMarketChartRangeResponse(rsp)
}

// GetCoinsIdHistoryWithResponse request returning *GetCoinsIdHistoryResponse
func (c *ClientWithResponses) GetCoinsIdHistoryWithResponse(ctx context.Context, id string, params *GetCoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*GetCoinsIdHistoryResponse, error) {
	rsp, err := c.GetCoinsIdHistory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdHistoryResponse(rsp)
}

// GetCoinsIdMarketChartWithResponse request returning *GetCoinsIdMarketChartResponse
func (c *ClientWithResponses) GetCoinsIdMarketChartWithResponse(ctx context.Context, id string, params *GetCoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*GetCoinsIdMarketChartResponse, error) {
	rsp, err := c.GetCoinsIdMarketChart(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdMarketChartResponse(rsp)
}

// GetCoinsIdMarketChartRangeWithResponse request returning *GetCoinsIdMarketChartRangeResponse
func (c *ClientWithResponses) GetCoinsIdMarketChartRangeWithResponse(ctx context.Context, id string, params *GetCoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*GetCoinsIdMarketChartRangeResponse, error) {
	rsp, err := c.GetCoinsIdMarketChartRange(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdMarketChartRangeResponse(rsp)
}

// GetCoinsIdOhlcWithResponse request returning *GetCoinsIdOhlcResponse
func (c *ClientWithResponses) GetCoinsIdOhlcWithResponse(ctx context.Context, id string, params *GetCoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*GetCoinsIdOhlcResponse, error) {
	rsp, err := c.GetCoinsIdOhlc(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdOhlcResponse(rsp)
}

// GetCoinsIdTickersWithResponse request returning *GetCoinsIdTickersResponse
func (c *ClientWithResponses) GetCoinsIdTickersWithResponse(ctx context.Context, id string, params *GetCoinsIdTickersParams, reqEditors ...RequestEditorFn) (*GetCoinsIdTickersResponse, error) {
	rsp, err := c.GetCoinsIdTickers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsIdTickersResponse(rsp)
}

// GetDerivativesWithResponse request returning *GetDerivativesResponse
func (c *ClientWithResponses) GetDerivativesWithResponse(ctx context.Context, params *GetDerivativesParams, reqEditors ...RequestEditorFn) (*GetDerivativesResponse, error) {
	rsp, err := c.GetDerivatives(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDerivativesResponse(rsp)
}

// GetDerivativesExchangesWithResponse request returning *GetDerivativesExchangesResponse
func (c *ClientWithResponses) GetDerivativesExchangesWithResponse(ctx context.Context, params *GetDerivativesExchangesParams, reqEditors ...RequestEditorFn) (*GetDerivativesExchangesResponse, error) {
	rsp, err := c.GetDerivativesExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDerivativesExchangesResponse(rsp)
}

// GetDerivativesExchangesListWithResponse request returning *GetDerivativesExchangesListResponse
func (c *ClientWithResponses) GetDerivativesExchangesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDerivativesExchangesListResponse, error) {
	rsp, err := c.GetDerivativesExchangesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDerivativesExchangesListResponse(rsp)
}

// GetDerivativesExchangesIdWithResponse request returning *GetDerivativesExchangesIdResponse
func (c *ClientWithResponses) GetDerivativesExchangesIdWithResponse(ctx context.Context, id string, params *GetDerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*GetDerivativesExchangesIdResponse, error) {
	rsp, err := c.GetDerivativesExchangesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDerivativesExchangesIdResponse(rsp)
}

// GetExchangeRatesWithResponse request returning *GetExchangeRatesResponse
func (c *ClientWithResponses) GetExchangeRatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExchangeRatesResponse, error) {
	rsp, err := c.GetExchangeRates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangeRatesResponse(rsp)
}

// GetExchangesWithResponse request returning *GetExchangesResponse
func (c *ClientWithResponses) GetExchangesWithResponse(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*GetExchangesResponse, error) {
	rsp, err := c.GetExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangesResponse(rsp)
}

// GetExchangesListWithResponse request returning *GetExchangesListResponse
func (c *ClientWithResponses) GetExchangesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExchangesListResponse, error) {
	rsp, err := c.GetExchangesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangesListResponse(rsp)
}

// GetExchangesIdWithResponse request returning *GetExchangesIdResponse
func (c *ClientWithResponses) GetExchangesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetExchangesIdResponse, error) {
	rsp, err := c.GetExchangesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangesIdResponse(rsp)
}

// GetExchangesIdTickersWithResponse request returning *GetExchangesIdTickersResponse
func (c *ClientWithResponses) GetExchangesIdTickersWithResponse(ctx context.Context, id string, params *GetExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*GetExchangesIdTickersResponse, error) {
	rsp, err := c.GetExchangesIdTickers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangesIdTickersResponse(rsp)
}

// GetExchangesIdVolumeChartWithResponse request returning *GetExchangesIdVolumeChartResponse
func (c *ClientWithResponses) GetExchangesIdVolumeChartWithResponse(ctx context.Context, id string, params *GetExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*GetExchangesIdVolumeChartResponse, error) {
	rsp, err := c.GetExchangesIdVolumeChart(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangesIdVolumeChartResponse(rsp)
}

// GetGlobalWithResponse request returning *GetGlobalResponse
func (c *ClientWithResponses) GetGlobalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error) {
	rsp, err := c.GetGlobal(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalResponse(rsp)
}

// GetIndexesWithResponse request returning *GetIndexesResponse
func (c *ClientWithResponses) GetIndexesWithResponse(ctx context.Context, params *GetIndexesParams, reqEditors ...RequestEditorFn) (*GetIndexesResponse, error) {
	rsp, err := c.GetIndexes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexesResponse(rsp)
}

// GetIndexesListWithResponse request returning *GetIndexesListResponse
func (c *ClientWithResponses) GetIndexesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIndexesListResponse, error) {
	rsp, err := c.GetIndexesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexesListResponse(rsp)
}

// GetIndexesMarketIdIdWithResponse request returning *GetIndexesMarketIdIdResponse
func (c *ClientWithResponses) GetIndexesMarketIdIdWithResponse(ctx context.Context, marketId string, id string, reqEditors ...RequestEditorFn) (*GetIndexesMarketIdIdResponse, error) {
	rsp, err := c.GetIndexesMarketIdId(ctx, marketId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIndexesMarketIdIdResponse(rsp)
}

// GetPingWithResponse request returning *GetPingResponse
func (c *ClientWithResponses) GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPingResponse, error) {
	rsp, err := c.GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPingResponse(rsp)
}

// GetSearchTrendingWithResponse request returning *GetSearchTrendingResponse
func (c *ClientWithResponses) GetSearchTrendingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchTrendingResponse, error) {
	rsp, err := c.GetSearchTrending(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchTrendingResponse(rsp)
}

// GetSimplePriceWithResponse request returning *GetSimplePriceResponse
func (c *ClientWithResponses) GetSimplePriceWithResponse(ctx context.Context, params *GetSimplePriceParams, reqEditors ...RequestEditorFn) (*GetSimplePriceResponse, error) {
	rsp, err := c.GetSimplePrice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimplePriceResponse(rsp)
}

// GetSimpleSupportedVsCurrenciesWithResponse request returning *GetSimpleSupportedVsCurrenciesResponse
func (c *ClientWithResponses) GetSimpleSupportedVsCurrenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSimpleSupportedVsCurrenciesResponse, error) {
	rsp, err := c.GetSimpleSupportedVsCurrencies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimpleSupportedVsCurrenciesResponse(rsp)
}

// GetSimpleTokenPriceIdWithResponse request returning *GetSimpleTokenPriceIdResponse
func (c *ClientWithResponses) GetSimpleTokenPriceIdWithResponse(ctx context.Context, id string, params *GetSimpleTokenPriceIdParams, reqEditors ...RequestEditorFn) (*GetSimpleTokenPriceIdResponse, error) {
	rsp, err := c.GetSimpleTokenPriceId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimpleTokenPriceIdResponse(rsp)
}

// ParseGetAssetPlatformsResponse parses an HTTP response from a GetAssetPlatformsWithResponse call
func ParseGetAssetPlatformsResponse(rsp *http.Response) (*GetAssetPlatformsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetPlatformsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsCategoriesResponse parses an HTTP response from a GetCoinsCategoriesWithResponse call
func ParseGetCoinsCategoriesResponse(rsp *http.Response) (*GetCoinsCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsCategoriesListResponse parses an HTTP response from a GetCoinsCategoriesListWithResponse call
func ParseGetCoinsCategoriesListResponse(rsp *http.Response) (*GetCoinsCategoriesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsCategoriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsListResponse parses an HTTP response from a GetCoinsListWithResponse call
func ParseGetCoinsListResponse(rsp *http.Response) (*GetCoinsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsMarketsResponse parses an HTTP response from a GetCoinsMarketsWithResponse call
func ParseGetCoinsMarketsResponse(rsp *http.Response) (*GetCoinsMarketsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsMarketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdResponse parses an HTTP response from a GetCoinsIdWithResponse call
func ParseGetCoinsIdResponse(rsp *http.Response) (*GetCoinsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdContractContractAddressResponse parses an HTTP response from a GetCoinsIdContractContractAddressWithResponse call
func ParseGetCoinsIdContractContractAddressResponse(rsp *http.Response) (*GetCoinsIdContractContractAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdContractContractAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdContractContractAddressMarketChartResponse parses an HTTP response from a GetCoinsIdContractContractAddressMarketChartWithResponse call
func ParseGetCoinsIdContractContractAddressMarketChartResponse(rsp *http.Response) (*GetCoinsIdContractContractAddressMarketChartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdContractContractAddressMarketChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdContractContractAddressMarketChartRangeResponse parses an HTTP response from a GetCoinsIdContractContractAddressMarketChartRangeWithResponse call
func ParseGetCoinsIdContractContractAddressMarketChartRangeResponse(rsp *http.Response) (*GetCoinsIdContractContractAddressMarketChartRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdContractContractAddressMarketChartRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdHistoryResponse parses an HTTP response from a GetCoinsIdHistoryWithResponse call
func ParseGetCoinsIdHistoryResponse(rsp *http.Response) (*GetCoinsIdHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdMarketChartResponse parses an HTTP response from a GetCoinsIdMarketChartWithResponse call
func ParseGetCoinsIdMarketChartResponse(rsp *http.Response) (*GetCoinsIdMarketChartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdMarketChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdMarketChartRangeResponse parses an HTTP response from a GetCoinsIdMarketChartRangeWithResponse call
func ParseGetCoinsIdMarketChartRangeResponse(rsp *http.Response) (*GetCoinsIdMarketChartRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdMarketChartRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCoinsIdOhlcResponse parses an HTTP response from a GetCoinsIdOhlcWithResponse call
func ParseGetCoinsIdOhlcResponse(rsp *http.Response) (*GetCoinsIdOhlcResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdOhlcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []float32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCoinsIdTickersResponse parses an HTTP response from a GetCoinsIdTickersWithResponse call
func ParseGetCoinsIdTickersResponse(rsp *http.Response) (*GetCoinsIdTickersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsIdTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDerivativesResponse parses an HTTP response from a GetDerivativesWithResponse call
func ParseGetDerivativesResponse(rsp *http.Response) (*GetDerivativesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDerivativesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDerivativesExchangesResponse parses an HTTP response from a GetDerivativesExchangesWithResponse call
func ParseGetDerivativesExchangesResponse(rsp *http.Response) (*GetDerivativesExchangesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDerivativesExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDerivativesExchangesListResponse parses an HTTP response from a GetDerivativesExchangesListWithResponse call
func ParseGetDerivativesExchangesListResponse(rsp *http.Response) (*GetDerivativesExchangesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDerivativesExchangesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDerivativesExchangesIdResponse parses an HTTP response from a GetDerivativesExchangesIdWithResponse call
func ParseGetDerivativesExchangesIdResponse(rsp *http.Response) (*GetDerivativesExchangesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDerivativesExchangesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExchangeRatesResponse parses an HTTP response from a GetExchangeRatesWithResponse call
func ParseGetExchangeRatesResponse(rsp *http.Response) (*GetExchangeRatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangeRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExchangesResponse parses an HTTP response from a GetExchangesWithResponse call
func ParseGetExchangesResponse(rsp *http.Response) (*GetExchangesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Exchange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExchangesListResponse parses an HTTP response from a GetExchangesListWithResponse call
func ParseGetExchangesListResponse(rsp *http.Response) (*GetExchangesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ExchangeIdName
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExchangesIdResponse parses an HTTP response from a GetExchangesIdWithResponse call
func ParseGetExchangesIdResponse(rsp *http.Response) (*GetExchangesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ExchangeDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExchangesIdTickersResponse parses an HTTP response from a GetExchangesIdTickersWithResponse call
func ParseGetExchangesIdTickersResponse(rsp *http.Response) (*GetExchangesIdTickersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangesIdTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExchangesIdVolumeChartResponse parses an HTTP response from a GetExchangesIdVolumeChartWithResponse call
func ParseGetExchangesIdVolumeChartResponse(rsp *http.Response) (*GetExchangesIdVolumeChartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangesIdVolumeChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGlobalResponse parses an HTTP response from a GetGlobalWithResponse call
func ParseGetGlobalResponse(rsp *http.Response) (*GetGlobalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIndexesResponse parses an HTTP response from a GetIndexesWithResponse call
func ParseGetIndexesResponse(rsp *http.Response) (*GetIndexesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIndexesListResponse parses an HTTP response from a GetIndexesListWithResponse call
func ParseGetIndexesListResponse(rsp *http.Response) (*GetIndexesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndexesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIndexesMarketIdIdResponse parses an HTTP response from a GetIndexesMarketIdIdWithResponse call
func ParseGetIndexesMarketIdIdResponse(rsp *http.Response) (*GetIndexesMarketIdIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIndexesMarketIdIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPingResponse parses an HTTP response from a GetPingWithResponse call
func ParseGetPingResponse(rsp *http.Response) (*GetPingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSearchTrendingResponse parses an HTTP response from a GetSearchTrendingWithResponse call
func ParseGetSearchTrendingResponse(rsp *http.Response) (*GetSearchTrendingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchTrendingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSimplePriceResponse parses an HTTP response from a GetSimplePriceWithResponse call
func ParseGetSimplePriceResponse(rsp *http.Response) (*GetSimplePriceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimplePriceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSimpleSupportedVsCurrenciesResponse parses an HTTP response from a GetSimpleSupportedVsCurrenciesWithResponse call
func ParseGetSimpleSupportedVsCurrenciesResponse(rsp *http.Response) (*GetSimpleSupportedVsCurrenciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimpleSupportedVsCurrenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSimpleTokenPriceIdResponse parses an HTTP response from a GetSimpleTokenPriceIdWithResponse call
func ParseGetSimpleTokenPriceIdResponse(rsp *http.Response) (*GetSimpleTokenPriceIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimpleTokenPriceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
