// Package ftxv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package ftxv1

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// Coin defines model for coin.
type Coin struct {
	Id                   string                 `json:"id"`
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Market defines model for market.
type Market struct {
	Ask                   float64                `json:"ask"`
	BaseCurrency          string                 `json:"baseCurrency"`
	Bid                   float64                `json:"bid"`
	Change1h              float64                `json:"change1h"`
	Change24h             float64                `json:"change24h"`
	ChangeBod             float64                `json:"changeBod"`
	Enabled               bool                   `json:"enabled"`
	FutureType            string                 `json:"futureType"`
	HighLeverageFeeExempt bool                   `json:"highLeverageFeeExempt"`
	IsEtfMarket           bool                   `json:"isEtfMarket"`
	LargeOrderThreshold   float32                `json:"largeOrderThreshold"`
	Last                  float64                `json:"last"`
	MinProvideSize        float32                `json:"minProvideSize"`
	Name                  string                 `json:"name"`
	PostOnly              bool                   `json:"postOnly"`
	Price                 float64                `json:"price"`
	PriceHigh24h          float64                `json:"priceHigh24h"`
	PriceIncrement        float32                `json:"priceIncrement"`
	PriceLow24h           float64                `json:"priceLow24h"`
	QuoteCurrency         string                 `json:"quoteCurrency"`
	QuoteVolume24h        float64                `json:"quoteVolume24h"`
	Restricted            bool                   `json:"restricted"`
	SizeIncrement         float32                `json:"sizeIncrement"`
	Type                  string                 `json:"type"`
	Underlying            string                 `json:"underlying"`
	VolumeUsd24h          float64                `json:"volumeUsd24h"`
	AdditionalProperties  map[string]interface{} `json:"-"`
}

// Getter for additional properties for Coin. Returns the specified
// element and whether it was found
func (a Coin) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Coin
func (a *Coin) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Coin to handle AdditionalProperties
func (a *Coin) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Coin to handle AdditionalProperties
func (a Coin) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Market. Returns the specified
// element and whether it was found
func (a Market) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Market
func (a *Market) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Market to handle AdditionalProperties
func (a *Market) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ask"]; found {
		err = json.Unmarshal(raw, &a.Ask)
		if err != nil {
			return fmt.Errorf("error reading 'ask': %w", err)
		}
		delete(object, "ask")
	}

	if raw, found := object["baseCurrency"]; found {
		err = json.Unmarshal(raw, &a.BaseCurrency)
		if err != nil {
			return fmt.Errorf("error reading 'baseCurrency': %w", err)
		}
		delete(object, "baseCurrency")
	}

	if raw, found := object["bid"]; found {
		err = json.Unmarshal(raw, &a.Bid)
		if err != nil {
			return fmt.Errorf("error reading 'bid': %w", err)
		}
		delete(object, "bid")
	}

	if raw, found := object["change1h"]; found {
		err = json.Unmarshal(raw, &a.Change1h)
		if err != nil {
			return fmt.Errorf("error reading 'change1h': %w", err)
		}
		delete(object, "change1h")
	}

	if raw, found := object["change24h"]; found {
		err = json.Unmarshal(raw, &a.Change24h)
		if err != nil {
			return fmt.Errorf("error reading 'change24h': %w", err)
		}
		delete(object, "change24h")
	}

	if raw, found := object["changeBod"]; found {
		err = json.Unmarshal(raw, &a.ChangeBod)
		if err != nil {
			return fmt.Errorf("error reading 'changeBod': %w", err)
		}
		delete(object, "changeBod")
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &a.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
		delete(object, "enabled")
	}

	if raw, found := object["futureType"]; found {
		err = json.Unmarshal(raw, &a.FutureType)
		if err != nil {
			return fmt.Errorf("error reading 'futureType': %w", err)
		}
		delete(object, "futureType")
	}

	if raw, found := object["highLeverageFeeExempt"]; found {
		err = json.Unmarshal(raw, &a.HighLeverageFeeExempt)
		if err != nil {
			return fmt.Errorf("error reading 'highLeverageFeeExempt': %w", err)
		}
		delete(object, "highLeverageFeeExempt")
	}

	if raw, found := object["isEtfMarket"]; found {
		err = json.Unmarshal(raw, &a.IsEtfMarket)
		if err != nil {
			return fmt.Errorf("error reading 'isEtfMarket': %w", err)
		}
		delete(object, "isEtfMarket")
	}

	if raw, found := object["largeOrderThreshold"]; found {
		err = json.Unmarshal(raw, &a.LargeOrderThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'largeOrderThreshold': %w", err)
		}
		delete(object, "largeOrderThreshold")
	}

	if raw, found := object["last"]; found {
		err = json.Unmarshal(raw, &a.Last)
		if err != nil {
			return fmt.Errorf("error reading 'last': %w", err)
		}
		delete(object, "last")
	}

	if raw, found := object["minProvideSize"]; found {
		err = json.Unmarshal(raw, &a.MinProvideSize)
		if err != nil {
			return fmt.Errorf("error reading 'minProvideSize': %w", err)
		}
		delete(object, "minProvideSize")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["postOnly"]; found {
		err = json.Unmarshal(raw, &a.PostOnly)
		if err != nil {
			return fmt.Errorf("error reading 'postOnly': %w", err)
		}
		delete(object, "postOnly")
	}

	if raw, found := object["price"]; found {
		err = json.Unmarshal(raw, &a.Price)
		if err != nil {
			return fmt.Errorf("error reading 'price': %w", err)
		}
		delete(object, "price")
	}

	if raw, found := object["priceHigh24h"]; found {
		err = json.Unmarshal(raw, &a.PriceHigh24h)
		if err != nil {
			return fmt.Errorf("error reading 'priceHigh24h': %w", err)
		}
		delete(object, "priceHigh24h")
	}

	if raw, found := object["priceIncrement"]; found {
		err = json.Unmarshal(raw, &a.PriceIncrement)
		if err != nil {
			return fmt.Errorf("error reading 'priceIncrement': %w", err)
		}
		delete(object, "priceIncrement")
	}

	if raw, found := object["priceLow24h"]; found {
		err = json.Unmarshal(raw, &a.PriceLow24h)
		if err != nil {
			return fmt.Errorf("error reading 'priceLow24h': %w", err)
		}
		delete(object, "priceLow24h")
	}

	if raw, found := object["quoteCurrency"]; found {
		err = json.Unmarshal(raw, &a.QuoteCurrency)
		if err != nil {
			return fmt.Errorf("error reading 'quoteCurrency': %w", err)
		}
		delete(object, "quoteCurrency")
	}

	if raw, found := object["quoteVolume24h"]; found {
		err = json.Unmarshal(raw, &a.QuoteVolume24h)
		if err != nil {
			return fmt.Errorf("error reading 'quoteVolume24h': %w", err)
		}
		delete(object, "quoteVolume24h")
	}

	if raw, found := object["restricted"]; found {
		err = json.Unmarshal(raw, &a.Restricted)
		if err != nil {
			return fmt.Errorf("error reading 'restricted': %w", err)
		}
		delete(object, "restricted")
	}

	if raw, found := object["sizeIncrement"]; found {
		err = json.Unmarshal(raw, &a.SizeIncrement)
		if err != nil {
			return fmt.Errorf("error reading 'sizeIncrement': %w", err)
		}
		delete(object, "sizeIncrement")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["underlying"]; found {
		err = json.Unmarshal(raw, &a.Underlying)
		if err != nil {
			return fmt.Errorf("error reading 'underlying': %w", err)
		}
		delete(object, "underlying")
	}

	if raw, found := object["volumeUsd24h"]; found {
		err = json.Unmarshal(raw, &a.VolumeUsd24h)
		if err != nil {
			return fmt.Errorf("error reading 'volumeUsd24h': %w", err)
		}
		delete(object, "volumeUsd24h")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Market to handle AdditionalProperties
func (a Market) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["ask"], err = json.Marshal(a.Ask)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ask': %w", err)
	}

	object["baseCurrency"], err = json.Marshal(a.BaseCurrency)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'baseCurrency': %w", err)
	}

	object["bid"], err = json.Marshal(a.Bid)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'bid': %w", err)
	}

	object["change1h"], err = json.Marshal(a.Change1h)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'change1h': %w", err)
	}

	object["change24h"], err = json.Marshal(a.Change24h)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'change24h': %w", err)
	}

	object["changeBod"], err = json.Marshal(a.ChangeBod)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'changeBod': %w", err)
	}

	object["enabled"], err = json.Marshal(a.Enabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
	}

	object["futureType"], err = json.Marshal(a.FutureType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'futureType': %w", err)
	}

	object["highLeverageFeeExempt"], err = json.Marshal(a.HighLeverageFeeExempt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'highLeverageFeeExempt': %w", err)
	}

	object["isEtfMarket"], err = json.Marshal(a.IsEtfMarket)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'isEtfMarket': %w", err)
	}

	object["largeOrderThreshold"], err = json.Marshal(a.LargeOrderThreshold)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'largeOrderThreshold': %w", err)
	}

	object["last"], err = json.Marshal(a.Last)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'last': %w", err)
	}

	object["minProvideSize"], err = json.Marshal(a.MinProvideSize)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'minProvideSize': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["postOnly"], err = json.Marshal(a.PostOnly)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'postOnly': %w", err)
	}

	object["price"], err = json.Marshal(a.Price)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'price': %w", err)
	}

	object["priceHigh24h"], err = json.Marshal(a.PriceHigh24h)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'priceHigh24h': %w", err)
	}

	object["priceIncrement"], err = json.Marshal(a.PriceIncrement)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'priceIncrement': %w", err)
	}

	object["priceLow24h"], err = json.Marshal(a.PriceLow24h)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'priceLow24h': %w", err)
	}

	object["quoteCurrency"], err = json.Marshal(a.QuoteCurrency)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'quoteCurrency': %w", err)
	}

	object["quoteVolume24h"], err = json.Marshal(a.QuoteVolume24h)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'quoteVolume24h': %w", err)
	}

	object["restricted"], err = json.Marshal(a.Restricted)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'restricted': %w", err)
	}

	object["sizeIncrement"], err = json.Marshal(a.SizeIncrement)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sizeIncrement': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	object["underlying"], err = json.Marshal(a.Underlying)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'underlying': %w", err)
	}

	object["volumeUsd24h"], err = json.Marshal(a.VolumeUsd24h)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'volumeUsd24h': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCoins request
	GetCoins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMarkets request
	GetMarkets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCoins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoinsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMarkets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMarketsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCoinsRequest generates requests for GetCoins
func NewGetCoinsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMarketsRequest generates requests for GetMarkets
func NewGetMarketsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCoins request
	GetCoinsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCoinsResponse, error)

	// GetMarkets request
	GetMarketsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketsResponse, error)
}

type GetCoinsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result  *[]Coin `json:"result,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCoinsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoinsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMarketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result  *[]Market `json:"result,omitempty"`
		Success *bool     `json:"success,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMarketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMarketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCoinsWithResponse request returning *GetCoinsResponse
func (c *ClientWithResponses) GetCoinsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCoinsResponse, error) {
	rsp, err := c.GetCoins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoinsResponse(rsp)
}

// GetMarketsWithResponse request returning *GetMarketsResponse
func (c *ClientWithResponses) GetMarketsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMarketsResponse, error) {
	rsp, err := c.GetMarkets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMarketsResponse(rsp)
}

// ParseGetCoinsResponse parses an HTTP response from a GetCoinsWithResponse call
func ParseGetCoinsResponse(rsp *http.Response) (*GetCoinsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoinsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result  *[]Coin `json:"result,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMarketsResponse parses an HTTP response from a GetMarketsWithResponse call
func ParseGetMarketsResponse(rsp *http.Response) (*GetMarketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMarketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result  *[]Market `json:"result,omitempty"`
			Success *bool     `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
