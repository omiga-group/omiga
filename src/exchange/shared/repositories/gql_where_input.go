// Code generated by ent, DO NOT EDIT.

package repositories

import (
	"errors"
	"fmt"
	"time"

	"github.com/omiga-group/omiga/src/exchange/shared/repositories/exchange"
	"github.com/omiga-group/omiga/src/exchange/shared/repositories/outbox"
	"github.com/omiga-group/omiga/src/exchange/shared/repositories/predicate"
	"github.com/omiga-group/omiga/src/exchange/shared/repositories/ticker"
)

// ExchangeWhereInput represents a where input for filtering Exchange queries.
type ExchangeWhereInput struct {
	Predicates []predicate.Exchange  `json:"-"`
	Not        *ExchangeWhereInput   `json:"not,omitempty"`
	Or         []*ExchangeWhereInput `json:"or,omitempty"`
	And        []*ExchangeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "exchange_id" field predicates.
	ExchangeID             *string  `json:"exchangeID,omitempty"`
	ExchangeIDNEQ          *string  `json:"exchangeIDNEQ,omitempty"`
	ExchangeIDIn           []string `json:"exchangeIDIn,omitempty"`
	ExchangeIDNotIn        []string `json:"exchangeIDNotIn,omitempty"`
	ExchangeIDGT           *string  `json:"exchangeIDGT,omitempty"`
	ExchangeIDGTE          *string  `json:"exchangeIDGTE,omitempty"`
	ExchangeIDLT           *string  `json:"exchangeIDLT,omitempty"`
	ExchangeIDLTE          *string  `json:"exchangeIDLTE,omitempty"`
	ExchangeIDContains     *string  `json:"exchangeIDContains,omitempty"`
	ExchangeIDHasPrefix    *string  `json:"exchangeIDHasPrefix,omitempty"`
	ExchangeIDHasSuffix    *string  `json:"exchangeIDHasSuffix,omitempty"`
	ExchangeIDEqualFold    *string  `json:"exchangeIDEqualFold,omitempty"`
	ExchangeIDContainsFold *string  `json:"exchangeIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "year_established" field predicates.
	YearEstablished       *int  `json:"yearEstablished,omitempty"`
	YearEstablishedNEQ    *int  `json:"yearEstablishedNEQ,omitempty"`
	YearEstablishedIn     []int `json:"yearEstablishedIn,omitempty"`
	YearEstablishedNotIn  []int `json:"yearEstablishedNotIn,omitempty"`
	YearEstablishedGT     *int  `json:"yearEstablishedGT,omitempty"`
	YearEstablishedGTE    *int  `json:"yearEstablishedGTE,omitempty"`
	YearEstablishedLT     *int  `json:"yearEstablishedLT,omitempty"`
	YearEstablishedLTE    *int  `json:"yearEstablishedLTE,omitempty"`
	YearEstablishedIsNil  bool  `json:"yearEstablishedIsNil,omitempty"`
	YearEstablishedNotNil bool  `json:"yearEstablishedNotNil,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryIsNil        bool     `json:"countryIsNil,omitempty"`
	CountryNotNil       bool     `json:"countryNotNil,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageIsNil        bool     `json:"imageIsNil,omitempty"`
	ImageNotNil       bool     `json:"imageNotNil,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "has_trading_incentive" field predicates.
	HasTradingIncentive       *bool `json:"hasTradingIncentive,omitempty"`
	HasTradingIncentiveNEQ    *bool `json:"hasTradingIncentiveNEQ,omitempty"`
	HasTradingIncentiveIsNil  bool  `json:"hasTradingIncentiveIsNil,omitempty"`
	HasTradingIncentiveNotNil bool  `json:"hasTradingIncentiveNotNil,omitempty"`

	// "centralized" field predicates.
	Centralized       *bool `json:"centralized,omitempty"`
	CentralizedNEQ    *bool `json:"centralizedNEQ,omitempty"`
	CentralizedIsNil  bool  `json:"centralizedIsNil,omitempty"`
	CentralizedNotNil bool  `json:"centralizedNotNil,omitempty"`

	// "public_notice" field predicates.
	PublicNotice             *string  `json:"publicNotice,omitempty"`
	PublicNoticeNEQ          *string  `json:"publicNoticeNEQ,omitempty"`
	PublicNoticeIn           []string `json:"publicNoticeIn,omitempty"`
	PublicNoticeNotIn        []string `json:"publicNoticeNotIn,omitempty"`
	PublicNoticeGT           *string  `json:"publicNoticeGT,omitempty"`
	PublicNoticeGTE          *string  `json:"publicNoticeGTE,omitempty"`
	PublicNoticeLT           *string  `json:"publicNoticeLT,omitempty"`
	PublicNoticeLTE          *string  `json:"publicNoticeLTE,omitempty"`
	PublicNoticeContains     *string  `json:"publicNoticeContains,omitempty"`
	PublicNoticeHasPrefix    *string  `json:"publicNoticeHasPrefix,omitempty"`
	PublicNoticeHasSuffix    *string  `json:"publicNoticeHasSuffix,omitempty"`
	PublicNoticeIsNil        bool     `json:"publicNoticeIsNil,omitempty"`
	PublicNoticeNotNil       bool     `json:"publicNoticeNotNil,omitempty"`
	PublicNoticeEqualFold    *string  `json:"publicNoticeEqualFold,omitempty"`
	PublicNoticeContainsFold *string  `json:"publicNoticeContainsFold,omitempty"`

	// "alert_notice" field predicates.
	AlertNotice             *string  `json:"alertNotice,omitempty"`
	AlertNoticeNEQ          *string  `json:"alertNoticeNEQ,omitempty"`
	AlertNoticeIn           []string `json:"alertNoticeIn,omitempty"`
	AlertNoticeNotIn        []string `json:"alertNoticeNotIn,omitempty"`
	AlertNoticeGT           *string  `json:"alertNoticeGT,omitempty"`
	AlertNoticeGTE          *string  `json:"alertNoticeGTE,omitempty"`
	AlertNoticeLT           *string  `json:"alertNoticeLT,omitempty"`
	AlertNoticeLTE          *string  `json:"alertNoticeLTE,omitempty"`
	AlertNoticeContains     *string  `json:"alertNoticeContains,omitempty"`
	AlertNoticeHasPrefix    *string  `json:"alertNoticeHasPrefix,omitempty"`
	AlertNoticeHasSuffix    *string  `json:"alertNoticeHasSuffix,omitempty"`
	AlertNoticeIsNil        bool     `json:"alertNoticeIsNil,omitempty"`
	AlertNoticeNotNil       bool     `json:"alertNoticeNotNil,omitempty"`
	AlertNoticeEqualFold    *string  `json:"alertNoticeEqualFold,omitempty"`
	AlertNoticeContainsFold *string  `json:"alertNoticeContainsFold,omitempty"`

	// "trust_score" field predicates.
	TrustScore       *int  `json:"trustScore,omitempty"`
	TrustScoreNEQ    *int  `json:"trustScoreNEQ,omitempty"`
	TrustScoreIn     []int `json:"trustScoreIn,omitempty"`
	TrustScoreNotIn  []int `json:"trustScoreNotIn,omitempty"`
	TrustScoreGT     *int  `json:"trustScoreGT,omitempty"`
	TrustScoreGTE    *int  `json:"trustScoreGTE,omitempty"`
	TrustScoreLT     *int  `json:"trustScoreLT,omitempty"`
	TrustScoreLTE    *int  `json:"trustScoreLTE,omitempty"`
	TrustScoreIsNil  bool  `json:"trustScoreIsNil,omitempty"`
	TrustScoreNotNil bool  `json:"trustScoreNotNil,omitempty"`

	// "trust_score_rank" field predicates.
	TrustScoreRank       *int  `json:"trustScoreRank,omitempty"`
	TrustScoreRankNEQ    *int  `json:"trustScoreRankNEQ,omitempty"`
	TrustScoreRankIn     []int `json:"trustScoreRankIn,omitempty"`
	TrustScoreRankNotIn  []int `json:"trustScoreRankNotIn,omitempty"`
	TrustScoreRankGT     *int  `json:"trustScoreRankGT,omitempty"`
	TrustScoreRankGTE    *int  `json:"trustScoreRankGTE,omitempty"`
	TrustScoreRankLT     *int  `json:"trustScoreRankLT,omitempty"`
	TrustScoreRankLTE    *int  `json:"trustScoreRankLTE,omitempty"`
	TrustScoreRankIsNil  bool  `json:"trustScoreRankIsNil,omitempty"`
	TrustScoreRankNotNil bool  `json:"trustScoreRankNotNil,omitempty"`

	// "trade_volume_24h_btc" field predicates.
	TradeVolume24hBtc       *float64  `json:"tradeVolume24hBtc,omitempty"`
	TradeVolume24hBtcNEQ    *float64  `json:"tradeVolume24hBtcNEQ,omitempty"`
	TradeVolume24hBtcIn     []float64 `json:"tradeVolume24hBtcIn,omitempty"`
	TradeVolume24hBtcNotIn  []float64 `json:"tradeVolume24hBtcNotIn,omitempty"`
	TradeVolume24hBtcGT     *float64  `json:"tradeVolume24hBtcGT,omitempty"`
	TradeVolume24hBtcGTE    *float64  `json:"tradeVolume24hBtcGTE,omitempty"`
	TradeVolume24hBtcLT     *float64  `json:"tradeVolume24hBtcLT,omitempty"`
	TradeVolume24hBtcLTE    *float64  `json:"tradeVolume24hBtcLTE,omitempty"`
	TradeVolume24hBtcIsNil  bool      `json:"tradeVolume24hBtcIsNil,omitempty"`
	TradeVolume24hBtcNotNil bool      `json:"tradeVolume24hBtcNotNil,omitempty"`

	// "trade_volume_24h_btc_normalized" field predicates.
	TradeVolume24hBtcNormalized       *float64  `json:"tradeVolume24hBtcNormalized,omitempty"`
	TradeVolume24hBtcNormalizedNEQ    *float64  `json:"tradeVolume24hBtcNormalizedNEQ,omitempty"`
	TradeVolume24hBtcNormalizedIn     []float64 `json:"tradeVolume24hBtcNormalizedIn,omitempty"`
	TradeVolume24hBtcNormalizedNotIn  []float64 `json:"tradeVolume24hBtcNormalizedNotIn,omitempty"`
	TradeVolume24hBtcNormalizedGT     *float64  `json:"tradeVolume24hBtcNormalizedGT,omitempty"`
	TradeVolume24hBtcNormalizedGTE    *float64  `json:"tradeVolume24hBtcNormalizedGTE,omitempty"`
	TradeVolume24hBtcNormalizedLT     *float64  `json:"tradeVolume24hBtcNormalizedLT,omitempty"`
	TradeVolume24hBtcNormalizedLTE    *float64  `json:"tradeVolume24hBtcNormalizedLTE,omitempty"`
	TradeVolume24hBtcNormalizedIsNil  bool      `json:"tradeVolume24hBtcNormalizedIsNil,omitempty"`
	TradeVolume24hBtcNormalizedNotNil bool      `json:"tradeVolume24hBtcNormalizedNotNil,omitempty"`

	// "ticker" edge predicates.
	HasTicker     *bool               `json:"hasTicker,omitempty"`
	HasTickerWith []*TickerWhereInput `json:"hasTickerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExchangeWhereInput) AddPredicates(predicates ...predicate.Exchange) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExchangeWhereInput filter on the ExchangeQuery builder.
func (i *ExchangeWhereInput) Filter(q *ExchangeQuery) (*ExchangeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExchangeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExchangeWhereInput is returned in case the ExchangeWhereInput is empty.
var ErrEmptyExchangeWhereInput = errors.New("repositories: empty predicate ExchangeWhereInput")

// P returns a predicate for filtering exchanges.
// An error is returned if the input is empty or invalid.
func (i *ExchangeWhereInput) P() (predicate.Exchange, error) {
	var predicates []predicate.Exchange
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, exchange.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Exchange, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, exchange.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Exchange, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, exchange.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, exchange.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, exchange.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, exchange.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, exchange.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, exchange.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, exchange.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, exchange.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, exchange.IDLTE(*i.IDLTE))
	}
	if i.ExchangeID != nil {
		predicates = append(predicates, exchange.ExchangeIDEQ(*i.ExchangeID))
	}
	if i.ExchangeIDNEQ != nil {
		predicates = append(predicates, exchange.ExchangeIDNEQ(*i.ExchangeIDNEQ))
	}
	if len(i.ExchangeIDIn) > 0 {
		predicates = append(predicates, exchange.ExchangeIDIn(i.ExchangeIDIn...))
	}
	if len(i.ExchangeIDNotIn) > 0 {
		predicates = append(predicates, exchange.ExchangeIDNotIn(i.ExchangeIDNotIn...))
	}
	if i.ExchangeIDGT != nil {
		predicates = append(predicates, exchange.ExchangeIDGT(*i.ExchangeIDGT))
	}
	if i.ExchangeIDGTE != nil {
		predicates = append(predicates, exchange.ExchangeIDGTE(*i.ExchangeIDGTE))
	}
	if i.ExchangeIDLT != nil {
		predicates = append(predicates, exchange.ExchangeIDLT(*i.ExchangeIDLT))
	}
	if i.ExchangeIDLTE != nil {
		predicates = append(predicates, exchange.ExchangeIDLTE(*i.ExchangeIDLTE))
	}
	if i.ExchangeIDContains != nil {
		predicates = append(predicates, exchange.ExchangeIDContains(*i.ExchangeIDContains))
	}
	if i.ExchangeIDHasPrefix != nil {
		predicates = append(predicates, exchange.ExchangeIDHasPrefix(*i.ExchangeIDHasPrefix))
	}
	if i.ExchangeIDHasSuffix != nil {
		predicates = append(predicates, exchange.ExchangeIDHasSuffix(*i.ExchangeIDHasSuffix))
	}
	if i.ExchangeIDEqualFold != nil {
		predicates = append(predicates, exchange.ExchangeIDEqualFold(*i.ExchangeIDEqualFold))
	}
	if i.ExchangeIDContainsFold != nil {
		predicates = append(predicates, exchange.ExchangeIDContainsFold(*i.ExchangeIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, exchange.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, exchange.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, exchange.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, exchange.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, exchange.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, exchange.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, exchange.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, exchange.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, exchange.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, exchange.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, exchange.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, exchange.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, exchange.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, exchange.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, exchange.NameContainsFold(*i.NameContainsFold))
	}
	if i.YearEstablished != nil {
		predicates = append(predicates, exchange.YearEstablishedEQ(*i.YearEstablished))
	}
	if i.YearEstablishedNEQ != nil {
		predicates = append(predicates, exchange.YearEstablishedNEQ(*i.YearEstablishedNEQ))
	}
	if len(i.YearEstablishedIn) > 0 {
		predicates = append(predicates, exchange.YearEstablishedIn(i.YearEstablishedIn...))
	}
	if len(i.YearEstablishedNotIn) > 0 {
		predicates = append(predicates, exchange.YearEstablishedNotIn(i.YearEstablishedNotIn...))
	}
	if i.YearEstablishedGT != nil {
		predicates = append(predicates, exchange.YearEstablishedGT(*i.YearEstablishedGT))
	}
	if i.YearEstablishedGTE != nil {
		predicates = append(predicates, exchange.YearEstablishedGTE(*i.YearEstablishedGTE))
	}
	if i.YearEstablishedLT != nil {
		predicates = append(predicates, exchange.YearEstablishedLT(*i.YearEstablishedLT))
	}
	if i.YearEstablishedLTE != nil {
		predicates = append(predicates, exchange.YearEstablishedLTE(*i.YearEstablishedLTE))
	}
	if i.YearEstablishedIsNil {
		predicates = append(predicates, exchange.YearEstablishedIsNil())
	}
	if i.YearEstablishedNotNil {
		predicates = append(predicates, exchange.YearEstablishedNotNil())
	}
	if i.Country != nil {
		predicates = append(predicates, exchange.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, exchange.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, exchange.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, exchange.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, exchange.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, exchange.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, exchange.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, exchange.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, exchange.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, exchange.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, exchange.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryIsNil {
		predicates = append(predicates, exchange.CountryIsNil())
	}
	if i.CountryNotNil {
		predicates = append(predicates, exchange.CountryNotNil())
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, exchange.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, exchange.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, exchange.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, exchange.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, exchange.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, exchange.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, exchange.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, exchange.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, exchange.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, exchange.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, exchange.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, exchange.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, exchange.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageIsNil {
		predicates = append(predicates, exchange.ImageIsNil())
	}
	if i.ImageNotNil {
		predicates = append(predicates, exchange.ImageNotNil())
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, exchange.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, exchange.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.HasTradingIncentive != nil {
		predicates = append(predicates, exchange.HasTradingIncentiveEQ(*i.HasTradingIncentive))
	}
	if i.HasTradingIncentiveNEQ != nil {
		predicates = append(predicates, exchange.HasTradingIncentiveNEQ(*i.HasTradingIncentiveNEQ))
	}
	if i.HasTradingIncentiveIsNil {
		predicates = append(predicates, exchange.HasTradingIncentiveIsNil())
	}
	if i.HasTradingIncentiveNotNil {
		predicates = append(predicates, exchange.HasTradingIncentiveNotNil())
	}
	if i.Centralized != nil {
		predicates = append(predicates, exchange.CentralizedEQ(*i.Centralized))
	}
	if i.CentralizedNEQ != nil {
		predicates = append(predicates, exchange.CentralizedNEQ(*i.CentralizedNEQ))
	}
	if i.CentralizedIsNil {
		predicates = append(predicates, exchange.CentralizedIsNil())
	}
	if i.CentralizedNotNil {
		predicates = append(predicates, exchange.CentralizedNotNil())
	}
	if i.PublicNotice != nil {
		predicates = append(predicates, exchange.PublicNoticeEQ(*i.PublicNotice))
	}
	if i.PublicNoticeNEQ != nil {
		predicates = append(predicates, exchange.PublicNoticeNEQ(*i.PublicNoticeNEQ))
	}
	if len(i.PublicNoticeIn) > 0 {
		predicates = append(predicates, exchange.PublicNoticeIn(i.PublicNoticeIn...))
	}
	if len(i.PublicNoticeNotIn) > 0 {
		predicates = append(predicates, exchange.PublicNoticeNotIn(i.PublicNoticeNotIn...))
	}
	if i.PublicNoticeGT != nil {
		predicates = append(predicates, exchange.PublicNoticeGT(*i.PublicNoticeGT))
	}
	if i.PublicNoticeGTE != nil {
		predicates = append(predicates, exchange.PublicNoticeGTE(*i.PublicNoticeGTE))
	}
	if i.PublicNoticeLT != nil {
		predicates = append(predicates, exchange.PublicNoticeLT(*i.PublicNoticeLT))
	}
	if i.PublicNoticeLTE != nil {
		predicates = append(predicates, exchange.PublicNoticeLTE(*i.PublicNoticeLTE))
	}
	if i.PublicNoticeContains != nil {
		predicates = append(predicates, exchange.PublicNoticeContains(*i.PublicNoticeContains))
	}
	if i.PublicNoticeHasPrefix != nil {
		predicates = append(predicates, exchange.PublicNoticeHasPrefix(*i.PublicNoticeHasPrefix))
	}
	if i.PublicNoticeHasSuffix != nil {
		predicates = append(predicates, exchange.PublicNoticeHasSuffix(*i.PublicNoticeHasSuffix))
	}
	if i.PublicNoticeIsNil {
		predicates = append(predicates, exchange.PublicNoticeIsNil())
	}
	if i.PublicNoticeNotNil {
		predicates = append(predicates, exchange.PublicNoticeNotNil())
	}
	if i.PublicNoticeEqualFold != nil {
		predicates = append(predicates, exchange.PublicNoticeEqualFold(*i.PublicNoticeEqualFold))
	}
	if i.PublicNoticeContainsFold != nil {
		predicates = append(predicates, exchange.PublicNoticeContainsFold(*i.PublicNoticeContainsFold))
	}
	if i.AlertNotice != nil {
		predicates = append(predicates, exchange.AlertNoticeEQ(*i.AlertNotice))
	}
	if i.AlertNoticeNEQ != nil {
		predicates = append(predicates, exchange.AlertNoticeNEQ(*i.AlertNoticeNEQ))
	}
	if len(i.AlertNoticeIn) > 0 {
		predicates = append(predicates, exchange.AlertNoticeIn(i.AlertNoticeIn...))
	}
	if len(i.AlertNoticeNotIn) > 0 {
		predicates = append(predicates, exchange.AlertNoticeNotIn(i.AlertNoticeNotIn...))
	}
	if i.AlertNoticeGT != nil {
		predicates = append(predicates, exchange.AlertNoticeGT(*i.AlertNoticeGT))
	}
	if i.AlertNoticeGTE != nil {
		predicates = append(predicates, exchange.AlertNoticeGTE(*i.AlertNoticeGTE))
	}
	if i.AlertNoticeLT != nil {
		predicates = append(predicates, exchange.AlertNoticeLT(*i.AlertNoticeLT))
	}
	if i.AlertNoticeLTE != nil {
		predicates = append(predicates, exchange.AlertNoticeLTE(*i.AlertNoticeLTE))
	}
	if i.AlertNoticeContains != nil {
		predicates = append(predicates, exchange.AlertNoticeContains(*i.AlertNoticeContains))
	}
	if i.AlertNoticeHasPrefix != nil {
		predicates = append(predicates, exchange.AlertNoticeHasPrefix(*i.AlertNoticeHasPrefix))
	}
	if i.AlertNoticeHasSuffix != nil {
		predicates = append(predicates, exchange.AlertNoticeHasSuffix(*i.AlertNoticeHasSuffix))
	}
	if i.AlertNoticeIsNil {
		predicates = append(predicates, exchange.AlertNoticeIsNil())
	}
	if i.AlertNoticeNotNil {
		predicates = append(predicates, exchange.AlertNoticeNotNil())
	}
	if i.AlertNoticeEqualFold != nil {
		predicates = append(predicates, exchange.AlertNoticeEqualFold(*i.AlertNoticeEqualFold))
	}
	if i.AlertNoticeContainsFold != nil {
		predicates = append(predicates, exchange.AlertNoticeContainsFold(*i.AlertNoticeContainsFold))
	}
	if i.TrustScore != nil {
		predicates = append(predicates, exchange.TrustScoreEQ(*i.TrustScore))
	}
	if i.TrustScoreNEQ != nil {
		predicates = append(predicates, exchange.TrustScoreNEQ(*i.TrustScoreNEQ))
	}
	if len(i.TrustScoreIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreIn(i.TrustScoreIn...))
	}
	if len(i.TrustScoreNotIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreNotIn(i.TrustScoreNotIn...))
	}
	if i.TrustScoreGT != nil {
		predicates = append(predicates, exchange.TrustScoreGT(*i.TrustScoreGT))
	}
	if i.TrustScoreGTE != nil {
		predicates = append(predicates, exchange.TrustScoreGTE(*i.TrustScoreGTE))
	}
	if i.TrustScoreLT != nil {
		predicates = append(predicates, exchange.TrustScoreLT(*i.TrustScoreLT))
	}
	if i.TrustScoreLTE != nil {
		predicates = append(predicates, exchange.TrustScoreLTE(*i.TrustScoreLTE))
	}
	if i.TrustScoreIsNil {
		predicates = append(predicates, exchange.TrustScoreIsNil())
	}
	if i.TrustScoreNotNil {
		predicates = append(predicates, exchange.TrustScoreNotNil())
	}
	if i.TrustScoreRank != nil {
		predicates = append(predicates, exchange.TrustScoreRankEQ(*i.TrustScoreRank))
	}
	if i.TrustScoreRankNEQ != nil {
		predicates = append(predicates, exchange.TrustScoreRankNEQ(*i.TrustScoreRankNEQ))
	}
	if len(i.TrustScoreRankIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreRankIn(i.TrustScoreRankIn...))
	}
	if len(i.TrustScoreRankNotIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreRankNotIn(i.TrustScoreRankNotIn...))
	}
	if i.TrustScoreRankGT != nil {
		predicates = append(predicates, exchange.TrustScoreRankGT(*i.TrustScoreRankGT))
	}
	if i.TrustScoreRankGTE != nil {
		predicates = append(predicates, exchange.TrustScoreRankGTE(*i.TrustScoreRankGTE))
	}
	if i.TrustScoreRankLT != nil {
		predicates = append(predicates, exchange.TrustScoreRankLT(*i.TrustScoreRankLT))
	}
	if i.TrustScoreRankLTE != nil {
		predicates = append(predicates, exchange.TrustScoreRankLTE(*i.TrustScoreRankLTE))
	}
	if i.TrustScoreRankIsNil {
		predicates = append(predicates, exchange.TrustScoreRankIsNil())
	}
	if i.TrustScoreRankNotNil {
		predicates = append(predicates, exchange.TrustScoreRankNotNil())
	}
	if i.TradeVolume24hBtc != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcEQ(*i.TradeVolume24hBtc))
	}
	if i.TradeVolume24hBtcNEQ != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNEQ(*i.TradeVolume24hBtcNEQ))
	}
	if len(i.TradeVolume24hBtcIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcIn(i.TradeVolume24hBtcIn...))
	}
	if len(i.TradeVolume24hBtcNotIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNotIn(i.TradeVolume24hBtcNotIn...))
	}
	if i.TradeVolume24hBtcGT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcGT(*i.TradeVolume24hBtcGT))
	}
	if i.TradeVolume24hBtcGTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcGTE(*i.TradeVolume24hBtcGTE))
	}
	if i.TradeVolume24hBtcLT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcLT(*i.TradeVolume24hBtcLT))
	}
	if i.TradeVolume24hBtcLTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcLTE(*i.TradeVolume24hBtcLTE))
	}
	if i.TradeVolume24hBtcIsNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcIsNil())
	}
	if i.TradeVolume24hBtcNotNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNotNil())
	}
	if i.TradeVolume24hBtcNormalized != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedEQ(*i.TradeVolume24hBtcNormalized))
	}
	if i.TradeVolume24hBtcNormalizedNEQ != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNEQ(*i.TradeVolume24hBtcNormalizedNEQ))
	}
	if len(i.TradeVolume24hBtcNormalizedIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedIn(i.TradeVolume24hBtcNormalizedIn...))
	}
	if len(i.TradeVolume24hBtcNormalizedNotIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNotIn(i.TradeVolume24hBtcNormalizedNotIn...))
	}
	if i.TradeVolume24hBtcNormalizedGT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedGT(*i.TradeVolume24hBtcNormalizedGT))
	}
	if i.TradeVolume24hBtcNormalizedGTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedGTE(*i.TradeVolume24hBtcNormalizedGTE))
	}
	if i.TradeVolume24hBtcNormalizedLT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedLT(*i.TradeVolume24hBtcNormalizedLT))
	}
	if i.TradeVolume24hBtcNormalizedLTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedLTE(*i.TradeVolume24hBtcNormalizedLTE))
	}
	if i.TradeVolume24hBtcNormalizedIsNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedIsNil())
	}
	if i.TradeVolume24hBtcNormalizedNotNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNotNil())
	}

	if i.HasTicker != nil {
		p := exchange.HasTicker()
		if !*i.HasTicker {
			p = exchange.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTickerWith) > 0 {
		with := make([]predicate.Ticker, 0, len(i.HasTickerWith))
		for _, w := range i.HasTickerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTickerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exchange.HasTickerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExchangeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return exchange.And(predicates...), nil
	}
}

// OutboxWhereInput represents a where input for filtering Outbox queries.
type OutboxWhereInput struct {
	Predicates []predicate.Outbox  `json:"-"`
	Not        *OutboxWhereInput   `json:"not,omitempty"`
	Or         []*OutboxWhereInput `json:"or,omitempty"`
	And        []*OutboxWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "topic" field predicates.
	Topic             *string  `json:"topic,omitempty"`
	TopicNEQ          *string  `json:"topicNEQ,omitempty"`
	TopicIn           []string `json:"topicIn,omitempty"`
	TopicNotIn        []string `json:"topicNotIn,omitempty"`
	TopicGT           *string  `json:"topicGT,omitempty"`
	TopicGTE          *string  `json:"topicGTE,omitempty"`
	TopicLT           *string  `json:"topicLT,omitempty"`
	TopicLTE          *string  `json:"topicLTE,omitempty"`
	TopicContains     *string  `json:"topicContains,omitempty"`
	TopicHasPrefix    *string  `json:"topicHasPrefix,omitempty"`
	TopicHasSuffix    *string  `json:"topicHasSuffix,omitempty"`
	TopicEqualFold    *string  `json:"topicEqualFold,omitempty"`
	TopicContainsFold *string  `json:"topicContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "retry_count" field predicates.
	RetryCount      *int  `json:"retryCount,omitempty"`
	RetryCountNEQ   *int  `json:"retryCountNEQ,omitempty"`
	RetryCountIn    []int `json:"retryCountIn,omitempty"`
	RetryCountNotIn []int `json:"retryCountNotIn,omitempty"`
	RetryCountGT    *int  `json:"retryCountGT,omitempty"`
	RetryCountGTE   *int  `json:"retryCountGTE,omitempty"`
	RetryCountLT    *int  `json:"retryCountLT,omitempty"`
	RetryCountLTE   *int  `json:"retryCountLTE,omitempty"`

	// "status" field predicates.
	Status      *outbox.Status  `json:"status,omitempty"`
	StatusNEQ   *outbox.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []outbox.Status `json:"statusIn,omitempty"`
	StatusNotIn []outbox.Status `json:"statusNotIn,omitempty"`

	// "last_retry" field predicates.
	LastRetry       *time.Time  `json:"lastRetry,omitempty"`
	LastRetryNEQ    *time.Time  `json:"lastRetryNEQ,omitempty"`
	LastRetryIn     []time.Time `json:"lastRetryIn,omitempty"`
	LastRetryNotIn  []time.Time `json:"lastRetryNotIn,omitempty"`
	LastRetryGT     *time.Time  `json:"lastRetryGT,omitempty"`
	LastRetryGTE    *time.Time  `json:"lastRetryGTE,omitempty"`
	LastRetryLT     *time.Time  `json:"lastRetryLT,omitempty"`
	LastRetryLTE    *time.Time  `json:"lastRetryLTE,omitempty"`
	LastRetryIsNil  bool        `json:"lastRetryIsNil,omitempty"`
	LastRetryNotNil bool        `json:"lastRetryNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OutboxWhereInput) AddPredicates(predicates ...predicate.Outbox) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OutboxWhereInput filter on the OutboxQuery builder.
func (i *OutboxWhereInput) Filter(q *OutboxQuery) (*OutboxQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOutboxWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOutboxWhereInput is returned in case the OutboxWhereInput is empty.
var ErrEmptyOutboxWhereInput = errors.New("repositories: empty predicate OutboxWhereInput")

// P returns a predicate for filtering outboxes.
// An error is returned if the input is empty or invalid.
func (i *OutboxWhereInput) P() (predicate.Outbox, error) {
	var predicates []predicate.Outbox
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, outbox.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Outbox, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, outbox.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Outbox, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, outbox.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, outbox.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, outbox.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, outbox.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, outbox.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, outbox.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, outbox.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, outbox.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, outbox.IDLTE(*i.IDLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, outbox.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, outbox.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, outbox.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, outbox.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, outbox.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, outbox.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, outbox.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, outbox.TimestampLTE(*i.TimestampLTE))
	}
	if i.Topic != nil {
		predicates = append(predicates, outbox.TopicEQ(*i.Topic))
	}
	if i.TopicNEQ != nil {
		predicates = append(predicates, outbox.TopicNEQ(*i.TopicNEQ))
	}
	if len(i.TopicIn) > 0 {
		predicates = append(predicates, outbox.TopicIn(i.TopicIn...))
	}
	if len(i.TopicNotIn) > 0 {
		predicates = append(predicates, outbox.TopicNotIn(i.TopicNotIn...))
	}
	if i.TopicGT != nil {
		predicates = append(predicates, outbox.TopicGT(*i.TopicGT))
	}
	if i.TopicGTE != nil {
		predicates = append(predicates, outbox.TopicGTE(*i.TopicGTE))
	}
	if i.TopicLT != nil {
		predicates = append(predicates, outbox.TopicLT(*i.TopicLT))
	}
	if i.TopicLTE != nil {
		predicates = append(predicates, outbox.TopicLTE(*i.TopicLTE))
	}
	if i.TopicContains != nil {
		predicates = append(predicates, outbox.TopicContains(*i.TopicContains))
	}
	if i.TopicHasPrefix != nil {
		predicates = append(predicates, outbox.TopicHasPrefix(*i.TopicHasPrefix))
	}
	if i.TopicHasSuffix != nil {
		predicates = append(predicates, outbox.TopicHasSuffix(*i.TopicHasSuffix))
	}
	if i.TopicEqualFold != nil {
		predicates = append(predicates, outbox.TopicEqualFold(*i.TopicEqualFold))
	}
	if i.TopicContainsFold != nil {
		predicates = append(predicates, outbox.TopicContainsFold(*i.TopicContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, outbox.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, outbox.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, outbox.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, outbox.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, outbox.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, outbox.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, outbox.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, outbox.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, outbox.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, outbox.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, outbox.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, outbox.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, outbox.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.RetryCount != nil {
		predicates = append(predicates, outbox.RetryCountEQ(*i.RetryCount))
	}
	if i.RetryCountNEQ != nil {
		predicates = append(predicates, outbox.RetryCountNEQ(*i.RetryCountNEQ))
	}
	if len(i.RetryCountIn) > 0 {
		predicates = append(predicates, outbox.RetryCountIn(i.RetryCountIn...))
	}
	if len(i.RetryCountNotIn) > 0 {
		predicates = append(predicates, outbox.RetryCountNotIn(i.RetryCountNotIn...))
	}
	if i.RetryCountGT != nil {
		predicates = append(predicates, outbox.RetryCountGT(*i.RetryCountGT))
	}
	if i.RetryCountGTE != nil {
		predicates = append(predicates, outbox.RetryCountGTE(*i.RetryCountGTE))
	}
	if i.RetryCountLT != nil {
		predicates = append(predicates, outbox.RetryCountLT(*i.RetryCountLT))
	}
	if i.RetryCountLTE != nil {
		predicates = append(predicates, outbox.RetryCountLTE(*i.RetryCountLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, outbox.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, outbox.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, outbox.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, outbox.StatusNotIn(i.StatusNotIn...))
	}
	if i.LastRetry != nil {
		predicates = append(predicates, outbox.LastRetryEQ(*i.LastRetry))
	}
	if i.LastRetryNEQ != nil {
		predicates = append(predicates, outbox.LastRetryNEQ(*i.LastRetryNEQ))
	}
	if len(i.LastRetryIn) > 0 {
		predicates = append(predicates, outbox.LastRetryIn(i.LastRetryIn...))
	}
	if len(i.LastRetryNotIn) > 0 {
		predicates = append(predicates, outbox.LastRetryNotIn(i.LastRetryNotIn...))
	}
	if i.LastRetryGT != nil {
		predicates = append(predicates, outbox.LastRetryGT(*i.LastRetryGT))
	}
	if i.LastRetryGTE != nil {
		predicates = append(predicates, outbox.LastRetryGTE(*i.LastRetryGTE))
	}
	if i.LastRetryLT != nil {
		predicates = append(predicates, outbox.LastRetryLT(*i.LastRetryLT))
	}
	if i.LastRetryLTE != nil {
		predicates = append(predicates, outbox.LastRetryLTE(*i.LastRetryLTE))
	}
	if i.LastRetryIsNil {
		predicates = append(predicates, outbox.LastRetryIsNil())
	}
	if i.LastRetryNotNil {
		predicates = append(predicates, outbox.LastRetryNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOutboxWhereInput
	case 1:
		return predicates[0], nil
	default:
		return outbox.And(predicates...), nil
	}
}

// TickerWhereInput represents a where input for filtering Ticker queries.
type TickerWhereInput struct {
	Predicates []predicate.Ticker  `json:"-"`
	Not        *TickerWhereInput   `json:"not,omitempty"`
	Or         []*TickerWhereInput `json:"or,omitempty"`
	And        []*TickerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "base" field predicates.
	Base             *string  `json:"base,omitempty"`
	BaseNEQ          *string  `json:"baseNEQ,omitempty"`
	BaseIn           []string `json:"baseIn,omitempty"`
	BaseNotIn        []string `json:"baseNotIn,omitempty"`
	BaseGT           *string  `json:"baseGT,omitempty"`
	BaseGTE          *string  `json:"baseGTE,omitempty"`
	BaseLT           *string  `json:"baseLT,omitempty"`
	BaseLTE          *string  `json:"baseLTE,omitempty"`
	BaseContains     *string  `json:"baseContains,omitempty"`
	BaseHasPrefix    *string  `json:"baseHasPrefix,omitempty"`
	BaseHasSuffix    *string  `json:"baseHasSuffix,omitempty"`
	BaseEqualFold    *string  `json:"baseEqualFold,omitempty"`
	BaseContainsFold *string  `json:"baseContainsFold,omitempty"`

	// "target" field predicates.
	Target             *string  `json:"target,omitempty"`
	TargetNEQ          *string  `json:"targetNEQ,omitempty"`
	TargetIn           []string `json:"targetIn,omitempty"`
	TargetNotIn        []string `json:"targetNotIn,omitempty"`
	TargetGT           *string  `json:"targetGT,omitempty"`
	TargetGTE          *string  `json:"targetGTE,omitempty"`
	TargetLT           *string  `json:"targetLT,omitempty"`
	TargetLTE          *string  `json:"targetLTE,omitempty"`
	TargetContains     *string  `json:"targetContains,omitempty"`
	TargetHasPrefix    *string  `json:"targetHasPrefix,omitempty"`
	TargetHasSuffix    *string  `json:"targetHasSuffix,omitempty"`
	TargetEqualFold    *string  `json:"targetEqualFold,omitempty"`
	TargetContainsFold *string  `json:"targetContainsFold,omitempty"`

	// "last" field predicates.
	Last      *float64  `json:"last,omitempty"`
	LastNEQ   *float64  `json:"lastNEQ,omitempty"`
	LastIn    []float64 `json:"lastIn,omitempty"`
	LastNotIn []float64 `json:"lastNotIn,omitempty"`
	LastGT    *float64  `json:"lastGT,omitempty"`
	LastGTE   *float64  `json:"lastGTE,omitempty"`
	LastLT    *float64  `json:"lastLT,omitempty"`
	LastLTE   *float64  `json:"lastLTE,omitempty"`

	// "volume" field predicates.
	Volume      *float64  `json:"volume,omitempty"`
	VolumeNEQ   *float64  `json:"volumeNEQ,omitempty"`
	VolumeIn    []float64 `json:"volumeIn,omitempty"`
	VolumeNotIn []float64 `json:"volumeNotIn,omitempty"`
	VolumeGT    *float64  `json:"volumeGT,omitempty"`
	VolumeGTE   *float64  `json:"volumeGTE,omitempty"`
	VolumeLT    *float64  `json:"volumeLT,omitempty"`
	VolumeLTE   *float64  `json:"volumeLTE,omitempty"`

	// "trust_score" field predicates.
	TrustScore             *string  `json:"trustScore,omitempty"`
	TrustScoreNEQ          *string  `json:"trustScoreNEQ,omitempty"`
	TrustScoreIn           []string `json:"trustScoreIn,omitempty"`
	TrustScoreNotIn        []string `json:"trustScoreNotIn,omitempty"`
	TrustScoreGT           *string  `json:"trustScoreGT,omitempty"`
	TrustScoreGTE          *string  `json:"trustScoreGTE,omitempty"`
	TrustScoreLT           *string  `json:"trustScoreLT,omitempty"`
	TrustScoreLTE          *string  `json:"trustScoreLTE,omitempty"`
	TrustScoreContains     *string  `json:"trustScoreContains,omitempty"`
	TrustScoreHasPrefix    *string  `json:"trustScoreHasPrefix,omitempty"`
	TrustScoreHasSuffix    *string  `json:"trustScoreHasSuffix,omitempty"`
	TrustScoreEqualFold    *string  `json:"trustScoreEqualFold,omitempty"`
	TrustScoreContainsFold *string  `json:"trustScoreContainsFold,omitempty"`

	// "bid_ask_spread_percentage" field predicates.
	BidAskSpreadPercentage      *float64  `json:"bidAskSpreadPercentage,omitempty"`
	BidAskSpreadPercentageNEQ   *float64  `json:"bidAskSpreadPercentageNEQ,omitempty"`
	BidAskSpreadPercentageIn    []float64 `json:"bidAskSpreadPercentageIn,omitempty"`
	BidAskSpreadPercentageNotIn []float64 `json:"bidAskSpreadPercentageNotIn,omitempty"`
	BidAskSpreadPercentageGT    *float64  `json:"bidAskSpreadPercentageGT,omitempty"`
	BidAskSpreadPercentageGTE   *float64  `json:"bidAskSpreadPercentageGTE,omitempty"`
	BidAskSpreadPercentageLT    *float64  `json:"bidAskSpreadPercentageLT,omitempty"`
	BidAskSpreadPercentageLTE   *float64  `json:"bidAskSpreadPercentageLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "last_traded_at" field predicates.
	LastTradedAt      *time.Time  `json:"lastTradedAt,omitempty"`
	LastTradedAtNEQ   *time.Time  `json:"lastTradedAtNEQ,omitempty"`
	LastTradedAtIn    []time.Time `json:"lastTradedAtIn,omitempty"`
	LastTradedAtNotIn []time.Time `json:"lastTradedAtNotIn,omitempty"`
	LastTradedAtGT    *time.Time  `json:"lastTradedAtGT,omitempty"`
	LastTradedAtGTE   *time.Time  `json:"lastTradedAtGTE,omitempty"`
	LastTradedAtLT    *time.Time  `json:"lastTradedAtLT,omitempty"`
	LastTradedAtLTE   *time.Time  `json:"lastTradedAtLTE,omitempty"`

	// "last_fetch_at" field predicates.
	LastFetchAt      *time.Time  `json:"lastFetchAt,omitempty"`
	LastFetchAtNEQ   *time.Time  `json:"lastFetchAtNEQ,omitempty"`
	LastFetchAtIn    []time.Time `json:"lastFetchAtIn,omitempty"`
	LastFetchAtNotIn []time.Time `json:"lastFetchAtNotIn,omitempty"`
	LastFetchAtGT    *time.Time  `json:"lastFetchAtGT,omitempty"`
	LastFetchAtGTE   *time.Time  `json:"lastFetchAtGTE,omitempty"`
	LastFetchAtLT    *time.Time  `json:"lastFetchAtLT,omitempty"`
	LastFetchAtLTE   *time.Time  `json:"lastFetchAtLTE,omitempty"`

	// "is_anomaly" field predicates.
	IsAnomaly    *bool `json:"isAnomaly,omitempty"`
	IsAnomalyNEQ *bool `json:"isAnomalyNEQ,omitempty"`

	// "is_stale" field predicates.
	IsStale    *bool `json:"isStale,omitempty"`
	IsStaleNEQ *bool `json:"isStaleNEQ,omitempty"`

	// "trade_url" field predicates.
	TradeURL             *string  `json:"tradeURL,omitempty"`
	TradeURLNEQ          *string  `json:"tradeURLNEQ,omitempty"`
	TradeURLIn           []string `json:"tradeURLIn,omitempty"`
	TradeURLNotIn        []string `json:"tradeURLNotIn,omitempty"`
	TradeURLGT           *string  `json:"tradeURLGT,omitempty"`
	TradeURLGTE          *string  `json:"tradeURLGTE,omitempty"`
	TradeURLLT           *string  `json:"tradeURLLT,omitempty"`
	TradeURLLTE          *string  `json:"tradeURLLTE,omitempty"`
	TradeURLContains     *string  `json:"tradeURLContains,omitempty"`
	TradeURLHasPrefix    *string  `json:"tradeURLHasPrefix,omitempty"`
	TradeURLHasSuffix    *string  `json:"tradeURLHasSuffix,omitempty"`
	TradeURLIsNil        bool     `json:"tradeURLIsNil,omitempty"`
	TradeURLNotNil       bool     `json:"tradeURLNotNil,omitempty"`
	TradeURLEqualFold    *string  `json:"tradeURLEqualFold,omitempty"`
	TradeURLContainsFold *string  `json:"tradeURLContainsFold,omitempty"`

	// "token_info_url" field predicates.
	TokenInfoURL             *string  `json:"tokenInfoURL,omitempty"`
	TokenInfoURLNEQ          *string  `json:"tokenInfoURLNEQ,omitempty"`
	TokenInfoURLIn           []string `json:"tokenInfoURLIn,omitempty"`
	TokenInfoURLNotIn        []string `json:"tokenInfoURLNotIn,omitempty"`
	TokenInfoURLGT           *string  `json:"tokenInfoURLGT,omitempty"`
	TokenInfoURLGTE          *string  `json:"tokenInfoURLGTE,omitempty"`
	TokenInfoURLLT           *string  `json:"tokenInfoURLLT,omitempty"`
	TokenInfoURLLTE          *string  `json:"tokenInfoURLLTE,omitempty"`
	TokenInfoURLContains     *string  `json:"tokenInfoURLContains,omitempty"`
	TokenInfoURLHasPrefix    *string  `json:"tokenInfoURLHasPrefix,omitempty"`
	TokenInfoURLHasSuffix    *string  `json:"tokenInfoURLHasSuffix,omitempty"`
	TokenInfoURLIsNil        bool     `json:"tokenInfoURLIsNil,omitempty"`
	TokenInfoURLNotNil       bool     `json:"tokenInfoURLNotNil,omitempty"`
	TokenInfoURLEqualFold    *string  `json:"tokenInfoURLEqualFold,omitempty"`
	TokenInfoURLContainsFold *string  `json:"tokenInfoURLContainsFold,omitempty"`

	// "coin_id" field predicates.
	CoinID             *string  `json:"coinID,omitempty"`
	CoinIDNEQ          *string  `json:"coinIDNEQ,omitempty"`
	CoinIDIn           []string `json:"coinIDIn,omitempty"`
	CoinIDNotIn        []string `json:"coinIDNotIn,omitempty"`
	CoinIDGT           *string  `json:"coinIDGT,omitempty"`
	CoinIDGTE          *string  `json:"coinIDGTE,omitempty"`
	CoinIDLT           *string  `json:"coinIDLT,omitempty"`
	CoinIDLTE          *string  `json:"coinIDLTE,omitempty"`
	CoinIDContains     *string  `json:"coinIDContains,omitempty"`
	CoinIDHasPrefix    *string  `json:"coinIDHasPrefix,omitempty"`
	CoinIDHasSuffix    *string  `json:"coinIDHasSuffix,omitempty"`
	CoinIDEqualFold    *string  `json:"coinIDEqualFold,omitempty"`
	CoinIDContainsFold *string  `json:"coinIDContainsFold,omitempty"`

	// "target_coin_id" field predicates.
	TargetCoinID             *string  `json:"targetCoinID,omitempty"`
	TargetCoinIDNEQ          *string  `json:"targetCoinIDNEQ,omitempty"`
	TargetCoinIDIn           []string `json:"targetCoinIDIn,omitempty"`
	TargetCoinIDNotIn        []string `json:"targetCoinIDNotIn,omitempty"`
	TargetCoinIDGT           *string  `json:"targetCoinIDGT,omitempty"`
	TargetCoinIDGTE          *string  `json:"targetCoinIDGTE,omitempty"`
	TargetCoinIDLT           *string  `json:"targetCoinIDLT,omitempty"`
	TargetCoinIDLTE          *string  `json:"targetCoinIDLTE,omitempty"`
	TargetCoinIDContains     *string  `json:"targetCoinIDContains,omitempty"`
	TargetCoinIDHasPrefix    *string  `json:"targetCoinIDHasPrefix,omitempty"`
	TargetCoinIDHasSuffix    *string  `json:"targetCoinIDHasSuffix,omitempty"`
	TargetCoinIDEqualFold    *string  `json:"targetCoinIDEqualFold,omitempty"`
	TargetCoinIDContainsFold *string  `json:"targetCoinIDContainsFold,omitempty"`

	// "exchange" edge predicates.
	HasExchange     *bool                 `json:"hasExchange,omitempty"`
	HasExchangeWith []*ExchangeWhereInput `json:"hasExchangeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TickerWhereInput) AddPredicates(predicates ...predicate.Ticker) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TickerWhereInput filter on the TickerQuery builder.
func (i *TickerWhereInput) Filter(q *TickerQuery) (*TickerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTickerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTickerWhereInput is returned in case the TickerWhereInput is empty.
var ErrEmptyTickerWhereInput = errors.New("repositories: empty predicate TickerWhereInput")

// P returns a predicate for filtering tickers.
// An error is returned if the input is empty or invalid.
func (i *TickerWhereInput) P() (predicate.Ticker, error) {
	var predicates []predicate.Ticker
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, ticker.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Ticker, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, ticker.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Ticker, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, ticker.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, ticker.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, ticker.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, ticker.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, ticker.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, ticker.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, ticker.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, ticker.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, ticker.IDLTE(*i.IDLTE))
	}
	if i.Base != nil {
		predicates = append(predicates, ticker.BaseEQ(*i.Base))
	}
	if i.BaseNEQ != nil {
		predicates = append(predicates, ticker.BaseNEQ(*i.BaseNEQ))
	}
	if len(i.BaseIn) > 0 {
		predicates = append(predicates, ticker.BaseIn(i.BaseIn...))
	}
	if len(i.BaseNotIn) > 0 {
		predicates = append(predicates, ticker.BaseNotIn(i.BaseNotIn...))
	}
	if i.BaseGT != nil {
		predicates = append(predicates, ticker.BaseGT(*i.BaseGT))
	}
	if i.BaseGTE != nil {
		predicates = append(predicates, ticker.BaseGTE(*i.BaseGTE))
	}
	if i.BaseLT != nil {
		predicates = append(predicates, ticker.BaseLT(*i.BaseLT))
	}
	if i.BaseLTE != nil {
		predicates = append(predicates, ticker.BaseLTE(*i.BaseLTE))
	}
	if i.BaseContains != nil {
		predicates = append(predicates, ticker.BaseContains(*i.BaseContains))
	}
	if i.BaseHasPrefix != nil {
		predicates = append(predicates, ticker.BaseHasPrefix(*i.BaseHasPrefix))
	}
	if i.BaseHasSuffix != nil {
		predicates = append(predicates, ticker.BaseHasSuffix(*i.BaseHasSuffix))
	}
	if i.BaseEqualFold != nil {
		predicates = append(predicates, ticker.BaseEqualFold(*i.BaseEqualFold))
	}
	if i.BaseContainsFold != nil {
		predicates = append(predicates, ticker.BaseContainsFold(*i.BaseContainsFold))
	}
	if i.Target != nil {
		predicates = append(predicates, ticker.TargetEQ(*i.Target))
	}
	if i.TargetNEQ != nil {
		predicates = append(predicates, ticker.TargetNEQ(*i.TargetNEQ))
	}
	if len(i.TargetIn) > 0 {
		predicates = append(predicates, ticker.TargetIn(i.TargetIn...))
	}
	if len(i.TargetNotIn) > 0 {
		predicates = append(predicates, ticker.TargetNotIn(i.TargetNotIn...))
	}
	if i.TargetGT != nil {
		predicates = append(predicates, ticker.TargetGT(*i.TargetGT))
	}
	if i.TargetGTE != nil {
		predicates = append(predicates, ticker.TargetGTE(*i.TargetGTE))
	}
	if i.TargetLT != nil {
		predicates = append(predicates, ticker.TargetLT(*i.TargetLT))
	}
	if i.TargetLTE != nil {
		predicates = append(predicates, ticker.TargetLTE(*i.TargetLTE))
	}
	if i.TargetContains != nil {
		predicates = append(predicates, ticker.TargetContains(*i.TargetContains))
	}
	if i.TargetHasPrefix != nil {
		predicates = append(predicates, ticker.TargetHasPrefix(*i.TargetHasPrefix))
	}
	if i.TargetHasSuffix != nil {
		predicates = append(predicates, ticker.TargetHasSuffix(*i.TargetHasSuffix))
	}
	if i.TargetEqualFold != nil {
		predicates = append(predicates, ticker.TargetEqualFold(*i.TargetEqualFold))
	}
	if i.TargetContainsFold != nil {
		predicates = append(predicates, ticker.TargetContainsFold(*i.TargetContainsFold))
	}
	if i.Last != nil {
		predicates = append(predicates, ticker.LastEQ(*i.Last))
	}
	if i.LastNEQ != nil {
		predicates = append(predicates, ticker.LastNEQ(*i.LastNEQ))
	}
	if len(i.LastIn) > 0 {
		predicates = append(predicates, ticker.LastIn(i.LastIn...))
	}
	if len(i.LastNotIn) > 0 {
		predicates = append(predicates, ticker.LastNotIn(i.LastNotIn...))
	}
	if i.LastGT != nil {
		predicates = append(predicates, ticker.LastGT(*i.LastGT))
	}
	if i.LastGTE != nil {
		predicates = append(predicates, ticker.LastGTE(*i.LastGTE))
	}
	if i.LastLT != nil {
		predicates = append(predicates, ticker.LastLT(*i.LastLT))
	}
	if i.LastLTE != nil {
		predicates = append(predicates, ticker.LastLTE(*i.LastLTE))
	}
	if i.Volume != nil {
		predicates = append(predicates, ticker.VolumeEQ(*i.Volume))
	}
	if i.VolumeNEQ != nil {
		predicates = append(predicates, ticker.VolumeNEQ(*i.VolumeNEQ))
	}
	if len(i.VolumeIn) > 0 {
		predicates = append(predicates, ticker.VolumeIn(i.VolumeIn...))
	}
	if len(i.VolumeNotIn) > 0 {
		predicates = append(predicates, ticker.VolumeNotIn(i.VolumeNotIn...))
	}
	if i.VolumeGT != nil {
		predicates = append(predicates, ticker.VolumeGT(*i.VolumeGT))
	}
	if i.VolumeGTE != nil {
		predicates = append(predicates, ticker.VolumeGTE(*i.VolumeGTE))
	}
	if i.VolumeLT != nil {
		predicates = append(predicates, ticker.VolumeLT(*i.VolumeLT))
	}
	if i.VolumeLTE != nil {
		predicates = append(predicates, ticker.VolumeLTE(*i.VolumeLTE))
	}
	if i.TrustScore != nil {
		predicates = append(predicates, ticker.TrustScoreEQ(*i.TrustScore))
	}
	if i.TrustScoreNEQ != nil {
		predicates = append(predicates, ticker.TrustScoreNEQ(*i.TrustScoreNEQ))
	}
	if len(i.TrustScoreIn) > 0 {
		predicates = append(predicates, ticker.TrustScoreIn(i.TrustScoreIn...))
	}
	if len(i.TrustScoreNotIn) > 0 {
		predicates = append(predicates, ticker.TrustScoreNotIn(i.TrustScoreNotIn...))
	}
	if i.TrustScoreGT != nil {
		predicates = append(predicates, ticker.TrustScoreGT(*i.TrustScoreGT))
	}
	if i.TrustScoreGTE != nil {
		predicates = append(predicates, ticker.TrustScoreGTE(*i.TrustScoreGTE))
	}
	if i.TrustScoreLT != nil {
		predicates = append(predicates, ticker.TrustScoreLT(*i.TrustScoreLT))
	}
	if i.TrustScoreLTE != nil {
		predicates = append(predicates, ticker.TrustScoreLTE(*i.TrustScoreLTE))
	}
	if i.TrustScoreContains != nil {
		predicates = append(predicates, ticker.TrustScoreContains(*i.TrustScoreContains))
	}
	if i.TrustScoreHasPrefix != nil {
		predicates = append(predicates, ticker.TrustScoreHasPrefix(*i.TrustScoreHasPrefix))
	}
	if i.TrustScoreHasSuffix != nil {
		predicates = append(predicates, ticker.TrustScoreHasSuffix(*i.TrustScoreHasSuffix))
	}
	if i.TrustScoreEqualFold != nil {
		predicates = append(predicates, ticker.TrustScoreEqualFold(*i.TrustScoreEqualFold))
	}
	if i.TrustScoreContainsFold != nil {
		predicates = append(predicates, ticker.TrustScoreContainsFold(*i.TrustScoreContainsFold))
	}
	if i.BidAskSpreadPercentage != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageEQ(*i.BidAskSpreadPercentage))
	}
	if i.BidAskSpreadPercentageNEQ != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageNEQ(*i.BidAskSpreadPercentageNEQ))
	}
	if len(i.BidAskSpreadPercentageIn) > 0 {
		predicates = append(predicates, ticker.BidAskSpreadPercentageIn(i.BidAskSpreadPercentageIn...))
	}
	if len(i.BidAskSpreadPercentageNotIn) > 0 {
		predicates = append(predicates, ticker.BidAskSpreadPercentageNotIn(i.BidAskSpreadPercentageNotIn...))
	}
	if i.BidAskSpreadPercentageGT != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageGT(*i.BidAskSpreadPercentageGT))
	}
	if i.BidAskSpreadPercentageGTE != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageGTE(*i.BidAskSpreadPercentageGTE))
	}
	if i.BidAskSpreadPercentageLT != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageLT(*i.BidAskSpreadPercentageLT))
	}
	if i.BidAskSpreadPercentageLTE != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageLTE(*i.BidAskSpreadPercentageLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, ticker.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, ticker.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, ticker.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, ticker.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, ticker.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, ticker.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, ticker.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, ticker.TimestampLTE(*i.TimestampLTE))
	}
	if i.LastTradedAt != nil {
		predicates = append(predicates, ticker.LastTradedAtEQ(*i.LastTradedAt))
	}
	if i.LastTradedAtNEQ != nil {
		predicates = append(predicates, ticker.LastTradedAtNEQ(*i.LastTradedAtNEQ))
	}
	if len(i.LastTradedAtIn) > 0 {
		predicates = append(predicates, ticker.LastTradedAtIn(i.LastTradedAtIn...))
	}
	if len(i.LastTradedAtNotIn) > 0 {
		predicates = append(predicates, ticker.LastTradedAtNotIn(i.LastTradedAtNotIn...))
	}
	if i.LastTradedAtGT != nil {
		predicates = append(predicates, ticker.LastTradedAtGT(*i.LastTradedAtGT))
	}
	if i.LastTradedAtGTE != nil {
		predicates = append(predicates, ticker.LastTradedAtGTE(*i.LastTradedAtGTE))
	}
	if i.LastTradedAtLT != nil {
		predicates = append(predicates, ticker.LastTradedAtLT(*i.LastTradedAtLT))
	}
	if i.LastTradedAtLTE != nil {
		predicates = append(predicates, ticker.LastTradedAtLTE(*i.LastTradedAtLTE))
	}
	if i.LastFetchAt != nil {
		predicates = append(predicates, ticker.LastFetchAtEQ(*i.LastFetchAt))
	}
	if i.LastFetchAtNEQ != nil {
		predicates = append(predicates, ticker.LastFetchAtNEQ(*i.LastFetchAtNEQ))
	}
	if len(i.LastFetchAtIn) > 0 {
		predicates = append(predicates, ticker.LastFetchAtIn(i.LastFetchAtIn...))
	}
	if len(i.LastFetchAtNotIn) > 0 {
		predicates = append(predicates, ticker.LastFetchAtNotIn(i.LastFetchAtNotIn...))
	}
	if i.LastFetchAtGT != nil {
		predicates = append(predicates, ticker.LastFetchAtGT(*i.LastFetchAtGT))
	}
	if i.LastFetchAtGTE != nil {
		predicates = append(predicates, ticker.LastFetchAtGTE(*i.LastFetchAtGTE))
	}
	if i.LastFetchAtLT != nil {
		predicates = append(predicates, ticker.LastFetchAtLT(*i.LastFetchAtLT))
	}
	if i.LastFetchAtLTE != nil {
		predicates = append(predicates, ticker.LastFetchAtLTE(*i.LastFetchAtLTE))
	}
	if i.IsAnomaly != nil {
		predicates = append(predicates, ticker.IsAnomalyEQ(*i.IsAnomaly))
	}
	if i.IsAnomalyNEQ != nil {
		predicates = append(predicates, ticker.IsAnomalyNEQ(*i.IsAnomalyNEQ))
	}
	if i.IsStale != nil {
		predicates = append(predicates, ticker.IsStaleEQ(*i.IsStale))
	}
	if i.IsStaleNEQ != nil {
		predicates = append(predicates, ticker.IsStaleNEQ(*i.IsStaleNEQ))
	}
	if i.TradeURL != nil {
		predicates = append(predicates, ticker.TradeURLEQ(*i.TradeURL))
	}
	if i.TradeURLNEQ != nil {
		predicates = append(predicates, ticker.TradeURLNEQ(*i.TradeURLNEQ))
	}
	if len(i.TradeURLIn) > 0 {
		predicates = append(predicates, ticker.TradeURLIn(i.TradeURLIn...))
	}
	if len(i.TradeURLNotIn) > 0 {
		predicates = append(predicates, ticker.TradeURLNotIn(i.TradeURLNotIn...))
	}
	if i.TradeURLGT != nil {
		predicates = append(predicates, ticker.TradeURLGT(*i.TradeURLGT))
	}
	if i.TradeURLGTE != nil {
		predicates = append(predicates, ticker.TradeURLGTE(*i.TradeURLGTE))
	}
	if i.TradeURLLT != nil {
		predicates = append(predicates, ticker.TradeURLLT(*i.TradeURLLT))
	}
	if i.TradeURLLTE != nil {
		predicates = append(predicates, ticker.TradeURLLTE(*i.TradeURLLTE))
	}
	if i.TradeURLContains != nil {
		predicates = append(predicates, ticker.TradeURLContains(*i.TradeURLContains))
	}
	if i.TradeURLHasPrefix != nil {
		predicates = append(predicates, ticker.TradeURLHasPrefix(*i.TradeURLHasPrefix))
	}
	if i.TradeURLHasSuffix != nil {
		predicates = append(predicates, ticker.TradeURLHasSuffix(*i.TradeURLHasSuffix))
	}
	if i.TradeURLIsNil {
		predicates = append(predicates, ticker.TradeURLIsNil())
	}
	if i.TradeURLNotNil {
		predicates = append(predicates, ticker.TradeURLNotNil())
	}
	if i.TradeURLEqualFold != nil {
		predicates = append(predicates, ticker.TradeURLEqualFold(*i.TradeURLEqualFold))
	}
	if i.TradeURLContainsFold != nil {
		predicates = append(predicates, ticker.TradeURLContainsFold(*i.TradeURLContainsFold))
	}
	if i.TokenInfoURL != nil {
		predicates = append(predicates, ticker.TokenInfoURLEQ(*i.TokenInfoURL))
	}
	if i.TokenInfoURLNEQ != nil {
		predicates = append(predicates, ticker.TokenInfoURLNEQ(*i.TokenInfoURLNEQ))
	}
	if len(i.TokenInfoURLIn) > 0 {
		predicates = append(predicates, ticker.TokenInfoURLIn(i.TokenInfoURLIn...))
	}
	if len(i.TokenInfoURLNotIn) > 0 {
		predicates = append(predicates, ticker.TokenInfoURLNotIn(i.TokenInfoURLNotIn...))
	}
	if i.TokenInfoURLGT != nil {
		predicates = append(predicates, ticker.TokenInfoURLGT(*i.TokenInfoURLGT))
	}
	if i.TokenInfoURLGTE != nil {
		predicates = append(predicates, ticker.TokenInfoURLGTE(*i.TokenInfoURLGTE))
	}
	if i.TokenInfoURLLT != nil {
		predicates = append(predicates, ticker.TokenInfoURLLT(*i.TokenInfoURLLT))
	}
	if i.TokenInfoURLLTE != nil {
		predicates = append(predicates, ticker.TokenInfoURLLTE(*i.TokenInfoURLLTE))
	}
	if i.TokenInfoURLContains != nil {
		predicates = append(predicates, ticker.TokenInfoURLContains(*i.TokenInfoURLContains))
	}
	if i.TokenInfoURLHasPrefix != nil {
		predicates = append(predicates, ticker.TokenInfoURLHasPrefix(*i.TokenInfoURLHasPrefix))
	}
	if i.TokenInfoURLHasSuffix != nil {
		predicates = append(predicates, ticker.TokenInfoURLHasSuffix(*i.TokenInfoURLHasSuffix))
	}
	if i.TokenInfoURLIsNil {
		predicates = append(predicates, ticker.TokenInfoURLIsNil())
	}
	if i.TokenInfoURLNotNil {
		predicates = append(predicates, ticker.TokenInfoURLNotNil())
	}
	if i.TokenInfoURLEqualFold != nil {
		predicates = append(predicates, ticker.TokenInfoURLEqualFold(*i.TokenInfoURLEqualFold))
	}
	if i.TokenInfoURLContainsFold != nil {
		predicates = append(predicates, ticker.TokenInfoURLContainsFold(*i.TokenInfoURLContainsFold))
	}
	if i.CoinID != nil {
		predicates = append(predicates, ticker.CoinIDEQ(*i.CoinID))
	}
	if i.CoinIDNEQ != nil {
		predicates = append(predicates, ticker.CoinIDNEQ(*i.CoinIDNEQ))
	}
	if len(i.CoinIDIn) > 0 {
		predicates = append(predicates, ticker.CoinIDIn(i.CoinIDIn...))
	}
	if len(i.CoinIDNotIn) > 0 {
		predicates = append(predicates, ticker.CoinIDNotIn(i.CoinIDNotIn...))
	}
	if i.CoinIDGT != nil {
		predicates = append(predicates, ticker.CoinIDGT(*i.CoinIDGT))
	}
	if i.CoinIDGTE != nil {
		predicates = append(predicates, ticker.CoinIDGTE(*i.CoinIDGTE))
	}
	if i.CoinIDLT != nil {
		predicates = append(predicates, ticker.CoinIDLT(*i.CoinIDLT))
	}
	if i.CoinIDLTE != nil {
		predicates = append(predicates, ticker.CoinIDLTE(*i.CoinIDLTE))
	}
	if i.CoinIDContains != nil {
		predicates = append(predicates, ticker.CoinIDContains(*i.CoinIDContains))
	}
	if i.CoinIDHasPrefix != nil {
		predicates = append(predicates, ticker.CoinIDHasPrefix(*i.CoinIDHasPrefix))
	}
	if i.CoinIDHasSuffix != nil {
		predicates = append(predicates, ticker.CoinIDHasSuffix(*i.CoinIDHasSuffix))
	}
	if i.CoinIDEqualFold != nil {
		predicates = append(predicates, ticker.CoinIDEqualFold(*i.CoinIDEqualFold))
	}
	if i.CoinIDContainsFold != nil {
		predicates = append(predicates, ticker.CoinIDContainsFold(*i.CoinIDContainsFold))
	}
	if i.TargetCoinID != nil {
		predicates = append(predicates, ticker.TargetCoinIDEQ(*i.TargetCoinID))
	}
	if i.TargetCoinIDNEQ != nil {
		predicates = append(predicates, ticker.TargetCoinIDNEQ(*i.TargetCoinIDNEQ))
	}
	if len(i.TargetCoinIDIn) > 0 {
		predicates = append(predicates, ticker.TargetCoinIDIn(i.TargetCoinIDIn...))
	}
	if len(i.TargetCoinIDNotIn) > 0 {
		predicates = append(predicates, ticker.TargetCoinIDNotIn(i.TargetCoinIDNotIn...))
	}
	if i.TargetCoinIDGT != nil {
		predicates = append(predicates, ticker.TargetCoinIDGT(*i.TargetCoinIDGT))
	}
	if i.TargetCoinIDGTE != nil {
		predicates = append(predicates, ticker.TargetCoinIDGTE(*i.TargetCoinIDGTE))
	}
	if i.TargetCoinIDLT != nil {
		predicates = append(predicates, ticker.TargetCoinIDLT(*i.TargetCoinIDLT))
	}
	if i.TargetCoinIDLTE != nil {
		predicates = append(predicates, ticker.TargetCoinIDLTE(*i.TargetCoinIDLTE))
	}
	if i.TargetCoinIDContains != nil {
		predicates = append(predicates, ticker.TargetCoinIDContains(*i.TargetCoinIDContains))
	}
	if i.TargetCoinIDHasPrefix != nil {
		predicates = append(predicates, ticker.TargetCoinIDHasPrefix(*i.TargetCoinIDHasPrefix))
	}
	if i.TargetCoinIDHasSuffix != nil {
		predicates = append(predicates, ticker.TargetCoinIDHasSuffix(*i.TargetCoinIDHasSuffix))
	}
	if i.TargetCoinIDEqualFold != nil {
		predicates = append(predicates, ticker.TargetCoinIDEqualFold(*i.TargetCoinIDEqualFold))
	}
	if i.TargetCoinIDContainsFold != nil {
		predicates = append(predicates, ticker.TargetCoinIDContainsFold(*i.TargetCoinIDContainsFold))
	}

	if i.HasExchange != nil {
		p := ticker.HasExchange()
		if !*i.HasExchange {
			p = ticker.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExchangeWith) > 0 {
		with := make([]predicate.Exchange, 0, len(i.HasExchangeWith))
		for _, w := range i.HasExchangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExchangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, ticker.HasExchangeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTickerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return ticker.And(predicates...), nil
	}
}
