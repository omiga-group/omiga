// Package pulsaradminv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package pulsaradminv2

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for AutoFailoverPolicyDataPolicyType.
const (
	MinAvailable AutoFailoverPolicyDataPolicyType = "min_available"
)

// Defines values for BacklogQuotaPolicy.
const (
	ConsumerBacklogEviction BacklogQuotaPolicy = "consumer_backlog_eviction"
	ProducerException       BacklogQuotaPolicy = "producer_exception"
	ProducerRequestHold     BacklogQuotaPolicy = "producer_request_hold"
)

// Defines values for ClusterDataProxyProtocol.
const (
	SNI ClusterDataProxyProtocol = "SNI"
)

// Defines values for GetSchemaResponseType.
const (
	AUTO           GetSchemaResponseType = "AUTO"
	AUTOCONSUME    GetSchemaResponseType = "AUTO_CONSUME"
	AUTOPUBLISH    GetSchemaResponseType = "AUTO_PUBLISH"
	AVRO           GetSchemaResponseType = "AVRO"
	BOOLEAN        GetSchemaResponseType = "BOOLEAN"
	BYTES          GetSchemaResponseType = "BYTES"
	DATE           GetSchemaResponseType = "DATE"
	DOUBLE         GetSchemaResponseType = "DOUBLE"
	FLOAT          GetSchemaResponseType = "FLOAT"
	INSTANT        GetSchemaResponseType = "INSTANT"
	INT16          GetSchemaResponseType = "INT16"
	INT32          GetSchemaResponseType = "INT32"
	INT64          GetSchemaResponseType = "INT64"
	INT8           GetSchemaResponseType = "INT8"
	JSON           GetSchemaResponseType = "JSON"
	KEYVALUE       GetSchemaResponseType = "KEY_VALUE"
	LOCALDATE      GetSchemaResponseType = "LOCAL_DATE"
	LOCALDATETIME  GetSchemaResponseType = "LOCAL_DATE_TIME"
	LOCALTIME      GetSchemaResponseType = "LOCAL_TIME"
	NONE           GetSchemaResponseType = "NONE"
	PROTOBUF       GetSchemaResponseType = "PROTOBUF"
	PROTOBUFNATIVE GetSchemaResponseType = "PROTOBUF_NATIVE"
	STRING         GetSchemaResponseType = "STRING"
	TIME           GetSchemaResponseType = "TIME"
	TIMESTAMP      GetSchemaResponseType = "TIMESTAMP"
)

// Defines values for InactiveTopicPoliciesInactiveTopicDeleteMode.
const (
	DeleteWhenNoSubscriptions       InactiveTopicPoliciesInactiveTopicDeleteMode = "delete_when_no_subscriptions"
	DeleteWhenSubscriptionsCaughtUp InactiveTopicPoliciesInactiveTopicDeleteMode = "delete_when_subscriptions_caught_up"
)

// Defines values for LongRunningProcessStatusStatus.
const (
	ERROR   LongRunningProcessStatusStatus = "ERROR"
	NOTRUN  LongRunningProcessStatusStatus = "NOT_RUN"
	RUNNING LongRunningProcessStatusStatus = "RUNNING"
	SUCCESS LongRunningProcessStatusStatus = "SUCCESS"
)

// Defines values for NamespaceOwnershipStatusBrokerAssignment.
const (
	Primary   NamespaceOwnershipStatusBrokerAssignment = "primary"
	Secondary NamespaceOwnershipStatusBrokerAssignment = "secondary"
	Shared    NamespaceOwnershipStatusBrokerAssignment = "shared"
)

// Defines values for OffloadPoliciesManagedLedgerOffloadedReadPriority.
const (
	OffloadPoliciesManagedLedgerOffloadedReadPriorityBOOKKEEPERFIRST    OffloadPoliciesManagedLedgerOffloadedReadPriority = "BOOKKEEPER_FIRST"
	OffloadPoliciesManagedLedgerOffloadedReadPriorityTIEREDSTORAGEFIRST OffloadPoliciesManagedLedgerOffloadedReadPriority = "TIERED_STORAGE_FIRST"
)

// Defines values for OffloadPoliciesImplManagedLedgerOffloadedReadPriority.
const (
	OffloadPoliciesImplManagedLedgerOffloadedReadPriorityBOOKKEEPERFIRST    OffloadPoliciesImplManagedLedgerOffloadedReadPriority = "BOOKKEEPER_FIRST"
	OffloadPoliciesImplManagedLedgerOffloadedReadPriorityTIEREDSTORAGEFIRST OffloadPoliciesImplManagedLedgerOffloadedReadPriority = "TIERED_STORAGE_FIRST"
)

// Defines values for PoliciesSchemaAutoUpdateCompatibilityStrategy.
const (
	AlwaysCompatible   PoliciesSchemaAutoUpdateCompatibilityStrategy = "AlwaysCompatible"
	AutoUpdateDisabled PoliciesSchemaAutoUpdateCompatibilityStrategy = "AutoUpdateDisabled"
	Backward           PoliciesSchemaAutoUpdateCompatibilityStrategy = "Backward"
	BackwardTransitive PoliciesSchemaAutoUpdateCompatibilityStrategy = "BackwardTransitive"
	Forward            PoliciesSchemaAutoUpdateCompatibilityStrategy = "Forward"
	ForwardTransitive  PoliciesSchemaAutoUpdateCompatibilityStrategy = "ForwardTransitive"
	Full               PoliciesSchemaAutoUpdateCompatibilityStrategy = "Full"
	FullTransitive     PoliciesSchemaAutoUpdateCompatibilityStrategy = "FullTransitive"
)

// Defines values for PoliciesSchemaCompatibilityStrategy.
const (
	ALWAYSCOMPATIBLE   PoliciesSchemaCompatibilityStrategy = "ALWAYS_COMPATIBLE"
	ALWAYSINCOMPATIBLE PoliciesSchemaCompatibilityStrategy = "ALWAYS_INCOMPATIBLE"
	BACKWARD           PoliciesSchemaCompatibilityStrategy = "BACKWARD"
	BACKWARDTRANSITIVE PoliciesSchemaCompatibilityStrategy = "BACKWARD_TRANSITIVE"
	FORWARD            PoliciesSchemaCompatibilityStrategy = "FORWARD"
	FORWARDTRANSITIVE  PoliciesSchemaCompatibilityStrategy = "FORWARD_TRANSITIVE"
	FULL               PoliciesSchemaCompatibilityStrategy = "FULL"
	FULLTRANSITIVE     PoliciesSchemaCompatibilityStrategy = "FULL_TRANSITIVE"
	UNDEFINED          PoliciesSchemaCompatibilityStrategy = "UNDEFINED"
)

// Defines values for PoliciesSubscriptionAuthMode.
const (
	None   PoliciesSubscriptionAuthMode = "None"
	Prefix PoliciesSubscriptionAuthMode = "Prefix"
)

// Defines values for AuthenticationType.
const (
	Consume   AuthenticationType = "consume"
	Functions AuthenticationType = "functions"
	Packages  AuthenticationType = "packages"
	Produce   AuthenticationType = "produce"
	Sinks     AuthenticationType = "sinks"
	Sources   AuthenticationType = "sources"
)

// Defines values for HealthCheckParamsTopicVersion.
const (
	V1 HealthCheckParamsTopicVersion = "V1"
	V2 HealthCheckParamsTopicVersion = "V2"
)

// Defines values for RemoveNamesapceBacklogQuotaParamsBacklogQuotaType.
const (
	RemoveNamesapceBacklogQuotaParamsBacklogQuotaTypeDestinationStorage RemoveNamesapceBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	RemoveNamesapceBacklogQuotaParamsBacklogQuotaTypeMessageAge         RemoveNamesapceBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for SetNamespaceBacklogQuotaParamsBacklogQuotaType.
const (
	SetNamespaceBacklogQuotaParamsBacklogQuotaTypeDestinationStorage SetNamespaceBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	SetNamespaceBacklogQuotaParamsBacklogQuotaTypeMessageAge         SetNamespaceBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for GetTopicsParamsMode.
const (
	ALL           GetTopicsParamsMode = "ALL"
	NONPERSISTENT GetTopicsParamsMode = "NON_PERSISTENT"
	PERSISTENT    GetTopicsParamsMode = "PERSISTENT"
)

// Defines values for RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaType.
const (
	RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaTypeDestinationStorage RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaTypeMessageAge         RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaType.
const (
	SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaTypeDestinationStorage SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaTypeMessageAge         SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for ExamineNonPersistentTopicMessageParamsInitialPosition.
const (
	ExamineNonPersistentTopicMessageParamsInitialPositionEarliest ExamineNonPersistentTopicMessageParamsInitialPosition = "earliest"
	ExamineNonPersistentTopicMessageParamsInitialPositionLatest   ExamineNonPersistentTopicMessageParamsInitialPosition = "latest"
)

// Defines values for RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaType.
const (
	RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaTypeDestinationStorage RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaType = "destination_storage"
	RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaTypeMessageAge         RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaType = "message_age"
)

// Defines values for RemovePersistentTopicBacklogQuotaParamsBacklogQuotaType.
const (
	RemovePersistentTopicBacklogQuotaParamsBacklogQuotaTypeDestinationStorage RemovePersistentTopicBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	RemovePersistentTopicBacklogQuotaParamsBacklogQuotaTypeMessageAge         RemovePersistentTopicBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for SetPersistentTopicBacklogQuotaParamsBacklogQuotaType.
const (
	SetPersistentTopicBacklogQuotaParamsBacklogQuotaTypeDestinationStorage SetPersistentTopicBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	SetPersistentTopicBacklogQuotaParamsBacklogQuotaTypeMessageAge         SetPersistentTopicBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for ExaminePersistentTopicMessageParamsInitialPosition.
const (
	ExaminePersistentTopicMessageParamsInitialPositionEarliest ExaminePersistentTopicMessageParamsInitialPosition = "earliest"
	ExaminePersistentTopicMessageParamsInitialPositionLatest   ExaminePersistentTopicMessageParamsInitialPosition = "latest"
)

// Defines values for RemovePersistentTopicReplicationClustersParamsBacklogQuotaType.
const (
	RemovePersistentTopicReplicationClustersParamsBacklogQuotaTypeDestinationStorage RemovePersistentTopicReplicationClustersParamsBacklogQuotaType = "destination_storage"
	RemovePersistentTopicReplicationClustersParamsBacklogQuotaTypeMessageAge         RemovePersistentTopicReplicationClustersParamsBacklogQuotaType = "message_age"
)

// AllocatorStats defines model for AllocatorStats.
type AllocatorStats struct {
	DirectArenas         *[]PoolArenaStats `json:"directArenas,omitempty"`
	HeapArenas           *[]PoolArenaStats `json:"heapArenas,omitempty"`
	NormalCacheSize      *int32            `json:"normalCacheSize,omitempty"`
	NumDirectArenas      *int32            `json:"numDirectArenas,omitempty"`
	NumHeapArenas        *int32            `json:"numHeapArenas,omitempty"`
	NumThreadLocalCaches *int32            `json:"numThreadLocalCaches,omitempty"`
	SmallCacheSize       *int32            `json:"smallCacheSize,omitempty"`
}

// Annotation defines model for Annotation.
type Annotation = map[string]interface{}

// AuthPolicies defines model for AuthPolicies.
type AuthPolicies struct {
	NamespaceAuthentication    *map[string][]AuthenticationType            `json:"namespaceAuthentication,omitempty"`
	SubscriptionAuthentication *map[string][]string                        `json:"subscriptionAuthentication,omitempty"`
	TopicAuthentication        *map[string]map[string][]AuthenticationType `json:"topicAuthentication,omitempty"`
}

// AutoFailoverPolicyData defines model for AutoFailoverPolicyData.
type AutoFailoverPolicyData struct {
	Parameters *map[string]string                `json:"parameters,omitempty"`
	PolicyType *AutoFailoverPolicyDataPolicyType `json:"policyType,omitempty"`
}

// AutoFailoverPolicyDataPolicyType defines model for AutoFailoverPolicyData.PolicyType.
type AutoFailoverPolicyDataPolicyType string

// AutoSubscriptionCreationOverride defines model for AutoSubscriptionCreationOverride.
type AutoSubscriptionCreationOverride struct {
	AllowAutoSubscriptionCreation *bool `json:"allowAutoSubscriptionCreation,omitempty"`
}

// AutoTopicCreationOverride defines model for AutoTopicCreationOverride.
type AutoTopicCreationOverride struct {
	AllowAutoTopicCreation *bool   `json:"allowAutoTopicCreation,omitempty"`
	DefaultNumPartitions   *int32  `json:"defaultNumPartitions,omitempty"`
	TopicType              *string `json:"topicType,omitempty"`
}

// BacklogQuota defines model for BacklogQuota.
type BacklogQuota struct {
	Limit     *int64              `json:"limit,omitempty"`
	LimitSize *int64              `json:"limitSize,omitempty"`
	LimitTime *int32              `json:"limitTime,omitempty"`
	Policy    *BacklogQuotaPolicy `json:"policy,omitempty"`
}

// BacklogQuotaPolicy defines model for BacklogQuota.Policy.
type BacklogQuotaPolicy string

// BookieAffinityGroupData defines model for BookieAffinityGroupData.
type BookieAffinityGroupData struct {
	BookkeeperAffinityGroupPrimary   *string `json:"bookkeeperAffinityGroupPrimary,omitempty"`
	BookkeeperAffinityGroupSecondary *string `json:"bookkeeperAffinityGroupSecondary,omitempty"`
}

// BookieInfo defines model for BookieInfo.
type BookieInfo struct {
	Hostname *string `json:"hostname,omitempty"`
	Rack     *string `json:"rack,omitempty"`
}

// BookiesClusterInfo defines model for BookiesClusterInfo.
type BookiesClusterInfo struct {
	Bookies *[]RawBookieInfo `json:"bookies,omitempty"`
}

// BrokerInfo defines model for BrokerInfo.
type BrokerInfo struct {
	ServiceUrl *string `json:"serviceUrl,omitempty"`
}

// BrokerNamespaceIsolationData The namespace isolation data for a given broker
type BrokerNamespaceIsolationData struct {
	// BrokerName The broker name
	BrokerName *string `json:"brokerName,omitempty"`

	// NamespaceRegex The namespace-isolation policies attached to this broker
	NamespaceRegex *[]string `json:"namespaceRegex,omitempty"`

	// PolicyName Policy name
	PolicyName *string `json:"policyName,omitempty"`
	Primary    *bool   `json:"primary,omitempty"`
}

// BundlesData defines model for BundlesData.
type BundlesData struct {
	Boundaries *[]string `json:"boundaries,omitempty"`
	NumBundles *int32    `json:"numBundles,omitempty"`
}

// CharacterEscapes defines model for CharacterEscapes.
type CharacterEscapes struct {
	EscapeCodesForAscii *[]int32 `json:"escapeCodesForAscii,omitempty"`
}

// ClassLoader defines model for ClassLoader.
type ClassLoader struct {
	DefinedPackages             *[]Package   `json:"definedPackages,omitempty"`
	Name                        *string      `json:"name,omitempty"`
	Parent                      *ClassLoader `json:"parent,omitempty"`
	RegisteredAsParallelCapable *bool        `json:"registeredAsParallelCapable,omitempty"`
	UnnamedModule               *Module      `json:"unnamedModule,omitempty"`
}

// ClusterData The configuration data for a cluster
type ClusterData struct {
	// AuthenticationParameters Authentication parameters when client would like to connect to cluster.
	AuthenticationParameters *string `json:"authenticationParameters,omitempty"`

	// AuthenticationPlugin Authentication plugin when client would like to connect to cluster.
	AuthenticationPlugin *string `json:"authenticationPlugin,omitempty"`

	// BrokerClientTlsEnabled Enable TLS when talking with other brokers in the same cluster (admin operation) or different clusters (replication)
	BrokerClientTlsEnabled *bool `json:"brokerClientTlsEnabled,omitempty"`

	// BrokerClientTlsEnabledWithKeyStore Whether internal client use KeyStore type to authenticate with other Pulsar brokers
	BrokerClientTlsEnabledWithKeyStore *bool `json:"brokerClientTlsEnabledWithKeyStore,omitempty"`

	// BrokerClientTlsTrustStore TLS TrustStore path for internal client used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStore *string `json:"brokerClientTlsTrustStore,omitempty"`

	// BrokerClientTlsTrustStorePassword TLS TrustStore password for internal client used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStorePassword *string `json:"brokerClientTlsTrustStorePassword,omitempty"`

	// BrokerClientTlsTrustStoreType TLS TrustStore type configuration for internal client: JKS, PKCS12 used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStoreType *string `json:"brokerClientTlsTrustStoreType,omitempty"`

	// BrokerClientTrustCertsFilePath Path for the trusted TLS certificate file for outgoing connection to a server (broker)
	BrokerClientTrustCertsFilePath *string `json:"brokerClientTrustCertsFilePath,omitempty"`

	// BrokerServiceUrl The broker service url (for produce and consume operations)
	BrokerServiceUrl *string `json:"brokerServiceUrl,omitempty"`

	// BrokerServiceUrlTls The secured broker service url (for produce and consume operations)
	BrokerServiceUrlTls *string `json:"brokerServiceUrlTls,omitempty"`

	// ListenerName listenerName when client would like to connect to cluster
	ListenerName *string `json:"listenerName,omitempty"`

	// PeerClusterNames A set of peer cluster names
	PeerClusterNames *[]string `json:"peerClusterNames,omitempty"`

	// ProxyProtocol protocol to decide type of proxy routing eg: SNI-routing
	ProxyProtocol *ClusterDataProxyProtocol `json:"proxyProtocol,omitempty"`

	// ProxyServiceUrl Proxy-service url when client would like to connect to broker via proxy.
	ProxyServiceUrl *string `json:"proxyServiceUrl,omitempty"`

	// ServiceUrl The HTTP rest service URL (for admin operations)
	ServiceUrl *string `json:"serviceUrl,omitempty"`

	// ServiceUrlTls The HTTPS rest service URL (for admin operations)
	ServiceUrlTls *string `json:"serviceUrlTls,omitempty"`

	// TlsAllowInsecureConnection Allow TLS connections to servers whose certificate cannot be be verified to have been signed by a trusted certificate authority.
	TlsAllowInsecureConnection *bool `json:"tlsAllowInsecureConnection,omitempty"`
}

// ClusterDataProxyProtocol protocol to decide type of proxy routing eg: SNI-routing
type ClusterDataProxyProtocol string

// DelayedDeliveryPolicies defines model for DelayedDeliveryPolicies.
type DelayedDeliveryPolicies struct {
	Active   *bool  `json:"active,omitempty"`
	TickTime *int64 `json:"tickTime,omitempty"`
}

// DeleteSchemaSuccessResponse defines model for DeleteSchemaSuccessResponse.
type DeleteSchemaSuccessResponse struct {
	Version *int64 `json:"version,omitempty"`
}

// DispatchRateImpl defines model for DispatchRateImpl.
type DispatchRateImpl struct {
	DispatchThrottlingRateInByte *int64 `json:"dispatchThrottlingRateInByte,omitempty"`
	DispatchThrottlingRateInMsg  *int32 `json:"dispatchThrottlingRateInMsg,omitempty"`
	RatePeriodInSecond           *int32 `json:"ratePeriodInSecond,omitempty"`
	RelativeToPublishRate        *bool  `json:"relativeToPublishRate,omitempty"`
}

// EntryFilters defines model for EntryFilters.
type EntryFilters struct {
	EntryFilterNames *string `json:"entryFilterNames,omitempty"`
}

// FailureDomain The data of a failure domain configuration in a cluster
type FailureDomain struct {
	// Brokers The collection of brokers in the same failure domain
	Brokers *[]string `json:"brokers,omitempty"`
}

// FunctionInstanceStatsData defines model for FunctionInstanceStatsData.
type FunctionInstanceStatsData struct {
	AvgProcessLatency          *float64                       `json:"avgProcessLatency,omitempty"`
	LastInvocation             *int64                         `json:"lastInvocation,omitempty"`
	OneMin                     *FunctionInstanceStatsDataBase `json:"oneMin,omitempty"`
	ProcessedSuccessfullyTotal *int64                         `json:"processedSuccessfullyTotal,omitempty"`
	ReceivedTotal              *int64                         `json:"receivedTotal,omitempty"`
	SystemExceptionsTotal      *int64                         `json:"systemExceptionsTotal,omitempty"`
	UserExceptionsTotal        *int64                         `json:"userExceptionsTotal,omitempty"`
	UserMetrics                *map[string]float64            `json:"userMetrics,omitempty"`
}

// FunctionInstanceStatsDataBase defines model for FunctionInstanceStatsDataBase.
type FunctionInstanceStatsDataBase struct {
	AvgProcessLatency          *float64 `json:"avgProcessLatency,omitempty"`
	ProcessedSuccessfullyTotal *int64   `json:"processedSuccessfullyTotal,omitempty"`
	ReceivedTotal              *int64   `json:"receivedTotal,omitempty"`
	SystemExceptionsTotal      *int64   `json:"systemExceptionsTotal,omitempty"`
	UserExceptionsTotal        *int64   `json:"userExceptionsTotal,omitempty"`
}

// GetAllVersionsSchemaResponse defines model for GetAllVersionsSchemaResponse.
type GetAllVersionsSchemaResponse struct {
	GetSchemaResponses *[]GetSchemaResponse `json:"getSchemaResponses,omitempty"`
}

// GetSchemaResponse defines model for GetSchemaResponse.
type GetSchemaResponse struct {
	Data       *string                `json:"data,omitempty"`
	Properties *map[string]string     `json:"properties,omitempty"`
	Timestamp  *int64                 `json:"timestamp,omitempty"`
	Type       *GetSchemaResponseType `json:"type,omitempty"`
	Version    *int64                 `json:"version,omitempty"`
}

// GetSchemaResponseType defines model for GetSchemaResponse.Type.
type GetSchemaResponseType string

// InactiveTopicPolicies defines model for InactiveTopicPolicies.
type InactiveTopicPolicies struct {
	DeleteWhileInactive        *bool                                         `json:"deleteWhileInactive,omitempty"`
	InactiveTopicDeleteMode    *InactiveTopicPoliciesInactiveTopicDeleteMode `json:"inactiveTopicDeleteMode,omitempty"`
	MaxInactiveDurationSeconds *int32                                        `json:"maxInactiveDurationSeconds,omitempty"`
}

// InactiveTopicPoliciesInactiveTopicDeleteMode defines model for InactiveTopicPolicies.InactiveTopicDeleteMode.
type InactiveTopicPoliciesInactiveTopicDeleteMode string

// InputDecorator defines model for InputDecorator.
type InputDecorator = map[string]interface{}

// InternalConfigurationData defines model for InternalConfigurationData.
type InternalConfigurationData struct {
	BookkeeperMetadataServiceUri  *string `json:"bookkeeperMetadataServiceUri,omitempty"`
	ConfigurationMetadataStoreUrl *string `json:"configurationMetadataStoreUrl,omitempty"`
	LedgersRootPath               *string `json:"ledgersRootPath,omitempty"`
	MetadataStoreUrl              *string `json:"metadataStoreUrl,omitempty"`
	StateStorageServiceUrl        *string `json:"stateStorageServiceUrl,omitempty"`
}

// IsCompatibilityResponse defines model for IsCompatibilityResponse.
type IsCompatibilityResponse struct {
	Compatibility               *bool   `json:"compatibility,omitempty"`
	SchemaCompatibilityStrategy *string `json:"schemaCompatibilityStrategy,omitempty"`
}

// JavaType defines model for JavaType.
type JavaType struct {
	Abstract            *bool                   `json:"abstract,omitempty"`
	ArrayType           *bool                   `json:"arrayType,omitempty"`
	Bindings            *TypeBindings           `json:"bindings,omitempty"`
	CollectionLikeType  *bool                   `json:"collectionLikeType,omitempty"`
	Concrete            *bool                   `json:"concrete,omitempty"`
	ContainerType       *bool                   `json:"containerType,omitempty"`
	ContentTypeHandler  *map[string]interface{} `json:"contentTypeHandler,omitempty"`
	ContentValueHandler *map[string]interface{} `json:"contentValueHandler,omitempty"`
	EnumType            *bool                   `json:"enumType,omitempty"`
	ErasedSignature     *string                 `json:"erasedSignature,omitempty"`
	Final               *bool                   `json:"final,omitempty"`
	GenericSignature    *string                 `json:"genericSignature,omitempty"`
	Interface           *bool                   `json:"interface,omitempty"`
	JavaLangObject      *bool                   `json:"javaLangObject,omitempty"`
	MapLikeType         *bool                   `json:"mapLikeType,omitempty"`
	Primitive           *bool                   `json:"primitive,omitempty"`
	ReferenceType       *bool                   `json:"referenceType,omitempty"`
	Throwable           *bool                   `json:"throwable,omitempty"`
	TypeHandler         *map[string]interface{} `json:"typeHandler,omitempty"`
	TypeName            *string                 `json:"typeName,omitempty"`
	ValueHandler        *map[string]interface{} `json:"valueHandler,omitempty"`
}

// JsonFactory defines model for JsonFactory.
type JsonFactory struct {
	CharacterEscapes   *CharacterEscapes `json:"characterEscapes,omitempty"`
	Codec              *ObjectCodec      `json:"codec,omitempty"`
	FormatName         *string           `json:"formatName,omitempty"`
	InputDecorator     *InputDecorator   `json:"inputDecorator,omitempty"`
	OutputDecorator    *OutputDecorator  `json:"outputDecorator,omitempty"`
	RootValueSeparator *string           `json:"rootValueSeparator,omitempty"`
}

// JsonSerializerObject defines model for JsonSerializerObject.
type JsonSerializerObject struct {
	Delegatee            *JsonSerializerObject `json:"delegatee,omitempty"`
	UnwrappingSerializer *bool                 `json:"unwrappingSerializer,omitempty"`
}

// JsonStreamContext defines model for JsonStreamContext.
type JsonStreamContext struct {
	CurrentIndex *int32                  `json:"currentIndex,omitempty"`
	CurrentName  *string                 `json:"currentName,omitempty"`
	CurrentValue *map[string]interface{} `json:"currentValue,omitempty"`
	EntryCount   *int32                  `json:"entryCount,omitempty"`
	Parent       *JsonStreamContext      `json:"parent,omitempty"`
	TypeDesc     *string                 `json:"typeDesc,omitempty"`
}

// LoadReport defines model for LoadReport.
type LoadReport struct {
	AllocatedBandwidthIn       *float64                         `json:"allocatedBandwidthIn,omitempty"`
	AllocatedBandwidthOut      *float64                         `json:"allocatedBandwidthOut,omitempty"`
	AllocatedCPU               *float64                         `json:"allocatedCPU,omitempty"`
	AllocatedMemory            *float64                         `json:"allocatedMemory,omitempty"`
	AllocatedMsgRateIn         *float64                         `json:"allocatedMsgRateIn,omitempty"`
	AllocatedMsgRateOut        *float64                         `json:"allocatedMsgRateOut,omitempty"`
	BandwidthIn                *ResourceUsage                   `json:"bandwidthIn,omitempty"`
	BandwidthOut               *ResourceUsage                   `json:"bandwidthOut,omitempty"`
	BrokerVersionString        *string                          `json:"brokerVersionString,omitempty"`
	BundleGains                *[]string                        `json:"bundleGains,omitempty"`
	BundleLosses               *[]string                        `json:"bundleLosses,omitempty"`
	BundleStats                *map[string]NamespaceBundleStats `json:"bundleStats,omitempty"`
	Cpu                        *ResourceUsage                   `json:"cpu,omitempty"`
	DirectMemory               *ResourceUsage                   `json:"directMemory,omitempty"`
	LastUpdate                 *int64                           `json:"lastUpdate,omitempty"`
	LoadReportType             *string                          `json:"loadReportType,omitempty"`
	Memory                     *ResourceUsage                   `json:"memory,omitempty"`
	MsgRateIn                  *float64                         `json:"msgRateIn,omitempty"`
	MsgRateOut                 *float64                         `json:"msgRateOut,omitempty"`
	MsgThroughputIn            *float64                         `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut           *float64                         `json:"msgThroughputOut,omitempty"`
	Name                       *string                          `json:"name,omitempty"`
	NonPersistentTopicsEnabled *bool                            `json:"nonPersistentTopicsEnabled,omitempty"`
	NumBundles                 *int32                           `json:"numBundles,omitempty"`
	NumConsumers               *int32                           `json:"numConsumers,omitempty"`
	NumProducers               *int32                           `json:"numProducers,omitempty"`
	NumTopics                  *int32                           `json:"numTopics,omitempty"`
	OverLoaded                 *bool                            `json:"overLoaded,omitempty"`
	PersistentTopicsEnabled    *bool                            `json:"persistentTopicsEnabled,omitempty"`
	PreAllocatedBandwidthIn    *float64                         `json:"preAllocatedBandwidthIn,omitempty"`
	PreAllocatedBandwidthOut   *float64                         `json:"preAllocatedBandwidthOut,omitempty"`
	PreAllocatedCPU            *float64                         `json:"preAllocatedCPU,omitempty"`
	PreAllocatedMemory         *float64                         `json:"preAllocatedMemory,omitempty"`
	PreAllocatedMsgRateIn      *float64                         `json:"preAllocatedMsgRateIn,omitempty"`
	PreAllocatedMsgRateOut     *float64                         `json:"preAllocatedMsgRateOut,omitempty"`
	Protocols                  *map[string]string               `json:"protocols,omitempty"`
	PulsarServiceUrl           *string                          `json:"pulsarServiceUrl,omitempty"`
	PulsarServiceUrlTls        *string                          `json:"pulsarServiceUrlTls,omitempty"`
	SystemResourceUsage        *SystemResourceUsage             `json:"systemResourceUsage,omitempty"`
	Timestamp                  *int64                           `json:"timestamp,omitempty"`
	UnderLoaded                *bool                            `json:"underLoaded,omitempty"`
	WebServiceUrl              *string                          `json:"webServiceUrl,omitempty"`
	WebServiceUrlTls           *string                          `json:"webServiceUrlTls,omitempty"`
}

// LongRunningProcessStatus defines model for LongRunningProcessStatus.
type LongRunningProcessStatus struct {
	LastError *string                         `json:"lastError,omitempty"`
	Status    *LongRunningProcessStatusStatus `json:"status,omitempty"`
}

// LongRunningProcessStatusStatus defines model for LongRunningProcessStatus.Status.
type LongRunningProcessStatusStatus string

// LongSchemaVersion defines model for LongSchemaVersion.
type LongSchemaVersion struct {
	Version *int64 `json:"version,omitempty"`
}

// Metrics defines model for Metrics.
type Metrics struct {
	Dimensions *map[string]string                 `json:"dimensions,omitempty"`
	Metrics    *map[string]map[string]interface{} `json:"metrics,omitempty"`
}

// Module defines model for Module.
type Module struct {
	Annotations         *[]Annotation     `json:"annotations,omitempty"`
	ClassLoader         *ClassLoader      `json:"classLoader,omitempty"`
	DeclaredAnnotations *[]Annotation     `json:"declaredAnnotations,omitempty"`
	Descriptor          *ModuleDescriptor `json:"descriptor,omitempty"`
	Layer               *ModuleLayer      `json:"layer,omitempty"`
	Name                *string           `json:"name,omitempty"`
	Named               *bool             `json:"named,omitempty"`
	Packages            *[]string         `json:"packages,omitempty"`
}

// ModuleDescriptor defines model for ModuleDescriptor.
type ModuleDescriptor struct {
	Automatic *bool `json:"automatic,omitempty"`
	Open      *bool `json:"open,omitempty"`
}

// ModuleLayer defines model for ModuleLayer.
type ModuleLayer = map[string]interface{}

// NamespaceBundleStats defines model for NamespaceBundleStats.
type NamespaceBundleStats struct {
	CacheSize        *int64   `json:"cacheSize,omitempty"`
	ConsumerCount    *int32   `json:"consumerCount,omitempty"`
	MsgRateIn        *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut       *float64 `json:"msgRateOut,omitempty"`
	MsgThroughputIn  *float64 `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut *float64 `json:"msgThroughputOut,omitempty"`
	ProducerCount    *int32   `json:"producerCount,omitempty"`
	Topics           *int64   `json:"topics,omitempty"`
}

// NamespaceIsolationData The data of namespace isolation configuration
type NamespaceIsolationData struct {
	AutoFailoverPolicy *AutoFailoverPolicyData `json:"auto_failover_policy,omitempty"`

	// Namespaces The list of namespaces to apply this namespace isolation data
	Namespaces *[]string `json:"namespaces,omitempty"`

	// Primary The list of primary brokers for serving the list of namespaces in this isolation policy
	Primary *[]string `json:"primary,omitempty"`

	// Secondary The list of secondary brokers for serving the list of namespaces in this isolation policy
	Secondary *[]string `json:"secondary,omitempty"`
}

// NamespaceOwnershipStatus defines model for NamespaceOwnershipStatus.
type NamespaceOwnershipStatus struct {
	BrokerAssignment *NamespaceOwnershipStatusBrokerAssignment `json:"broker_assignment,omitempty"`
	IsActive         *bool                                     `json:"is_active,omitempty"`
	IsControlled     *bool                                     `json:"is_controlled,omitempty"`
}

// NamespaceOwnershipStatusBrokerAssignment defines model for NamespaceOwnershipStatus.BrokerAssignment.
type NamespaceOwnershipStatusBrokerAssignment string

// ObjectCodec defines model for ObjectCodec.
type ObjectCodec struct {
	Factory     *JsonFactory `json:"factory,omitempty"`
	JsonFactory *JsonFactory `json:"jsonFactory,omitempty"`
}

// OffloadPolicies defines model for OffloadPolicies.
type OffloadPolicies struct {
	FileSystemProfilePath                        *string                                            `json:"fileSystemProfilePath,omitempty"`
	FileSystemURI                                *string                                            `json:"fileSystemURI,omitempty"`
	GcsManagedLedgerOffloadBucket                *string                                            `json:"gcsManagedLedgerOffloadBucket,omitempty"`
	GcsManagedLedgerOffloadMaxBlockSizeInBytes   *int32                                             `json:"gcsManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadReadBufferSizeInBytes *int32                                             `json:"gcsManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadRegion                *string                                            `json:"gcsManagedLedgerOffloadRegion,omitempty"`
	GcsManagedLedgerOffloadServiceAccountKeyFile *string                                            `json:"gcsManagedLedgerOffloadServiceAccountKeyFile,omitempty"`
	ManagedLedgerOffloadBucket                   *string                                            `json:"managedLedgerOffloadBucket,omitempty"`
	ManagedLedgerOffloadDeletionLagInMillis      *int64                                             `json:"managedLedgerOffloadDeletionLagInMillis,omitempty"`
	ManagedLedgerOffloadDriver                   *string                                            `json:"managedLedgerOffloadDriver,omitempty"`
	ManagedLedgerOffloadMaxBlockSizeInBytes      *int32                                             `json:"managedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	ManagedLedgerOffloadMaxThreads               *int32                                             `json:"managedLedgerOffloadMaxThreads,omitempty"`
	ManagedLedgerOffloadPrefetchRounds           *int32                                             `json:"managedLedgerOffloadPrefetchRounds,omitempty"`
	ManagedLedgerOffloadReadBufferSizeInBytes    *int32                                             `json:"managedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	ManagedLedgerOffloadRegion                   *string                                            `json:"managedLedgerOffloadRegion,omitempty"`
	ManagedLedgerOffloadServiceEndpoint          *string                                            `json:"managedLedgerOffloadServiceEndpoint,omitempty"`
	ManagedLedgerOffloadThresholdInBytes         *int64                                             `json:"managedLedgerOffloadThresholdInBytes,omitempty"`
	ManagedLedgerOffloadedReadPriority           *OffloadPoliciesManagedLedgerOffloadedReadPriority `json:"managedLedgerOffloadedReadPriority,omitempty"`
	OffloadersDirectory                          *string                                            `json:"offloadersDirectory,omitempty"`
	S3ManagedLedgerOffloadBucket                 *string                                            `json:"s3ManagedLedgerOffloadBucket,omitempty"`
	S3ManagedLedgerOffloadCredentialId           *string                                            `json:"s3ManagedLedgerOffloadCredentialId,omitempty"`
	S3ManagedLedgerOffloadCredentialSecret       *string                                            `json:"s3ManagedLedgerOffloadCredentialSecret,omitempty"`
	S3ManagedLedgerOffloadMaxBlockSizeInBytes    *int32                                             `json:"s3ManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadReadBufferSizeInBytes  *int32                                             `json:"s3ManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadRegion                 *string                                            `json:"s3ManagedLedgerOffloadRegion,omitempty"`
	S3ManagedLedgerOffloadRole                   *string                                            `json:"s3ManagedLedgerOffloadRole,omitempty"`
	S3ManagedLedgerOffloadRoleSessionName        *string                                            `json:"s3ManagedLedgerOffloadRoleSessionName,omitempty"`
	S3ManagedLedgerOffloadServiceEndpoint        *string                                            `json:"s3ManagedLedgerOffloadServiceEndpoint,omitempty"`
}

// OffloadPoliciesManagedLedgerOffloadedReadPriority defines model for OffloadPolicies.ManagedLedgerOffloadedReadPriority.
type OffloadPoliciesManagedLedgerOffloadedReadPriority string

// OffloadPoliciesImpl defines model for OffloadPoliciesImpl.
type OffloadPoliciesImpl struct {
	FileSystemDriver                             *bool                                                  `json:"fileSystemDriver,omitempty"`
	FileSystemProfilePath                        *string                                                `json:"fileSystemProfilePath,omitempty"`
	FileSystemURI                                *string                                                `json:"fileSystemURI,omitempty"`
	GcsDriver                                    *bool                                                  `json:"gcsDriver,omitempty"`
	GcsManagedLedgerOffloadBucket                *string                                                `json:"gcsManagedLedgerOffloadBucket,omitempty"`
	GcsManagedLedgerOffloadMaxBlockSizeInBytes   *int32                                                 `json:"gcsManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadReadBufferSizeInBytes *int32                                                 `json:"gcsManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadRegion                *string                                                `json:"gcsManagedLedgerOffloadRegion,omitempty"`
	GcsManagedLedgerOffloadServiceAccountKeyFile *string                                                `json:"gcsManagedLedgerOffloadServiceAccountKeyFile,omitempty"`
	ManagedLedgerOffloadBucket                   *string                                                `json:"managedLedgerOffloadBucket,omitempty"`
	ManagedLedgerOffloadDeletionLagInMillis      *int64                                                 `json:"managedLedgerOffloadDeletionLagInMillis,omitempty"`
	ManagedLedgerOffloadDriver                   *string                                                `json:"managedLedgerOffloadDriver,omitempty"`
	ManagedLedgerOffloadMaxBlockSizeInBytes      *int32                                                 `json:"managedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	ManagedLedgerOffloadMaxThreads               *int32                                                 `json:"managedLedgerOffloadMaxThreads,omitempty"`
	ManagedLedgerOffloadPrefetchRounds           *int32                                                 `json:"managedLedgerOffloadPrefetchRounds,omitempty"`
	ManagedLedgerOffloadReadBufferSizeInBytes    *int32                                                 `json:"managedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	ManagedLedgerOffloadRegion                   *string                                                `json:"managedLedgerOffloadRegion,omitempty"`
	ManagedLedgerOffloadServiceEndpoint          *string                                                `json:"managedLedgerOffloadServiceEndpoint,omitempty"`
	ManagedLedgerOffloadThresholdInBytes         *int64                                                 `json:"managedLedgerOffloadThresholdInBytes,omitempty"`
	ManagedLedgerOffloadedReadPriority           *OffloadPoliciesImplManagedLedgerOffloadedReadPriority `json:"managedLedgerOffloadedReadPriority,omitempty"`
	OffloadersDirectory                          *string                                                `json:"offloadersDirectory,omitempty"`
	S3Driver                                     *bool                                                  `json:"s3Driver,omitempty"`
	S3ManagedLedgerOffloadBucket                 *string                                                `json:"s3ManagedLedgerOffloadBucket,omitempty"`
	S3ManagedLedgerOffloadCredentialId           *string                                                `json:"s3ManagedLedgerOffloadCredentialId,omitempty"`
	S3ManagedLedgerOffloadCredentialSecret       *string                                                `json:"s3ManagedLedgerOffloadCredentialSecret,omitempty"`
	S3ManagedLedgerOffloadMaxBlockSizeInBytes    *int32                                                 `json:"s3ManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadReadBufferSizeInBytes  *int32                                                 `json:"s3ManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadRegion                 *string                                                `json:"s3ManagedLedgerOffloadRegion,omitempty"`
	S3ManagedLedgerOffloadRole                   *string                                                `json:"s3ManagedLedgerOffloadRole,omitempty"`
	S3ManagedLedgerOffloadRoleSessionName        *string                                                `json:"s3ManagedLedgerOffloadRoleSessionName,omitempty"`
	S3ManagedLedgerOffloadServiceEndpoint        *string                                                `json:"s3ManagedLedgerOffloadServiceEndpoint,omitempty"`
}

// OffloadPoliciesImplManagedLedgerOffloadedReadPriority defines model for OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriority.
type OffloadPoliciesImplManagedLedgerOffloadedReadPriority string

// OutputDecorator defines model for OutputDecorator.
type OutputDecorator = map[string]interface{}

// OutputStream defines model for OutputStream.
type OutputStream = map[string]interface{}

// Package defines model for Package.
type Package struct {
	Annotations           *[]Annotation `json:"annotations,omitempty"`
	DeclaredAnnotations   *[]Annotation `json:"declaredAnnotations,omitempty"`
	ImplementationTitle   *string       `json:"implementationTitle,omitempty"`
	ImplementationVendor  *string       `json:"implementationVendor,omitempty"`
	ImplementationVersion *string       `json:"implementationVersion,omitempty"`
	Name                  *string       `json:"name,omitempty"`
	Sealed                *bool         `json:"sealed,omitempty"`
	SpecificationTitle    *string       `json:"specificationTitle,omitempty"`
	SpecificationVendor   *string       `json:"specificationVendor,omitempty"`
	SpecificationVersion  *string       `json:"specificationVersion,omitempty"`
}

// PartitionedTopicMetadata defines model for PartitionedTopicMetadata.
type PartitionedTopicMetadata struct {
	Partitions *int32             `json:"partitions,omitempty"`
	Properties *map[string]string `json:"properties,omitempty"`
}

// PendingBookieOpsStats defines model for PendingBookieOpsStats.
type PendingBookieOpsStats struct {
	CursorLedgerCloseOp  *int64 `json:"cursorLedgerCloseOp,omitempty"`
	CursorLedgerCreateOp *int64 `json:"cursorLedgerCreateOp,omitempty"`
	CursorLedgerDeleteOp *int64 `json:"cursorLedgerDeleteOp,omitempty"`
	CursorLedgerOpenOp   *int64 `json:"cursorLedgerOpenOp,omitempty"`
	DataLedgerCloseOp    *int64 `json:"dataLedgerCloseOp,omitempty"`
	DataLedgerCreateOp   *int64 `json:"dataLedgerCreateOp,omitempty"`
	DataLedgerDeleteOp   *int64 `json:"dataLedgerDeleteOp,omitempty"`
	DataLedgerOpenOp     *int64 `json:"dataLedgerOpenOp,omitempty"`
}

// PersistencePolicies defines model for PersistencePolicies.
type PersistencePolicies struct {
	BookkeeperAckQuorum            *int32   `json:"bookkeeperAckQuorum,omitempty"`
	BookkeeperEnsemble             *int32   `json:"bookkeeperEnsemble,omitempty"`
	BookkeeperWriteQuorum          *int32   `json:"bookkeeperWriteQuorum,omitempty"`
	ManagedLedgerMaxMarkDeleteRate *float64 `json:"managedLedgerMaxMarkDeleteRate,omitempty"`
}

// Policies defines model for Policies.
type Policies struct {
	AuthPolicies                          *AuthPolicies                                  `json:"auth_policies,omitempty"`
	AutoSubscriptionCreationOverride      *AutoSubscriptionCreationOverride              `json:"autoSubscriptionCreationOverride,omitempty"`
	AutoTopicCreationOverride             *AutoTopicCreationOverride                     `json:"autoTopicCreationOverride,omitempty"`
	BacklogQuotaMap                       *map[string]BacklogQuota                       `json:"backlog_quota_map,omitempty"`
	Bundles                               *BundlesData                                   `json:"bundles,omitempty"`
	ClusterDispatchRate                   *map[string]DispatchRateImpl                   `json:"clusterDispatchRate,omitempty"`
	ClusterSubscribeRate                  *map[string]SubscribeRate                      `json:"clusterSubscribeRate,omitempty"`
	CompactionThreshold                   *int64                                         `json:"compaction_threshold,omitempty"`
	DeduplicationEnabled                  *bool                                          `json:"deduplicationEnabled,omitempty"`
	DeduplicationSnapshotIntervalSeconds  *int32                                         `json:"deduplicationSnapshotIntervalSeconds,omitempty"`
	DelayedDeliveryPolicies               *DelayedDeliveryPolicies                       `json:"delayed_delivery_policies,omitempty"`
	Deleted                               *bool                                          `json:"deleted,omitempty"`
	EncryptionRequired                    *bool                                          `json:"encryption_required,omitempty"`
	EntryFilters                          *EntryFilters                                  `json:"entryFilters,omitempty"`
	InactiveTopicPolicies                 *InactiveTopicPolicies                         `json:"inactive_topic_policies,omitempty"`
	IsAllowAutoUpdateSchema               *bool                                          `json:"is_allow_auto_update_schema,omitempty"`
	LatencyStatsSampleRate                *map[string]int32                              `json:"latency_stats_sample_rate,omitempty"`
	MaxConsumersPerSubscription           *int32                                         `json:"max_consumers_per_subscription,omitempty"`
	MaxConsumersPerTopic                  *int32                                         `json:"max_consumers_per_topic,omitempty"`
	MaxProducersPerTopic                  *int32                                         `json:"max_producers_per_topic,omitempty"`
	MaxSubscriptionsPerTopic              *int32                                         `json:"max_subscriptions_per_topic,omitempty"`
	MaxTopicsPerNamespace                 *int32                                         `json:"max_topics_per_namespace,omitempty"`
	MaxUnackedMessagesPerConsumer         *int32                                         `json:"max_unacked_messages_per_consumer,omitempty"`
	MaxUnackedMessagesPerSubscription     *int32                                         `json:"max_unacked_messages_per_subscription,omitempty"`
	MessageTtlInSeconds                   *int32                                         `json:"message_ttl_in_seconds,omitempty"`
	OffloadDeletionLagMs                  *int64                                         `json:"offload_deletion_lag_ms,omitempty"`
	OffloadPolicies                       *OffloadPolicies                               `json:"offload_policies,omitempty"`
	OffloadThreshold                      *int64                                         `json:"offload_threshold,omitempty"`
	Persistence                           *PersistencePolicies                           `json:"persistence,omitempty"`
	Properties                            *map[string]string                             `json:"properties,omitempty"`
	PublishMaxMessageRate                 *map[string]PublishRate                        `json:"publishMaxMessageRate,omitempty"`
	ReplicationClusters                   *[]string                                      `json:"replication_clusters,omitempty"`
	ReplicatorDispatchRate                *map[string]DispatchRateImpl                   `json:"replicatorDispatchRate,omitempty"`
	ResourceGroupName                     *string                                        `json:"resource_group_name,omitempty"`
	RetentionPolicies                     *RetentionPolicies                             `json:"retention_policies,omitempty"`
	SchemaAutoUpdateCompatibilityStrategy *PoliciesSchemaAutoUpdateCompatibilityStrategy `json:"schema_auto_update_compatibility_strategy,omitempty"`
	SchemaCompatibilityStrategy           *PoliciesSchemaCompatibilityStrategy           `json:"schema_compatibility_strategy,omitempty"`
	SchemaValidationEnforced              *bool                                          `json:"schema_validation_enforced,omitempty"`
	SubscriptionDispatchRate              *map[string]DispatchRateImpl                   `json:"subscriptionDispatchRate,omitempty"`
	SubscriptionAuthMode                  *PoliciesSubscriptionAuthMode                  `json:"subscription_auth_mode,omitempty"`
	SubscriptionExpirationTimeMinutes     *int32                                         `json:"subscription_expiration_time_minutes,omitempty"`
	SubscriptionTypesEnabled              *[]string                                      `json:"subscription_types_enabled,omitempty"`
	TopicDispatchRate                     *map[string]DispatchRateImpl                   `json:"topicDispatchRate,omitempty"`
}

// PoliciesSchemaAutoUpdateCompatibilityStrategy defines model for Policies.SchemaAutoUpdateCompatibilityStrategy.
type PoliciesSchemaAutoUpdateCompatibilityStrategy string

// PoliciesSchemaCompatibilityStrategy defines model for Policies.SchemaCompatibilityStrategy.
type PoliciesSchemaCompatibilityStrategy string

// PoliciesSubscriptionAuthMode defines model for Policies.SubscriptionAuthMode.
type PoliciesSubscriptionAuthMode string

// PoolArenaStats defines model for PoolArenaStats.
type PoolArenaStats struct {
	ChunkLists                 *[]PoolChunkListStats `json:"chunkLists,omitempty"`
	NumActiveAllocations       *int64                `json:"numActiveAllocations,omitempty"`
	NumActiveHugeAllocations   *int64                `json:"numActiveHugeAllocations,omitempty"`
	NumActiveNormalAllocations *int64                `json:"numActiveNormalAllocations,omitempty"`
	NumActiveSmallAllocations  *int64                `json:"numActiveSmallAllocations,omitempty"`
	NumAllocations             *int64                `json:"numAllocations,omitempty"`
	NumChunkLists              *int32                `json:"numChunkLists,omitempty"`
	NumDeallocations           *int64                `json:"numDeallocations,omitempty"`
	NumHugeAllocations         *int64                `json:"numHugeAllocations,omitempty"`
	NumHugeDeallocations       *int64                `json:"numHugeDeallocations,omitempty"`
	NumNormalAllocations       *int64                `json:"numNormalAllocations,omitempty"`
	NumNormalDeallocations     *int64                `json:"numNormalDeallocations,omitempty"`
	NumSmallAllocations        *int64                `json:"numSmallAllocations,omitempty"`
	NumSmallDeallocations      *int64                `json:"numSmallDeallocations,omitempty"`
	NumSmallSubpages           *int32                `json:"numSmallSubpages,omitempty"`
	SmallSubpages              *[]PoolSubpageStats   `json:"smallSubpages,omitempty"`
}

// PoolChunkListStats defines model for PoolChunkListStats.
type PoolChunkListStats struct {
	Chunks   *[]PoolChunkStats `json:"chunks,omitempty"`
	MaxUsage *int32            `json:"maxUsage,omitempty"`
	MinUsage *int32            `json:"minUsage,omitempty"`
}

// PoolChunkStats defines model for PoolChunkStats.
type PoolChunkStats struct {
	ChunkSize *int32 `json:"chunkSize,omitempty"`
	FreeBytes *int32 `json:"freeBytes,omitempty"`
	Usage     *int32 `json:"usage,omitempty"`
}

// PoolSubpageStats defines model for PoolSubpageStats.
type PoolSubpageStats struct {
	ElementSize    *int32 `json:"elementSize,omitempty"`
	MaxNumElements *int32 `json:"maxNumElements,omitempty"`
	NumAvailable   *int32 `json:"numAvailable,omitempty"`
	PageSize       *int32 `json:"pageSize,omitempty"`
}

// PostSchemaPayload defines model for PostSchemaPayload.
type PostSchemaPayload struct {
	Properties *map[string]string `json:"properties,omitempty"`
	Schema     *string            `json:"schema,omitempty"`
	Type       *string            `json:"type,omitempty"`
}

// PostSchemaSuccessResponse defines model for PostSchemaSuccessResponse.
type PostSchemaSuccessResponse struct {
	Version *SchemaVersion `json:"version,omitempty"`
}

// PublishRate defines model for PublishRate.
type PublishRate struct {
	PublishThrottlingRateInByte *int64 `json:"publishThrottlingRateInByte,omitempty"`
	PublishThrottlingRateInMsg  *int32 `json:"publishThrottlingRateInMsg,omitempty"`
}

// RawBookieInfo defines model for RawBookieInfo.
type RawBookieInfo struct {
	BookieId *string `json:"bookieId,omitempty"`
}

// ResetCursorData defines model for ResetCursorData.
type ResetCursorData struct {
	BatchIndex     *int32             `json:"batchIndex,omitempty"`
	EntryId        *int64             `json:"entryId,omitempty"`
	Excluded       *bool              `json:"excluded,omitempty"`
	LedgerId       *int64             `json:"ledgerId,omitempty"`
	PartitionIndex *int32             `json:"partitionIndex,omitempty"`
	Properties     *map[string]string `json:"properties,omitempty"`
}

// ResourceDescription defines model for ResourceDescription.
type ResourceDescription struct {
	ResourceUsage *map[string]ResourceUsage `json:"resourceUsage,omitempty"`
	UsagePct      *int32                    `json:"usagePct,omitempty"`
}

// ResourceGroup defines model for ResourceGroup.
type ResourceGroup struct {
	DispatchRateInBytes *int64 `json:"dispatchRateInBytes,omitempty"`
	DispatchRateInMsgs  *int32 `json:"dispatchRateInMsgs,omitempty"`
	PublishRateInBytes  *int64 `json:"publishRateInBytes,omitempty"`
	PublishRateInMsgs   *int32 `json:"publishRateInMsgs,omitempty"`
}

// ResourceQuota defines model for ResourceQuota.
type ResourceQuota struct {
	BandwidthIn  *float64 `json:"bandwidthIn,omitempty"`
	BandwidthOut *float64 `json:"bandwidthOut,omitempty"`
	Dynamic      *bool    `json:"dynamic,omitempty"`
	Memory       *float64 `json:"memory,omitempty"`
	MsgRateIn    *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut   *float64 `json:"msgRateOut,omitempty"`
}

// ResourceUnit defines model for ResourceUnit.
type ResourceUnit struct {
	AvailableResource *ResourceDescription `json:"availableResource,omitempty"`
	ResourceId        *string              `json:"resourceId,omitempty"`
}

// ResourceUsage defines model for ResourceUsage.
type ResourceUsage struct {
	Limit *float64 `json:"limit,omitempty"`
	Usage *float64 `json:"usage,omitempty"`
}

// RetentionPolicies defines model for RetentionPolicies.
type RetentionPolicies struct {
	RetentionSizeInMB      *int64 `json:"retentionSizeInMB,omitempty"`
	RetentionTimeInMinutes *int32 `json:"retentionTimeInMinutes,omitempty"`
}

// SchemaVersion defines model for SchemaVersion.
type SchemaVersion = map[string]interface{}

// SubscribeRate defines model for SubscribeRate.
type SubscribeRate struct {
	RatePeriodInSecond                 *int32 `json:"ratePeriodInSecond,omitempty"`
	SubscribeThrottlingRatePerConsumer *int32 `json:"subscribeThrottlingRatePerConsumer,omitempty"`
}

// SystemResourceUsage defines model for SystemResourceUsage.
type SystemResourceUsage struct {
	BandwidthIn  *ResourceUsage `json:"bandwidthIn,omitempty"`
	BandwidthOut *ResourceUsage `json:"bandwidthOut,omitempty"`
	Cpu          *ResourceUsage `json:"cpu,omitempty"`
	DirectMemory *ResourceUsage `json:"directMemory,omitempty"`
	Memory       *ResourceUsage `json:"memory,omitempty"`
}

// TenantInfo Information of adminRoles and allowedClusters for tenant
type TenantInfo struct {
	// AdminRoles Comma separated list of auth principal allowed to administrate the tenant.
	AdminRoles *[]string `json:"adminRoles,omitempty"`

	// AllowedClusters Comma separated allowed clusters.
	AllowedClusters *[]string `json:"allowedClusters,omitempty"`
}

// TypeBindings defines model for TypeBindings.
type TypeBindings struct {
	Empty          *bool       `json:"empty,omitempty"`
	TypeParameters *[]JavaType `json:"typeParameters,omitempty"`
}

// WorkerFunctionInstanceStats defines model for WorkerFunctionInstanceStats.
type WorkerFunctionInstanceStats struct {
	Metrics *FunctionInstanceStatsData `json:"metrics,omitempty"`
	Name    *string                    `json:"name,omitempty"`
}

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo struct {
	Port           *int32  `json:"port,omitempty"`
	WorkerHostname *string `json:"workerHostname,omitempty"`
	WorkerId       *string `json:"workerId,omitempty"`
}

// AuthenticationType defines model for authenticationType.
type AuthenticationType string

// UpdateBookieRackInfoParams defines parameters for UpdateBookieRackInfo.
type UpdateBookieRackInfoParams struct {
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// HealthCheckParams defines parameters for HealthCheck.
type HealthCheckParams struct {
	TopicVersion *HealthCheckParamsTopicVersion `form:"topicVersion,omitempty" json:"topicVersion,omitempty"`
}

// HealthCheckParamsTopicVersion defines parameters for HealthCheck.
type HealthCheckParamsTopicVersion string

// ShutDownBrokerGracefullyParams defines parameters for ShutDownBrokerGracefully.
type ShutDownBrokerGracefullyParams struct {
	// MaxConcurrentUnloadPerSec if the value absent(value=0) means no concurrent limitation.
	MaxConcurrentUnloadPerSec *int32 `form:"maxConcurrentUnloadPerSec,omitempty" json:"maxConcurrentUnloadPerSec,omitempty"`
	ForcedTerminateTopic      *bool  `form:"forcedTerminateTopic,omitempty" json:"forcedTerminateTopic,omitempty"`
}

// GetAntiAffinityNamespacesParams defines parameters for GetAntiAffinityNamespaces.
type GetAntiAffinityNamespacesParams struct {
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`
}

// DeleteNamespaceParams defines parameters for DeleteNamespace.
type DeleteNamespaceParams struct {
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNamespaceAntiAffinityGroupJSONBody defines parameters for SetNamespaceAntiAffinityGroup.
type SetNamespaceAntiAffinityGroupJSONBody = string

// RemoveNamesapceBacklogQuotaParams defines parameters for RemoveNamesapceBacklogQuota.
type RemoveNamesapceBacklogQuotaParams struct {
	BacklogQuotaType *RemoveNamesapceBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// RemoveNamesapceBacklogQuotaParamsBacklogQuotaType defines parameters for RemoveNamesapceBacklogQuota.
type RemoveNamesapceBacklogQuotaParamsBacklogQuotaType string

// SetNamespaceBacklogQuotaParams defines parameters for SetNamespaceBacklogQuota.
type SetNamespaceBacklogQuotaParams struct {
	BacklogQuotaType *SetNamespaceBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// SetNamespaceBacklogQuotaParamsBacklogQuotaType defines parameters for SetNamespaceBacklogQuota.
type SetNamespaceBacklogQuotaParamsBacklogQuotaType string

// ClearNamespaceBacklogParams defines parameters for ClearNamespaceBacklog.
type ClearNamespaceBacklogParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ClearNamespaceBacklogForSubscriptionParams defines parameters for ClearNamespaceBacklogForSubscription.
type ClearNamespaceBacklogForSubscriptionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNamespaceCompactionThresholdJSONBody defines parameters for SetNamespaceCompactionThreshold.
type SetNamespaceCompactionThresholdJSONBody = int64

// ModifyDeduplicationJSONBody defines parameters for ModifyDeduplication.
type ModifyDeduplicationJSONBody = bool

// SetNamespaceDeduplicationSnapshotIntervalJSONBody defines parameters for SetNamespaceDeduplicationSnapshotInterval.
type SetNamespaceDeduplicationSnapshotIntervalJSONBody = int32

// ModifyEncryptionRequiredJSONBody defines parameters for ModifyEncryptionRequired.
type ModifyEncryptionRequiredJSONBody = bool

// SetIsAllowAutoUpdateSchemaJSONBody defines parameters for SetIsAllowAutoUpdateSchema.
type SetIsAllowAutoUpdateSchemaJSONBody = bool

// SetNamespaceMaxConsumersPerSubscriptionJSONBody defines parameters for SetNamespaceMaxConsumersPerSubscription.
type SetNamespaceMaxConsumersPerSubscriptionJSONBody = int32

// SetNamespaceMaxConsumersPerTopicJSONBody defines parameters for SetNamespaceMaxConsumersPerTopic.
type SetNamespaceMaxConsumersPerTopicJSONBody = int32

// SetNamespaceMaxProducersPerTopicJSONBody defines parameters for SetNamespaceMaxProducersPerTopic.
type SetNamespaceMaxProducersPerTopicJSONBody = int32

// SetNamespaceMaxSubscriptionsPerTopicJSONBody defines parameters for SetNamespaceMaxSubscriptionsPerTopic.
type SetNamespaceMaxSubscriptionsPerTopicJSONBody = int32

// SetNamespaceMaxTopicsPerNamespaceJSONBody defines parameters for SetNamespaceMaxTopicsPerNamespace.
type SetNamespaceMaxTopicsPerNamespaceJSONBody = int32

// SetNamespaceMaxUnackedMessagesPerConsumerJSONBody defines parameters for SetNamespaceMaxUnackedMessagesPerConsumer.
type SetNamespaceMaxUnackedMessagesPerConsumerJSONBody = int32

// SetNamespaceMaxUnackedMessagesPerSubscriptionJSONBody defines parameters for SetNamespaceMaxUnackedMessagesPerSubscription.
type SetNamespaceMaxUnackedMessagesPerSubscriptionJSONBody = int32

// SetNamespaceMessageTTLJSONBody defines parameters for SetNamespaceMessageTTL.
type SetNamespaceMessageTTLJSONBody = int32

// SetNamespaceOffloadDeletionLagJSONBody defines parameters for SetNamespaceOffloadDeletionLag.
type SetNamespaceOffloadDeletionLagJSONBody = int64

// SetNamespaceOffloadThresholdJSONBody defines parameters for SetNamespaceOffloadThreshold.
type SetNamespaceOffloadThresholdJSONBody = int64

// GrantPermissionOnNamespaceJSONBody defines parameters for GrantPermissionOnNamespace.
type GrantPermissionOnNamespaceJSONBody = []string

// SetPropertiesJSONBody defines parameters for SetProperties.
type SetPropertiesJSONBody map[string]string

// SetNamespaceReplicationClustersJSONBody defines parameters for SetNamespaceReplicationClusters.
type SetNamespaceReplicationClustersJSONBody = []string

// SetSchemaAutoUpdateCompatibilityStrategyJSONBody defines parameters for SetSchemaAutoUpdateCompatibilityStrategy.
type SetSchemaAutoUpdateCompatibilityStrategyJSONBody = string

// SetNamespaceSchemaCompatibilityStrategyJSONBody defines parameters for SetNamespaceSchemaCompatibilityStrategy.
type SetNamespaceSchemaCompatibilityStrategyJSONBody = string

// GetSchemaValidtionEnforcedParams defines parameters for GetSchemaValidtionEnforced.
type GetSchemaValidtionEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`
}

// SetNamespaceSchemaValidationEnforcedJSONBody defines parameters for SetNamespaceSchemaValidationEnforced.
type SetNamespaceSchemaValidationEnforcedJSONBody = bool

// SetNamespaceSubscriptionAuthModeJSONBody defines parameters for SetNamespaceSubscriptionAuthMode.
type SetNamespaceSubscriptionAuthModeJSONBody = string

// SetNamespaceSubscriptionExpirationTimeJSONBody defines parameters for SetNamespaceSubscriptionExpirationTime.
type SetNamespaceSubscriptionExpirationTimeJSONBody = int32

// SetNamespaceSubscriptionTypesEnabledJSONBody defines parameters for SetNamespaceSubscriptionTypesEnabled.
type SetNamespaceSubscriptionTypesEnabledJSONBody = []string

// GetTopicsParams defines parameters for GetTopics.
type GetTopicsParams struct {
	Mode *GetTopicsParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// GetTopicsParamsMode defines parameters for GetTopics.
type GetTopicsParamsMode string

// UnsubscribeNamespaceParams defines parameters for UnsubscribeNamespace.
type UnsubscribeNamespaceParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNamespaceBundleParams defines parameters for DeleteNamespaceBundle.
type DeleteNamespaceBundleParams struct {
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ClearNamespaceBundleBacklogParams defines parameters for ClearNamespaceBundleBacklog.
type ClearNamespaceBundleBacklogParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ClearNamespaceBundleBacklogForSubscriptionParams defines parameters for ClearNamespaceBundleBacklogForSubscription.
type ClearNamespaceBundleBacklogForSubscriptionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SplitNamespaceBundleJSONBody defines parameters for SplitNamespaceBundle.
type SplitNamespaceBundleJSONBody = []int64

// SplitNamespaceBundleParams defines parameters for SplitNamespaceBundle.
type SplitNamespaceBundleParams struct {
	Authoritative      *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Unload             *bool   `form:"unload,omitempty" json:"unload,omitempty"`
	SplitAlgorithmName *string `form:"splitAlgorithmName,omitempty" json:"splitAlgorithmName,omitempty"`
}

// GetTopicHashPositionsParams defines parameters for GetTopicHashPositions.
type GetTopicHashPositionsParams struct {
	Topics *[]string `form:"topics,omitempty" json:"topics,omitempty"`
}

// UnloadNamespaceBundleParams defines parameters for UnloadNamespaceBundle.
type UnloadNamespaceBundleParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UnsubscribeNamespaceBundleParams defines parameters for UnsubscribeNamespaceBundle.
type UnsubscribeNamespaceBundleParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicListParams defines parameters for GetNonPersistentTopicList.
type GetNonPersistentTopicListParams struct {
	// Bundle Specify the bundle name
	Bundle *string `form:"bundle,omitempty" json:"bundle,omitempty"`

	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// GetNonPersistentPartitionedTopicListParams defines parameters for GetNonPersistentPartitionedTopicList.
type GetNonPersistentPartitionedTopicListParams struct {
	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// DeleteNonPersistentTopicParams defines parameters for DeleteNonPersistentTopic.
type DeleteNonPersistentTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreateNonPersistentTopicNonPartitionedTopicParams defines parameters for CreateNonPersistentTopicNonPartitionedTopic.
type CreateNonPersistentTopicNonPartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireNonPersistentTopicMessagesForAllSubscriptionsParams defines parameters for ExpireNonPersistentTopicMessagesForAllSubscriptions.
type ExpireNonPersistentTopicMessagesForAllSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicBacklogParams defines parameters for GetNonPersistentTopicBacklog.
type GetNonPersistentTopicBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicBacklogQuotaParams defines parameters for RemoveNonPersistentTopicBacklogQuota.
type RemoveNonPersistentTopicBacklogQuotaParams struct {
	BacklogQuotaType *RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaType defines parameters for RemoveNonPersistentTopicBacklogQuota.
type RemoveNonPersistentTopicBacklogQuotaParamsBacklogQuotaType string

// SetNonPersistentTopicBacklogQuotaParams defines parameters for SetNonPersistentTopicBacklogQuota.
type SetNonPersistentTopicBacklogQuotaParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative    *bool                                                    `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal         *bool                                                    `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	BacklogQuotaType *SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaType defines parameters for SetNonPersistentTopicBacklogQuota.
type SetNonPersistentTopicBacklogQuotaParamsBacklogQuotaType string

// GetNonPersistentTopicBacklogQuotaMapParams defines parameters for GetNonPersistentTopicBacklogQuotaMap.
type GetNonPersistentTopicBacklogQuotaMapParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetNonPersistentTopicBacklogSizeByMessageIdParams defines parameters for GetNonPersistentTopicBacklogSizeByMessageId.
type GetNonPersistentTopicBacklogSizeByMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicCompactionStatusParams defines parameters for GetNonPersistentTopicCompactionStatus.
type GetNonPersistentTopicCompactionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CompactNonPersistentTopicParams defines parameters for CompactNonPersistentTopic.
type CompactNonPersistentTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicCompactionThresholdParams defines parameters for RemoveNonPersistentTopicCompactionThreshold.
type RemoveNonPersistentTopicCompactionThresholdParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicCompactionThresholdParams defines parameters for GetNonPersistentTopicCompactionThreshold.
type GetNonPersistentTopicCompactionThresholdParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicCompactionThresholdParams defines parameters for SetNonPersistentTopicCompactionThreshold.
type SetNonPersistentTopicCompactionThresholdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveNonPersistentTopicDeduplicationParams defines parameters for RemoveNonPersistentTopicDeduplication.
type RemoveNonPersistentTopicDeduplicationParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicDeduplicationParams defines parameters for GetNonPersistentTopicDeduplication.
type GetNonPersistentTopicDeduplicationParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicDeduplicationParams defines parameters for SetNonPersistentTopicDeduplication.
type SetNonPersistentTopicDeduplicationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNonPersistentTopicDeduplicationSnapshotIntervalParams defines parameters for DeleteNonPersistentTopicDeduplicationSnapshotInterval.
type DeleteNonPersistentTopicDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicDeduplicationSnapshotIntervalParams defines parameters for GetNonPersistentTopicDeduplicationSnapshotInterval.
type GetNonPersistentTopicDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicDeduplicationSnapshotIntervalParams defines parameters for SetNonPersistentTopicDeduplicationSnapshotInterval.
type SetNonPersistentTopicDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNonPersistentTopicDelayedDeliveryPoliciesParams defines parameters for DeleteNonPersistentTopicDelayedDeliveryPolicies.
type DeleteNonPersistentTopicDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicDelayedDeliveryPoliciesParams defines parameters for GetNonPersistentTopicDelayedDeliveryPolicies.
type GetNonPersistentTopicDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicDelayedDeliveryPoliciesParams defines parameters for SetNonPersistentTopicDelayedDeliveryPolicies.
type SetNonPersistentTopicDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicDispatchRateParams defines parameters for RemoveNonPersistentTopicDispatchRate.
type RemoveNonPersistentTopicDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicDispatchRateParams defines parameters for GetNonPersistentTopicDispatchRate.
type GetNonPersistentTopicDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicDispatchRateParams defines parameters for SetNonPersistentTopicDispatchRate.
type SetNonPersistentTopicDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveNonPersistentTopicEntryFiltersParams defines parameters for RemoveNonPersistentTopicEntryFilters.
type RemoveNonPersistentTopicEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicEntryFiltersParams defines parameters for GetNonPersistentTopicEntryFilters.
type GetNonPersistentTopicEntryFiltersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicEntryFiltersParams defines parameters for SetNonPersistentTopicEntryFilters.
type SetNonPersistentTopicEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExamineNonPersistentTopicMessageParams defines parameters for ExamineNonPersistentTopicMessage.
type ExamineNonPersistentTopicMessageParams struct {
	// InitialPosition Relative start position to examine message.It can be 'latest' or 'earliest'
	InitialPosition *ExamineNonPersistentTopicMessageParamsInitialPosition `form:"initialPosition,omitempty" json:"initialPosition,omitempty"`

	// MessagePosition The position of messages (default 1)
	MessagePosition *int64 `form:"messagePosition,omitempty" json:"messagePosition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExamineNonPersistentTopicMessageParamsInitialPosition defines parameters for ExamineNonPersistentTopicMessage.
type ExamineNonPersistentTopicMessageParamsInitialPosition string

// DeleteNonPersistentTopicInactiveTopicPoliciesParams defines parameters for DeleteNonPersistentTopicInactiveTopicPolicies.
type DeleteNonPersistentTopicInactiveTopicPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicInactiveTopicPoliciesParams defines parameters for GetNonPersistentTopicInactiveTopicPolicies.
type GetNonPersistentTopicInactiveTopicPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicInactiveTopicPoliciesParams defines parameters for SetNonPersistentTopicInactiveTopicPolicies.
type SetNonPersistentTopicInactiveTopicPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetNonPersistentTopicManagedLedgerInfoParams defines parameters for GetNonPersistentTopicManagedLedgerInfo.
type GetNonPersistentTopicManagedLedgerInfoParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicInternalStatsParams defines parameters for GetNonPersistentTopicInternalStats.
type GetNonPersistentTopicInternalStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Metadata      *bool `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetNonPersistentTopicLastMessageIdParams defines parameters for GetNonPersistentTopicLastMessageId.
type GetNonPersistentTopicLastMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMessageByIdParams defines parameters for GetNonPersistentTopicMessageById.
type GetNonPersistentTopicMessageByIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicMaxConsumersParams defines parameters for RemoveNonPersistentTopicMaxConsumers.
type RemoveNonPersistentTopicMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMaxConsumersParams defines parameters for GetNonPersistentTopicMaxConsumers.
type GetNonPersistentTopicMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMaxConsumersParams defines parameters for SetNonPersistentTopicMaxConsumers.
type SetNonPersistentTopicMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicMaxConsumersPerSubscriptionParams defines parameters for RemoveNonPersistentTopicMaxConsumersPerSubscription.
type RemoveNonPersistentTopicMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMaxConsumersPerSubscriptionParams defines parameters for GetNonPersistentTopicMaxConsumersPerSubscription.
type GetNonPersistentTopicMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMaxConsumersPerSubscriptionParams defines parameters for SetNonPersistentTopicMaxConsumersPerSubscription.
type SetNonPersistentTopicMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicMaxMessageSizeParams defines parameters for RemoveNonPersistentTopicMaxMessageSize.
type RemoveNonPersistentTopicMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMaxMessageSizeParams defines parameters for GetNonPersistentTopicMaxMessageSize.
type GetNonPersistentTopicMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMaxMessageSizeParams defines parameters for SetNonPersistentTopicMaxMessageSize.
type SetNonPersistentTopicMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicMaxProducersParams defines parameters for RemoveNonPersistentTopicMaxProducers.
type RemoveNonPersistentTopicMaxProducersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMaxProducersParams defines parameters for GetNonPersistentTopicMaxProducers.
type GetNonPersistentTopicMaxProducersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMaxProducersParams defines parameters for SetNonPersistentTopicMaxProducers.
type SetNonPersistentTopicMaxProducersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveNonPersistentTopicMaxSubscriptionsPerTopicParams defines parameters for RemoveNonPersistentTopicMaxSubscriptionsPerTopic.
type RemoveNonPersistentTopicMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMaxSubscriptionsPerTopicParams defines parameters for GetNonPersistentTopicMaxSubscriptionsPerTopic.
type GetNonPersistentTopicMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMaxSubscriptionsPerTopicParams defines parameters for SetNonPersistentTopicMaxSubscriptionsPerTopic.
type SetNonPersistentTopicMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerParams defines parameters for DeleteNonPersistentTopicMaxUnackedMessagesOnConsumer.
type DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMaxUnackedMessagesOnConsumerParams defines parameters for GetNonPersistentTopicMaxUnackedMessagesOnConsumer.
type GetNonPersistentTopicMaxUnackedMessagesOnConsumerParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMaxUnackedMessagesOnConsumerParams defines parameters for SetNonPersistentTopicMaxUnackedMessagesOnConsumer.
type SetNonPersistentTopicMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams defines parameters for DeleteNonPersistentTopicMaxUnackedMessagesOnSubscription.
type DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams defines parameters for GetNonPersistentTopicMaxUnackedMessagesOnSubscription.
type GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams defines parameters for SetNonPersistentTopicMaxUnackedMessagesOnSubscription.
type SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicMessageTTLParams defines parameters for RemoveNonPersistentTopicMessageTTL.
type RemoveNonPersistentTopicMessageTTLParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMessageTTLParams defines parameters for GetNonPersistentTopicMessageTTL.
type GetNonPersistentTopicMessageTTLParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicMessageTTLParams defines parameters for SetNonPersistentTopicMessageTTL.
type SetNonPersistentTopicMessageTTLParams struct {
	// MessageTTL TTL in seconds for the specified namespace
	MessageTTL int32 `form:"messageTTL" json:"messageTTL"`
	IsGlobal   *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicMessageIdByTimestampParams defines parameters for GetNonPersistentTopicMessageIdByTimestamp.
type GetNonPersistentTopicMessageIdByTimestampParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// OffloadNonPersistentTopicStatusParams defines parameters for OffloadNonPersistentTopicStatus.
type OffloadNonPersistentTopicStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TriggerNonPersistentTopicOffloadParams defines parameters for TriggerNonPersistentTopicOffload.
type TriggerNonPersistentTopicOffloadParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicOffloadPoliciesParams defines parameters for RemoveNonPersistentTopicOffloadPolicies.
type RemoveNonPersistentTopicOffloadPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicOffloadPoliciesParams defines parameters for GetNonPersistentTopicOffloadPolicies.
type GetNonPersistentTopicOffloadPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicOffloadPoliciesParams defines parameters for SetNonPersistentTopicOffloadPolicies.
type SetNonPersistentTopicOffloadPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetNonPersistentTopicPartitionedStatsParams defines parameters for GetNonPersistentTopicPartitionedStats.
type GetNonPersistentTopicPartitionedStatsParams struct {
	// PerPartition Get per partition stats
	PerPartition *bool `form:"perPartition,omitempty" json:"perPartition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return the earliest time in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// DeleteNonPersistentTopicPartitionedTopicParams defines parameters for DeleteNonPersistentTopicPartitionedTopic.
type DeleteNonPersistentTopicPartitionedTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicPartitionedMetadataParams defines parameters for GetNonPersistentTopicPartitionedMetadata.
type GetNonPersistentTopicPartitionedMetadataParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// CheckAllowAutoCreation Is check configuration required to automatically create topic
	CheckAllowAutoCreation *bool `form:"checkAllowAutoCreation,omitempty" json:"checkAllowAutoCreation,omitempty"`
}

// UpdateNonPersistentTopicPartitionedTopicParams defines parameters for UpdateNonPersistentTopicPartitionedTopic.
type UpdateNonPersistentTopicPartitionedTopicParams struct {
	UpdateLocalTopicOnly *bool `form:"updateLocalTopicOnly,omitempty" json:"updateLocalTopicOnly,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// CreateNonPersistentTopicPartitionedTopicParams defines parameters for CreateNonPersistentTopicPartitionedTopic.
type CreateNonPersistentTopicPartitionedTopicParams struct {
	CreateLocalTopicOnly *bool `form:"createLocalTopicOnly,omitempty" json:"createLocalTopicOnly,omitempty"`
}

// RemoveNonPersistentTopicPersistenceParams defines parameters for RemoveNonPersistentTopicPersistence.
type RemoveNonPersistentTopicPersistenceParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicPersistenceParams defines parameters for GetNonPersistentTopicPersistence.
type GetNonPersistentTopicPersistenceParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicPersistenceParams defines parameters for SetNonPersistentTopicPersistence.
type SetNonPersistentTopicPersistenceParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveNonPersistentTopicPropertiesParams defines parameters for RemoveNonPersistentTopicProperties.
type RemoveNonPersistentTopicPropertiesParams struct {
	Key           *string `form:"key,omitempty" json:"key,omitempty"`
	Authoritative *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicPropertiesParams defines parameters for GetNonPersistentTopicProperties.
type GetNonPersistentTopicPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdateNonPersistentTopicPropertiesParams defines parameters for UpdateNonPersistentTopicProperties.
type UpdateNonPersistentTopicPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicPublishRateParams defines parameters for RemoveNonPersistentTopicPublishRate.
type RemoveNonPersistentTopicPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicPublishRateParams defines parameters for GetNonPersistentTopicPublishRate.
type GetNonPersistentTopicPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicPublishRateParams defines parameters for SetNonPersistentTopicPublishRate.
type SetNonPersistentTopicPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicReplicationClustersParams defines parameters for RemoveNonPersistentTopicReplicationClusters.
type RemoveNonPersistentTopicReplicationClustersParams struct {
	BacklogQuotaType *RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaType defines parameters for RemoveNonPersistentTopicReplicationClusters.
type RemoveNonPersistentTopicReplicationClustersParamsBacklogQuotaType string

// GetNonPersistentTopicReplicationClustersParams defines parameters for GetNonPersistentTopicReplicationClusters.
type GetNonPersistentTopicReplicationClustersParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicReplicationClustersParams defines parameters for SetNonPersistentTopicReplicationClusters.
type SetNonPersistentTopicReplicationClustersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicReplicatorDispatchRateParams defines parameters for RemoveNonPersistentTopicReplicatorDispatchRate.
type RemoveNonPersistentTopicReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicReplicatorDispatchRateParams defines parameters for GetNonPersistentTopicReplicatorDispatchRate.
type GetNonPersistentTopicReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicReplicatorDispatchRateParams defines parameters for SetNonPersistentTopicReplicatorDispatchRate.
type SetNonPersistentTopicReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicRetentionParams defines parameters for RemoveNonPersistentTopicRetention.
type RemoveNonPersistentTopicRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicRetentionParams defines parameters for GetNonPersistentTopicRetention.
type GetNonPersistentTopicRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicRetentionParams defines parameters for SetNonPersistentTopicRetention.
type SetNonPersistentTopicRetentionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveNonPersistentTopicSchemaCompatibilityStrategyParams defines parameters for RemoveNonPersistentTopicSchemaCompatibilityStrategy.
type RemoveNonPersistentTopicSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSchemaCompatibilityStrategyParams defines parameters for GetNonPersistentTopicSchemaCompatibilityStrategy.
type GetNonPersistentTopicSchemaCompatibilityStrategyParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicSchemaCompatibilityStrategyParams defines parameters for SetNonPersistentTopicSchemaCompatibilityStrategy.
type SetNonPersistentTopicSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSchemaValidationEnforcedParams defines parameters for GetNonPersistentTopicSchemaValidationEnforced.
type GetNonPersistentTopicSchemaValidationEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicSchemaValidationEnforcedParams defines parameters for SetNonPersistentTopicSchemaValidationEnforced.
type SetNonPersistentTopicSchemaValidationEnforcedParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNonPersistentTopicShadowTopicsParams defines parameters for DeleteNonPersistentTopicShadowTopics.
type DeleteNonPersistentTopicShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicShadowTopicsParams defines parameters for GetNonPersistentTopicShadowTopics.
type GetNonPersistentTopicShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicShadowTopicsParams defines parameters for SetNonPersistentTopicShadowTopics.
type SetNonPersistentTopicShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicStatsParams defines parameters for GetNonPersistentTopicStats.
type GetNonPersistentTopicStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return time of the earliest message in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// RemoveNonPersistentTopicSubscribeRateParams defines parameters for RemoveNonPersistentTopicSubscribeRate.
type RemoveNonPersistentTopicSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSubscribeRateParams defines parameters for GetNonPersistentTopicSubscribeRate.
type GetNonPersistentTopicSubscribeRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicSubscribeRateParams defines parameters for SetNonPersistentTopicSubscribeRate.
type SetNonPersistentTopicSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteNonPersistentTopicSubscriptionParams defines parameters for DeleteNonPersistentTopicSubscription.
type DeleteNonPersistentTopicSubscriptionParams struct {
	// Force Disconnect and close all consumers and delete subscription forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// AnalyzeNonPersistentTopicSubscriptionBacklogParams defines parameters for AnalyzeNonPersistentTopicSubscriptionBacklog.
type AnalyzeNonPersistentTopicSubscriptionBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireNonPersistentTopicMessagesParams defines parameters for ExpireNonPersistentTopicMessages.
type ExpireNonPersistentTopicMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpireNonPersistentTopicMessagesTimeInSecondsParams defines parameters for ExpireNonPersistentTopicMessagesTimeInSeconds.
type ExpireNonPersistentTopicMessagesTimeInSecondsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PeekNonPersistentTopicNthMessageParams defines parameters for PeekNonPersistentTopicNthMessage.
type PeekNonPersistentTopicNthMessageParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSubscriptionPropertiesParams defines parameters for GetNonPersistentTopicSubscriptionProperties.
type GetNonPersistentTopicSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdateNonPersistentTopicSubscriptionPropertiesParams defines parameters for UpdateNonPersistentTopicSubscriptionProperties.
type UpdateNonPersistentTopicSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicReplicatedSubscriptionStatusParams defines parameters for GetNonPersistentTopicReplicatedSubscriptionStatus.
type GetNonPersistentTopicReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicReplicatedSubscriptionStatusParams defines parameters for SetNonPersistentTopicReplicatedSubscriptionStatus.
type SetNonPersistentTopicReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetNonPersistentTopicCursorOnPositionParams defines parameters for ResetNonPersistentTopicCursorOnPosition.
type ResetNonPersistentTopicCursorOnPositionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetNonPersistentTopicCursorParams defines parameters for ResetNonPersistentTopicCursor.
type ResetNonPersistentTopicCursorParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipNonPersistentTopicMessagesParams defines parameters for SkipNonPersistentTopicMessages.
type SkipNonPersistentTopicMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipNonPersistentTopicAllMessagesParams defines parameters for SkipNonPersistentTopicAllMessages.
type SkipNonPersistentTopicAllMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreateNonPersistentTopicSubscriptionParams defines parameters for CreateNonPersistentTopicSubscription.
type CreateNonPersistentTopicSubscriptionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Replicated Is replicated required to perform this operation
	Replicated *bool `form:"replicated,omitempty" json:"replicated,omitempty"`
}

// RemoveNonPersistentTopicSubscriptionDispatchRateParams defines parameters for RemoveNonPersistentTopicSubscriptionDispatchRate.
type RemoveNonPersistentTopicSubscriptionDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSubscriptionDispatchRateParams defines parameters for GetNonPersistentTopicSubscriptionDispatchRate.
type GetNonPersistentTopicSubscriptionDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicSubscriptionDispatchRateParams defines parameters for SetNonPersistentTopicSubscriptionDispatchRate.
type SetNonPersistentTopicSubscriptionDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemoveNonPersistentTopicSubscriptionTypesEnabledParams defines parameters for RemoveNonPersistentTopicSubscriptionTypesEnabled.
type RemoveNonPersistentTopicSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSubscriptionTypesEnabledParams defines parameters for GetNonPersistentTopicSubscriptionTypesEnabled.
type GetNonPersistentTopicSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicSubscriptionTypesEnabledParams defines parameters for SetNonPersistentTopicSubscriptionTypesEnabled.
type SetNonPersistentTopicSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSubscriptionsParams defines parameters for GetNonPersistentTopicSubscriptions.
type GetNonPersistentTopicSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminateNonPersistentTopicParams defines parameters for TerminateNonPersistentTopic.
type TerminateNonPersistentTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminateNonPersistentTopicPartitionedTopicParams defines parameters for TerminateNonPersistentTopicPartitionedTopic.
type TerminateNonPersistentTopicPartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TruncateNonPersistentTopicTopicParams defines parameters for TruncateNonPersistentTopicTopic.
type TruncateNonPersistentTopicTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UnloadNonPersistentTopicTopicParams defines parameters for UnloadNonPersistentTopicTopic.
type UnloadNonPersistentTopicTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemoveNonPersistentTopicSubscriptionLevelDispatchRateParams defines parameters for RemoveNonPersistentTopicSubscriptionLevelDispatchRate.
type RemoveNonPersistentTopicSubscriptionLevelDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetNonPersistentTopicSubscriptionLevelDispatchRateParams defines parameters for GetNonPersistentTopicSubscriptionLevelDispatchRate.
type GetNonPersistentTopicSubscriptionLevelDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetNonPersistentTopicSubscriptionLevelDispatchRateParams defines parameters for SetNonPersistentTopicSubscriptionLevelDispatchRate.
type SetNonPersistentTopicSubscriptionLevelDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetPersistentTopicListParams defines parameters for GetPersistentTopicList.
type GetPersistentTopicListParams struct {
	// Bundle Specify the bundle name
	Bundle *string `form:"bundle,omitempty" json:"bundle,omitempty"`

	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// GetPersistentPartitionedTopicListParams defines parameters for GetPersistentPartitionedTopicList.
type GetPersistentPartitionedTopicListParams struct {
	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// DeletePersistentTopicParams defines parameters for DeletePersistentTopic.
type DeletePersistentTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreatePersistentTopicNonPartitionedTopicParams defines parameters for CreatePersistentTopicNonPartitionedTopic.
type CreatePersistentTopicNonPartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpirePersistentTopicMessagesForAllSubscriptionsParams defines parameters for ExpirePersistentTopicMessagesForAllSubscriptions.
type ExpirePersistentTopicMessagesForAllSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicBacklogParams defines parameters for GetPersistentTopicBacklog.
type GetPersistentTopicBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicBacklogQuotaParams defines parameters for RemovePersistentTopicBacklogQuota.
type RemovePersistentTopicBacklogQuotaParams struct {
	BacklogQuotaType *RemovePersistentTopicBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePersistentTopicBacklogQuotaParamsBacklogQuotaType defines parameters for RemovePersistentTopicBacklogQuota.
type RemovePersistentTopicBacklogQuotaParamsBacklogQuotaType string

// SetPersistentTopicBacklogQuotaParams defines parameters for SetPersistentTopicBacklogQuota.
type SetPersistentTopicBacklogQuotaParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative    *bool                                                 `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal         *bool                                                 `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	BacklogQuotaType *SetPersistentTopicBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// SetPersistentTopicBacklogQuotaParamsBacklogQuotaType defines parameters for SetPersistentTopicBacklogQuota.
type SetPersistentTopicBacklogQuotaParamsBacklogQuotaType string

// GetPersistentTopicBacklogQuotaMapParams defines parameters for GetPersistentTopicBacklogQuotaMap.
type GetPersistentTopicBacklogQuotaMapParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetPersistentTopicBacklogSizeByMessageIdParams defines parameters for GetPersistentTopicBacklogSizeByMessageId.
type GetPersistentTopicBacklogSizeByMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicCompactionStatusParams defines parameters for GetPersistentTopicCompactionStatus.
type GetPersistentTopicCompactionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CompactPersistentTopicParams defines parameters for CompactPersistentTopic.
type CompactPersistentTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicCompactionThresholdParams defines parameters for RemovePersistentTopicCompactionThreshold.
type RemovePersistentTopicCompactionThresholdParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicCompactionThresholdParams defines parameters for GetPersistentTopicCompactionThreshold.
type GetPersistentTopicCompactionThresholdParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicCompactionThresholdParams defines parameters for SetPersistentTopicCompactionThreshold.
type SetPersistentTopicCompactionThresholdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePersistentTopicDeduplicationParams defines parameters for RemovePersistentTopicDeduplication.
type RemovePersistentTopicDeduplicationParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicDeduplicationParams defines parameters for GetPersistentTopicDeduplication.
type GetPersistentTopicDeduplicationParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicDeduplicationParams defines parameters for SetPersistentTopicDeduplication.
type SetPersistentTopicDeduplicationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeletePersistentTopicDeduplicationSnapshotIntervalParams defines parameters for DeletePersistentTopicDeduplicationSnapshotInterval.
type DeletePersistentTopicDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicDeduplicationSnapshotIntervalParams defines parameters for GetPersistentTopicDeduplicationSnapshotInterval.
type GetPersistentTopicDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicDeduplicationSnapshotIntervalParams defines parameters for SetPersistentTopicDeduplicationSnapshotInterval.
type SetPersistentTopicDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeletePersistentTopicDelayedDeliveryPoliciesParams defines parameters for DeletePersistentTopicDelayedDeliveryPolicies.
type DeletePersistentTopicDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicDelayedDeliveryPoliciesParams defines parameters for GetPersistentTopicDelayedDeliveryPolicies.
type GetPersistentTopicDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicDelayedDeliveryPoliciesParams defines parameters for SetPersistentTopicDelayedDeliveryPolicies.
type SetPersistentTopicDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicDispatchRateParams defines parameters for RemovePersistentTopicDispatchRate.
type RemovePersistentTopicDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicDispatchRateParams defines parameters for GetPersistentTopicDispatchRate.
type GetPersistentTopicDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicDispatchRateParams defines parameters for SetPersistentTopicDispatchRate.
type SetPersistentTopicDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePersistentTopicEntryFiltersParams defines parameters for RemovePersistentTopicEntryFilters.
type RemovePersistentTopicEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicEntryFiltersParams defines parameters for GetPersistentTopicEntryFilters.
type GetPersistentTopicEntryFiltersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicEntryFiltersParams defines parameters for SetPersistentTopicEntryFilters.
type SetPersistentTopicEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExaminePersistentTopicMessageParams defines parameters for ExaminePersistentTopicMessage.
type ExaminePersistentTopicMessageParams struct {
	// InitialPosition Relative start position to examine message.It can be 'latest' or 'earliest'
	InitialPosition *ExaminePersistentTopicMessageParamsInitialPosition `form:"initialPosition,omitempty" json:"initialPosition,omitempty"`

	// MessagePosition The position of messages (default 1)
	MessagePosition *int64 `form:"messagePosition,omitempty" json:"messagePosition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExaminePersistentTopicMessageParamsInitialPosition defines parameters for ExaminePersistentTopicMessage.
type ExaminePersistentTopicMessageParamsInitialPosition string

// DeletePersistentTopicInactiveTopicPoliciesParams defines parameters for DeletePersistentTopicInactiveTopicPolicies.
type DeletePersistentTopicInactiveTopicPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicInactiveTopicPoliciesParams defines parameters for GetPersistentTopicInactiveTopicPolicies.
type GetPersistentTopicInactiveTopicPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicInactiveTopicPoliciesParams defines parameters for SetPersistentTopicInactiveTopicPolicies.
type SetPersistentTopicInactiveTopicPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetPersistentTopicManagedLedgerInfoParams defines parameters for GetPersistentTopicManagedLedgerInfo.
type GetPersistentTopicManagedLedgerInfoParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicInternalStatsParams defines parameters for GetPersistentTopicInternalStats.
type GetPersistentTopicInternalStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Metadata      *bool `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetPersistentTopicLastMessageIdParams defines parameters for GetPersistentTopicLastMessageId.
type GetPersistentTopicLastMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMessageByIdParams defines parameters for GetPersistentTopicMessageById.
type GetPersistentTopicMessageByIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicMaxConsumersParams defines parameters for RemovePersistentTopicMaxConsumers.
type RemovePersistentTopicMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMaxConsumersParams defines parameters for GetPersistentTopicMaxConsumers.
type GetPersistentTopicMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMaxConsumersParams defines parameters for SetPersistentTopicMaxConsumers.
type SetPersistentTopicMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicMaxConsumersPerSubscriptionParams defines parameters for RemovePersistentTopicMaxConsumersPerSubscription.
type RemovePersistentTopicMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMaxConsumersPerSubscriptionParams defines parameters for GetPersistentTopicMaxConsumersPerSubscription.
type GetPersistentTopicMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMaxConsumersPerSubscriptionParams defines parameters for SetPersistentTopicMaxConsumersPerSubscription.
type SetPersistentTopicMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicMaxMessageSizeParams defines parameters for RemovePersistentTopicMaxMessageSize.
type RemovePersistentTopicMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMaxMessageSizeParams defines parameters for GetPersistentTopicMaxMessageSize.
type GetPersistentTopicMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMaxMessageSizeParams defines parameters for SetPersistentTopicMaxMessageSize.
type SetPersistentTopicMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicMaxProducersParams defines parameters for RemovePersistentTopicMaxProducers.
type RemovePersistentTopicMaxProducersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMaxProducersParams defines parameters for GetPersistentTopicMaxProducers.
type GetPersistentTopicMaxProducersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMaxProducersParams defines parameters for SetPersistentTopicMaxProducers.
type SetPersistentTopicMaxProducersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePersistentTopicMaxSubscriptionsPerTopicParams defines parameters for RemovePersistentTopicMaxSubscriptionsPerTopic.
type RemovePersistentTopicMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMaxSubscriptionsPerTopicParams defines parameters for GetPersistentTopicMaxSubscriptionsPerTopic.
type GetPersistentTopicMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMaxSubscriptionsPerTopicParams defines parameters for SetPersistentTopicMaxSubscriptionsPerTopic.
type SetPersistentTopicMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeletePersistentTopicMaxUnackedMessagesOnConsumerParams defines parameters for DeletePersistentTopicMaxUnackedMessagesOnConsumer.
type DeletePersistentTopicMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMaxUnackedMessagesOnConsumerParams defines parameters for GetPersistentTopicMaxUnackedMessagesOnConsumer.
type GetPersistentTopicMaxUnackedMessagesOnConsumerParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMaxUnackedMessagesOnConsumerParams defines parameters for SetPersistentTopicMaxUnackedMessagesOnConsumer.
type SetPersistentTopicMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeletePersistentTopicMaxUnackedMessagesOnSubscriptionParams defines parameters for DeletePersistentTopicMaxUnackedMessagesOnSubscription.
type DeletePersistentTopicMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMaxUnackedMessagesOnSubscriptionParams defines parameters for GetPersistentTopicMaxUnackedMessagesOnSubscription.
type GetPersistentTopicMaxUnackedMessagesOnSubscriptionParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMaxUnackedMessagesOnSubscriptionParams defines parameters for SetPersistentTopicMaxUnackedMessagesOnSubscription.
type SetPersistentTopicMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicMessageTTLParams defines parameters for RemovePersistentTopicMessageTTL.
type RemovePersistentTopicMessageTTLParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMessageTTLParams defines parameters for GetPersistentTopicMessageTTL.
type GetPersistentTopicMessageTTLParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicMessageTTLParams defines parameters for SetPersistentTopicMessageTTL.
type SetPersistentTopicMessageTTLParams struct {
	// MessageTTL TTL in seconds for the specified namespace
	MessageTTL int32 `form:"messageTTL" json:"messageTTL"`
	IsGlobal   *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicMessageIdByTimestampParams defines parameters for GetPersistentTopicMessageIdByTimestamp.
type GetPersistentTopicMessageIdByTimestampParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// OffloadPersistentTopicStatusParams defines parameters for OffloadPersistentTopicStatus.
type OffloadPersistentTopicStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TriggerPersistentTopicOffloadParams defines parameters for TriggerPersistentTopicOffload.
type TriggerPersistentTopicOffloadParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicOffloadPoliciesParams defines parameters for RemovePersistentTopicOffloadPolicies.
type RemovePersistentTopicOffloadPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicOffloadPoliciesParams defines parameters for GetPersistentTopicOffloadPolicies.
type GetPersistentTopicOffloadPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicOffloadPoliciesParams defines parameters for SetPersistentTopicOffloadPolicies.
type SetPersistentTopicOffloadPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// GetPersistentTopicPartitionedStatsParams defines parameters for GetPersistentTopicPartitionedStats.
type GetPersistentTopicPartitionedStatsParams struct {
	// PerPartition Get per partition stats
	PerPartition *bool `form:"perPartition,omitempty" json:"perPartition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return the earliest time in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// DeletePersistentTopicPartitionedTopicParams defines parameters for DeletePersistentTopicPartitionedTopic.
type DeletePersistentTopicPartitionedTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicPartitionedMetadataParams defines parameters for GetPersistentTopicPartitionedMetadata.
type GetPersistentTopicPartitionedMetadataParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// CheckAllowAutoCreation Is check configuration required to automatically create topic
	CheckAllowAutoCreation *bool `form:"checkAllowAutoCreation,omitempty" json:"checkAllowAutoCreation,omitempty"`
}

// UpdatePersistentTopicPartitionedTopicParams defines parameters for UpdatePersistentTopicPartitionedTopic.
type UpdatePersistentTopicPartitionedTopicParams struct {
	UpdateLocalTopicOnly *bool `form:"updateLocalTopicOnly,omitempty" json:"updateLocalTopicOnly,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// CreatePersistentTopicPartitionedTopicParams defines parameters for CreatePersistentTopicPartitionedTopic.
type CreatePersistentTopicPartitionedTopicParams struct {
	CreateLocalTopicOnly *bool `form:"createLocalTopicOnly,omitempty" json:"createLocalTopicOnly,omitempty"`
}

// RemovePersistentTopicPersistenceParams defines parameters for RemovePersistentTopicPersistence.
type RemovePersistentTopicPersistenceParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicPersistenceParams defines parameters for GetPersistentTopicPersistence.
type GetPersistentTopicPersistenceParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicPersistenceParams defines parameters for SetPersistentTopicPersistence.
type SetPersistentTopicPersistenceParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePersistentTopicPropertiesParams defines parameters for RemovePersistentTopicProperties.
type RemovePersistentTopicPropertiesParams struct {
	Key           *string `form:"key,omitempty" json:"key,omitempty"`
	Authoritative *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicPropertiesParams defines parameters for GetPersistentTopicProperties.
type GetPersistentTopicPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdatePersistentTopicPropertiesParams defines parameters for UpdatePersistentTopicProperties.
type UpdatePersistentTopicPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicPublishRateParams defines parameters for RemovePersistentTopicPublishRate.
type RemovePersistentTopicPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicPublishRateParams defines parameters for GetPersistentTopicPublishRate.
type GetPersistentTopicPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicPublishRateParams defines parameters for SetPersistentTopicPublishRate.
type SetPersistentTopicPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicReplicationClustersParams defines parameters for RemovePersistentTopicReplicationClusters.
type RemovePersistentTopicReplicationClustersParams struct {
	BacklogQuotaType *RemovePersistentTopicReplicationClustersParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicReplicationClustersParamsBacklogQuotaType defines parameters for RemovePersistentTopicReplicationClusters.
type RemovePersistentTopicReplicationClustersParamsBacklogQuotaType string

// GetPersistentTopicReplicationClustersParams defines parameters for GetPersistentTopicReplicationClusters.
type GetPersistentTopicReplicationClustersParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicReplicationClustersParams defines parameters for SetPersistentTopicReplicationClusters.
type SetPersistentTopicReplicationClustersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicReplicatorDispatchRateParams defines parameters for RemovePersistentTopicReplicatorDispatchRate.
type RemovePersistentTopicReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicReplicatorDispatchRateParams defines parameters for GetPersistentTopicReplicatorDispatchRate.
type GetPersistentTopicReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicReplicatorDispatchRateParams defines parameters for SetPersistentTopicReplicatorDispatchRate.
type SetPersistentTopicReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicRetentionParams defines parameters for RemovePersistentTopicRetention.
type RemovePersistentTopicRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicRetentionParams defines parameters for GetPersistentTopicRetention.
type GetPersistentTopicRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicRetentionParams defines parameters for SetPersistentTopicRetention.
type SetPersistentTopicRetentionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePersistentTopicSchemaCompatibilityStrategyParams defines parameters for RemovePersistentTopicSchemaCompatibilityStrategy.
type RemovePersistentTopicSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSchemaCompatibilityStrategyParams defines parameters for GetPersistentTopicSchemaCompatibilityStrategy.
type GetPersistentTopicSchemaCompatibilityStrategyParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicSchemaCompatibilityStrategyParams defines parameters for SetPersistentTopicSchemaCompatibilityStrategy.
type SetPersistentTopicSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSchemaValidationEnforcedParams defines parameters for GetPersistentTopicSchemaValidationEnforced.
type GetPersistentTopicSchemaValidationEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicSchemaValidationEnforcedParams defines parameters for SetPersistentTopicSchemaValidationEnforced.
type SetPersistentTopicSchemaValidationEnforcedParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeletePersistentTopicShadowTopicsParams defines parameters for DeletePersistentTopicShadowTopics.
type DeletePersistentTopicShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicShadowTopicsParams defines parameters for GetPersistentTopicShadowTopics.
type GetPersistentTopicShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicShadowTopicsParams defines parameters for SetPersistentTopicShadowTopics.
type SetPersistentTopicShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicStatsParams defines parameters for GetPersistentTopicStats.
type GetPersistentTopicStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return time of the earliest message in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// RemovePersistentTopicSubscribeRateParams defines parameters for RemovePersistentTopicSubscribeRate.
type RemovePersistentTopicSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSubscribeRateParams defines parameters for GetPersistentTopicSubscribeRate.
type GetPersistentTopicSubscribeRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicSubscribeRateParams defines parameters for SetPersistentTopicSubscribeRate.
type SetPersistentTopicSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeletePersistentTopicSubscriptionParams defines parameters for DeletePersistentTopicSubscription.
type DeletePersistentTopicSubscriptionParams struct {
	// Force Disconnect and close all consumers and delete subscription forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// AnalyzePersistentTopicSubscriptionBacklogParams defines parameters for AnalyzePersistentTopicSubscriptionBacklog.
type AnalyzePersistentTopicSubscriptionBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpirePersistentTopicMessagesParams defines parameters for ExpirePersistentTopicMessages.
type ExpirePersistentTopicMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ExpirePersistentTopicMessagesTimeInSecondsParams defines parameters for ExpirePersistentTopicMessagesTimeInSeconds.
type ExpirePersistentTopicMessagesTimeInSecondsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PeekPersistentTopicNthMessageParams defines parameters for PeekPersistentTopicNthMessage.
type PeekPersistentTopicNthMessageParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSubscriptionPropertiesParams defines parameters for GetPersistentTopicSubscriptionProperties.
type GetPersistentTopicSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UpdatePersistentTopicSubscriptionPropertiesParams defines parameters for UpdatePersistentTopicSubscriptionProperties.
type UpdatePersistentTopicSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicReplicatedSubscriptionStatusParams defines parameters for GetPersistentTopicReplicatedSubscriptionStatus.
type GetPersistentTopicReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicReplicatedSubscriptionStatusParams defines parameters for SetPersistentTopicReplicatedSubscriptionStatus.
type SetPersistentTopicReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetPersistentTopicCursorOnPositionParams defines parameters for ResetPersistentTopicCursorOnPosition.
type ResetPersistentTopicCursorOnPositionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// ResetPersistentTopicCursorParams defines parameters for ResetPersistentTopicCursor.
type ResetPersistentTopicCursorParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipPersistentTopicMessagesParams defines parameters for SkipPersistentTopicMessages.
type SkipPersistentTopicMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SkipPersistentTopicAllMessagesParams defines parameters for SkipPersistentTopicAllMessages.
type SkipPersistentTopicAllMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// CreatePersistentTopicSubscriptionParams defines parameters for CreatePersistentTopicSubscription.
type CreatePersistentTopicSubscriptionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Replicated Is replicated required to perform this operation
	Replicated *bool `form:"replicated,omitempty" json:"replicated,omitempty"`
}

// RemovePersistentTopicSubscriptionDispatchRateParams defines parameters for RemovePersistentTopicSubscriptionDispatchRate.
type RemovePersistentTopicSubscriptionDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSubscriptionDispatchRateParams defines parameters for GetPersistentTopicSubscriptionDispatchRate.
type GetPersistentTopicSubscriptionDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicSubscriptionDispatchRateParams defines parameters for SetPersistentTopicSubscriptionDispatchRate.
type SetPersistentTopicSubscriptionDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// RemovePersistentTopicSubscriptionTypesEnabledParams defines parameters for RemovePersistentTopicSubscriptionTypesEnabled.
type RemovePersistentTopicSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSubscriptionTypesEnabledParams defines parameters for GetPersistentTopicSubscriptionTypesEnabled.
type GetPersistentTopicSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicSubscriptionTypesEnabledParams defines parameters for SetPersistentTopicSubscriptionTypesEnabled.
type SetPersistentTopicSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSubscriptionsParams defines parameters for GetPersistentTopicSubscriptions.
type GetPersistentTopicSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminatePersistentTopicParams defines parameters for TerminatePersistentTopic.
type TerminatePersistentTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TerminatePersistentTopicPartitionedTopicParams defines parameters for TerminatePersistentTopicPartitionedTopic.
type TerminatePersistentTopicPartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TruncatePersistentTopicTopicParams defines parameters for TruncatePersistentTopicTopic.
type TruncatePersistentTopicTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// UnloadPersistentTopicTopicParams defines parameters for UnloadPersistentTopicTopic.
type UnloadPersistentTopicTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// RemovePersistentTopicSubscriptionLevelDispatchRateParams defines parameters for RemovePersistentTopicSubscriptionLevelDispatchRate.
type RemovePersistentTopicSubscriptionLevelDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetPersistentTopicSubscriptionLevelDispatchRateParams defines parameters for GetPersistentTopicSubscriptionLevelDispatchRate.
type GetPersistentTopicSubscriptionLevelDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SetPersistentTopicSubscriptionLevelDispatchRateParams defines parameters for SetPersistentTopicSubscriptionLevelDispatchRate.
type SetPersistentTopicSubscriptionLevelDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// TestCompatibilityParams defines parameters for TestCompatibility.
type TestCompatibilityParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteSchemaParams defines parameters for DeleteSchema.
type DeleteSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetSchemaOfTopicParams defines parameters for GetSchemaOfTopic.
type GetSchemaOfTopicParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PostSchemaParams defines parameters for PostSchema.
type PostSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetSchemaOfTopicGivenVersionParams defines parameters for GetSchemaOfTopicGivenVersion.
type GetSchemaOfTopicGivenVersionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetAllSchemasParams defines parameters for GetAllSchemas.
type GetAllSchemasParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// GetVersionBySchemaParams defines parameters for GetVersionBySchema.
type GetVersionBySchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// DeleteTenantParams defines parameters for DeleteTenant.
type DeleteTenantParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetDrainStatusFromLeaderParams defines parameters for GetDrainStatusFromLeader.
type GetDrainStatusFromLeaderParams struct {
	WorkerId *string `form:"workerId,omitempty" json:"workerId,omitempty"`
}

// DrainAtLeaderParams defines parameters for DrainAtLeader.
type DrainAtLeaderParams struct {
	WorkerId *string `form:"workerId,omitempty" json:"workerId,omitempty"`
}

// CreateNamespaceJSONRequestBody defines body for CreateNamespace for application/json ContentType.
type CreateNamespaceJSONRequestBody = Policies

// SetNamespaceAntiAffinityGroupJSONRequestBody defines body for SetNamespaceAntiAffinityGroup for application/json ContentType.
type SetNamespaceAntiAffinityGroupJSONRequestBody = SetNamespaceAntiAffinityGroupJSONBody

// SetAutoSubscriptionCreationJSONRequestBody defines body for SetAutoSubscriptionCreation for application/json ContentType.
type SetAutoSubscriptionCreationJSONRequestBody = AutoSubscriptionCreationOverride

// SetAutoTopicCreationJSONRequestBody defines body for SetAutoTopicCreation for application/json ContentType.
type SetAutoTopicCreationJSONRequestBody = AutoTopicCreationOverride

// SetNamespaceBacklogQuotaJSONRequestBody defines body for SetNamespaceBacklogQuota for application/json ContentType.
type SetNamespaceBacklogQuotaJSONRequestBody = BacklogQuota

// SetNamespaceCompactionThresholdJSONRequestBody defines body for SetNamespaceCompactionThreshold for application/json ContentType.
type SetNamespaceCompactionThresholdJSONRequestBody = SetNamespaceCompactionThresholdJSONBody

// ModifyDeduplicationJSONRequestBody defines body for ModifyDeduplication for application/json ContentType.
type ModifyDeduplicationJSONRequestBody = ModifyDeduplicationJSONBody

// SetNamespaceDeduplicationSnapshotIntervalJSONRequestBody defines body for SetNamespaceDeduplicationSnapshotInterval for application/json ContentType.
type SetNamespaceDeduplicationSnapshotIntervalJSONRequestBody = SetNamespaceDeduplicationSnapshotIntervalJSONBody

// SetNamespaceDelayedDeliveryPoliciesJSONRequestBody defines body for SetNamespaceDelayedDeliveryPolicies for application/json ContentType.
type SetNamespaceDelayedDeliveryPoliciesJSONRequestBody = DelayedDeliveryPolicies

// SetNamespaceDispatchRateJSONRequestBody defines body for SetNamespaceDispatchRate for application/json ContentType.
type SetNamespaceDispatchRateJSONRequestBody = DispatchRateImpl

// ModifyEncryptionRequiredJSONRequestBody defines body for ModifyEncryptionRequired for application/json ContentType.
type ModifyEncryptionRequiredJSONRequestBody = ModifyEncryptionRequiredJSONBody

// SetEntryFiltersPerTopicJSONRequestBody defines body for SetEntryFiltersPerTopic for application/json ContentType.
type SetEntryFiltersPerTopicJSONRequestBody = EntryFilters

// SetNamespaceInactiveTopicPoliciesJSONRequestBody defines body for SetNamespaceInactiveTopicPolicies for application/json ContentType.
type SetNamespaceInactiveTopicPoliciesJSONRequestBody = InactiveTopicPolicies

// SetIsAllowAutoUpdateSchemaJSONRequestBody defines body for SetIsAllowAutoUpdateSchema for application/json ContentType.
type SetIsAllowAutoUpdateSchemaJSONRequestBody = SetIsAllowAutoUpdateSchemaJSONBody

// SetNamespaceMaxConsumersPerSubscriptionJSONRequestBody defines body for SetNamespaceMaxConsumersPerSubscription for application/json ContentType.
type SetNamespaceMaxConsumersPerSubscriptionJSONRequestBody = SetNamespaceMaxConsumersPerSubscriptionJSONBody

// SetNamespaceMaxConsumersPerTopicJSONRequestBody defines body for SetNamespaceMaxConsumersPerTopic for application/json ContentType.
type SetNamespaceMaxConsumersPerTopicJSONRequestBody = SetNamespaceMaxConsumersPerTopicJSONBody

// SetNamespaceMaxProducersPerTopicJSONRequestBody defines body for SetNamespaceMaxProducersPerTopic for application/json ContentType.
type SetNamespaceMaxProducersPerTopicJSONRequestBody = SetNamespaceMaxProducersPerTopicJSONBody

// SetNamespaceMaxSubscriptionsPerTopicJSONRequestBody defines body for SetNamespaceMaxSubscriptionsPerTopic for application/json ContentType.
type SetNamespaceMaxSubscriptionsPerTopicJSONRequestBody = SetNamespaceMaxSubscriptionsPerTopicJSONBody

// SetNamespaceMaxTopicsPerNamespaceJSONRequestBody defines body for SetNamespaceMaxTopicsPerNamespace for application/json ContentType.
type SetNamespaceMaxTopicsPerNamespaceJSONRequestBody = SetNamespaceMaxTopicsPerNamespaceJSONBody

// SetNamespaceMaxUnackedMessagesPerConsumerJSONRequestBody defines body for SetNamespaceMaxUnackedMessagesPerConsumer for application/json ContentType.
type SetNamespaceMaxUnackedMessagesPerConsumerJSONRequestBody = SetNamespaceMaxUnackedMessagesPerConsumerJSONBody

// SetNamespaceMaxUnackedMessagesPerSubscriptionJSONRequestBody defines body for SetNamespaceMaxUnackedMessagesPerSubscription for application/json ContentType.
type SetNamespaceMaxUnackedMessagesPerSubscriptionJSONRequestBody = SetNamespaceMaxUnackedMessagesPerSubscriptionJSONBody

// SetNamespaceMessageTTLJSONRequestBody defines body for SetNamespaceMessageTTL for application/json ContentType.
type SetNamespaceMessageTTLJSONRequestBody = SetNamespaceMessageTTLJSONBody

// SetNamespaceOffloadDeletionLagJSONRequestBody defines body for SetNamespaceOffloadDeletionLag for application/json ContentType.
type SetNamespaceOffloadDeletionLagJSONRequestBody = SetNamespaceOffloadDeletionLagJSONBody

// SetNamespaceOffloadPoliciesJSONRequestBody defines body for SetNamespaceOffloadPolicies for application/json ContentType.
type SetNamespaceOffloadPoliciesJSONRequestBody = OffloadPoliciesImpl

// SetNamespaceOffloadThresholdJSONRequestBody defines body for SetNamespaceOffloadThreshold for application/json ContentType.
type SetNamespaceOffloadThresholdJSONRequestBody = SetNamespaceOffloadThresholdJSONBody

// GrantPermissionOnNamespaceJSONRequestBody defines body for GrantPermissionOnNamespace for application/json ContentType.
type GrantPermissionOnNamespaceJSONRequestBody = GrantPermissionOnNamespaceJSONBody

// SetNamespacePersistenceJSONRequestBody defines body for SetNamespacePersistence for application/json ContentType.
type SetNamespacePersistenceJSONRequestBody = PersistencePolicies

// SetBookieAffinityGroupJSONRequestBody defines body for SetBookieAffinityGroup for application/json ContentType.
type SetBookieAffinityGroupJSONRequestBody = BookieAffinityGroupData

// SetPropertiesJSONRequestBody defines body for SetProperties for application/json ContentType.
type SetPropertiesJSONRequestBody SetPropertiesJSONBody

// SetNamespaceReplicationClustersJSONRequestBody defines body for SetNamespaceReplicationClusters for application/json ContentType.
type SetNamespaceReplicationClustersJSONRequestBody = SetNamespaceReplicationClustersJSONBody

// SetNamespaceReplicatorDispatchRateJSONRequestBody defines body for SetNamespaceReplicatorDispatchRate for application/json ContentType.
type SetNamespaceReplicatorDispatchRateJSONRequestBody = DispatchRateImpl

// RemoveNamespaceRetentionJSONRequestBody defines body for RemoveNamespaceRetention for application/json ContentType.
type RemoveNamespaceRetentionJSONRequestBody = RetentionPolicies

// SetNamespaceRetentionJSONRequestBody defines body for SetNamespaceRetention for application/json ContentType.
type SetNamespaceRetentionJSONRequestBody = RetentionPolicies

// SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody defines body for SetSchemaAutoUpdateCompatibilityStrategy for application/json ContentType.
type SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody = SetSchemaAutoUpdateCompatibilityStrategyJSONBody

// SetNamespaceSchemaCompatibilityStrategyJSONRequestBody defines body for SetNamespaceSchemaCompatibilityStrategy for application/json ContentType.
type SetNamespaceSchemaCompatibilityStrategyJSONRequestBody = SetNamespaceSchemaCompatibilityStrategyJSONBody

// SetNamespaceSchemaValidationEnforcedJSONRequestBody defines body for SetNamespaceSchemaValidationEnforced for application/json ContentType.
type SetNamespaceSchemaValidationEnforcedJSONRequestBody = SetNamespaceSchemaValidationEnforcedJSONBody

// SetNamespaceSubscribeRateJSONRequestBody defines body for SetNamespaceSubscribeRate for application/json ContentType.
type SetNamespaceSubscribeRateJSONRequestBody = SubscribeRate

// SetNamespaceSubscriptionAuthModeJSONRequestBody defines body for SetNamespaceSubscriptionAuthMode for application/json ContentType.
type SetNamespaceSubscriptionAuthModeJSONRequestBody = SetNamespaceSubscriptionAuthModeJSONBody

// SetNamespaceSubscriptionDispatchRateJSONRequestBody defines body for SetNamespaceSubscriptionDispatchRate for application/json ContentType.
type SetNamespaceSubscriptionDispatchRateJSONRequestBody = DispatchRateImpl

// SetNamespaceSubscriptionExpirationTimeJSONRequestBody defines body for SetNamespaceSubscriptionExpirationTime for application/json ContentType.
type SetNamespaceSubscriptionExpirationTimeJSONRequestBody = SetNamespaceSubscriptionExpirationTimeJSONBody

// SetNamespaceSubscriptionTypesEnabledJSONRequestBody defines body for SetNamespaceSubscriptionTypesEnabled for application/json ContentType.
type SetNamespaceSubscriptionTypesEnabledJSONRequestBody = SetNamespaceSubscriptionTypesEnabledJSONBody

// SplitNamespaceBundleJSONRequestBody defines body for SplitNamespaceBundle for application/json ContentType.
type SplitNamespaceBundleJSONRequestBody = SplitNamespaceBundleJSONBody

// CreateNonPersistentTopicPartitionedTopicJSONRequestBody defines body for CreateNonPersistentTopicPartitionedTopic for application/vnd.partitioned-topic-metadata+json ContentType.
type CreateNonPersistentTopicPartitionedTopicJSONRequestBody = PartitionedTopicMetadata

// SetDefaultResourceQuotaJSONRequestBody defines body for SetDefaultResourceQuota for application/json ContentType.
type SetDefaultResourceQuotaJSONRequestBody = ResourceQuota

// SetNamespaceBundleResourceQuotaJSONRequestBody defines body for SetNamespaceBundleResourceQuota for application/json ContentType.
type SetNamespaceBundleResourceQuotaJSONRequestBody = ResourceQuota

// CreateOrUpdateResourceGroupJSONRequestBody defines body for CreateOrUpdateResourceGroup for application/json ContentType.
type CreateOrUpdateResourceGroupJSONRequestBody = ResourceGroup

// TestCompatibilityJSONRequestBody defines body for TestCompatibility for application/json ContentType.
type TestCompatibilityJSONRequestBody = PostSchemaPayload

// PostSchemaJSONRequestBody defines body for PostSchema for application/json ContentType.
type PostSchemaJSONRequestBody = PostSchemaPayload

// GetVersionBySchemaJSONRequestBody defines body for GetVersionBySchema for application/json ContentType.
type GetVersionBySchemaJSONRequestBody = PostSchemaPayload

// UpdateTenantJSONRequestBody defines body for UpdateTenant for application/json ContentType.
type UpdateTenantJSONRequestBody = TenantInfo

// CreateTenantJSONRequestBody defines body for CreateTenant for application/json ContentType.
type CreateTenantJSONRequestBody = TenantInfo

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllBookies request
	GetAllBookies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookiesRackInfo request
	GetBookiesRackInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBookieRackInfo request
	DeleteBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookieRackInfo request
	GetBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBookieRackInfo request
	UpdateBookieRackInfo(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllocatorStats request
	GetAllocatorStats(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingBookieOpsStats request
	GetPendingBookieOpsStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrokerResourceAvailability request
	GetBrokerResourceAvailability(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoadReport request
	GetLoadReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMBeans request
	GetMBeans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrokerStatsMetrics request
	GetBrokerStatsMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopics2 request
	GetTopics2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActiveBrokers request
	GetActiveBrokers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BacklogQuotaCheck request
	BacklogQuotaCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDynamicConfigurationName request
	GetDynamicConfigurationName(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeConfiguration request
	GetRuntimeConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDynamicConfigurations request
	GetAllDynamicConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDynamicConfiguration request
	DeleteDynamicConfiguration(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDynamicConfiguration request
	UpdateDynamicConfiguration(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInternalConfigurationData request
	GetInternalConfigurationData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLeaderBroker request
	GetLeaderBroker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsReady request
	IsReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShutDownBrokerGracefully request
	ShutDownBrokerGracefully(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Version request
	Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOwnedNamespaces request
	GetOwnedNamespaces(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActiveClusterBrokers request
	GetActiveClusterBrokers(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusters request
	GetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCluster request with any body
	UpdateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCluster request with any body
	CreateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFailureDomains request
	GetFailureDomains(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFailureDomain request
	DeleteFailureDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomain request
	GetDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetFailureDomain request with any body
	SetFailureDomainWithBody(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceIsolationPolicies request
	GetNamespaceIsolationPolicies(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrokersWithNamespaceIsolationPolicy request
	GetBrokersWithNamespaceIsolationPolicy(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrokerWithNamespaceIsolationPolicy request
	GetBrokerWithNamespaceIsolationPolicy(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespaceIsolationPolicy request
	DeleteNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceIsolationPolicy request
	GetNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceIsolationPolicy request with any body
	SetNamespaceIsolationPolicyWithBody(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerCluster request
	GetPeerCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPeerClusterNames request with any body
	SetPeerClusterNamesWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAntiAffinityNamespaces request
	GetAntiAffinityNamespaces(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBookieAffinityGroup request
	DeleteBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookieAffinityGroup request
	GetBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenantNamespaces request
	GetTenantNamespaces(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespace request
	DeleteNamespace(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicies request
	GetPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNamespace request with any body
	CreateNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNamespace(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceAntiAffinityGroup request
	RemoveNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceAntiAffinityGroup request
	GetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceAntiAffinityGroup request with any body
	SetNamespaceAntiAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAutoSubscriptionCreation request
	RemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoSubscriptionCreation request
	GetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAutoSubscriptionCreation request with any body
	SetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAutoTopicCreation request
	RemoveAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoTopicCreation request
	GetAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAutoTopicCreation request with any body
	SetAutoTopicCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAutoTopicCreation(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamesapceBacklogQuota request
	RemoveNamesapceBacklogQuota(ctx context.Context, tenant string, namespace string, params *RemoveNamesapceBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceBacklogQuota request with any body
	SetNamespaceBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceBacklogQuota(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, body SetNamespaceBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceBacklogQuotaMap request
	GetNamespaceBacklogQuotaMap(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBundlesData request
	GetBundlesData(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBacklog request
	ClearNamespaceBacklog(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBacklogForSubscription request
	ClearNamespaceBacklogForSubscription(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCompactionThreshold request
	DeleteCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceCompactionThreshold request
	GetNamespaceCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceCompactionThreshold request with any body
	SetNamespaceCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceCompactionThreshold(ctx context.Context, tenant string, namespace string, body SetNamespaceCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceDeduplication request
	RemoveNamespaceDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceDeduplication request
	GetNamespaceDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyDeduplication request with any body
	ModifyDeduplicationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyDeduplication(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceDeduplicationSnapshotInterval request
	GetNamespaceDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceDeduplicationSnapshotInterval request with any body
	SetNamespaceDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, body SetNamespaceDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveDelayedDeliveryPolicies request
	RemoveDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceDelayedDeliveryPolicies request
	GetNamespaceDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceDelayedDeliveryPolicies request with any body
	SetNamespaceDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, body SetNamespaceDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDispatchRate request
	DeleteDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceDispatchRate request
	GetNamespaceDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceDispatchRate request with any body
	SetNamespaceDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceDispatchRate(ctx context.Context, tenant string, namespace string, body SetNamespaceDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEncryptionRequired request
	GetEncryptionRequired(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyEncryptionRequired request with any body
	ModifyEncryptionRequiredWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyEncryptionRequired(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceEntryFilters request
	RemoveNamespaceEntryFilters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceEntryFiltersPerTopic request
	GetNamespaceEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEntryFiltersPerTopic request with any body
	SetEntryFiltersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveInactiveTopicPolicies request
	RemoveInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceInactiveTopicPolicies request
	GetNamespaceInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceInactiveTopicPolicies request with any body
	SetNamespaceInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body SetNamespaceInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIsAllowAutoUpdateSchema request
	GetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIsAllowAutoUpdateSchema request with any body
	SetIsAllowAutoUpdateSchemaWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMaxConsumersPerSubscription request
	RemoveNamespaceMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMaxConsumersPerSubscription request
	GetNamespaceMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMaxConsumersPerSubscription request with any body
	SetNamespaceMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMaxConsumersPerTopic request
	RemoveNamespaceMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMaxConsumersPerTopic request
	GetNamespaceMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMaxConsumersPerTopic request with any body
	SetNamespaceMaxConsumersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMaxProducersPerTopic request
	RemoveNamespaceMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMaxProducersPerTopic request
	GetNamespaceMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMaxProducersPerTopic request with any body
	SetNamespaceMaxProducersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMaxSubscriptionsPerTopic request
	RemoveNamespaceMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMaxSubscriptionsPerTopic request
	GetNamespaceMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMaxSubscriptionsPerTopic request with any body
	SetNamespaceMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespaceMaxTopicsPerNamespace request
	DeleteNamespaceMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMaxTopicsPerNamespace request
	GetNamespaceMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMaxTopicsPerNamespace request with any body
	SetNamespaceMaxTopicsPerNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMaxUnackedmessagesPerConsumer request
	RemoveNamespaceMaxUnackedmessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMaxUnackedMessagesPerConsumer request
	GetNamespaceMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMaxUnackedMessagesPerConsumer request with any body
	SetNamespaceMaxUnackedMessagesPerConsumerWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMaxUnackedmessagesPerSubscription request
	RemoveNamespaceMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMaxUnackedmessagesPerSubscription request
	GetNamespaceMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMaxUnackedMessagesPerSubscription request with any body
	SetNamespaceMaxUnackedMessagesPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMaxUnackedMessagesPerSubscription(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceMessageTTL request
	RemoveNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceMessageTTL request
	GetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceMessageTTL request with any body
	SetNamespaceMessageTTLWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearOffloadDeletionLag request
	ClearOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceOffloadDeletionLag request
	GetNamespaceOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceOffloadDeletionLag request with any body
	SetNamespaceOffloadDeletionLagWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceOffloadDeletionLag(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceOffloadPolicies request
	GetNamespaceOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceOffloadPolicies request with any body
	SetNamespaceOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceOffloadPolicies(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceOffloadThreshold request
	GetNamespaceOffloadThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceOffloadThreshold request with any body
	SetNamespaceOffloadThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceOffloadThreshold(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissions request
	GetPermissions(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionOnSubscription request
	GetPermissionOnSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePermissionsOnNamespace request
	RevokePermissionsOnNamespace(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantPermissionOnNamespace request with any body
	GrantPermissionOnNamespaceWithBody(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GrantPermissionOnNamespace(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistence request
	DeletePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespacePersistence request
	GetNamespacePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespacePersistence request with any body
	SetNamespacePersistenceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespacePersistence(ctx context.Context, tenant string, namespace string, body SetNamespacePersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBookieAffinityGroup request with any body
	SetBookieAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBookieAffinityGroup(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearProperties request
	ClearProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceProperties request
	GetNamespaceProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetProperties request with any body
	SetPropertiesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetProperties(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveProperty request
	RemoveProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProperty request
	GetProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetProperty request
	SetProperty(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceOffloadPolicies request
	RemoveNamespaceOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceReplicationClusters request
	GetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceReplicationClusters request with any body
	SetNamespaceReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceReplicatorDispatchRate request
	RemoveNamespaceReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceReplicatorDispatchRate request
	GetNamespaceReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceReplicatorDispatchRate request with any body
	SetNamespaceReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceResourceGroup request
	RemoveNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceResourceGroup request
	GetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceResourceGroup request
	SetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceRetention request with any body
	RemoveNamespaceRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveNamespaceRetention(ctx context.Context, tenant string, namespace string, body RemoveNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceRetention request
	GetNamespaceRetention(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceRetention request with any body
	SetNamespaceRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceRetention(ctx context.Context, tenant string, namespace string, body SetNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScanOffloadedLedgers request
	ScanOffloadedLedgers(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaAutoUpdateCompatibilityStrategy request
	GetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSchemaAutoUpdateCompatibilityStrategy request with any body
	SetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceSchemaCompatibilityStrategy request
	GetNamespaceSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceSchemaCompatibilityStrategy request with any body
	SetNamespaceSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaValidtionEnforced request
	GetSchemaValidtionEnforced(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceSchemaValidationEnforced request with any body
	SetNamespaceSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscribeRate request
	DeleteSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceSubscribeRate request
	GetNamespaceSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceSubscribeRate request with any body
	SetNamespaceSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceSubscribeRate(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionAuthMode request
	GetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceSubscriptionAuthMode request with any body
	SetNamespaceSubscriptionAuthModeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscriptionDispatchRate request
	DeleteSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceSubscriptionDispatchRate request
	GetNamespaceSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceSubscriptionDispatchRate request with any body
	SetNamespaceSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscriptionExpirationTime request
	RemoveSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionExpirationTime request
	GetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceSubscriptionExpirationTime request with any body
	SetNamespaceSubscriptionExpirationTimeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceSubscriptionTypesEnabled request
	RemoveNamespaceSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceSubscriptionTypesEnabled request
	GetNamespaceSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceSubscriptionTypesEnabled request with any body
	SetNamespaceSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopics request
	GetTopics(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadNamespace request
	UnloadNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsubscribeNamespace request
	UnsubscribeNamespace(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespaceBundle request
	DeleteNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBundleBacklog request
	ClearNamespaceBundleBacklog(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearNamespaceBundleBacklogForSubscription request
	ClearNamespaceBundleBacklogForSubscription(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SplitNamespaceBundle request with any body
	SplitNamespaceBundleWithBody(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SplitNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopicHashPositions request
	GetTopicHashPositions(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadNamespaceBundle request
	UnloadNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsubscribeNamespaceBundle request
	UnsubscribeNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicList request
	GetNonPersistentTopicList(ctx context.Context, tenant string, namespace string, params *GetNonPersistentTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentPartitionedTopicList request
	GetNonPersistentPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetNonPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListFromBundle request
	GetListFromBundle(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopic request
	DeleteNonPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNonPersistentTopicNonPartitionedTopic request with any body
	CreateNonPersistentTopicNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireNonPersistentTopicMessagesForAllSubscriptions request
	ExpireNonPersistentTopicMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicBacklog request
	GetNonPersistentTopicBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicBacklogQuota request
	RemoveNonPersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicBacklogQuota request
	SetNonPersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicBacklogQuotaMap request
	GetNonPersistentTopicBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicBacklogSizeByMessageId request
	GetNonPersistentTopicBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicCompactionStatus request
	GetNonPersistentTopicCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompactNonPersistentTopic request
	CompactNonPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *CompactNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicCompactionThreshold request
	RemoveNonPersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicCompactionThreshold request
	GetNonPersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicCompactionThreshold request with any body
	SetNonPersistentTopicCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNonPersistentTopicMissedPartitions request
	CreateNonPersistentTopicMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicDeduplication request
	RemoveNonPersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicDeduplication request
	GetNonPersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicDeduplication request with any body
	SetNonPersistentTopicDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicDeduplicationSnapshotInterval request
	DeleteNonPersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicDeduplicationSnapshotInterval request
	GetNonPersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicDeduplicationSnapshotInterval request with any body
	SetNonPersistentTopicDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicDelayedDeliveryPolicies request
	DeleteNonPersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicDelayedDeliveryPolicies request
	GetNonPersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicDelayedDeliveryPolicies request with any body
	SetNonPersistentTopicDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicDispatchRate request
	RemoveNonPersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicDispatchRate request
	GetNonPersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicDispatchRate request with any body
	SetNonPersistentTopicDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicEntryFilters request
	RemoveNonPersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicEntryFilters request
	GetNonPersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicEntryFilters request with any body
	SetNonPersistentTopicEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExamineNonPersistentTopicMessage request
	ExamineNonPersistentTopicMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExamineNonPersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicInactiveTopicPolicies request
	DeleteNonPersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicInactiveTopicPolicies request
	GetNonPersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicInactiveTopicPolicies request with any body
	SetNonPersistentTopicInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicManagedLedgerInfo request
	GetNonPersistentTopicManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicInternalStats request
	GetNonPersistentTopicInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicLastMessageId request
	GetNonPersistentTopicLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMessageById request
	GetNonPersistentTopicMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetNonPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicMaxConsumers request
	RemoveNonPersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMaxConsumers request
	GetNonPersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMaxConsumers request with any body
	SetNonPersistentTopicMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicMaxConsumersPerSubscription request
	RemoveNonPersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMaxConsumersPerSubscription request
	GetNonPersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMaxConsumersPerSubscription request with any body
	SetNonPersistentTopicMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicMaxMessageSize request
	RemoveNonPersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMaxMessageSize request
	GetNonPersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMaxMessageSize request with any body
	SetNonPersistentTopicMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicMaxProducers request
	RemoveNonPersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMaxProducers request
	GetNonPersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMaxProducers request with any body
	SetNonPersistentTopicMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicMaxSubscriptionsPerTopic request
	RemoveNonPersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMaxSubscriptionsPerTopic request
	GetNonPersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMaxSubscriptionsPerTopic request with any body
	SetNonPersistentTopicMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicMaxUnackedMessagesOnConsumer request
	DeleteNonPersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMaxUnackedMessagesOnConsumer request
	GetNonPersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMaxUnackedMessagesOnConsumer request with any body
	SetNonPersistentTopicMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicMaxUnackedMessagesOnSubscription request
	DeleteNonPersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMaxUnackedMessagesOnSubscription request
	GetNonPersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMaxUnackedMessagesOnSubscription request with any body
	SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicMessageTTL request
	RemoveNonPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMessageTTL request
	GetNonPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicMessageTTL request
	SetNonPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicMessageIdByTimestamp request
	GetNonPersistentTopicMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetNonPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OffloadNonPersistentTopicStatus request
	OffloadNonPersistentTopicStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadNonPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerNonPersistentTopicOffload request
	TriggerNonPersistentTopicOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerNonPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicOffloadPolicies request
	RemoveNonPersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicOffloadPolicies request
	GetNonPersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicOffloadPolicies request with any body
	SetNonPersistentTopicOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicPartitionedStats request
	GetNonPersistentTopicPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicPartitionedTopic request
	DeleteNonPersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicPartitionedMetadata request
	GetNonPersistentTopicPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNonPersistentTopicPartitionedTopic request with any body
	UpdateNonPersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNonPersistentTopicPartitionedTopic request with any body
	CreateNonPersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNonPersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, body CreateNonPersistentTopicPartitionedTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicPermissionsOnTopic request
	GetNonPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopic request
	RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantNonPersistentTopicPermissionsOnTopic request with any body
	GrantNonPersistentTopicPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicPersistence request
	RemoveNonPersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicPersistence request
	GetNonPersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicPersistence request with any body
	SetNonPersistentTopicPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicProperties request
	RemoveNonPersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicProperties request
	GetNonPersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNonPersistentTopicProperties request with any body
	UpdateNonPersistentTopicPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicPublishRate request
	RemoveNonPersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicPublishRate request
	GetNonPersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicPublishRate request with any body
	SetNonPersistentTopicPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicReplicationClusters request
	RemoveNonPersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicReplicationClusters request
	GetNonPersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicReplicationClusters request with any body
	SetNonPersistentTopicReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicReplicatorDispatchRate request
	RemoveNonPersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicReplicatorDispatchRate request
	GetNonPersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicReplicatorDispatchRate request with any body
	SetNonPersistentTopicReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicRetention request
	RemoveNonPersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicRetention request
	GetNonPersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicRetention request with any body
	SetNonPersistentTopicRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicSchemaCompatibilityStrategy request with any body
	RemoveNonPersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSchemaCompatibilityStrategy request
	GetNonPersistentTopicSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicSchemaCompatibilityStrategy request with any body
	SetNonPersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSchemaValidationEnforced request
	GetNonPersistentTopicSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicSchemaValidationEnforced request with any body
	SetNonPersistentTopicSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicShadowTopics request
	DeleteNonPersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicShadowTopics request
	GetNonPersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicShadowTopics request with any body
	SetNonPersistentTopicShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicStats request
	GetNonPersistentTopicStats(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicSubscribeRate request with any body
	RemoveNonPersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSubscribeRate request
	GetNonPersistentTopicSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicSubscribeRate request with any body
	SetNonPersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNonPersistentTopicSubscription request
	DeleteNonPersistentTopicSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteNonPersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnalyzeNonPersistentTopicSubscriptionBacklog request with any body
	AnalyzeNonPersistentTopicSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeNonPersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireNonPersistentTopicMessages request with any body
	ExpireNonPersistentTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireNonPersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireNonPersistentTopicMessagesTimeInSeconds request
	ExpireNonPersistentTopicMessagesTimeInSeconds(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PeekNonPersistentTopicNthMessage request
	PeekNonPersistentTopicNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNonPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSubscriptionProperties request
	GetNonPersistentTopicSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNonPersistentTopicSubscriptionProperties request with any body
	UpdateNonPersistentTopicSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateNonPersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicReplicatedSubscriptionStatus request
	GetNonPersistentTopicReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicReplicatedSubscriptionStatus request with any body
	SetNonPersistentTopicReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetNonPersistentTopicCursorOnPosition request with any body
	ResetNonPersistentTopicCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetNonPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetNonPersistentTopicCursor request
	ResetNonPersistentTopicCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetNonPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipNonPersistentTopicMessages request
	SkipNonPersistentTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipNonPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipNonPersistentTopicAllMessages request
	SkipNonPersistentTopicAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipNonPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNonPersistentTopicSubscription request with any body
	CreateNonPersistentTopicSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateNonPersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicSubscriptionDispatchRate request
	RemoveNonPersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSubscriptionDispatchRate request
	GetNonPersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicSubscriptionDispatchRate request with any body
	SetNonPersistentTopicSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicSubscriptionTypesEnabled request
	RemoveNonPersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSubscriptionTypesEnabled request
	GetNonPersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicSubscriptionTypesEnabled request with any body
	SetNonPersistentTopicSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSubscriptions request
	GetNonPersistentTopicSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateNonPersistentTopic request
	TerminateNonPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateNonPersistentTopicPartitionedTopic request
	TerminateNonPersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TruncateNonPersistentTopicTopic request
	TruncateNonPersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncateNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadNonPersistentTopicTopic request
	UnloadNonPersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNonPersistentTopicSubscriptionLevelDispatchRate request
	RemoveNonPersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNonPersistentTopicSubscriptionLevelDispatchRate request
	GetNonPersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNonPersistentTopicSubscriptionLevelDispatchRate request with any body
	SetNonPersistentTopicSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicList request
	GetPersistentTopicList(ctx context.Context, tenant string, namespace string, params *GetPersistentTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentPartitionedTopicList request
	GetPersistentPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopic request
	DeletePersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePersistentTopicNonPartitionedTopic request with any body
	CreatePersistentTopicNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpirePersistentTopicMessagesForAllSubscriptions request
	ExpirePersistentTopicMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicBacklog request
	GetPersistentTopicBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicBacklogQuota request
	RemovePersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicBacklogQuota request
	SetPersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicBacklogQuotaMap request
	GetPersistentTopicBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicBacklogSizeByMessageId request
	GetPersistentTopicBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicCompactionStatus request
	GetPersistentTopicCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompactPersistentTopic request
	CompactPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *CompactPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicCompactionThreshold request
	RemovePersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicCompactionThreshold request
	GetPersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicCompactionThreshold request with any body
	SetPersistentTopicCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePersistentTopicMissedPartitions request
	CreatePersistentTopicMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicDeduplication request
	RemovePersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicDeduplication request
	GetPersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicDeduplication request with any body
	SetPersistentTopicDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicDeduplicationSnapshotInterval request
	DeletePersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicDeduplicationSnapshotInterval request
	GetPersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicDeduplicationSnapshotInterval request with any body
	SetPersistentTopicDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicDelayedDeliveryPolicies request
	DeletePersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicDelayedDeliveryPolicies request
	GetPersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicDelayedDeliveryPolicies request with any body
	SetPersistentTopicDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicDispatchRate request
	RemovePersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicDispatchRate request
	GetPersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicDispatchRate request with any body
	SetPersistentTopicDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicEntryFilters request
	RemovePersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicEntryFilters request
	GetPersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicEntryFilters request with any body
	SetPersistentTopicEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExaminePersistentTopicMessage request
	ExaminePersistentTopicMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExaminePersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicInactiveTopicPolicies request
	DeletePersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicInactiveTopicPolicies request
	GetPersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicInactiveTopicPolicies request with any body
	SetPersistentTopicInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicManagedLedgerInfo request
	GetPersistentTopicManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicInternalStats request
	GetPersistentTopicInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicLastMessageId request
	GetPersistentTopicLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMessageById request
	GetPersistentTopicMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicMaxConsumers request
	RemovePersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMaxConsumers request
	GetPersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMaxConsumers request with any body
	SetPersistentTopicMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicMaxConsumersPerSubscription request
	RemovePersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMaxConsumersPerSubscription request
	GetPersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMaxConsumersPerSubscription request with any body
	SetPersistentTopicMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicMaxMessageSize request
	RemovePersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMaxMessageSize request
	GetPersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMaxMessageSize request with any body
	SetPersistentTopicMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicMaxProducers request
	RemovePersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMaxProducers request
	GetPersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMaxProducers request with any body
	SetPersistentTopicMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicMaxSubscriptionsPerTopic request
	RemovePersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMaxSubscriptionsPerTopic request
	GetPersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMaxSubscriptionsPerTopic request with any body
	SetPersistentTopicMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicMaxUnackedMessagesOnConsumer request
	DeletePersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMaxUnackedMessagesOnConsumer request
	GetPersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMaxUnackedMessagesOnConsumer request with any body
	SetPersistentTopicMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicMaxUnackedMessagesOnSubscription request
	DeletePersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMaxUnackedMessagesOnSubscription request
	GetPersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMaxUnackedMessagesOnSubscription request with any body
	SetPersistentTopicMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicMessageTTL request
	RemovePersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMessageTTL request
	GetPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicMessageTTL request
	SetPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicMessageIdByTimestamp request
	GetPersistentTopicMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OffloadPersistentTopicStatus request
	OffloadPersistentTopicStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerPersistentTopicOffload request
	TriggerPersistentTopicOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicOffloadPolicies request
	RemovePersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicOffloadPolicies request
	GetPersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicOffloadPolicies request with any body
	SetPersistentTopicOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicPartitionedStats request
	GetPersistentTopicPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicPartitionedTopic request
	DeletePersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicPartitionedMetadata request
	GetPersistentTopicPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePersistentTopicPartitionedTopic request with any body
	UpdatePersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePersistentTopicPartitionedTopic request with any body
	CreatePersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicPermissionsOnTopic request
	GetPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePersistentTopicNonPersistentTopicPermissionsOnTopic request
	RevokePersistentTopicNonPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GrantPersistentTopicPermissionsOnTopic request with any body
	GrantPersistentTopicPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicPersistence request
	RemovePersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicPersistence request
	GetPersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicPersistence request with any body
	SetPersistentTopicPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicProperties request
	RemovePersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicProperties request
	GetPersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePersistentTopicProperties request with any body
	UpdatePersistentTopicPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicPublishRate request
	RemovePersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicPublishRate request
	GetPersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicPublishRate request with any body
	SetPersistentTopicPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicReplicationClusters request
	RemovePersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicReplicationClusters request
	GetPersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicReplicationClusters request with any body
	SetPersistentTopicReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicReplicatorDispatchRate request
	RemovePersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicReplicatorDispatchRate request
	GetPersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicReplicatorDispatchRate request with any body
	SetPersistentTopicReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicRetention request
	RemovePersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicRetention request
	GetPersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicRetention request with any body
	SetPersistentTopicRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicSchemaCompatibilityStrategy request with any body
	RemovePersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSchemaCompatibilityStrategy request
	GetPersistentTopicSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicSchemaCompatibilityStrategy request with any body
	SetPersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSchemaValidationEnforced request
	GetPersistentTopicSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicSchemaValidationEnforced request with any body
	SetPersistentTopicSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicShadowTopics request
	DeletePersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicShadowTopics request
	GetPersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicShadowTopics request with any body
	SetPersistentTopicShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicStats request
	GetPersistentTopicStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicSubscribeRate request with any body
	RemovePersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSubscribeRate request
	GetPersistentTopicSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicSubscribeRate request with any body
	SetPersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistentTopicSubscription request
	DeletePersistentTopicSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeletePersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AnalyzePersistentTopicSubscriptionBacklog request with any body
	AnalyzePersistentTopicSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzePersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpirePersistentTopicMessages request with any body
	ExpirePersistentTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpirePersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpirePersistentTopicMessagesTimeInSeconds request
	ExpirePersistentTopicMessagesTimeInSeconds(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PeekPersistentTopicNthMessage request
	PeekPersistentTopicNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSubscriptionProperties request
	GetPersistentTopicSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePersistentTopicSubscriptionProperties request with any body
	UpdatePersistentTopicSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdatePersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicReplicatedSubscriptionStatus request
	GetPersistentTopicReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicReplicatedSubscriptionStatus request with any body
	SetPersistentTopicReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPersistentTopicCursorOnPosition request with any body
	ResetPersistentTopicCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPersistentTopicCursor request
	ResetPersistentTopicCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipPersistentTopicMessages request
	SkipPersistentTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipPersistentTopicAllMessages request
	SkipPersistentTopicAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePersistentTopicSubscription request with any body
	CreatePersistentTopicSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreatePersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicSubscriptionDispatchRate request
	RemovePersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSubscriptionDispatchRate request
	GetPersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicSubscriptionDispatchRate request with any body
	SetPersistentTopicSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicSubscriptionTypesEnabled request
	RemovePersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSubscriptionTypesEnabled request
	GetPersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicSubscriptionTypesEnabled request with any body
	SetPersistentTopicSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSubscriptions request
	GetPersistentTopicSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminatePersistentTopic request
	TerminatePersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminatePersistentTopicPartitionedTopic request
	TerminatePersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TruncatePersistentTopicTopic request
	TruncatePersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncatePersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnloadPersistentTopicTopic request
	UnloadPersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePersistentTopicSubscriptionLevelDispatchRate request
	RemovePersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemovePersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistentTopicSubscriptionLevelDispatchRate request
	GetPersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPersistentTopicSubscriptionLevelDispatchRate request with any body
	SetPersistentTopicSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultResourceQuota request
	GetDefaultResourceQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultResourceQuota request with any body
	SetDefaultResourceQuotaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetDefaultResourceQuota(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNamespaceBundleResourceQuota request
	RemoveNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamespaceBundleResourceQuota request
	GetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetNamespaceBundleResourceQuota request with any body
	SetNamespaceBundleResourceQuotaWithBody(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceGroups request
	GetResourceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceGroup request
	DeleteResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceGroup request
	GetResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateResourceGroup request with any body
	CreateOrUpdateResourceGroupWithBody(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateResourceGroup(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestCompatibility request with any body
	TestCompatibilityWithBody(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestCompatibility(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSchema request
	DeleteSchema(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaOfTopic request
	GetSchemaOfTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaOfTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchema request with any body
	PostSchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSchema(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaOfTopicGivenVersion request
	GetSchemaOfTopicGivenVersion(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaOfTopicGivenVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSchemas request
	GetAllSchemas(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionBySchema request with any body
	GetVersionBySchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetVersionBySchema(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenants request
	GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTenant request
	DeleteTenant(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenantAdmin request
	GetTenantAdmin(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTenant request with any body
	UpdateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTenant(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTenant request with any body
	CreateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTenant(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkerStats request
	GetWorkerStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkerStatsMetrics request
	GetWorkerStatsMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssignments request
	GetAssignments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkerCluster request
	GetWorkerCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkerClusterLeader request
	GetWorkerClusterLeader(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsLeaderReady request
	IsLeaderReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectorsList request
	GetConnectorsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDrainStatus request
	GetDrainStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Drain request
	Drain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDrainStatusFromLeader request
	GetDrainStatusFromLeader(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DrainAtLeader request
	DrainAtLeader(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Rebalance request
	Rebalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllBookies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBookiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookiesRackInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookiesRackInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBookieRackInfoRequest(c.Server, bookie)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookieRackInfoRequest(c.Server, bookie)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBookieRackInfo(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBookieRackInfoRequest(c.Server, bookie, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllocatorStats(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllocatorStatsRequest(c.Server, allocator)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingBookieOpsStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingBookieOpsStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrokerResourceAvailability(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrokerResourceAvailabilityRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoadReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoadReportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMBeans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMBeansRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrokerStatsMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrokerStatsMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopics2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopics2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActiveBrokers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActiveBrokersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BacklogQuotaCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBacklogQuotaCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDynamicConfigurationName(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDynamicConfigurationNameRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDynamicConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDynamicConfigurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDynamicConfiguration(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDynamicConfigurationRequest(c.Server, configName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDynamicConfiguration(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDynamicConfigurationRequest(c.Server, configName, configValue)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInternalConfigurationData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInternalConfigurationDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLeaderBroker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLeaderBrokerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShutDownBrokerGracefully(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShutDownBrokerGracefullyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Version(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOwnedNamespaces(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOwnedNamespacesRequest(c.Server, clusterName, brokerWebserviceurl)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActiveClusterBrokers(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActiveClusterBrokersRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFailureDomains(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFailureDomainsRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFailureDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFailureDomainRequest(c.Server, cluster, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainRequest(c.Server, cluster, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFailureDomainWithBody(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFailureDomainRequestWithBody(c.Server, cluster, domainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceIsolationPolicies(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceIsolationPoliciesRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrokersWithNamespaceIsolationPolicy(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrokersWithNamespaceIsolationPolicyRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrokerWithNamespaceIsolationPolicy(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrokerWithNamespaceIsolationPolicyRequest(c.Server, cluster, broker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceIsolationPolicyRequest(c.Server, cluster, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceIsolationPolicyRequest(c.Server, cluster, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceIsolationPolicyWithBody(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceIsolationPolicyRequestWithBody(c.Server, cluster, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPeerClusterNamesWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPeerClusterNamesRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAntiAffinityNamespaces(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAntiAffinityNamespacesRequest(c.Server, cluster, group, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBookieAffinityGroupRequest(c.Server, property, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookieAffinityGroupRequest(c.Server, property, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenantNamespaces(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantNamespacesRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespace(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNamespace(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNamespaceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceAntiAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceAntiAffinityGroupRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAutoSubscriptionCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoSubscriptionCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoSubscriptionCreationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoSubscriptionCreationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAutoTopicCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoTopicCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoTopicCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoTopicCreationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAutoTopicCreation(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAutoTopicCreationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamesapceBacklogQuota(ctx context.Context, tenant string, namespace string, params *RemoveNamesapceBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamesapceBacklogQuotaRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceBacklogQuotaRequestWithBody(c.Server, tenant, namespace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceBacklogQuota(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, body SetNamespaceBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceBacklogQuotaRequest(c.Server, tenant, namespace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceBacklogQuotaMap(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceBacklogQuotaMapRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBundlesData(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBundlesDataRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBacklog(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBacklogRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBacklogForSubscription(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBacklogForSubscriptionRequest(c.Server, tenant, namespace, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCompactionThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceCompactionThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceCompactionThresholdRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceCompactionThreshold(ctx context.Context, tenant string, namespace string, body SetNamespaceCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceCompactionThresholdRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceDeduplicationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceDeduplicationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyDeduplicationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyDeduplicationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyDeduplication(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyDeduplicationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, body SetNamespaceDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, body SetNamespaceDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceDispatchRate(ctx context.Context, tenant string, namespace string, body SetNamespaceDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEncryptionRequired(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEncryptionRequiredRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyEncryptionRequiredWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyEncryptionRequiredRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyEncryptionRequired(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyEncryptionRequiredRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceEntryFilters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceEntryFiltersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceEntryFiltersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEntryFiltersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEntryFiltersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEntryFiltersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveInactiveTopicPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceInactiveTopicPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body SetNamespaceInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceInactiveTopicPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIsAllowAutoUpdateSchemaRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIsAllowAutoUpdateSchemaWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIsAllowAutoUpdateSchemaRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIsAllowAutoUpdateSchemaRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMaxConsumersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMaxConsumersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxConsumersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxConsumersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxConsumersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMaxProducersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMaxProducersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxProducersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxProducersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxProducersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespaceMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceMaxTopicsPerNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMaxTopicsPerNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxTopicsPerNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxTopicsPerNamespaceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxTopicsPerNamespaceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMaxUnackedmessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMaxUnackedmessagesPerConsumerRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMaxUnackedMessagesPerConsumerRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxUnackedMessagesPerConsumerWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxUnackedMessagesPerConsumerRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxUnackedMessagesPerConsumerRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMaxUnackedmessagesPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMaxUnackedmessagesPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxUnackedMessagesPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxUnackedMessagesPerSubscriptionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMaxUnackedMessagesPerSubscription(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMaxUnackedMessagesPerSubscriptionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceMessageTTLRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceMessageTTLRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMessageTTLWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMessageTTLRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceMessageTTLRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearOffloadDeletionLagRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceOffloadDeletionLagRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceOffloadDeletionLagWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceOffloadDeletionLagRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceOffloadDeletionLag(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceOffloadDeletionLagRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceOffloadPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceOffloadPolicies(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceOffloadPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceOffloadThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceOffloadThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceOffloadThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceOffloadThresholdRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceOffloadThreshold(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceOffloadThresholdRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissions(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionsRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionOnSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionOnSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePermissionsOnNamespace(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePermissionsOnNamespaceRequest(c.Server, tenant, namespace, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantPermissionOnNamespaceWithBody(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantPermissionOnNamespaceRequestWithBody(c.Server, tenant, namespace, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantPermissionOnNamespace(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantPermissionOnNamespaceRequest(c.Server, tenant, namespace, role, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistenceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespacePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespacePersistenceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespacePersistenceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespacePersistenceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespacePersistence(ctx context.Context, tenant string, namespace string, body SetNamespacePersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespacePersistenceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBookieAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBookieAffinityGroupRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBookieAffinityGroup(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBookieAffinityGroupRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearPropertiesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespacePropertiesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPropertiesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPropertiesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetProperties(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPropertiesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePropertyRequest(c.Server, tenant, namespace, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPropertyRequest(c.Server, tenant, namespace, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetProperty(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPropertyRequest(c.Server, tenant, namespace, key, value)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceOffloadPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceReplicationClustersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceReplicationClustersRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceReplicationClustersRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceReplicatorDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceReplicatorDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceReplicatorDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceResourceGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceResourceGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceResourceGroupRequest(c.Server, tenant, namespace, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceRetentionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceRetention(ctx context.Context, tenant string, namespace string, body RemoveNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceRetentionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceRetention(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceRetentionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceRetentionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceRetention(ctx context.Context, tenant string, namespace string, body SetNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceRetentionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScanOffloadedLedgers(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScanOffloadedLedgersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaAutoUpdateCompatibilityStrategyRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSchemaAutoUpdateCompatibilityStrategyRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaValidtionEnforced(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaValidtionEnforcedRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSchemaValidationEnforcedRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscribeRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceSubscribeRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscribeRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscribeRate(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscribeRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionAuthModeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionAuthModeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionAuthModeRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionAuthModeRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceSubscriptionDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionExpirationTimeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionExpirationTimeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionExpirationTimeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionExpirationTimeRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionExpirationTimeRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceSubscriptionTypesEnabledRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceSubscriptionTypesEnabledRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopics(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopicsRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsubscribeNamespace(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeNamespaceRequest(c.Server, tenant, namespace, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBundleBacklog(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBundleBacklogRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearNamespaceBundleBacklogForSubscription(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearNamespaceBundleBacklogForSubscriptionRequest(c.Server, tenant, namespace, bundle, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SplitNamespaceBundleWithBody(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSplitNamespaceBundleRequestWithBody(c.Server, tenant, namespace, bundle, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SplitNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSplitNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopicHashPositions(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopicHashPositionsRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsubscribeNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsubscribeNamespaceBundleRequest(c.Server, tenant, namespace, bundle, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicList(ctx context.Context, tenant string, namespace string, params *GetNonPersistentTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetNonPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentPartitionedTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListFromBundle(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListFromBundleRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNonPersistentTopicNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNonPersistentTopicNonPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireNonPersistentTopicMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireNonPersistentTopicMessagesForAllSubscriptionsRequest(c.Server, tenant, namespace, topic, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicBacklogRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicBacklogQuotaMapRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicBacklogSizeByMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicCompactionStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompactNonPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *CompactNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompactNonPersistentTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicCompactionThresholdRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNonPersistentTopicMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNonPersistentTopicMissedPartitionsRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicDeduplicationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicEntryFiltersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExamineNonPersistentTopicMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExamineNonPersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExamineNonPersistentTopicMessageRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicManagedLedgerInfoRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicInternalStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicLastMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetNonPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMessageByIdRequest(c.Server, tenant, namespace, topic, ledgerId, entryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMaxConsumersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMaxMessageSizeRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMaxProducersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMaxUnackedMessagesOnConsumerRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetNonPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicMessageIdByTimestampRequest(c.Server, tenant, namespace, topic, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OffloadNonPersistentTopicStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadNonPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOffloadNonPersistentTopicStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerNonPersistentTopicOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerNonPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerNonPersistentTopicOffloadRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicPartitionedStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicPartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicPartitionedMetadataRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNonPersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNonPersistentTopicPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNonPersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNonPersistentTopicPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNonPersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, body CreateNonPersistentTopicPartitionedTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNonPersistentTopicPartitionedTopicRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicPermissionsOnTopicRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicRequest(c.Server, tenant, namespace, topic, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantNonPersistentTopicPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantNonPersistentTopicPermissionsOnTopicRequestWithBody(c.Server, tenant, namespace, topic, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicPersistenceRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNonPersistentTopicPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNonPersistentTopicPropertiesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicPublishRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicReplicationClustersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicRetentionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSchemaValidationEnforcedRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicShadowTopicsRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicStats(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSubscribeRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNonPersistentTopicSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteNonPersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNonPersistentTopicSubscriptionRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnalyzeNonPersistentTopicSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeNonPersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnalyzeNonPersistentTopicSubscriptionBacklogRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireNonPersistentTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireNonPersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireNonPersistentTopicMessagesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireNonPersistentTopicMessagesTimeInSeconds(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireNonPersistentTopicMessagesTimeInSecondsRequest(c.Server, tenant, namespace, topic, subName, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PeekNonPersistentTopicNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNonPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPeekNonPersistentTopicNthMessageRequest(c.Server, tenant, namespace, topic, subName, messagePosition, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSubscriptionPropertiesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNonPersistentTopicSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateNonPersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNonPersistentTopicSubscriptionPropertiesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicReplicatedSubscriptionStatusRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicReplicatedSubscriptionStatusRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetNonPersistentTopicCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetNonPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetNonPersistentTopicCursorOnPositionRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetNonPersistentTopicCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetNonPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetNonPersistentTopicCursorRequest(c.Server, tenant, namespace, topic, subName, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipNonPersistentTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipNonPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipNonPersistentTopicMessagesRequest(c.Server, tenant, namespace, topic, subName, numMessages, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipNonPersistentTopicAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipNonPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipNonPersistentTopicAllMessagesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNonPersistentTopicSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateNonPersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNonPersistentTopicSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, subscriptionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSubscriptionsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateNonPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateNonPersistentTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateNonPersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateNonPersistentTopicPartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TruncateNonPersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncateNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTruncateNonPersistentTopicTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadNonPersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadNonPersistentTopicTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNonPersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNonPersistentTopicSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNonPersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNonPersistentTopicSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNonPersistentTopicSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNonPersistentTopicSubscriptionLevelDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicList(ctx context.Context, tenant string, namespace string, params *GetPersistentTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *GetPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentPartitionedTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePersistentTopicNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePersistentTopicNonPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpirePersistentTopicMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpirePersistentTopicMessagesForAllSubscriptionsRequest(c.Server, tenant, namespace, topic, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicBacklog(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicBacklogRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicBacklogQuotaMapRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicBacklogSizeByMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicCompactionStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompactPersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *CompactPersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompactPersistentTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicCompactionThresholdRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePersistentTopicMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePersistentTopicMissedPartitionsRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicDeduplicationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicEntryFiltersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExaminePersistentTopicMessage(ctx context.Context, tenant string, namespace string, topic string, params *ExaminePersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExaminePersistentTopicMessageRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicManagedLedgerInfoRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicInternalStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicLastMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMessageByIdRequest(c.Server, tenant, namespace, topic, ledgerId, entryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMaxConsumersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMaxMessageSizeRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMaxProducersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMaxUnackedMessagesOnConsumerRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMaxUnackedMessagesOnSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicMessageIdByTimestampRequest(c.Server, tenant, namespace, topic, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OffloadPersistentTopicStatus(ctx context.Context, tenant string, namespace string, topic string, params *OffloadPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOffloadPersistentTopicStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPersistentTopicOffload(ctx context.Context, tenant string, namespace string, topic string, params *TriggerPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPersistentTopicOffloadRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicPartitionedStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicPartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicPartitionedMetadataRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersistentTopicPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePersistentTopicPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePersistentTopicPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicPermissionsOnTopicRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePersistentTopicNonPersistentTopicPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePersistentTopicNonPersistentTopicPermissionsOnTopicRequest(c.Server, tenant, namespace, topic, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GrantPersistentTopicPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGrantPersistentTopicPermissionsOnTopicRequestWithBody(c.Server, tenant, namespace, topic, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicPersistence(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicPersistenceRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicProperties(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersistentTopicPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersistentTopicPropertiesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicPublishRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicReplicationClustersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicRetention(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicRetentionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSchemaValidationEnforcedRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicShadowTopicsRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicStats(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSubscribeRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistentTopicSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeletePersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistentTopicSubscriptionRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AnalyzePersistentTopicSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzePersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnalyzePersistentTopicSubscriptionBacklogRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpirePersistentTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpirePersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpirePersistentTopicMessagesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpirePersistentTopicMessagesTimeInSeconds(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpirePersistentTopicMessagesTimeInSecondsRequest(c.Server, tenant, namespace, topic, subName, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PeekPersistentTopicNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPeekPersistentTopicNthMessageRequest(c.Server, tenant, namespace, topic, subName, messagePosition, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSubscriptionPropertiesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePersistentTopicSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdatePersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePersistentTopicSubscriptionPropertiesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicReplicatedSubscriptionStatusRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicReplicatedSubscriptionStatusRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPersistentTopicCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPersistentTopicCursorOnPositionRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPersistentTopicCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPersistentTopicCursorRequest(c.Server, tenant, namespace, topic, subName, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipPersistentTopicMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipPersistentTopicMessagesRequest(c.Server, tenant, namespace, topic, subName, numMessages, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipPersistentTopicAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipPersistentTopicAllMessagesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePersistentTopicSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreatePersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePersistentTopicSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, subscriptionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSubscriptionsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminatePersistentTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminatePersistentTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminatePersistentTopicPartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminatePersistentTopicPartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TruncatePersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *TruncatePersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTruncatePersistentTopicTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnloadPersistentTopicTopic(ctx context.Context, tenant string, namespace string, topic string, params *UnloadPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnloadPersistentTopicTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemovePersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePersistentTopicSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistentTopicSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistentTopicSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPersistentTopicSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPersistentTopicSubscriptionLevelDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultResourceQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultResourceQuotaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultResourceQuotaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultResourceQuotaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultResourceQuota(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultResourceQuotaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceBundleResourceQuotaWithBody(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceBundleResourceQuotaRequestWithBody(c.Server, tenant, namespace, bundle, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceGroupRequest(c.Server, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceGroupRequest(c.Server, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateResourceGroupWithBody(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateResourceGroupRequestWithBody(c.Server, resourcegroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateResourceGroup(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateResourceGroupRequest(c.Server, resourcegroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestCompatibilityWithBody(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestCompatibilityRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestCompatibility(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestCompatibilityRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSchema(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSchemaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaOfTopic(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaOfTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaOfTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchema(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchemaRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaOfTopicGivenVersion(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaOfTopicGivenVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaOfTopicGivenVersionRequest(c.Server, tenant, namespace, topic, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSchemas(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSchemasRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionBySchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionBySchemaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionBySchema(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionBySchemaRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTenant(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTenantRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenantAdmin(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantAdminRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenant(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTenant(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTenantRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkerStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkerStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkerStatsMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkerStatsMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssignments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssignmentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkerCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkerClusterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkerClusterLeader(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkerClusterLeaderRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsLeaderReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsLeaderReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectorsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDrainStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDrainStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Drain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDrainRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDrainStatusFromLeader(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDrainStatusFromLeaderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DrainAtLeader(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDrainAtLeaderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Rebalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebalanceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllBookiesRequest generates requests for GetAllBookies
func NewGetAllBookiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBookiesRackInfoRequest generates requests for GetBookiesRackInfo
func NewGetBookiesRackInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBookieRackInfoRequest generates requests for DeleteBookieRackInfo
func NewDeleteBookieRackInfoRequest(server string, bookie string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBookieRackInfoRequest generates requests for GetBookieRackInfo
func NewGetBookieRackInfoRequest(server string, bookie string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBookieRackInfoRequest generates requests for UpdateBookieRackInfo
func NewUpdateBookieRackInfoRequest(server string, bookie string, params *UpdateBookieRackInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Group != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllocatorStatsRequest generates requests for GetAllocatorStats
func NewGetAllocatorStatsRequest(server string, allocator string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "allocator", runtime.ParamLocationPath, allocator)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/allocator-stats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingBookieOpsStatsRequest generates requests for GetPendingBookieOpsStats
func NewGetPendingBookieOpsStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/bookieops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrokerResourceAvailabilityRequest generates requests for GetBrokerResourceAvailability
func NewGetBrokerResourceAvailabilityRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/broker-resource-availability/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoadReportRequest generates requests for GetLoadReport
func NewGetLoadReportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/load-report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMBeansRequest generates requests for GetMBeans
func NewGetMBeansRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/mbeans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrokerStatsMetricsRequest generates requests for GetBrokerStatsMetrics
func NewGetBrokerStatsMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopics2Request generates requests for GetTopics2
func NewGetTopics2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/topics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActiveBrokersRequest generates requests for GetActiveBrokers
func NewGetActiveBrokersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBacklogQuotaCheckRequest generates requests for BacklogQuotaCheck
func NewBacklogQuotaCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/backlog-quota-check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDynamicConfigurationNameRequest generates requests for GetDynamicConfigurationName
func NewGetDynamicConfigurationNameRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeConfigurationRequest generates requests for GetRuntimeConfiguration
func NewGetRuntimeConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/runtime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllDynamicConfigurationsRequest generates requests for GetAllDynamicConfigurations
func NewGetAllDynamicConfigurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/values")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDynamicConfigurationRequest generates requests for DeleteDynamicConfiguration
func NewDeleteDynamicConfigurationRequest(server string, configName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configName", runtime.ParamLocationPath, configName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDynamicConfigurationRequest generates requests for UpdateDynamicConfiguration
func NewUpdateDynamicConfigurationRequest(server string, configName string, configValue string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configName", runtime.ParamLocationPath, configName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "configValue", runtime.ParamLocationPath, configValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string, params *HealthCheckParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.TopicVersion != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topicVersion", runtime.ParamLocationQuery, *params.TopicVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInternalConfigurationDataRequest generates requests for GetInternalConfigurationData
func NewGetInternalConfigurationDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/internal-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLeaderBrokerRequest generates requests for GetLeaderBroker
func NewGetLeaderBrokerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/leaderBroker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsReadyRequest generates requests for IsReady
func NewIsReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShutDownBrokerGracefullyRequest generates requests for ShutDownBrokerGracefully
func NewShutDownBrokerGracefullyRequest(server string, params *ShutDownBrokerGracefullyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.MaxConcurrentUnloadPerSec != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxConcurrentUnloadPerSec", runtime.ParamLocationQuery, *params.MaxConcurrentUnloadPerSec); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ForcedTerminateTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forcedTerminateTopic", runtime.ParamLocationQuery, *params.ForcedTerminateTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVersionRequest generates requests for Version
func NewVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOwnedNamespacesRequest generates requests for GetOwnedNamespaces
func NewGetOwnedNamespacesRequest(server string, clusterName string, brokerWebserviceurl string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterName", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "broker-webserviceurl", runtime.ParamLocationPath, brokerWebserviceurl)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/%s/%s/ownedNamespaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActiveClusterBrokersRequest generates requests for GetActiveClusterBrokers
func NewGetActiveClusterBrokersRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClustersRequest generates requests for GetClusters
func NewGetClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFailureDomainsRequest generates requests for GetFailureDomains
func NewGetFailureDomainsRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFailureDomainRequest generates requests for DeleteFailureDomain
func NewDeleteFailureDomainRequest(server string, cluster string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainRequest generates requests for GetDomain
func NewGetDomainRequest(server string, cluster string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetFailureDomainRequestWithBody generates requests for SetFailureDomain with any type of body
func NewSetFailureDomainRequestWithBody(server string, cluster string, domainName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceIsolationPoliciesRequest generates requests for GetNamespaceIsolationPolicies
func NewGetNamespaceIsolationPoliciesRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrokersWithNamespaceIsolationPolicyRequest generates requests for GetBrokersWithNamespaceIsolationPolicy
func NewGetBrokersWithNamespaceIsolationPolicyRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/brokers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrokerWithNamespaceIsolationPolicyRequest generates requests for GetBrokerWithNamespaceIsolationPolicy
func NewGetBrokerWithNamespaceIsolationPolicyRequest(server string, cluster string, broker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "broker", runtime.ParamLocationPath, broker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/brokers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNamespaceIsolationPolicyRequest generates requests for DeleteNamespaceIsolationPolicy
func NewDeleteNamespaceIsolationPolicyRequest(server string, cluster string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceIsolationPolicyRequest generates requests for GetNamespaceIsolationPolicy
func NewGetNamespaceIsolationPolicyRequest(server string, cluster string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceIsolationPolicyRequestWithBody generates requests for SetNamespaceIsolationPolicy with any type of body
func NewSetNamespaceIsolationPolicyRequestWithBody(server string, cluster string, policyName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerClusterRequest generates requests for GetPeerCluster
func NewGetPeerClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/peers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPeerClusterNamesRequestWithBody generates requests for SetPeerClusterNames with any type of body
func NewSetPeerClusterNamesRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/peers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAntiAffinityNamespacesRequest generates requests for GetAntiAffinityNamespaces
func NewGetAntiAffinityNamespacesRequest(server string, cluster string, group string, params *GetAntiAffinityNamespacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/antiAffinity/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Tenant != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBookieAffinityGroupRequest generates requests for DeleteBookieAffinityGroup
func NewDeleteBookieAffinityGroupRequest(server string, property string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property", runtime.ParamLocationPath, property)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBookieAffinityGroupRequest generates requests for GetBookieAffinityGroup
func NewGetBookieAffinityGroupRequest(server string, property string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property", runtime.ParamLocationPath, property)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantNamespacesRequest generates requests for GetTenantNamespaces
func NewGetTenantNamespacesRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNamespaceRequest generates requests for DeleteNamespace
func NewDeleteNamespaceRequest(server string, tenant string, namespace string, params *DeleteNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPoliciesRequest generates requests for GetPolicies
func NewGetPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNamespaceRequest calls the generic CreateNamespace builder with application/json body
func NewCreateNamespaceRequest(server string, tenant string, namespace string, body CreateNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNamespaceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewCreateNamespaceRequestWithBody generates requests for CreateNamespace with any type of body
func NewCreateNamespaceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceAntiAffinityGroupRequest generates requests for RemoveNamespaceAntiAffinityGroup
func NewRemoveNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceAntiAffinityGroupRequest generates requests for GetNamespaceAntiAffinityGroup
func NewGetNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceAntiAffinityGroupRequest calls the generic SetNamespaceAntiAffinityGroup builder with application/json body
func NewSetNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceAntiAffinityGroupRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceAntiAffinityGroupRequestWithBody generates requests for SetNamespaceAntiAffinityGroup with any type of body
func NewSetNamespaceAntiAffinityGroupRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveAutoSubscriptionCreationRequest generates requests for RemoveAutoSubscriptionCreation
func NewRemoveAutoSubscriptionCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoSubscriptionCreationRequest generates requests for GetAutoSubscriptionCreation
func NewGetAutoSubscriptionCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAutoSubscriptionCreationRequest calls the generic SetAutoSubscriptionCreation builder with application/json body
func NewSetAutoSubscriptionCreationRequest(server string, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAutoSubscriptionCreationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetAutoSubscriptionCreationRequestWithBody generates requests for SetAutoSubscriptionCreation with any type of body
func NewSetAutoSubscriptionCreationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveAutoTopicCreationRequest generates requests for RemoveAutoTopicCreation
func NewRemoveAutoTopicCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoTopicCreationRequest generates requests for GetAutoTopicCreation
func NewGetAutoTopicCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetAutoTopicCreationRequest calls the generic SetAutoTopicCreation builder with application/json body
func NewSetAutoTopicCreationRequest(server string, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAutoTopicCreationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetAutoTopicCreationRequestWithBody generates requests for SetAutoTopicCreation with any type of body
func NewSetAutoTopicCreationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamesapceBacklogQuotaRequest generates requests for RemoveNamesapceBacklogQuota
func NewRemoveNamesapceBacklogQuotaRequest(server string, tenant string, namespace string, params *RemoveNamesapceBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuota", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceBacklogQuotaRequest calls the generic SetNamespaceBacklogQuota builder with application/json body
func NewSetNamespaceBacklogQuotaRequest(server string, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, body SetNamespaceBacklogQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceBacklogQuotaRequestWithBody(server, tenant, namespace, params, "application/json", bodyReader)
}

// NewSetNamespaceBacklogQuotaRequestWithBody generates requests for SetNamespaceBacklogQuota with any type of body
func NewSetNamespaceBacklogQuotaRequestWithBody(server string, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuota", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceBacklogQuotaMapRequest generates requests for GetNamespaceBacklogQuotaMap
func NewGetNamespaceBacklogQuotaMapRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuotaMap", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBundlesDataRequest generates requests for GetBundlesData
func NewGetBundlesDataRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/bundles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBacklogRequest generates requests for ClearNamespaceBacklog
func NewClearNamespaceBacklogRequest(server string, tenant string, namespace string, params *ClearNamespaceBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/clearBacklog", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBacklogForSubscriptionRequest generates requests for ClearNamespaceBacklogForSubscription
func NewClearNamespaceBacklogForSubscriptionRequest(server string, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/clearBacklog/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCompactionThresholdRequest generates requests for DeleteCompactionThreshold
func NewDeleteCompactionThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceCompactionThresholdRequest generates requests for GetNamespaceCompactionThreshold
func NewGetNamespaceCompactionThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceCompactionThresholdRequest calls the generic SetNamespaceCompactionThreshold builder with application/json body
func NewSetNamespaceCompactionThresholdRequest(server string, tenant string, namespace string, body SetNamespaceCompactionThresholdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceCompactionThresholdRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceCompactionThresholdRequestWithBody generates requests for SetNamespaceCompactionThreshold with any type of body
func NewSetNamespaceCompactionThresholdRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceDeduplicationRequest generates requests for RemoveNamespaceDeduplication
func NewRemoveNamespaceDeduplicationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceDeduplicationRequest generates requests for GetNamespaceDeduplication
func NewGetNamespaceDeduplicationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyDeduplicationRequest calls the generic ModifyDeduplication builder with application/json body
func NewModifyDeduplicationRequest(server string, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyDeduplicationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewModifyDeduplicationRequestWithBody generates requests for ModifyDeduplication with any type of body
func NewModifyDeduplicationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceDeduplicationSnapshotIntervalRequest generates requests for GetNamespaceDeduplicationSnapshotInterval
func NewGetNamespaceDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceDeduplicationSnapshotIntervalRequest calls the generic SetNamespaceDeduplicationSnapshotInterval builder with application/json body
func NewSetNamespaceDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, body SetNamespaceDeduplicationSnapshotIntervalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceDeduplicationSnapshotIntervalRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceDeduplicationSnapshotIntervalRequestWithBody generates requests for SetNamespaceDeduplicationSnapshotInterval with any type of body
func NewSetNamespaceDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveDelayedDeliveryPoliciesRequest generates requests for RemoveDelayedDeliveryPolicies
func NewRemoveDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceDelayedDeliveryPoliciesRequest generates requests for GetNamespaceDelayedDeliveryPolicies
func NewGetNamespaceDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceDelayedDeliveryPoliciesRequest calls the generic SetNamespaceDelayedDeliveryPolicies builder with application/json body
func NewSetNamespaceDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, body SetNamespaceDelayedDeliveryPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceDelayedDeliveryPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceDelayedDeliveryPoliciesRequestWithBody generates requests for SetNamespaceDelayedDeliveryPolicies with any type of body
func NewSetNamespaceDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDispatchRateRequest generates requests for DeleteDispatchRate
func NewDeleteDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceDispatchRateRequest generates requests for GetNamespaceDispatchRate
func NewGetNamespaceDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceDispatchRateRequest calls the generic SetNamespaceDispatchRate builder with application/json body
func NewSetNamespaceDispatchRateRequest(server string, tenant string, namespace string, body SetNamespaceDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceDispatchRateRequestWithBody generates requests for SetNamespaceDispatchRate with any type of body
func NewSetNamespaceDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEncryptionRequiredRequest generates requests for GetEncryptionRequired
func NewGetEncryptionRequiredRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/encryptionRequired", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyEncryptionRequiredRequest calls the generic ModifyEncryptionRequired builder with application/json body
func NewModifyEncryptionRequiredRequest(server string, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyEncryptionRequiredRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewModifyEncryptionRequiredRequestWithBody generates requests for ModifyEncryptionRequired with any type of body
func NewModifyEncryptionRequiredRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/encryptionRequired", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceEntryFiltersRequest generates requests for RemoveNamespaceEntryFilters
func NewRemoveNamespaceEntryFiltersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceEntryFiltersPerTopicRequest generates requests for GetNamespaceEntryFiltersPerTopic
func NewGetNamespaceEntryFiltersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetEntryFiltersPerTopicRequest calls the generic SetEntryFiltersPerTopic builder with application/json body
func NewSetEntryFiltersPerTopicRequest(server string, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetEntryFiltersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetEntryFiltersPerTopicRequestWithBody generates requests for SetEntryFiltersPerTopic with any type of body
func NewSetEntryFiltersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveInactiveTopicPoliciesRequest generates requests for RemoveInactiveTopicPolicies
func NewRemoveInactiveTopicPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceInactiveTopicPoliciesRequest generates requests for GetNamespaceInactiveTopicPolicies
func NewGetNamespaceInactiveTopicPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceInactiveTopicPoliciesRequest calls the generic SetNamespaceInactiveTopicPolicies builder with application/json body
func NewSetNamespaceInactiveTopicPoliciesRequest(server string, tenant string, namespace string, body SetNamespaceInactiveTopicPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceInactiveTopicPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceInactiveTopicPoliciesRequestWithBody generates requests for SetNamespaceInactiveTopicPolicies with any type of body
func NewSetNamespaceInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIsAllowAutoUpdateSchemaRequest generates requests for GetIsAllowAutoUpdateSchema
func NewGetIsAllowAutoUpdateSchemaRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/isAllowAutoUpdateSchema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIsAllowAutoUpdateSchemaRequest calls the generic SetIsAllowAutoUpdateSchema builder with application/json body
func NewSetIsAllowAutoUpdateSchemaRequest(server string, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIsAllowAutoUpdateSchemaRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetIsAllowAutoUpdateSchemaRequestWithBody generates requests for SetIsAllowAutoUpdateSchema with any type of body
func NewSetIsAllowAutoUpdateSchemaRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/isAllowAutoUpdateSchema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMaxConsumersPerSubscriptionRequest generates requests for RemoveNamespaceMaxConsumersPerSubscription
func NewRemoveNamespaceMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMaxConsumersPerSubscriptionRequest generates requests for GetNamespaceMaxConsumersPerSubscription
func NewGetNamespaceMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMaxConsumersPerSubscriptionRequest calls the generic SetNamespaceMaxConsumersPerSubscription builder with application/json body
func NewSetNamespaceMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, body SetNamespaceMaxConsumersPerSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMaxConsumersPerSubscriptionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMaxConsumersPerSubscriptionRequestWithBody generates requests for SetNamespaceMaxConsumersPerSubscription with any type of body
func NewSetNamespaceMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMaxConsumersPerTopicRequest generates requests for RemoveNamespaceMaxConsumersPerTopic
func NewRemoveNamespaceMaxConsumersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMaxConsumersPerTopicRequest generates requests for GetNamespaceMaxConsumersPerTopic
func NewGetNamespaceMaxConsumersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMaxConsumersPerTopicRequest calls the generic SetNamespaceMaxConsumersPerTopic builder with application/json body
func NewSetNamespaceMaxConsumersPerTopicRequest(server string, tenant string, namespace string, body SetNamespaceMaxConsumersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMaxConsumersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMaxConsumersPerTopicRequestWithBody generates requests for SetNamespaceMaxConsumersPerTopic with any type of body
func NewSetNamespaceMaxConsumersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMaxProducersPerTopicRequest generates requests for RemoveNamespaceMaxProducersPerTopic
func NewRemoveNamespaceMaxProducersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMaxProducersPerTopicRequest generates requests for GetNamespaceMaxProducersPerTopic
func NewGetNamespaceMaxProducersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMaxProducersPerTopicRequest calls the generic SetNamespaceMaxProducersPerTopic builder with application/json body
func NewSetNamespaceMaxProducersPerTopicRequest(server string, tenant string, namespace string, body SetNamespaceMaxProducersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMaxProducersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMaxProducersPerTopicRequestWithBody generates requests for SetNamespaceMaxProducersPerTopic with any type of body
func NewSetNamespaceMaxProducersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMaxSubscriptionsPerTopicRequest generates requests for RemoveNamespaceMaxSubscriptionsPerTopic
func NewRemoveNamespaceMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMaxSubscriptionsPerTopicRequest generates requests for GetNamespaceMaxSubscriptionsPerTopic
func NewGetNamespaceMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMaxSubscriptionsPerTopicRequest calls the generic SetNamespaceMaxSubscriptionsPerTopic builder with application/json body
func NewSetNamespaceMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, body SetNamespaceMaxSubscriptionsPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMaxSubscriptionsPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMaxSubscriptionsPerTopicRequestWithBody generates requests for SetNamespaceMaxSubscriptionsPerTopic with any type of body
func NewSetNamespaceMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNamespaceMaxTopicsPerNamespaceRequest generates requests for DeleteNamespaceMaxTopicsPerNamespace
func NewDeleteNamespaceMaxTopicsPerNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMaxTopicsPerNamespaceRequest generates requests for GetNamespaceMaxTopicsPerNamespace
func NewGetNamespaceMaxTopicsPerNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMaxTopicsPerNamespaceRequest calls the generic SetNamespaceMaxTopicsPerNamespace builder with application/json body
func NewSetNamespaceMaxTopicsPerNamespaceRequest(server string, tenant string, namespace string, body SetNamespaceMaxTopicsPerNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMaxTopicsPerNamespaceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMaxTopicsPerNamespaceRequestWithBody generates requests for SetNamespaceMaxTopicsPerNamespace with any type of body
func NewSetNamespaceMaxTopicsPerNamespaceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMaxUnackedmessagesPerConsumerRequest generates requests for RemoveNamespaceMaxUnackedmessagesPerConsumer
func NewRemoveNamespaceMaxUnackedmessagesPerConsumerRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMaxUnackedMessagesPerConsumerRequest generates requests for GetNamespaceMaxUnackedMessagesPerConsumer
func NewGetNamespaceMaxUnackedMessagesPerConsumerRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMaxUnackedMessagesPerConsumerRequest calls the generic SetNamespaceMaxUnackedMessagesPerConsumer builder with application/json body
func NewSetNamespaceMaxUnackedMessagesPerConsumerRequest(server string, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMaxUnackedMessagesPerConsumerRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMaxUnackedMessagesPerConsumerRequestWithBody generates requests for SetNamespaceMaxUnackedMessagesPerConsumer with any type of body
func NewSetNamespaceMaxUnackedMessagesPerConsumerRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMaxUnackedmessagesPerSubscriptionRequest generates requests for RemoveNamespaceMaxUnackedmessagesPerSubscription
func NewRemoveNamespaceMaxUnackedmessagesPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMaxUnackedmessagesPerSubscriptionRequest generates requests for GetNamespaceMaxUnackedmessagesPerSubscription
func NewGetNamespaceMaxUnackedmessagesPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMaxUnackedMessagesPerSubscriptionRequest calls the generic SetNamespaceMaxUnackedMessagesPerSubscription builder with application/json body
func NewSetNamespaceMaxUnackedMessagesPerSubscriptionRequest(server string, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMaxUnackedMessagesPerSubscriptionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMaxUnackedMessagesPerSubscriptionRequestWithBody generates requests for SetNamespaceMaxUnackedMessagesPerSubscription with any type of body
func NewSetNamespaceMaxUnackedMessagesPerSubscriptionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceMessageTTLRequest generates requests for RemoveNamespaceMessageTTL
func NewRemoveNamespaceMessageTTLRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceMessageTTLRequest generates requests for GetNamespaceMessageTTL
func NewGetNamespaceMessageTTLRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceMessageTTLRequest calls the generic SetNamespaceMessageTTL builder with application/json body
func NewSetNamespaceMessageTTLRequest(server string, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceMessageTTLRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceMessageTTLRequestWithBody generates requests for SetNamespaceMessageTTL with any type of body
func NewSetNamespaceMessageTTLRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearOffloadDeletionLagRequest generates requests for ClearOffloadDeletionLag
func NewClearOffloadDeletionLagRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceOffloadDeletionLagRequest generates requests for GetNamespaceOffloadDeletionLag
func NewGetNamespaceOffloadDeletionLagRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceOffloadDeletionLagRequest calls the generic SetNamespaceOffloadDeletionLag builder with application/json body
func NewSetNamespaceOffloadDeletionLagRequest(server string, tenant string, namespace string, body SetNamespaceOffloadDeletionLagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceOffloadDeletionLagRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceOffloadDeletionLagRequestWithBody generates requests for SetNamespaceOffloadDeletionLag with any type of body
func NewSetNamespaceOffloadDeletionLagRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceOffloadPoliciesRequest generates requests for GetNamespaceOffloadPolicies
func NewGetNamespaceOffloadPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceOffloadPoliciesRequest calls the generic SetNamespaceOffloadPolicies builder with application/json body
func NewSetNamespaceOffloadPoliciesRequest(server string, tenant string, namespace string, body SetNamespaceOffloadPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceOffloadPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceOffloadPoliciesRequestWithBody generates requests for SetNamespaceOffloadPolicies with any type of body
func NewSetNamespaceOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceOffloadThresholdRequest generates requests for GetNamespaceOffloadThreshold
func NewGetNamespaceOffloadThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceOffloadThresholdRequest calls the generic SetNamespaceOffloadThreshold builder with application/json body
func NewSetNamespaceOffloadThresholdRequest(server string, tenant string, namespace string, body SetNamespaceOffloadThresholdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceOffloadThresholdRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceOffloadThresholdRequestWithBody generates requests for SetNamespaceOffloadThreshold with any type of body
func NewSetNamespaceOffloadThresholdRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPermissionsRequest generates requests for GetPermissions
func NewGetPermissionsRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionOnSubscriptionRequest generates requests for GetPermissionOnSubscription
func NewGetPermissionOnSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/subscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePermissionsOnNamespaceRequest generates requests for RevokePermissionsOnNamespace
func NewRevokePermissionsOnNamespaceRequest(server string, tenant string, namespace string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGrantPermissionOnNamespaceRequest calls the generic GrantPermissionOnNamespace builder with application/json body
func NewGrantPermissionOnNamespaceRequest(server string, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGrantPermissionOnNamespaceRequestWithBody(server, tenant, namespace, role, "application/json", bodyReader)
}

// NewGrantPermissionOnNamespaceRequestWithBody generates requests for GrantPermissionOnNamespace with any type of body
func NewGrantPermissionOnNamespaceRequestWithBody(server string, tenant string, namespace string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistenceRequest generates requests for DeletePersistence
func NewDeletePersistenceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespacePersistenceRequest generates requests for GetNamespacePersistence
func NewGetNamespacePersistenceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespacePersistenceRequest calls the generic SetNamespacePersistence builder with application/json body
func NewSetNamespacePersistenceRequest(server string, tenant string, namespace string, body SetNamespacePersistenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespacePersistenceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespacePersistenceRequestWithBody generates requests for SetNamespacePersistence with any type of body
func NewSetNamespacePersistenceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetBookieAffinityGroupRequest calls the generic SetBookieAffinityGroup builder with application/json body
func NewSetBookieAffinityGroupRequest(server string, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBookieAffinityGroupRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetBookieAffinityGroupRequestWithBody generates requests for SetBookieAffinityGroup with any type of body
func NewSetBookieAffinityGroupRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearPropertiesRequest generates requests for ClearProperties
func NewClearPropertiesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespacePropertiesRequest generates requests for GetNamespaceProperties
func NewGetNamespacePropertiesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPropertiesRequest calls the generic SetProperties builder with application/json body
func NewSetPropertiesRequest(server string, tenant string, namespace string, body SetPropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPropertiesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetPropertiesRequestWithBody generates requests for SetProperties with any type of body
func NewSetPropertiesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePropertyRequest generates requests for RemoveProperty
func NewRemovePropertyRequest(server string, tenant string, namespace string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPropertyRequest generates requests for GetProperty
func NewGetPropertyRequest(server string, tenant string, namespace string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPropertyRequest generates requests for SetProperty
func NewSetPropertyRequest(server string, tenant string, namespace string, key string, value string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "value", runtime.ParamLocationPath, value)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNamespaceOffloadPoliciesRequest generates requests for RemoveNamespaceOffloadPolicies
func NewRemoveNamespaceOffloadPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/removeOffloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceReplicationClustersRequest generates requests for GetNamespaceReplicationClusters
func NewGetNamespaceReplicationClustersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceReplicationClustersRequest calls the generic SetNamespaceReplicationClusters builder with application/json body
func NewSetNamespaceReplicationClustersRequest(server string, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceReplicationClustersRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceReplicationClustersRequestWithBody generates requests for SetNamespaceReplicationClusters with any type of body
func NewSetNamespaceReplicationClustersRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceReplicatorDispatchRateRequest generates requests for RemoveNamespaceReplicatorDispatchRate
func NewRemoveNamespaceReplicatorDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceReplicatorDispatchRateRequest generates requests for GetNamespaceReplicatorDispatchRate
func NewGetNamespaceReplicatorDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceReplicatorDispatchRateRequest calls the generic SetNamespaceReplicatorDispatchRate builder with application/json body
func NewSetNamespaceReplicatorDispatchRateRequest(server string, tenant string, namespace string, body SetNamespaceReplicatorDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceReplicatorDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceReplicatorDispatchRateRequestWithBody generates requests for SetNamespaceReplicatorDispatchRate with any type of body
func NewSetNamespaceReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceResourceGroupRequest generates requests for RemoveNamespaceResourceGroup
func NewRemoveNamespaceResourceGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceResourceGroupRequest generates requests for GetNamespaceResourceGroup
func NewGetNamespaceResourceGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceResourceGroupRequest generates requests for SetNamespaceResourceGroup
func NewSetNamespaceResourceGroupRequest(server string, tenant string, namespace string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNamespaceRetentionRequest calls the generic RemoveNamespaceRetention builder with application/json body
func NewRemoveNamespaceRetentionRequest(server string, tenant string, namespace string, body RemoveNamespaceRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveNamespaceRetentionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewRemoveNamespaceRetentionRequestWithBody generates requests for RemoveNamespaceRetention with any type of body
func NewRemoveNamespaceRetentionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceRetentionRequest generates requests for GetNamespaceRetention
func NewGetNamespaceRetentionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceRetentionRequest calls the generic SetNamespaceRetention builder with application/json body
func NewSetNamespaceRetentionRequest(server string, tenant string, namespace string, body SetNamespaceRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceRetentionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceRetentionRequestWithBody generates requests for SetNamespaceRetention with any type of body
func NewSetNamespaceRetentionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScanOffloadedLedgersRequest generates requests for ScanOffloadedLedgers
func NewScanOffloadedLedgersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/scanOffloadedLedgers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemaAutoUpdateCompatibilityStrategyRequest generates requests for GetSchemaAutoUpdateCompatibilityStrategy
func NewGetSchemaAutoUpdateCompatibilityStrategyRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaAutoUpdateCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSchemaAutoUpdateCompatibilityStrategyRequest calls the generic SetSchemaAutoUpdateCompatibilityStrategy builder with application/json body
func NewSetSchemaAutoUpdateCompatibilityStrategyRequest(server string, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody generates requests for SetSchemaAutoUpdateCompatibilityStrategy with any type of body
func NewSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaAutoUpdateCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNamespaceSchemaCompatibilityStrategyRequest generates requests for GetNamespaceSchemaCompatibilityStrategy
func NewGetNamespaceSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceSchemaCompatibilityStrategyRequest calls the generic SetNamespaceSchemaCompatibilityStrategy builder with application/json body
func NewSetNamespaceSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, body SetNamespaceSchemaCompatibilityStrategyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceSchemaCompatibilityStrategyRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceSchemaCompatibilityStrategyRequestWithBody generates requests for SetNamespaceSchemaCompatibilityStrategy with any type of body
func NewSetNamespaceSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaValidtionEnforcedRequest generates requests for GetSchemaValidtionEnforced
func NewGetSchemaValidtionEnforcedRequest(server string, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaValidationEnforced", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceSchemaValidationEnforcedRequest calls the generic SetNamespaceSchemaValidationEnforced builder with application/json body
func NewSetNamespaceSchemaValidationEnforcedRequest(server string, tenant string, namespace string, body SetNamespaceSchemaValidationEnforcedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceSchemaValidationEnforcedRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceSchemaValidationEnforcedRequestWithBody generates requests for SetNamespaceSchemaValidationEnforced with any type of body
func NewSetNamespaceSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaValidationEnforced", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscribeRateRequest generates requests for DeleteSubscribeRate
func NewDeleteSubscribeRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceSubscribeRateRequest generates requests for GetNamespaceSubscribeRate
func NewGetNamespaceSubscribeRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceSubscribeRateRequest calls the generic SetNamespaceSubscribeRate builder with application/json body
func NewSetNamespaceSubscribeRateRequest(server string, tenant string, namespace string, body SetNamespaceSubscribeRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceSubscribeRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceSubscribeRateRequestWithBody generates requests for SetNamespaceSubscribeRate with any type of body
func NewSetNamespaceSubscribeRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionAuthModeRequest generates requests for GetSubscriptionAuthMode
func NewGetSubscriptionAuthModeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionAuthMode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceSubscriptionAuthModeRequest calls the generic SetNamespaceSubscriptionAuthMode builder with application/json body
func NewSetNamespaceSubscriptionAuthModeRequest(server string, tenant string, namespace string, body SetNamespaceSubscriptionAuthModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceSubscriptionAuthModeRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceSubscriptionAuthModeRequestWithBody generates requests for SetNamespaceSubscriptionAuthMode with any type of body
func NewSetNamespaceSubscriptionAuthModeRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionAuthMode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionDispatchRateRequest generates requests for DeleteSubscriptionDispatchRate
func NewDeleteSubscriptionDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceSubscriptionDispatchRateRequest generates requests for GetNamespaceSubscriptionDispatchRate
func NewGetNamespaceSubscriptionDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceSubscriptionDispatchRateRequest calls the generic SetNamespaceSubscriptionDispatchRate builder with application/json body
func NewSetNamespaceSubscriptionDispatchRateRequest(server string, tenant string, namespace string, body SetNamespaceSubscriptionDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceSubscriptionDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceSubscriptionDispatchRateRequestWithBody generates requests for SetNamespaceSubscriptionDispatchRate with any type of body
func NewSetNamespaceSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubscriptionExpirationTimeRequest generates requests for RemoveSubscriptionExpirationTime
func NewRemoveSubscriptionExpirationTimeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionExpirationTimeRequest generates requests for GetSubscriptionExpirationTime
func NewGetSubscriptionExpirationTimeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceSubscriptionExpirationTimeRequest calls the generic SetNamespaceSubscriptionExpirationTime builder with application/json body
func NewSetNamespaceSubscriptionExpirationTimeRequest(server string, tenant string, namespace string, body SetNamespaceSubscriptionExpirationTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceSubscriptionExpirationTimeRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceSubscriptionExpirationTimeRequestWithBody generates requests for SetNamespaceSubscriptionExpirationTime with any type of body
func NewSetNamespaceSubscriptionExpirationTimeRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceSubscriptionTypesEnabledRequest generates requests for RemoveNamespaceSubscriptionTypesEnabled
func NewRemoveNamespaceSubscriptionTypesEnabledRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceSubscriptionTypesEnabledRequest generates requests for GetNamespaceSubscriptionTypesEnabled
func NewGetNamespaceSubscriptionTypesEnabledRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceSubscriptionTypesEnabledRequest calls the generic SetNamespaceSubscriptionTypesEnabled builder with application/json body
func NewSetNamespaceSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, body SetNamespaceSubscriptionTypesEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceSubscriptionTypesEnabledRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewSetNamespaceSubscriptionTypesEnabledRequestWithBody generates requests for SetNamespaceSubscriptionTypesEnabled with any type of body
func NewSetNamespaceSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTopicsRequest generates requests for GetTopics
func NewGetTopicsRequest(server string, tenant string, namespace string, params *GetTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/topics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Mode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadNamespaceRequest generates requests for UnloadNamespace
func NewUnloadNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/unload", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnsubscribeNamespaceRequest generates requests for UnsubscribeNamespace
func NewUnsubscribeNamespaceRequest(server string, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/unsubscribe/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNamespaceBundleRequest generates requests for DeleteNamespaceBundle
func NewDeleteNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBundleBacklogRequest generates requests for ClearNamespaceBundleBacklog
func NewClearNamespaceBundleBacklogRequest(server string, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/clearBacklog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearNamespaceBundleBacklogForSubscriptionRequest generates requests for ClearNamespaceBundleBacklogForSubscription
func NewClearNamespaceBundleBacklogForSubscriptionRequest(server string, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/clearBacklog/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSplitNamespaceBundleRequest calls the generic SplitNamespaceBundle builder with application/json body
func NewSplitNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSplitNamespaceBundleRequestWithBody(server, tenant, namespace, bundle, params, "application/json", bodyReader)
}

// NewSplitNamespaceBundleRequestWithBody generates requests for SplitNamespaceBundle with any type of body
func NewSplitNamespaceBundleRequestWithBody(server string, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/split", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Unload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unload", runtime.ParamLocationQuery, *params.Unload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SplitAlgorithmName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splitAlgorithmName", runtime.ParamLocationQuery, *params.SplitAlgorithmName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTopicHashPositionsRequest generates requests for GetTopicHashPositions
func NewGetTopicHashPositionsRequest(server string, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/topicHashPositions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Topics != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topics", runtime.ParamLocationQuery, *params.Topics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadNamespaceBundleRequest generates requests for UnloadNamespaceBundle
func NewUnloadNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnsubscribeNamespaceBundleRequest generates requests for UnsubscribeNamespaceBundle
func NewUnsubscribeNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/unsubscribe/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicListRequest generates requests for GetNonPersistentTopicList
func NewGetNonPersistentTopicListRequest(server string, tenant string, namespace string, params *GetNonPersistentTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Bundle != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundle", runtime.ParamLocationQuery, *params.Bundle); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentPartitionedTopicListRequest generates requests for GetNonPersistentPartitionedTopicList
func NewGetNonPersistentPartitionedTopicListRequest(server string, tenant string, namespace string, params *GetNonPersistentPartitionedTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/partitioned", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListFromBundleRequest generates requests for GetListFromBundle
func NewGetListFromBundleRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNonPersistentTopicRequest generates requests for DeleteNonPersistentTopic
func NewDeleteNonPersistentTopicRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNonPersistentTopicNonPartitionedTopicRequestWithBody generates requests for CreateNonPersistentTopicNonPartitionedTopic with any type of body
func NewCreateNonPersistentTopicNonPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreateNonPersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireNonPersistentTopicMessagesForAllSubscriptionsRequest generates requests for ExpireNonPersistentTopicMessagesForAllSubscriptions
func NewExpireNonPersistentTopicMessagesForAllSubscriptionsRequest(server string, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesForAllSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/all_subscription/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicBacklogRequest generates requests for GetNonPersistentTopicBacklog
func NewGetNonPersistentTopicBacklogRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNonPersistentTopicBacklogQuotaRequest generates requests for RemoveNonPersistentTopicBacklogQuota
func NewRemoveNonPersistentTopicBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicBacklogQuotaRequest generates requests for SetNonPersistentTopicBacklogQuota
func NewSetNonPersistentTopicBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicBacklogQuotaMapRequest generates requests for GetNonPersistentTopicBacklogQuotaMap
func NewGetNonPersistentTopicBacklogQuotaMapRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogQuotaMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuotaMap", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicBacklogSizeByMessageIdRequest generates requests for GetNonPersistentTopicBacklogSizeByMessageId
func NewGetNonPersistentTopicBacklogSizeByMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogSizeByMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicCompactionStatusRequest generates requests for GetNonPersistentTopicCompactionStatus
func NewGetNonPersistentTopicCompactionStatusRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompactNonPersistentTopicRequest generates requests for CompactNonPersistentTopic
func NewCompactNonPersistentTopicRequest(server string, tenant string, namespace string, topic string, params *CompactNonPersistentTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNonPersistentTopicCompactionThresholdRequest generates requests for RemoveNonPersistentTopicCompactionThreshold
func NewRemoveNonPersistentTopicCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicCompactionThresholdRequest generates requests for GetNonPersistentTopicCompactionThreshold
func NewGetNonPersistentTopicCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicCompactionThresholdRequestWithBody generates requests for SetNonPersistentTopicCompactionThreshold with any type of body
func NewSetNonPersistentTopicCompactionThresholdRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicCompactionThresholdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateNonPersistentTopicMissedPartitionsRequest generates requests for CreateNonPersistentTopicMissedPartitions
func NewCreateNonPersistentTopicMissedPartitionsRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/createMissedPartitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNonPersistentTopicDeduplicationRequest generates requests for RemoveNonPersistentTopicDeduplication
func NewRemoveNonPersistentTopicDeduplicationRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicDeduplicationRequest generates requests for GetNonPersistentTopicDeduplication
func NewGetNonPersistentTopicDeduplicationRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicDeduplicationRequestWithBody generates requests for SetNonPersistentTopicDeduplication with any type of body
func NewSetNonPersistentTopicDeduplicationRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNonPersistentTopicDeduplicationSnapshotIntervalRequest generates requests for DeleteNonPersistentTopicDeduplicationSnapshotInterval
func NewDeleteNonPersistentTopicDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicDeduplicationSnapshotIntervalRequest generates requests for GetNonPersistentTopicDeduplicationSnapshotInterval
func NewGetNonPersistentTopicDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicDeduplicationSnapshotIntervalRequestWithBody generates requests for SetNonPersistentTopicDeduplicationSnapshotInterval with any type of body
func NewSetNonPersistentTopicDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNonPersistentTopicDelayedDeliveryPoliciesRequest generates requests for DeleteNonPersistentTopicDelayedDeliveryPolicies
func NewDeleteNonPersistentTopicDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicDelayedDeliveryPoliciesRequest generates requests for GetNonPersistentTopicDelayedDeliveryPolicies
func NewGetNonPersistentTopicDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicDelayedDeliveryPoliciesRequestWithBody generates requests for SetNonPersistentTopicDelayedDeliveryPolicies with any type of body
func NewSetNonPersistentTopicDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicDispatchRateRequest generates requests for RemoveNonPersistentTopicDispatchRate
func NewRemoveNonPersistentTopicDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicDispatchRateRequest generates requests for GetNonPersistentTopicDispatchRate
func NewGetNonPersistentTopicDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicDispatchRateRequestWithBody generates requests for SetNonPersistentTopicDispatchRate with any type of body
func NewSetNonPersistentTopicDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicEntryFiltersRequest generates requests for RemoveNonPersistentTopicEntryFilters
func NewRemoveNonPersistentTopicEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicEntryFiltersRequest generates requests for GetNonPersistentTopicEntryFilters
func NewGetNonPersistentTopicEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicEntryFiltersRequestWithBody generates requests for SetNonPersistentTopicEntryFilters with any type of body
func NewSetNonPersistentTopicEntryFiltersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicEntryFiltersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExamineNonPersistentTopicMessageRequest generates requests for ExamineNonPersistentTopicMessage
func NewExamineNonPersistentTopicMessageRequest(server string, tenant string, namespace string, topic string, params *ExamineNonPersistentTopicMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/examinemessage", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InitialPosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "initialPosition", runtime.ParamLocationQuery, *params.InitialPosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MessagePosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messagePosition", runtime.ParamLocationQuery, *params.MessagePosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNonPersistentTopicInactiveTopicPoliciesRequest generates requests for DeleteNonPersistentTopicInactiveTopicPolicies
func NewDeleteNonPersistentTopicInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicInactiveTopicPoliciesRequest generates requests for GetNonPersistentTopicInactiveTopicPolicies
func NewGetNonPersistentTopicInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicInactiveTopicPoliciesRequestWithBody generates requests for SetNonPersistentTopicInactiveTopicPolicies with any type of body
func NewSetNonPersistentTopicInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicManagedLedgerInfoRequest generates requests for GetNonPersistentTopicManagedLedgerInfo
func NewGetNonPersistentTopicManagedLedgerInfoRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicManagedLedgerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/internal-info", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicInternalStatsRequest generates requests for GetNonPersistentTopicInternalStats
func NewGetNonPersistentTopicInternalStatsRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicInternalStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicLastMessageIdRequest generates requests for GetNonPersistentTopicLastMessageId
func NewGetNonPersistentTopicLastMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicLastMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/lastMessageId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMessageByIdRequest generates requests for GetNonPersistentTopicMessageById
func NewGetNonPersistentTopicMessageByIdRequest(server string, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetNonPersistentTopicMessageByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "ledgerId", runtime.ParamLocationPath, ledgerId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "entryId", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/ledger/%s/entry/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNonPersistentTopicMaxConsumersRequest generates requests for RemoveNonPersistentTopicMaxConsumers
func NewRemoveNonPersistentTopicMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMaxConsumersRequest generates requests for GetNonPersistentTopicMaxConsumers
func NewGetNonPersistentTopicMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMaxConsumersRequestWithBody generates requests for SetNonPersistentTopicMaxConsumers with any type of body
func NewSetNonPersistentTopicMaxConsumersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicMaxConsumersPerSubscriptionRequest generates requests for RemoveNonPersistentTopicMaxConsumersPerSubscription
func NewRemoveNonPersistentTopicMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMaxConsumersPerSubscriptionRequest generates requests for GetNonPersistentTopicMaxConsumersPerSubscription
func NewGetNonPersistentTopicMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMaxConsumersPerSubscriptionRequestWithBody generates requests for SetNonPersistentTopicMaxConsumersPerSubscription with any type of body
func NewSetNonPersistentTopicMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicMaxMessageSizeRequest generates requests for RemoveNonPersistentTopicMaxMessageSize
func NewRemoveNonPersistentTopicMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMaxMessageSizeRequest generates requests for GetNonPersistentTopicMaxMessageSize
func NewGetNonPersistentTopicMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMaxMessageSizeRequestWithBody generates requests for SetNonPersistentTopicMaxMessageSize with any type of body
func NewSetNonPersistentTopicMaxMessageSizeRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicMaxProducersRequest generates requests for RemoveNonPersistentTopicMaxProducers
func NewRemoveNonPersistentTopicMaxProducersRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMaxProducersRequest generates requests for GetNonPersistentTopicMaxProducers
func NewGetNonPersistentTopicMaxProducersRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMaxProducersRequestWithBody generates requests for SetNonPersistentTopicMaxProducers with any type of body
func NewSetNonPersistentTopicMaxProducersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxProducersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicMaxSubscriptionsPerTopicRequest generates requests for RemoveNonPersistentTopicMaxSubscriptionsPerTopic
func NewRemoveNonPersistentTopicMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMaxSubscriptionsPerTopicRequest generates requests for GetNonPersistentTopicMaxSubscriptionsPerTopic
func NewGetNonPersistentTopicMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMaxSubscriptionsPerTopicRequestWithBody generates requests for SetNonPersistentTopicMaxSubscriptionsPerTopic with any type of body
func NewSetNonPersistentTopicMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNonPersistentTopicMaxUnackedMessagesOnConsumerRequest generates requests for DeleteNonPersistentTopicMaxUnackedMessagesOnConsumer
func NewDeleteNonPersistentTopicMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMaxUnackedMessagesOnConsumerRequest generates requests for GetNonPersistentTopicMaxUnackedMessagesOnConsumer
func NewGetNonPersistentTopicMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMaxUnackedMessagesOnConsumerRequestWithBody generates requests for SetNonPersistentTopicMaxUnackedMessagesOnConsumer with any type of body
func NewSetNonPersistentTopicMaxUnackedMessagesOnConsumerRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequest generates requests for DeleteNonPersistentTopicMaxUnackedMessagesOnSubscription
func NewDeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequest generates requests for GetNonPersistentTopicMaxUnackedMessagesOnSubscription
func NewGetNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequestWithBody generates requests for SetNonPersistentTopicMaxUnackedMessagesOnSubscription with any type of body
func NewSetNonPersistentTopicMaxUnackedMessagesOnSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicMessageTTLRequest generates requests for RemoveNonPersistentTopicMessageTTL
func NewRemoveNonPersistentTopicMessageTTLRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMessageTTLRequest generates requests for GetNonPersistentTopicMessageTTL
func NewGetNonPersistentTopicMessageTTLRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicMessageTTLRequest generates requests for SetNonPersistentTopicMessageTTL
func NewSetNonPersistentTopicMessageTTLRequest(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageTTL", runtime.ParamLocationQuery, params.MessageTTL); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicMessageIdByTimestampRequest generates requests for GetNonPersistentTopicMessageIdByTimestamp
func NewGetNonPersistentTopicMessageIdByTimestampRequest(server string, tenant string, namespace string, topic string, timestamp int64, params *GetNonPersistentTopicMessageIdByTimestampParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageid/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOffloadNonPersistentTopicStatusRequest generates requests for OffloadNonPersistentTopicStatus
func NewOffloadNonPersistentTopicStatusRequest(server string, tenant string, namespace string, topic string, params *OffloadNonPersistentTopicStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerNonPersistentTopicOffloadRequest generates requests for TriggerNonPersistentTopicOffload
func NewTriggerNonPersistentTopicOffloadRequest(server string, tenant string, namespace string, topic string, params *TriggerNonPersistentTopicOffloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNonPersistentTopicOffloadPoliciesRequest generates requests for RemoveNonPersistentTopicOffloadPolicies
func NewRemoveNonPersistentTopicOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicOffloadPoliciesRequest generates requests for GetNonPersistentTopicOffloadPolicies
func NewGetNonPersistentTopicOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicOffloadPoliciesRequestWithBody generates requests for SetNonPersistentTopicOffloadPolicies with any type of body
func NewSetNonPersistentTopicOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicPartitionedStatsRequest generates requests for GetNonPersistentTopicPartitionedStats
func NewGetNonPersistentTopicPartitionedStatsRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitioned-stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPartition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPartition", runtime.ParamLocationQuery, *params.PerPartition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNonPersistentTopicPartitionedTopicRequest generates requests for DeleteNonPersistentTopicPartitionedTopic
func NewDeleteNonPersistentTopicPartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicPartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicPartitionedMetadataRequest generates requests for GetNonPersistentTopicPartitionedMetadata
func NewGetNonPersistentTopicPartitionedMetadataRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CheckAllowAutoCreation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkAllowAutoCreation", runtime.ParamLocationQuery, *params.CheckAllowAutoCreation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNonPersistentTopicPartitionedTopicRequestWithBody generates requests for UpdateNonPersistentTopicPartitionedTopic with any type of body
func NewUpdateNonPersistentTopicPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateLocalTopicOnly", runtime.ParamLocationQuery, *params.UpdateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateNonPersistentTopicPartitionedTopicRequest calls the generic CreateNonPersistentTopicPartitionedTopic builder with application/vnd.partitioned-topic-metadata+json body
func NewCreateNonPersistentTopicPartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, body CreateNonPersistentTopicPartitionedTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNonPersistentTopicPartitionedTopicRequestWithBody(server, tenant, namespace, topic, params, "application/vnd.partitioned-topic-metadata+json", bodyReader)
}

// NewCreateNonPersistentTopicPartitionedTopicRequestWithBody generates requests for CreateNonPersistentTopicPartitionedTopic with any type of body
func NewCreateNonPersistentTopicPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createLocalTopicOnly", runtime.ParamLocationQuery, *params.CreateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicPermissionsOnTopicRequest generates requests for GetNonPersistentTopicPermissionsOnTopic
func NewGetNonPersistentTopicPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicRequest generates requests for RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopic
func NewRevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGrantNonPersistentTopicPermissionsOnTopicRequestWithBody generates requests for GrantNonPersistentTopicPermissionsOnTopic with any type of body
func NewGrantNonPersistentTopicPermissionsOnTopicRequestWithBody(server string, tenant string, namespace string, topic string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicPersistenceRequest generates requests for RemoveNonPersistentTopicPersistence
func NewRemoveNonPersistentTopicPersistenceRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicPersistenceRequest generates requests for GetNonPersistentTopicPersistence
func NewGetNonPersistentTopicPersistenceRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicPersistenceRequestWithBody generates requests for SetNonPersistentTopicPersistence with any type of body
func NewSetNonPersistentTopicPersistenceRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicPersistenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicPropertiesRequest generates requests for RemoveNonPersistentTopicProperties
func NewRemoveNonPersistentTopicPropertiesRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Key != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicPropertiesRequest generates requests for GetNonPersistentTopicProperties
func NewGetNonPersistentTopicPropertiesRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNonPersistentTopicPropertiesRequestWithBody generates requests for UpdateNonPersistentTopicProperties with any type of body
func NewUpdateNonPersistentTopicPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicPublishRateRequest generates requests for RemoveNonPersistentTopicPublishRate
func NewRemoveNonPersistentTopicPublishRateRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicPublishRateRequest generates requests for GetNonPersistentTopicPublishRate
func NewGetNonPersistentTopicPublishRateRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicPublishRateRequestWithBody generates requests for SetNonPersistentTopicPublishRate with any type of body
func NewSetNonPersistentTopicPublishRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicPublishRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicReplicationClustersRequest generates requests for RemoveNonPersistentTopicReplicationClusters
func NewRemoveNonPersistentTopicReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicReplicationClustersRequest generates requests for GetNonPersistentTopicReplicationClusters
func NewGetNonPersistentTopicReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicReplicationClustersRequestWithBody generates requests for SetNonPersistentTopicReplicationClusters with any type of body
func NewSetNonPersistentTopicReplicationClustersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicationClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicReplicatorDispatchRateRequest generates requests for RemoveNonPersistentTopicReplicatorDispatchRate
func NewRemoveNonPersistentTopicReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicReplicatorDispatchRateRequest generates requests for GetNonPersistentTopicReplicatorDispatchRate
func NewGetNonPersistentTopicReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicReplicatorDispatchRateRequestWithBody generates requests for SetNonPersistentTopicReplicatorDispatchRate with any type of body
func NewSetNonPersistentTopicReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicRetentionRequest generates requests for RemoveNonPersistentTopicRetention
func NewRemoveNonPersistentTopicRetentionRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicRetentionRequest generates requests for GetNonPersistentTopicRetention
func NewGetNonPersistentTopicRetentionRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicRetentionRequestWithBody generates requests for SetNonPersistentTopicRetention with any type of body
func NewSetNonPersistentTopicRetentionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicRetentionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicSchemaCompatibilityStrategyRequestWithBody generates requests for RemoveNonPersistentTopicSchemaCompatibilityStrategy with any type of body
func NewRemoveNonPersistentTopicSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicSchemaCompatibilityStrategyRequest generates requests for GetNonPersistentTopicSchemaCompatibilityStrategy
func NewGetNonPersistentTopicSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaCompatibilityStrategyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicSchemaCompatibilityStrategyRequestWithBody generates requests for SetNonPersistentTopicSchemaCompatibilityStrategy with any type of body
func NewSetNonPersistentTopicSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicSchemaValidationEnforcedRequest generates requests for GetNonPersistentTopicSchemaValidationEnforced
func NewGetNonPersistentTopicSchemaValidationEnforcedRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaValidationEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicSchemaValidationEnforcedRequestWithBody generates requests for SetNonPersistentTopicSchemaValidationEnforced with any type of body
func NewSetNonPersistentTopicSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNonPersistentTopicShadowTopicsRequest generates requests for DeleteNonPersistentTopicShadowTopics
func NewDeleteNonPersistentTopicShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicShadowTopicsRequest generates requests for GetNonPersistentTopicShadowTopics
func NewGetNonPersistentTopicShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicShadowTopicsRequestWithBody generates requests for SetNonPersistentTopicShadowTopics with any type of body
func NewSetNonPersistentTopicShadowTopicsRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicShadowTopicsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicStatsRequest generates requests for GetNonPersistentTopicStats
func NewGetNonPersistentTopicStatsRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNonPersistentTopicSubscribeRateRequestWithBody generates requests for RemoveNonPersistentTopicSubscribeRate with any type of body
func NewRemoveNonPersistentTopicSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicSubscribeRateRequest generates requests for GetNonPersistentTopicSubscribeRate
func NewGetNonPersistentTopicSubscribeRateRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscribeRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicSubscribeRateRequestWithBody generates requests for SetNonPersistentTopicSubscribeRate with any type of body
func NewSetNonPersistentTopicSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNonPersistentTopicSubscriptionRequest generates requests for DeleteNonPersistentTopicSubscription
func NewDeleteNonPersistentTopicSubscriptionRequest(server string, tenant string, namespace string, topic string, subName string, params *DeleteNonPersistentTopicSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnalyzeNonPersistentTopicSubscriptionBacklogRequestWithBody generates requests for AnalyzeNonPersistentTopicSubscriptionBacklog with any type of body
func NewAnalyzeNonPersistentTopicSubscriptionBacklogRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *AnalyzeNonPersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/analyzeBacklog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireNonPersistentTopicMessagesRequestWithBody generates requests for ExpireNonPersistentTopicMessages with any type of body
func NewExpireNonPersistentTopicMessagesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ExpireNonPersistentTopicMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/expireMessages", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpireNonPersistentTopicMessagesTimeInSecondsRequest generates requests for ExpireNonPersistentTopicMessagesTimeInSeconds
func NewExpireNonPersistentTopicMessagesTimeInSecondsRequest(server string, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesTimeInSecondsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPeekNonPersistentTopicNthMessageRequest generates requests for PeekNonPersistentTopicNthMessage
func NewPeekNonPersistentTopicNthMessageRequest(server string, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNonPersistentTopicNthMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "messagePosition", runtime.ParamLocationPath, messagePosition)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/position/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicSubscriptionPropertiesRequest generates requests for GetNonPersistentTopicSubscriptionProperties
func NewGetNonPersistentTopicSubscriptionPropertiesRequest(server string, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNonPersistentTopicSubscriptionPropertiesRequestWithBody generates requests for UpdateNonPersistentTopicSubscriptionProperties with any type of body
func NewUpdateNonPersistentTopicSubscriptionPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *UpdateNonPersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicReplicatedSubscriptionStatusRequest generates requests for GetNonPersistentTopicReplicatedSubscriptionStatus
func NewGetNonPersistentTopicReplicatedSubscriptionStatusRequest(server string, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicReplicatedSubscriptionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicReplicatedSubscriptionStatusRequestWithBody generates requests for SetNonPersistentTopicReplicatedSubscriptionStatus with any type of body
func NewSetNonPersistentTopicReplicatedSubscriptionStatusRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetNonPersistentTopicCursorOnPositionRequestWithBody generates requests for ResetNonPersistentTopicCursorOnPosition with any type of body
func NewResetNonPersistentTopicCursorOnPositionRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ResetNonPersistentTopicCursorOnPositionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/resetcursor", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetNonPersistentTopicCursorRequest generates requests for ResetNonPersistentTopicCursor
func NewResetNonPersistentTopicCursorRequest(server string, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetNonPersistentTopicCursorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/resetcursor/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipNonPersistentTopicMessagesRequest generates requests for SkipNonPersistentTopicMessages
func NewSkipNonPersistentTopicMessagesRequest(server string, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipNonPersistentTopicMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "numMessages", runtime.ParamLocationPath, numMessages)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/skip/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipNonPersistentTopicAllMessagesRequest generates requests for SkipNonPersistentTopicAllMessages
func NewSkipNonPersistentTopicAllMessagesRequest(server string, tenant string, namespace string, topic string, subName string, params *SkipNonPersistentTopicAllMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/skip_all", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNonPersistentTopicSubscriptionRequestWithBody generates requests for CreateNonPersistentTopicSubscription with any type of body
func NewCreateNonPersistentTopicSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, subscriptionName string, params *CreateNonPersistentTopicSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscriptionName", runtime.ParamLocationPath, subscriptionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Replicated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replicated", runtime.ParamLocationQuery, *params.Replicated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicSubscriptionDispatchRateRequest generates requests for RemoveNonPersistentTopicSubscriptionDispatchRate
func NewRemoveNonPersistentTopicSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicSubscriptionDispatchRateRequest generates requests for GetNonPersistentTopicSubscriptionDispatchRate
func NewGetNonPersistentTopicSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicSubscriptionDispatchRateRequestWithBody generates requests for SetNonPersistentTopicSubscriptionDispatchRate with any type of body
func NewSetNonPersistentTopicSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNonPersistentTopicSubscriptionTypesEnabledRequest generates requests for RemoveNonPersistentTopicSubscriptionTypesEnabled
func NewRemoveNonPersistentTopicSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicSubscriptionTypesEnabledRequest generates requests for GetNonPersistentTopicSubscriptionTypesEnabled
func NewGetNonPersistentTopicSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicSubscriptionTypesEnabledRequestWithBody generates requests for SetNonPersistentTopicSubscriptionTypesEnabled with any type of body
func NewSetNonPersistentTopicSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNonPersistentTopicSubscriptionsRequest generates requests for GetNonPersistentTopicSubscriptions
func NewGetNonPersistentTopicSubscriptionsRequest(server string, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateNonPersistentTopicRequest generates requests for TerminateNonPersistentTopic
func NewTerminateNonPersistentTopicRequest(server string, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/terminate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminateNonPersistentTopicPartitionedTopicRequest generates requests for TerminateNonPersistentTopicPartitionedTopic
func NewTerminateNonPersistentTopicPartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicPartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/terminate/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTruncateNonPersistentTopicTopicRequest generates requests for TruncateNonPersistentTopicTopic
func NewTruncateNonPersistentTopicTopicRequest(server string, tenant string, namespace string, topic string, params *TruncateNonPersistentTopicTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/truncate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadNonPersistentTopicTopicRequest generates requests for UnloadNonPersistentTopicTopic
func NewUnloadNonPersistentTopicTopicRequest(server string, tenant string, namespace string, topic string, params *UnloadNonPersistentTopicTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveNonPersistentTopicSubscriptionLevelDispatchRateRequest generates requests for RemoveNonPersistentTopicSubscriptionLevelDispatchRate
func NewRemoveNonPersistentTopicSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *RemoveNonPersistentTopicSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNonPersistentTopicSubscriptionLevelDispatchRateRequest generates requests for GetNonPersistentTopicSubscriptionLevelDispatchRate
func NewGetNonPersistentTopicSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNonPersistentTopicSubscriptionLevelDispatchRateRequestWithBody generates requests for SetNonPersistentTopicSubscriptionLevelDispatchRate with any type of body
func NewSetNonPersistentTopicSubscriptionLevelDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicListRequest generates requests for GetPersistentTopicList
func NewGetPersistentTopicListRequest(server string, tenant string, namespace string, params *GetPersistentTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Bundle != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundle", runtime.ParamLocationQuery, *params.Bundle); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentPartitionedTopicListRequest generates requests for GetPersistentPartitionedTopicList
func NewGetPersistentPartitionedTopicListRequest(server string, tenant string, namespace string, params *GetPersistentPartitionedTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/partitioned", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeSystemTopic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersistentTopicRequest generates requests for DeletePersistentTopic
func NewDeletePersistentTopicRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePersistentTopicNonPartitionedTopicRequestWithBody generates requests for CreatePersistentTopicNonPartitionedTopic with any type of body
func NewCreatePersistentTopicNonPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreatePersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpirePersistentTopicMessagesForAllSubscriptionsRequest generates requests for ExpirePersistentTopicMessagesForAllSubscriptions
func NewExpirePersistentTopicMessagesForAllSubscriptionsRequest(server string, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesForAllSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/all_subscription/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicBacklogRequest generates requests for GetPersistentTopicBacklog
func NewGetPersistentTopicBacklogRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePersistentTopicBacklogQuotaRequest generates requests for RemovePersistentTopicBacklogQuota
func NewRemovePersistentTopicBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicBacklogQuotaRequest generates requests for SetPersistentTopicBacklogQuota
func NewSetPersistentTopicBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *SetPersistentTopicBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicBacklogQuotaMapRequest generates requests for GetPersistentTopicBacklogQuotaMap
func NewGetPersistentTopicBacklogQuotaMapRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogQuotaMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuotaMap", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicBacklogSizeByMessageIdRequest generates requests for GetPersistentTopicBacklogSizeByMessageId
func NewGetPersistentTopicBacklogSizeByMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogSizeByMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicCompactionStatusRequest generates requests for GetPersistentTopicCompactionStatus
func NewGetPersistentTopicCompactionStatusRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompactPersistentTopicRequest generates requests for CompactPersistentTopic
func NewCompactPersistentTopicRequest(server string, tenant string, namespace string, topic string, params *CompactPersistentTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePersistentTopicCompactionThresholdRequest generates requests for RemovePersistentTopicCompactionThreshold
func NewRemovePersistentTopicCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicCompactionThresholdRequest generates requests for GetPersistentTopicCompactionThreshold
func NewGetPersistentTopicCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicCompactionThresholdRequestWithBody generates requests for SetPersistentTopicCompactionThreshold with any type of body
func NewSetPersistentTopicCompactionThresholdRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicCompactionThresholdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePersistentTopicMissedPartitionsRequest generates requests for CreatePersistentTopicMissedPartitions
func NewCreatePersistentTopicMissedPartitionsRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/createMissedPartitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePersistentTopicDeduplicationRequest generates requests for RemovePersistentTopicDeduplication
func NewRemovePersistentTopicDeduplicationRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicDeduplicationRequest generates requests for GetPersistentTopicDeduplication
func NewGetPersistentTopicDeduplicationRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicDeduplicationRequestWithBody generates requests for SetPersistentTopicDeduplication with any type of body
func NewSetPersistentTopicDeduplicationRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistentTopicDeduplicationSnapshotIntervalRequest generates requests for DeletePersistentTopicDeduplicationSnapshotInterval
func NewDeletePersistentTopicDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicDeduplicationSnapshotIntervalRequest generates requests for GetPersistentTopicDeduplicationSnapshotInterval
func NewGetPersistentTopicDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicDeduplicationSnapshotIntervalRequestWithBody generates requests for SetPersistentTopicDeduplicationSnapshotInterval with any type of body
func NewSetPersistentTopicDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistentTopicDelayedDeliveryPoliciesRequest generates requests for DeletePersistentTopicDelayedDeliveryPolicies
func NewDeletePersistentTopicDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicDelayedDeliveryPoliciesRequest generates requests for GetPersistentTopicDelayedDeliveryPolicies
func NewGetPersistentTopicDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicDelayedDeliveryPoliciesRequestWithBody generates requests for SetPersistentTopicDelayedDeliveryPolicies with any type of body
func NewSetPersistentTopicDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicDispatchRateRequest generates requests for RemovePersistentTopicDispatchRate
func NewRemovePersistentTopicDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicDispatchRateRequest generates requests for GetPersistentTopicDispatchRate
func NewGetPersistentTopicDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicDispatchRateRequestWithBody generates requests for SetPersistentTopicDispatchRate with any type of body
func NewSetPersistentTopicDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicEntryFiltersRequest generates requests for RemovePersistentTopicEntryFilters
func NewRemovePersistentTopicEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicEntryFiltersRequest generates requests for GetPersistentTopicEntryFilters
func NewGetPersistentTopicEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicEntryFiltersRequestWithBody generates requests for SetPersistentTopicEntryFilters with any type of body
func NewSetPersistentTopicEntryFiltersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicEntryFiltersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExaminePersistentTopicMessageRequest generates requests for ExaminePersistentTopicMessage
func NewExaminePersistentTopicMessageRequest(server string, tenant string, namespace string, topic string, params *ExaminePersistentTopicMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/examinemessage", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InitialPosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "initialPosition", runtime.ParamLocationQuery, *params.InitialPosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MessagePosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messagePosition", runtime.ParamLocationQuery, *params.MessagePosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersistentTopicInactiveTopicPoliciesRequest generates requests for DeletePersistentTopicInactiveTopicPolicies
func NewDeletePersistentTopicInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicInactiveTopicPoliciesRequest generates requests for GetPersistentTopicInactiveTopicPolicies
func NewGetPersistentTopicInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicInactiveTopicPoliciesRequestWithBody generates requests for SetPersistentTopicInactiveTopicPolicies with any type of body
func NewSetPersistentTopicInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicManagedLedgerInfoRequest generates requests for GetPersistentTopicManagedLedgerInfo
func NewGetPersistentTopicManagedLedgerInfoRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicManagedLedgerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/internal-info", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicInternalStatsRequest generates requests for GetPersistentTopicInternalStats
func NewGetPersistentTopicInternalStatsRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicInternalStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicLastMessageIdRequest generates requests for GetPersistentTopicLastMessageId
func NewGetPersistentTopicLastMessageIdRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicLastMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/lastMessageId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMessageByIdRequest generates requests for GetPersistentTopicMessageById
func NewGetPersistentTopicMessageByIdRequest(server string, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetPersistentTopicMessageByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "ledgerId", runtime.ParamLocationPath, ledgerId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "entryId", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/ledger/%s/entry/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePersistentTopicMaxConsumersRequest generates requests for RemovePersistentTopicMaxConsumers
func NewRemovePersistentTopicMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMaxConsumersRequest generates requests for GetPersistentTopicMaxConsumers
func NewGetPersistentTopicMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMaxConsumersRequestWithBody generates requests for SetPersistentTopicMaxConsumers with any type of body
func NewSetPersistentTopicMaxConsumersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicMaxConsumersPerSubscriptionRequest generates requests for RemovePersistentTopicMaxConsumersPerSubscription
func NewRemovePersistentTopicMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMaxConsumersPerSubscriptionRequest generates requests for GetPersistentTopicMaxConsumersPerSubscription
func NewGetPersistentTopicMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMaxConsumersPerSubscriptionRequestWithBody generates requests for SetPersistentTopicMaxConsumersPerSubscription with any type of body
func NewSetPersistentTopicMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicMaxMessageSizeRequest generates requests for RemovePersistentTopicMaxMessageSize
func NewRemovePersistentTopicMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMaxMessageSizeRequest generates requests for GetPersistentTopicMaxMessageSize
func NewGetPersistentTopicMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMaxMessageSizeRequestWithBody generates requests for SetPersistentTopicMaxMessageSize with any type of body
func NewSetPersistentTopicMaxMessageSizeRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicMaxProducersRequest generates requests for RemovePersistentTopicMaxProducers
func NewRemovePersistentTopicMaxProducersRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMaxProducersRequest generates requests for GetPersistentTopicMaxProducers
func NewGetPersistentTopicMaxProducersRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMaxProducersRequestWithBody generates requests for SetPersistentTopicMaxProducers with any type of body
func NewSetPersistentTopicMaxProducersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMaxProducersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicMaxSubscriptionsPerTopicRequest generates requests for RemovePersistentTopicMaxSubscriptionsPerTopic
func NewRemovePersistentTopicMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMaxSubscriptionsPerTopicRequest generates requests for GetPersistentTopicMaxSubscriptionsPerTopic
func NewGetPersistentTopicMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMaxSubscriptionsPerTopicRequestWithBody generates requests for SetPersistentTopicMaxSubscriptionsPerTopic with any type of body
func NewSetPersistentTopicMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistentTopicMaxUnackedMessagesOnConsumerRequest generates requests for DeletePersistentTopicMaxUnackedMessagesOnConsumer
func NewDeletePersistentTopicMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMaxUnackedMessagesOnConsumerRequest generates requests for GetPersistentTopicMaxUnackedMessagesOnConsumer
func NewGetPersistentTopicMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMaxUnackedMessagesOnConsumerRequestWithBody generates requests for SetPersistentTopicMaxUnackedMessagesOnConsumer with any type of body
func NewSetPersistentTopicMaxUnackedMessagesOnConsumerRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistentTopicMaxUnackedMessagesOnSubscriptionRequest generates requests for DeletePersistentTopicMaxUnackedMessagesOnSubscription
func NewDeletePersistentTopicMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMaxUnackedMessagesOnSubscriptionRequest generates requests for GetPersistentTopicMaxUnackedMessagesOnSubscription
func NewGetPersistentTopicMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMaxUnackedMessagesOnSubscriptionRequestWithBody generates requests for SetPersistentTopicMaxUnackedMessagesOnSubscription with any type of body
func NewSetPersistentTopicMaxUnackedMessagesOnSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicMessageTTLRequest generates requests for RemovePersistentTopicMessageTTL
func NewRemovePersistentTopicMessageTTLRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMessageTTLRequest generates requests for GetPersistentTopicMessageTTL
func NewGetPersistentTopicMessageTTLRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicMessageTTLRequest generates requests for SetPersistentTopicMessageTTL
func NewSetPersistentTopicMessageTTLRequest(server string, tenant string, namespace string, topic string, params *SetPersistentTopicMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageTTL", runtime.ParamLocationQuery, params.MessageTTL); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicMessageIdByTimestampRequest generates requests for GetPersistentTopicMessageIdByTimestamp
func NewGetPersistentTopicMessageIdByTimestampRequest(server string, tenant string, namespace string, topic string, timestamp int64, params *GetPersistentTopicMessageIdByTimestampParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageid/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOffloadPersistentTopicStatusRequest generates requests for OffloadPersistentTopicStatus
func NewOffloadPersistentTopicStatusRequest(server string, tenant string, namespace string, topic string, params *OffloadPersistentTopicStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerPersistentTopicOffloadRequest generates requests for TriggerPersistentTopicOffload
func NewTriggerPersistentTopicOffloadRequest(server string, tenant string, namespace string, topic string, params *TriggerPersistentTopicOffloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePersistentTopicOffloadPoliciesRequest generates requests for RemovePersistentTopicOffloadPolicies
func NewRemovePersistentTopicOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicOffloadPoliciesRequest generates requests for GetPersistentTopicOffloadPolicies
func NewGetPersistentTopicOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicOffloadPoliciesRequestWithBody generates requests for SetPersistentTopicOffloadPolicies with any type of body
func NewSetPersistentTopicOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicPartitionedStatsRequest generates requests for GetPersistentTopicPartitionedStats
func NewGetPersistentTopicPartitionedStatsRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitioned-stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPartition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPartition", runtime.ParamLocationQuery, *params.PerPartition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersistentTopicPartitionedTopicRequest generates requests for DeletePersistentTopicPartitionedTopic
func NewDeletePersistentTopicPartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicPartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicPartitionedMetadataRequest generates requests for GetPersistentTopicPartitionedMetadata
func NewGetPersistentTopicPartitionedMetadataRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CheckAllowAutoCreation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkAllowAutoCreation", runtime.ParamLocationQuery, *params.CheckAllowAutoCreation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePersistentTopicPartitionedTopicRequestWithBody generates requests for UpdatePersistentTopicPartitionedTopic with any type of body
func NewUpdatePersistentTopicPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateLocalTopicOnly", runtime.ParamLocationQuery, *params.UpdateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePersistentTopicPartitionedTopicRequestWithBody generates requests for CreatePersistentTopicPartitionedTopic with any type of body
func NewCreatePersistentTopicPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *CreatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreateLocalTopicOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createLocalTopicOnly", runtime.ParamLocationQuery, *params.CreateLocalTopicOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicPermissionsOnTopicRequest generates requests for GetPersistentTopicPermissionsOnTopic
func NewGetPersistentTopicPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokePersistentTopicNonPersistentTopicPermissionsOnTopicRequest generates requests for RevokePersistentTopicNonPersistentTopicPermissionsOnTopic
func NewRevokePersistentTopicNonPersistentTopicPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGrantPersistentTopicPermissionsOnTopicRequestWithBody generates requests for GrantPersistentTopicPermissionsOnTopic with any type of body
func NewGrantPersistentTopicPermissionsOnTopicRequestWithBody(server string, tenant string, namespace string, topic string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicPersistenceRequest generates requests for RemovePersistentTopicPersistence
func NewRemovePersistentTopicPersistenceRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicPersistenceRequest generates requests for GetPersistentTopicPersistence
func NewGetPersistentTopicPersistenceRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicPersistenceRequestWithBody generates requests for SetPersistentTopicPersistence with any type of body
func NewSetPersistentTopicPersistenceRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicPersistenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicPropertiesRequest generates requests for RemovePersistentTopicProperties
func NewRemovePersistentTopicPropertiesRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Key != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicPropertiesRequest generates requests for GetPersistentTopicProperties
func NewGetPersistentTopicPropertiesRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePersistentTopicPropertiesRequestWithBody generates requests for UpdatePersistentTopicProperties with any type of body
func NewUpdatePersistentTopicPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, params *UpdatePersistentTopicPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicPublishRateRequest generates requests for RemovePersistentTopicPublishRate
func NewRemovePersistentTopicPublishRateRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicPublishRateRequest generates requests for GetPersistentTopicPublishRate
func NewGetPersistentTopicPublishRateRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicPublishRateRequestWithBody generates requests for SetPersistentTopicPublishRate with any type of body
func NewSetPersistentTopicPublishRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicPublishRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicReplicationClustersRequest generates requests for RemovePersistentTopicReplicationClusters
func NewRemovePersistentTopicReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.BacklogQuotaType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicReplicationClustersRequest generates requests for GetPersistentTopicReplicationClusters
func NewGetPersistentTopicReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicReplicationClustersRequestWithBody generates requests for SetPersistentTopicReplicationClusters with any type of body
func NewSetPersistentTopicReplicationClustersRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicReplicationClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicReplicatorDispatchRateRequest generates requests for RemovePersistentTopicReplicatorDispatchRate
func NewRemovePersistentTopicReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicReplicatorDispatchRateRequest generates requests for GetPersistentTopicReplicatorDispatchRate
func NewGetPersistentTopicReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicReplicatorDispatchRateRequestWithBody generates requests for SetPersistentTopicReplicatorDispatchRate with any type of body
func NewSetPersistentTopicReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicRetentionRequest generates requests for RemovePersistentTopicRetention
func NewRemovePersistentTopicRetentionRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicRetentionRequest generates requests for GetPersistentTopicRetention
func NewGetPersistentTopicRetentionRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicRetentionRequestWithBody generates requests for SetPersistentTopicRetention with any type of body
func NewSetPersistentTopicRetentionRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicRetentionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicSchemaCompatibilityStrategyRequestWithBody generates requests for RemovePersistentTopicSchemaCompatibilityStrategy with any type of body
func NewRemovePersistentTopicSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicSchemaCompatibilityStrategyRequest generates requests for GetPersistentTopicSchemaCompatibilityStrategy
func NewGetPersistentTopicSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaCompatibilityStrategyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicSchemaCompatibilityStrategyRequestWithBody generates requests for SetPersistentTopicSchemaCompatibilityStrategy with any type of body
func NewSetPersistentTopicSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicSchemaValidationEnforcedRequest generates requests for GetPersistentTopicSchemaValidationEnforced
func NewGetPersistentTopicSchemaValidationEnforcedRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaValidationEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicSchemaValidationEnforcedRequestWithBody generates requests for SetPersistentTopicSchemaValidationEnforced with any type of body
func NewSetPersistentTopicSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistentTopicShadowTopicsRequest generates requests for DeletePersistentTopicShadowTopics
func NewDeletePersistentTopicShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *DeletePersistentTopicShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicShadowTopicsRequest generates requests for GetPersistentTopicShadowTopics
func NewGetPersistentTopicShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicShadowTopicsRequestWithBody generates requests for SetPersistentTopicShadowTopics with any type of body
func NewSetPersistentTopicShadowTopicsRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicShadowTopicsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicStatsRequest generates requests for GetPersistentTopicStats
func NewGetPersistentTopicStatsRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetPreciseBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubscriptionBacklogSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.GetEarliestTimeInBacklog != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePersistentTopicSubscribeRateRequestWithBody generates requests for RemovePersistentTopicSubscribeRate with any type of body
func NewRemovePersistentTopicSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicSubscribeRateRequest generates requests for GetPersistentTopicSubscribeRate
func NewGetPersistentTopicSubscribeRateRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicSubscribeRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicSubscribeRateRequestWithBody generates requests for SetPersistentTopicSubscribeRate with any type of body
func NewSetPersistentTopicSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePersistentTopicSubscriptionRequest generates requests for DeletePersistentTopicSubscription
func NewDeletePersistentTopicSubscriptionRequest(server string, tenant string, namespace string, topic string, subName string, params *DeletePersistentTopicSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnalyzePersistentTopicSubscriptionBacklogRequestWithBody generates requests for AnalyzePersistentTopicSubscriptionBacklog with any type of body
func NewAnalyzePersistentTopicSubscriptionBacklogRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *AnalyzePersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/analyzeBacklog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpirePersistentTopicMessagesRequestWithBody generates requests for ExpirePersistentTopicMessages with any type of body
func NewExpirePersistentTopicMessagesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ExpirePersistentTopicMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/expireMessages", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExpirePersistentTopicMessagesTimeInSecondsRequest generates requests for ExpirePersistentTopicMessagesTimeInSeconds
func NewExpirePersistentTopicMessagesTimeInSecondsRequest(server string, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesTimeInSecondsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPeekPersistentTopicNthMessageRequest generates requests for PeekPersistentTopicNthMessage
func NewPeekPersistentTopicNthMessageRequest(server string, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekPersistentTopicNthMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "messagePosition", runtime.ParamLocationPath, messagePosition)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/position/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicSubscriptionPropertiesRequest generates requests for GetPersistentTopicSubscriptionProperties
func NewGetPersistentTopicSubscriptionPropertiesRequest(server string, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePersistentTopicSubscriptionPropertiesRequestWithBody generates requests for UpdatePersistentTopicSubscriptionProperties with any type of body
func NewUpdatePersistentTopicSubscriptionPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *UpdatePersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicReplicatedSubscriptionStatusRequest generates requests for GetPersistentTopicReplicatedSubscriptionStatus
func NewGetPersistentTopicReplicatedSubscriptionStatusRequest(server string, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicReplicatedSubscriptionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicReplicatedSubscriptionStatusRequestWithBody generates requests for SetPersistentTopicReplicatedSubscriptionStatus with any type of body
func NewSetPersistentTopicReplicatedSubscriptionStatusRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPersistentTopicCursorOnPositionRequestWithBody generates requests for ResetPersistentTopicCursorOnPosition with any type of body
func NewResetPersistentTopicCursorOnPositionRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *ResetPersistentTopicCursorOnPositionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/resetcursor", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPersistentTopicCursorRequest generates requests for ResetPersistentTopicCursor
func NewResetPersistentTopicCursorRequest(server string, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetPersistentTopicCursorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/resetcursor/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipPersistentTopicMessagesRequest generates requests for SkipPersistentTopicMessages
func NewSkipPersistentTopicMessagesRequest(server string, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipPersistentTopicMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "numMessages", runtime.ParamLocationPath, numMessages)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/skip/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipPersistentTopicAllMessagesRequest generates requests for SkipPersistentTopicAllMessages
func NewSkipPersistentTopicAllMessagesRequest(server string, tenant string, namespace string, topic string, subName string, params *SkipPersistentTopicAllMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/skip_all", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePersistentTopicSubscriptionRequestWithBody generates requests for CreatePersistentTopicSubscription with any type of body
func NewCreatePersistentTopicSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, subscriptionName string, params *CreatePersistentTopicSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscriptionName", runtime.ParamLocationPath, subscriptionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Replicated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replicated", runtime.ParamLocationQuery, *params.Replicated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicSubscriptionDispatchRateRequest generates requests for RemovePersistentTopicSubscriptionDispatchRate
func NewRemovePersistentTopicSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicSubscriptionDispatchRateRequest generates requests for GetPersistentTopicSubscriptionDispatchRate
func NewGetPersistentTopicSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicSubscriptionDispatchRateRequestWithBody generates requests for SetPersistentTopicSubscriptionDispatchRate with any type of body
func NewSetPersistentTopicSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePersistentTopicSubscriptionTypesEnabledRequest generates requests for RemovePersistentTopicSubscriptionTypesEnabled
func NewRemovePersistentTopicSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicSubscriptionTypesEnabledRequest generates requests for GetPersistentTopicSubscriptionTypesEnabled
func NewGetPersistentTopicSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicSubscriptionTypesEnabledRequestWithBody generates requests for SetPersistentTopicSubscriptionTypesEnabled with any type of body
func NewSetPersistentTopicSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersistentTopicSubscriptionsRequest generates requests for GetPersistentTopicSubscriptions
func NewGetPersistentTopicSubscriptionsRequest(server string, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminatePersistentTopicRequest generates requests for TerminatePersistentTopic
func NewTerminatePersistentTopicRequest(server string, tenant string, namespace string, topic string, params *TerminatePersistentTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/terminate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerminatePersistentTopicPartitionedTopicRequest generates requests for TerminatePersistentTopicPartitionedTopic
func NewTerminatePersistentTopicPartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *TerminatePersistentTopicPartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/terminate/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTruncatePersistentTopicTopicRequest generates requests for TruncatePersistentTopicTopic
func NewTruncatePersistentTopicTopicRequest(server string, tenant string, namespace string, topic string, params *TruncatePersistentTopicTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/truncate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnloadPersistentTopicTopicRequest generates requests for UnloadPersistentTopicTopic
func NewUnloadPersistentTopicTopicRequest(server string, tenant string, namespace string, topic string, params *UnloadPersistentTopicTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemovePersistentTopicSubscriptionLevelDispatchRateRequest generates requests for RemovePersistentTopicSubscriptionLevelDispatchRate
func NewRemovePersistentTopicSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *RemovePersistentTopicSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistentTopicSubscriptionLevelDispatchRateRequest generates requests for GetPersistentTopicSubscriptionLevelDispatchRate
func NewGetPersistentTopicSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Applied != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPersistentTopicSubscriptionLevelDispatchRateRequestWithBody generates requests for SetPersistentTopicSubscriptionLevelDispatchRate with any type of body
func NewSetPersistentTopicSubscriptionLevelDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsGlobal != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultResourceQuotaRequest generates requests for GetDefaultResourceQuota
func NewGetDefaultResourceQuotaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultResourceQuotaRequest calls the generic SetDefaultResourceQuota builder with application/json body
func NewSetDefaultResourceQuotaRequest(server string, body SetDefaultResourceQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetDefaultResourceQuotaRequestWithBody(server, "application/json", bodyReader)
}

// NewSetDefaultResourceQuotaRequestWithBody generates requests for SetDefaultResourceQuota with any type of body
func NewSetDefaultResourceQuotaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNamespaceBundleResourceQuotaRequest generates requests for RemoveNamespaceBundleResourceQuota
func NewRemoveNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamespaceBundleResourceQuotaRequest generates requests for GetNamespaceBundleResourceQuota
func NewGetNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetNamespaceBundleResourceQuotaRequest calls the generic SetNamespaceBundleResourceQuota builder with application/json body
func NewSetNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetNamespaceBundleResourceQuotaRequestWithBody(server, tenant, namespace, bundle, "application/json", bodyReader)
}

// NewSetNamespaceBundleResourceQuotaRequestWithBody generates requests for SetNamespaceBundleResourceQuota with any type of body
func NewSetNamespaceBundleResourceQuotaRequestWithBody(server string, tenant string, namespace string, bundle string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResourceGroupsRequest generates requests for GetResourceGroups
func NewGetResourceGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteResourceGroupRequest generates requests for DeleteResourceGroup
func NewDeleteResourceGroupRequest(server string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceGroupRequest generates requests for GetResourceGroup
func NewGetResourceGroupRequest(server string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateResourceGroupRequest calls the generic CreateOrUpdateResourceGroup builder with application/json body
func NewCreateOrUpdateResourceGroupRequest(server string, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateResourceGroupRequestWithBody(server, resourcegroup, "application/json", bodyReader)
}

// NewCreateOrUpdateResourceGroupRequestWithBody generates requests for CreateOrUpdateResourceGroup with any type of body
func NewCreateOrUpdateResourceGroupRequestWithBody(server string, resourcegroup string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestCompatibilityRequest calls the generic TestCompatibility builder with application/json body
func NewTestCompatibilityRequest(server string, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestCompatibilityRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewTestCompatibilityRequestWithBody generates requests for TestCompatibility with any type of body
func NewTestCompatibilityRequestWithBody(server string, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/compatibility", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSchemaRequest generates requests for DeleteSchema
func NewDeleteSchemaRequest(server string, tenant string, namespace string, topic string, params *DeleteSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemaOfTopicRequest generates requests for GetSchemaOfTopic
func NewGetSchemaOfTopicRequest(server string, tenant string, namespace string, topic string, params *GetSchemaOfTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchemaRequest calls the generic PostSchema builder with application/json body
func NewPostSchemaRequest(server string, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSchemaRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewPostSchemaRequestWithBody generates requests for PostSchema with any type of body
func NewPostSchemaRequestWithBody(server string, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchemaOfTopicGivenVersionRequest generates requests for GetSchemaOfTopicGivenVersion
func NewGetSchemaOfTopicGivenVersionRequest(server string, tenant string, namespace string, topic string, version string, params *GetSchemaOfTopicGivenVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSchemasRequest generates requests for GetAllSchemas
func NewGetAllSchemasRequest(server string, tenant string, namespace string, topic string, params *GetAllSchemasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schemas", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionBySchemaRequest calls the generic GetVersionBySchema builder with application/json body
func NewGetVersionBySchemaRequest(server string, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetVersionBySchemaRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewGetVersionBySchemaRequestWithBody generates requests for GetVersionBySchema with any type of body
func NewGetVersionBySchemaRequestWithBody(server string, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/version", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Authoritative != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTenantsRequest generates requests for GetTenants
func NewGetTenantsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTenantRequest generates requests for DeleteTenant
func NewDeleteTenantRequest(server string, tenant string, params *DeleteTenantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantAdminRequest generates requests for GetTenantAdmin
func NewGetTenantAdminRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTenantRequest calls the generic UpdateTenant builder with application/json body
func NewUpdateTenantRequest(server string, tenant string, body UpdateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTenantRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewUpdateTenantRequestWithBody generates requests for UpdateTenant with any type of body
func NewUpdateTenantRequestWithBody(server string, tenant string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTenantRequest calls the generic CreateTenant builder with application/json body
func NewCreateTenantRequest(server string, tenant string, body CreateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTenantRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewCreateTenantRequestWithBody generates requests for CreateTenant with any type of body
func NewCreateTenantRequestWithBody(server string, tenant string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkerStatsRequest generates requests for GetWorkerStats
func NewGetWorkerStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker-stats/functionsmetrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkerStatsMetricsRequest generates requests for GetWorkerStatsMetrics
func NewGetWorkerStatsMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker-stats/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssignmentsRequest generates requests for GetAssignments
func NewGetAssignmentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/assignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkerClusterRequest generates requests for GetWorkerCluster
func NewGetWorkerClusterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkerClusterLeaderRequest generates requests for GetWorkerClusterLeader
func NewGetWorkerClusterLeaderRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster/leader")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsLeaderReadyRequest generates requests for IsLeaderReady
func NewIsLeaderReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster/leader/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectorsListRequest generates requests for GetConnectorsList
func NewGetConnectorsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDrainStatusRequest generates requests for GetDrainStatus
func NewGetDrainStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDrainRequest generates requests for Drain
func NewDrainRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDrainStatusFromLeaderRequest generates requests for GetDrainStatusFromLeader
func NewGetDrainStatusFromLeaderRequest(server string, params *GetDrainStatusFromLeaderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/leader/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.WorkerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workerId", runtime.ParamLocationQuery, *params.WorkerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDrainAtLeaderRequest generates requests for DrainAtLeader
func NewDrainAtLeaderRequest(server string, params *DrainAtLeaderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/leader/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.WorkerId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workerId", runtime.ParamLocationQuery, *params.WorkerId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebalanceRequest generates requests for Rebalance
func NewRebalanceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/rebalance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllBookies request
	GetAllBookiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllBookiesResponse, error)

	// GetBookiesRackInfo request
	GetBookiesRackInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBookiesRackInfoResponse, error)

	// DeleteBookieRackInfo request
	DeleteBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*DeleteBookieRackInfoResponse, error)

	// GetBookieRackInfo request
	GetBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*GetBookieRackInfoResponse, error)

	// UpdateBookieRackInfo request
	UpdateBookieRackInfoWithResponse(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*UpdateBookieRackInfoResponse, error)

	// GetAllocatorStats request
	GetAllocatorStatsWithResponse(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*GetAllocatorStatsResponse, error)

	// GetPendingBookieOpsStats request
	GetPendingBookieOpsStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingBookieOpsStatsResponse, error)

	// GetBrokerResourceAvailability request
	GetBrokerResourceAvailabilityWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBrokerResourceAvailabilityResponse, error)

	// GetLoadReport request
	GetLoadReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoadReportResponse, error)

	// GetMBeans request
	GetMBeansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMBeansResponse, error)

	// GetBrokerStatsMetrics request
	GetBrokerStatsMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrokerStatsMetricsResponse, error)

	// GetTopics2 request
	GetTopics2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopics2Response, error)

	// GetActiveBrokers request
	GetActiveBrokersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActiveBrokersResponse, error)

	// BacklogQuotaCheck request
	BacklogQuotaCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BacklogQuotaCheckResponse, error)

	// GetDynamicConfigurationName request
	GetDynamicConfigurationNameWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDynamicConfigurationNameResponse, error)

	// GetRuntimeConfiguration request
	GetRuntimeConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeConfigurationResponse, error)

	// GetAllDynamicConfigurations request
	GetAllDynamicConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDynamicConfigurationsResponse, error)

	// DeleteDynamicConfiguration request
	DeleteDynamicConfigurationWithResponse(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*DeleteDynamicConfigurationResponse, error)

	// UpdateDynamicConfiguration request
	UpdateDynamicConfigurationWithResponse(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*UpdateDynamicConfigurationResponse, error)

	// HealthCheck request
	HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// GetInternalConfigurationData request
	GetInternalConfigurationDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInternalConfigurationDataResponse, error)

	// GetLeaderBroker request
	GetLeaderBrokerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeaderBrokerResponse, error)

	// IsReady request
	IsReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsReadyResponse, error)

	// ShutDownBrokerGracefully request
	ShutDownBrokerGracefullyWithResponse(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*ShutDownBrokerGracefullyResponse, error)

	// Version request
	VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error)

	// GetOwnedNamespaces request
	GetOwnedNamespacesWithResponse(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*GetOwnedNamespacesResponse, error)

	// GetActiveClusterBrokers request
	GetActiveClusterBrokersWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetActiveClusterBrokersResponse, error)

	// GetClusters request
	GetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClustersResponse, error)

	// DeleteCluster request
	DeleteClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetCluster request
	GetClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateCluster request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// CreateCluster request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// GetFailureDomains request
	GetFailureDomainsWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetFailureDomainsResponse, error)

	// DeleteFailureDomain request
	DeleteFailureDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*DeleteFailureDomainResponse, error)

	// GetDomain request
	GetDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*GetDomainResponse, error)

	// SetFailureDomain request with any body
	SetFailureDomainWithBodyWithResponse(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFailureDomainResponse, error)

	// GetNamespaceIsolationPolicies request
	GetNamespaceIsolationPoliciesWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPoliciesResponse, error)

	// GetBrokersWithNamespaceIsolationPolicy request
	GetBrokersWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetBrokersWithNamespaceIsolationPolicyResponse, error)

	// GetBrokerWithNamespaceIsolationPolicy request
	GetBrokerWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*GetBrokerWithNamespaceIsolationPolicyResponse, error)

	// DeleteNamespaceIsolationPolicy request
	DeleteNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*DeleteNamespaceIsolationPolicyResponse, error)

	// GetNamespaceIsolationPolicy request
	GetNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPolicyResponse, error)

	// SetNamespaceIsolationPolicy request with any body
	SetNamespaceIsolationPolicyWithBodyWithResponse(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceIsolationPolicyResponse, error)

	// GetPeerCluster request
	GetPeerClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetPeerClusterResponse, error)

	// SetPeerClusterNames request with any body
	SetPeerClusterNamesWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPeerClusterNamesResponse, error)

	// GetAntiAffinityNamespaces request
	GetAntiAffinityNamespacesWithResponse(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*GetAntiAffinityNamespacesResponse, error)

	// DeleteBookieAffinityGroup request
	DeleteBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*DeleteBookieAffinityGroupResponse, error)

	// GetBookieAffinityGroup request
	GetBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*GetBookieAffinityGroupResponse, error)

	// GetTenantNamespaces request
	GetTenantNamespacesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantNamespacesResponse, error)

	// DeleteNamespace request
	DeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceResponse, error)

	// GetPolicies request
	GetPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPoliciesResponse, error)

	// CreateNamespace request with any body
	CreateNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error)

	CreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error)

	// RemoveNamespaceAntiAffinityGroup request
	RemoveNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceAntiAffinityGroupResponse, error)

	// GetNamespaceAntiAffinityGroup request
	GetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceAntiAffinityGroupResponse, error)

	// SetNamespaceAntiAffinityGroup request with any body
	SetNamespaceAntiAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error)

	SetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error)

	// RemoveAutoSubscriptionCreation request
	RemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoSubscriptionCreationResponse, error)

	// GetAutoSubscriptionCreation request
	GetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoSubscriptionCreationResponse, error)

	// SetAutoSubscriptionCreation request with any body
	SetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error)

	SetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error)

	// RemoveAutoTopicCreation request
	RemoveAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoTopicCreationResponse, error)

	// GetAutoTopicCreation request
	GetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoTopicCreationResponse, error)

	// SetAutoTopicCreation request with any body
	SetAutoTopicCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error)

	SetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error)

	// RemoveNamesapceBacklogQuota request
	RemoveNamesapceBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *RemoveNamesapceBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveNamesapceBacklogQuotaResponse, error)

	// SetNamespaceBacklogQuota request with any body
	SetNamespaceBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceBacklogQuotaResponse, error)

	SetNamespaceBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, body SetNamespaceBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceBacklogQuotaResponse, error)

	// GetNamespaceBacklogQuotaMap request
	GetNamespaceBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceBacklogQuotaMapResponse, error)

	// GetBundlesData request
	GetBundlesDataWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBundlesDataResponse, error)

	// ClearNamespaceBacklog request
	ClearNamespaceBacklogWithResponse(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogResponse, error)

	// ClearNamespaceBacklogForSubscription request
	ClearNamespaceBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogForSubscriptionResponse, error)

	// DeleteCompactionThreshold request
	DeleteCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteCompactionThresholdResponse, error)

	// GetNamespaceCompactionThreshold request
	GetNamespaceCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceCompactionThresholdResponse, error)

	// SetNamespaceCompactionThreshold request with any body
	SetNamespaceCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceCompactionThresholdResponse, error)

	SetNamespaceCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceCompactionThresholdResponse, error)

	// RemoveNamespaceDeduplication request
	RemoveNamespaceDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceDeduplicationResponse, error)

	// GetNamespaceDeduplication request
	GetNamespaceDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDeduplicationResponse, error)

	// ModifyDeduplication request with any body
	ModifyDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error)

	ModifyDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error)

	// GetNamespaceDeduplicationSnapshotInterval request
	GetNamespaceDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDeduplicationSnapshotIntervalResponse, error)

	// SetNamespaceDeduplicationSnapshotInterval request with any body
	SetNamespaceDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceDeduplicationSnapshotIntervalResponse, error)

	SetNamespaceDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceDeduplicationSnapshotIntervalResponse, error)

	// RemoveDelayedDeliveryPolicies request
	RemoveDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveDelayedDeliveryPoliciesResponse, error)

	// GetNamespaceDelayedDeliveryPolicies request
	GetNamespaceDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDelayedDeliveryPoliciesResponse, error)

	// SetNamespaceDelayedDeliveryPolicies request with any body
	SetNamespaceDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceDelayedDeliveryPoliciesResponse, error)

	SetNamespaceDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceDelayedDeliveryPoliciesResponse, error)

	// DeleteDispatchRate request
	DeleteDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteDispatchRateResponse, error)

	// GetNamespaceDispatchRate request
	GetNamespaceDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDispatchRateResponse, error)

	// SetNamespaceDispatchRate request with any body
	SetNamespaceDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceDispatchRateResponse, error)

	SetNamespaceDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceDispatchRateResponse, error)

	// GetEncryptionRequired request
	GetEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetEncryptionRequiredResponse, error)

	// ModifyEncryptionRequired request with any body
	ModifyEncryptionRequiredWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error)

	ModifyEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error)

	// RemoveNamespaceEntryFilters request
	RemoveNamespaceEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceEntryFiltersResponse, error)

	// GetNamespaceEntryFiltersPerTopic request
	GetNamespaceEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceEntryFiltersPerTopicResponse, error)

	// SetEntryFiltersPerTopic request with any body
	SetEntryFiltersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error)

	SetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error)

	// RemoveInactiveTopicPolicies request
	RemoveInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveInactiveTopicPoliciesResponse, error)

	// GetNamespaceInactiveTopicPolicies request
	GetNamespaceInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceInactiveTopicPoliciesResponse, error)

	// SetNamespaceInactiveTopicPolicies request with any body
	SetNamespaceInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceInactiveTopicPoliciesResponse, error)

	SetNamespaceInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceInactiveTopicPoliciesResponse, error)

	// GetIsAllowAutoUpdateSchema request
	GetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetIsAllowAutoUpdateSchemaResponse, error)

	// SetIsAllowAutoUpdateSchema request with any body
	SetIsAllowAutoUpdateSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error)

	SetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error)

	// RemoveNamespaceMaxConsumersPerSubscription request
	RemoveNamespaceMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxConsumersPerSubscriptionResponse, error)

	// GetNamespaceMaxConsumersPerSubscription request
	GetNamespaceMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxConsumersPerSubscriptionResponse, error)

	// SetNamespaceMaxConsumersPerSubscription request with any body
	SetNamespaceMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerSubscriptionResponse, error)

	SetNamespaceMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerSubscriptionResponse, error)

	// RemoveNamespaceMaxConsumersPerTopic request
	RemoveNamespaceMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxConsumersPerTopicResponse, error)

	// GetNamespaceMaxConsumersPerTopic request
	GetNamespaceMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxConsumersPerTopicResponse, error)

	// SetNamespaceMaxConsumersPerTopic request with any body
	SetNamespaceMaxConsumersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerTopicResponse, error)

	SetNamespaceMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerTopicResponse, error)

	// RemoveNamespaceMaxProducersPerTopic request
	RemoveNamespaceMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxProducersPerTopicResponse, error)

	// GetNamespaceMaxProducersPerTopic request
	GetNamespaceMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxProducersPerTopicResponse, error)

	// SetNamespaceMaxProducersPerTopic request with any body
	SetNamespaceMaxProducersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxProducersPerTopicResponse, error)

	SetNamespaceMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxProducersPerTopicResponse, error)

	// RemoveNamespaceMaxSubscriptionsPerTopic request
	RemoveNamespaceMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxSubscriptionsPerTopicResponse, error)

	// GetNamespaceMaxSubscriptionsPerTopic request
	GetNamespaceMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxSubscriptionsPerTopicResponse, error)

	// SetNamespaceMaxSubscriptionsPerTopic request with any body
	SetNamespaceMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxSubscriptionsPerTopicResponse, error)

	SetNamespaceMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxSubscriptionsPerTopicResponse, error)

	// DeleteNamespaceMaxTopicsPerNamespace request
	DeleteNamespaceMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteNamespaceMaxTopicsPerNamespaceResponse, error)

	// GetNamespaceMaxTopicsPerNamespace request
	GetNamespaceMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxTopicsPerNamespaceResponse, error)

	// SetNamespaceMaxTopicsPerNamespace request with any body
	SetNamespaceMaxTopicsPerNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxTopicsPerNamespaceResponse, error)

	SetNamespaceMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxTopicsPerNamespaceResponse, error)

	// RemoveNamespaceMaxUnackedmessagesPerConsumer request
	RemoveNamespaceMaxUnackedmessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxUnackedmessagesPerConsumerResponse, error)

	// GetNamespaceMaxUnackedMessagesPerConsumer request
	GetNamespaceMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxUnackedMessagesPerConsumerResponse, error)

	// SetNamespaceMaxUnackedMessagesPerConsumer request with any body
	SetNamespaceMaxUnackedMessagesPerConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerConsumerResponse, error)

	SetNamespaceMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerConsumerResponse, error)

	// RemoveNamespaceMaxUnackedmessagesPerSubscription request
	RemoveNamespaceMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse, error)

	// GetNamespaceMaxUnackedmessagesPerSubscription request
	GetNamespaceMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxUnackedmessagesPerSubscriptionResponse, error)

	// SetNamespaceMaxUnackedMessagesPerSubscription request with any body
	SetNamespaceMaxUnackedMessagesPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerSubscriptionResponse, error)

	SetNamespaceMaxUnackedMessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerSubscriptionResponse, error)

	// RemoveNamespaceMessageTTL request
	RemoveNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMessageTTLResponse, error)

	// GetNamespaceMessageTTL request
	GetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMessageTTLResponse, error)

	// SetNamespaceMessageTTL request with any body
	SetNamespaceMessageTTLWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error)

	SetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error)

	// ClearOffloadDeletionLag request
	ClearOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearOffloadDeletionLagResponse, error)

	// GetNamespaceOffloadDeletionLag request
	GetNamespaceOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceOffloadDeletionLagResponse, error)

	// SetNamespaceOffloadDeletionLag request with any body
	SetNamespaceOffloadDeletionLagWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadDeletionLagResponse, error)

	SetNamespaceOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadDeletionLagResponse, error)

	// GetNamespaceOffloadPolicies request
	GetNamespaceOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceOffloadPoliciesResponse, error)

	// SetNamespaceOffloadPolicies request with any body
	SetNamespaceOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadPoliciesResponse, error)

	SetNamespaceOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadPoliciesResponse, error)

	// GetNamespaceOffloadThreshold request
	GetNamespaceOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceOffloadThresholdResponse, error)

	// SetNamespaceOffloadThreshold request with any body
	SetNamespaceOffloadThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadThresholdResponse, error)

	SetNamespaceOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadThresholdResponse, error)

	// GetPermissions request
	GetPermissionsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionsResponse, error)

	// GetPermissionOnSubscription request
	GetPermissionOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionOnSubscriptionResponse, error)

	// RevokePermissionsOnNamespace request
	RevokePermissionsOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnNamespaceResponse, error)

	// GrantPermissionOnNamespace request with any body
	GrantPermissionOnNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error)

	GrantPermissionOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error)

	// DeletePersistence request
	DeletePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeletePersistenceResponse, error)

	// GetNamespacePersistence request
	GetNamespacePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespacePersistenceResponse, error)

	// SetNamespacePersistence request with any body
	SetNamespacePersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespacePersistenceResponse, error)

	SetNamespacePersistenceWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespacePersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespacePersistenceResponse, error)

	// SetBookieAffinityGroup request with any body
	SetBookieAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error)

	SetBookieAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error)

	// ClearProperties request
	ClearPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearPropertiesResponse, error)

	// GetNamespaceProperties request
	GetNamespacePropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespacePropertiesResponse, error)

	// SetProperties request with any body
	SetPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error)

	SetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error)

	// RemoveProperty request
	RemovePropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*RemovePropertyResponse, error)

	// GetProperty request
	GetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*GetPropertyResponse, error)

	// SetProperty request
	SetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*SetPropertyResponse, error)

	// RemoveNamespaceOffloadPolicies request
	RemoveNamespaceOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceOffloadPoliciesResponse, error)

	// GetNamespaceReplicationClusters request
	GetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceReplicationClustersResponse, error)

	// SetNamespaceReplicationClusters request with any body
	SetNamespaceReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error)

	SetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error)

	// RemoveNamespaceReplicatorDispatchRate request
	RemoveNamespaceReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceReplicatorDispatchRateResponse, error)

	// GetNamespaceReplicatorDispatchRate request
	GetNamespaceReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceReplicatorDispatchRateResponse, error)

	// SetNamespaceReplicatorDispatchRate request with any body
	SetNamespaceReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceReplicatorDispatchRateResponse, error)

	SetNamespaceReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceReplicatorDispatchRateResponse, error)

	// RemoveNamespaceResourceGroup request
	RemoveNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceResourceGroupResponse, error)

	// GetNamespaceResourceGroup request
	GetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceResourceGroupResponse, error)

	// SetNamespaceResourceGroup request
	SetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*SetNamespaceResourceGroupResponse, error)

	// RemoveNamespaceRetention request with any body
	RemoveNamespaceRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNamespaceRetentionResponse, error)

	RemoveNamespaceRetentionWithResponse(ctx context.Context, tenant string, namespace string, body RemoveNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveNamespaceRetentionResponse, error)

	// GetNamespaceRetention request
	GetNamespaceRetentionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceRetentionResponse, error)

	// SetNamespaceRetention request with any body
	SetNamespaceRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceRetentionResponse, error)

	SetNamespaceRetentionWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceRetentionResponse, error)

	// ScanOffloadedLedgers request
	ScanOffloadedLedgersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ScanOffloadedLedgersResponse, error)

	// GetSchemaAutoUpdateCompatibilityStrategy request
	GetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	// SetSchemaAutoUpdateCompatibilityStrategy request with any body
	SetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	SetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	// GetNamespaceSchemaCompatibilityStrategy request
	GetNamespaceSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSchemaCompatibilityStrategyResponse, error)

	// SetNamespaceSchemaCompatibilityStrategy request with any body
	SetNamespaceSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaCompatibilityStrategyResponse, error)

	SetNamespaceSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaCompatibilityStrategyResponse, error)

	// GetSchemaValidtionEnforced request
	GetSchemaValidtionEnforcedWithResponse(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidtionEnforcedResponse, error)

	// SetNamespaceSchemaValidationEnforced request with any body
	SetNamespaceSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaValidationEnforcedResponse, error)

	SetNamespaceSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaValidationEnforcedResponse, error)

	// DeleteSubscribeRate request
	DeleteSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscribeRateResponse, error)

	// GetNamespaceSubscribeRate request
	GetNamespaceSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSubscribeRateResponse, error)

	// SetNamespaceSubscribeRate request with any body
	SetNamespaceSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscribeRateResponse, error)

	SetNamespaceSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscribeRateResponse, error)

	// GetSubscriptionAuthMode request
	GetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionAuthModeResponse, error)

	// SetNamespaceSubscriptionAuthMode request with any body
	SetNamespaceSubscriptionAuthModeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionAuthModeResponse, error)

	SetNamespaceSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionAuthModeResponse, error)

	// DeleteSubscriptionDispatchRate request
	DeleteSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscriptionDispatchRateResponse, error)

	// GetNamespaceSubscriptionDispatchRate request
	GetNamespaceSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSubscriptionDispatchRateResponse, error)

	// SetNamespaceSubscriptionDispatchRate request with any body
	SetNamespaceSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionDispatchRateResponse, error)

	SetNamespaceSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionDispatchRateResponse, error)

	// RemoveSubscriptionExpirationTime request
	RemoveSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionExpirationTimeResponse, error)

	// GetSubscriptionExpirationTime request
	GetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionExpirationTimeResponse, error)

	// SetNamespaceSubscriptionExpirationTime request with any body
	SetNamespaceSubscriptionExpirationTimeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionExpirationTimeResponse, error)

	SetNamespaceSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionExpirationTimeResponse, error)

	// RemoveNamespaceSubscriptionTypesEnabled request
	RemoveNamespaceSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceSubscriptionTypesEnabledResponse, error)

	// GetNamespaceSubscriptionTypesEnabled request
	GetNamespaceSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSubscriptionTypesEnabledResponse, error)

	// SetNamespaceSubscriptionTypesEnabled request with any body
	SetNamespaceSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionTypesEnabledResponse, error)

	SetNamespaceSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionTypesEnabledResponse, error)

	// GetTopics request
	GetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*GetTopicsResponse, error)

	// UnloadNamespace request
	UnloadNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*UnloadNamespaceResponse, error)

	// UnsubscribeNamespace request
	UnsubscribeNamespaceWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceResponse, error)

	// DeleteNamespaceBundle request
	DeleteNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceBundleResponse, error)

	// ClearNamespaceBundleBacklog request
	ClearNamespaceBundleBacklogWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogResponse, error)

	// ClearNamespaceBundleBacklogForSubscription request
	ClearNamespaceBundleBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogForSubscriptionResponse, error)

	// SplitNamespaceBundle request with any body
	SplitNamespaceBundleWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error)

	SplitNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error)

	// GetTopicHashPositions request
	GetTopicHashPositionsWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*GetTopicHashPositionsResponse, error)

	// UnloadNamespaceBundle request
	UnloadNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnloadNamespaceBundleResponse, error)

	// UnsubscribeNamespaceBundle request
	UnsubscribeNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceBundleResponse, error)

	// GetNonPersistentTopicList request
	GetNonPersistentTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetNonPersistentTopicListParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicListResponse, error)

	// GetNonPersistentPartitionedTopicList request
	GetNonPersistentPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetNonPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetNonPersistentPartitionedTopicListResponse, error)

	// GetListFromBundle request
	GetListFromBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetListFromBundleResponse, error)

	// DeleteNonPersistentTopic request
	DeleteNonPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicResponse, error)

	// CreateNonPersistentTopicNonPartitionedTopic request with any body
	CreateNonPersistentTopicNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicNonPartitionedTopicResponse, error)

	// ExpireNonPersistentTopicMessagesForAllSubscriptions request
	ExpireNonPersistentTopicMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse, error)

	// GetNonPersistentTopicBacklog request
	GetNonPersistentTopicBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicBacklogResponse, error)

	// RemoveNonPersistentTopicBacklogQuota request
	RemoveNonPersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicBacklogQuotaResponse, error)

	// SetNonPersistentTopicBacklogQuota request
	SetNonPersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicBacklogQuotaResponse, error)

	// GetNonPersistentTopicBacklogQuotaMap request
	GetNonPersistentTopicBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicBacklogQuotaMapResponse, error)

	// GetNonPersistentTopicBacklogSizeByMessageId request
	GetNonPersistentTopicBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicBacklogSizeByMessageIdResponse, error)

	// GetNonPersistentTopicCompactionStatus request
	GetNonPersistentTopicCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicCompactionStatusResponse, error)

	// CompactNonPersistentTopic request
	CompactNonPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*CompactNonPersistentTopicResponse, error)

	// RemoveNonPersistentTopicCompactionThreshold request
	RemoveNonPersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicCompactionThresholdResponse, error)

	// GetNonPersistentTopicCompactionThreshold request
	GetNonPersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicCompactionThresholdResponse, error)

	// SetNonPersistentTopicCompactionThreshold request with any body
	SetNonPersistentTopicCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicCompactionThresholdResponse, error)

	// CreateNonPersistentTopicMissedPartitions request
	CreateNonPersistentTopicMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicMissedPartitionsResponse, error)

	// RemoveNonPersistentTopicDeduplication request
	RemoveNonPersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicDeduplicationResponse, error)

	// GetNonPersistentTopicDeduplication request
	GetNonPersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDeduplicationResponse, error)

	// SetNonPersistentTopicDeduplication request with any body
	SetNonPersistentTopicDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDeduplicationResponse, error)

	// DeleteNonPersistentTopicDeduplicationSnapshotInterval request
	DeleteNonPersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse, error)

	// GetNonPersistentTopicDeduplicationSnapshotInterval request
	GetNonPersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDeduplicationSnapshotIntervalResponse, error)

	// SetNonPersistentTopicDeduplicationSnapshotInterval request with any body
	SetNonPersistentTopicDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDeduplicationSnapshotIntervalResponse, error)

	// DeleteNonPersistentTopicDelayedDeliveryPolicies request
	DeleteNonPersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse, error)

	// GetNonPersistentTopicDelayedDeliveryPolicies request
	GetNonPersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDelayedDeliveryPoliciesResponse, error)

	// SetNonPersistentTopicDelayedDeliveryPolicies request with any body
	SetNonPersistentTopicDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDelayedDeliveryPoliciesResponse, error)

	// RemoveNonPersistentTopicDispatchRate request
	RemoveNonPersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicDispatchRateResponse, error)

	// GetNonPersistentTopicDispatchRate request
	GetNonPersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDispatchRateResponse, error)

	// SetNonPersistentTopicDispatchRate request with any body
	SetNonPersistentTopicDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDispatchRateResponse, error)

	// RemoveNonPersistentTopicEntryFilters request
	RemoveNonPersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicEntryFiltersResponse, error)

	// GetNonPersistentTopicEntryFilters request
	GetNonPersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicEntryFiltersResponse, error)

	// SetNonPersistentTopicEntryFilters request with any body
	SetNonPersistentTopicEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicEntryFiltersResponse, error)

	// ExamineNonPersistentTopicMessage request
	ExamineNonPersistentTopicMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExamineNonPersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*ExamineNonPersistentTopicMessageResponse, error)

	// DeleteNonPersistentTopicInactiveTopicPolicies request
	DeleteNonPersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicInactiveTopicPoliciesResponse, error)

	// GetNonPersistentTopicInactiveTopicPolicies request
	GetNonPersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicInactiveTopicPoliciesResponse, error)

	// SetNonPersistentTopicInactiveTopicPolicies request with any body
	SetNonPersistentTopicInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicInactiveTopicPoliciesResponse, error)

	// GetNonPersistentTopicManagedLedgerInfo request
	GetNonPersistentTopicManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicManagedLedgerInfoResponse, error)

	// GetNonPersistentTopicInternalStats request
	GetNonPersistentTopicInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicInternalStatsResponse, error)

	// GetNonPersistentTopicLastMessageId request
	GetNonPersistentTopicLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicLastMessageIdResponse, error)

	// GetNonPersistentTopicMessageById request
	GetNonPersistentTopicMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetNonPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMessageByIdResponse, error)

	// RemoveNonPersistentTopicMaxConsumers request
	RemoveNonPersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxConsumersResponse, error)

	// GetNonPersistentTopicMaxConsumers request
	GetNonPersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxConsumersResponse, error)

	// SetNonPersistentTopicMaxConsumers request with any body
	SetNonPersistentTopicMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxConsumersResponse, error)

	// RemoveNonPersistentTopicMaxConsumersPerSubscription request
	RemoveNonPersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse, error)

	// GetNonPersistentTopicMaxConsumersPerSubscription request
	GetNonPersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxConsumersPerSubscriptionResponse, error)

	// SetNonPersistentTopicMaxConsumersPerSubscription request with any body
	SetNonPersistentTopicMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxConsumersPerSubscriptionResponse, error)

	// RemoveNonPersistentTopicMaxMessageSize request
	RemoveNonPersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxMessageSizeResponse, error)

	// GetNonPersistentTopicMaxMessageSize request
	GetNonPersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxMessageSizeResponse, error)

	// SetNonPersistentTopicMaxMessageSize request with any body
	SetNonPersistentTopicMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxMessageSizeResponse, error)

	// RemoveNonPersistentTopicMaxProducers request
	RemoveNonPersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxProducersResponse, error)

	// GetNonPersistentTopicMaxProducers request
	GetNonPersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxProducersResponse, error)

	// SetNonPersistentTopicMaxProducers request with any body
	SetNonPersistentTopicMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxProducersResponse, error)

	// RemoveNonPersistentTopicMaxSubscriptionsPerTopic request
	RemoveNonPersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse, error)

	// GetNonPersistentTopicMaxSubscriptionsPerTopic request
	GetNonPersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxSubscriptionsPerTopicResponse, error)

	// SetNonPersistentTopicMaxSubscriptionsPerTopic request with any body
	SetNonPersistentTopicMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxSubscriptionsPerTopicResponse, error)

	// DeleteNonPersistentTopicMaxUnackedMessagesOnConsumer request
	DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error)

	// GetNonPersistentTopicMaxUnackedMessagesOnConsumer request
	GetNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error)

	// SetNonPersistentTopicMaxUnackedMessagesOnConsumer request with any body
	SetNonPersistentTopicMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error)

	// DeleteNonPersistentTopicMaxUnackedMessagesOnSubscription request
	DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error)

	// GetNonPersistentTopicMaxUnackedMessagesOnSubscription request
	GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error)

	// SetNonPersistentTopicMaxUnackedMessagesOnSubscription request with any body
	SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error)

	// RemoveNonPersistentTopicMessageTTL request
	RemoveNonPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMessageTTLResponse, error)

	// GetNonPersistentTopicMessageTTL request
	GetNonPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMessageTTLResponse, error)

	// SetNonPersistentTopicMessageTTL request
	SetNonPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMessageTTLResponse, error)

	// GetNonPersistentTopicMessageIdByTimestamp request
	GetNonPersistentTopicMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetNonPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMessageIdByTimestampResponse, error)

	// OffloadNonPersistentTopicStatus request
	OffloadNonPersistentTopicStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadNonPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*OffloadNonPersistentTopicStatusResponse, error)

	// TriggerNonPersistentTopicOffload request
	TriggerNonPersistentTopicOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerNonPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*TriggerNonPersistentTopicOffloadResponse, error)

	// RemoveNonPersistentTopicOffloadPolicies request
	RemoveNonPersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicOffloadPoliciesResponse, error)

	// GetNonPersistentTopicOffloadPolicies request
	GetNonPersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicOffloadPoliciesResponse, error)

	// SetNonPersistentTopicOffloadPolicies request with any body
	SetNonPersistentTopicOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicOffloadPoliciesResponse, error)

	// GetNonPersistentTopicPartitionedStats request
	GetNonPersistentTopicPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPartitionedStatsResponse, error)

	// DeleteNonPersistentTopicPartitionedTopic request
	DeleteNonPersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicPartitionedTopicResponse, error)

	// GetNonPersistentTopicPartitionedMetadata request
	GetNonPersistentTopicPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPartitionedMetadataResponse, error)

	// UpdateNonPersistentTopicPartitionedTopic request with any body
	UpdateNonPersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNonPersistentTopicPartitionedTopicResponse, error)

	// CreateNonPersistentTopicPartitionedTopic request with any body
	CreateNonPersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicPartitionedTopicResponse, error)

	CreateNonPersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, body CreateNonPersistentTopicPartitionedTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicPartitionedTopicResponse, error)

	// GetNonPersistentTopicPermissionsOnTopic request
	GetNonPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPermissionsOnTopicResponse, error)

	// RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopic request
	RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse, error)

	// GrantNonPersistentTopicPermissionsOnTopic request with any body
	GrantNonPersistentTopicPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantNonPersistentTopicPermissionsOnTopicResponse, error)

	// RemoveNonPersistentTopicPersistence request
	RemoveNonPersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicPersistenceResponse, error)

	// GetNonPersistentTopicPersistence request
	GetNonPersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPersistenceResponse, error)

	// SetNonPersistentTopicPersistence request with any body
	SetNonPersistentTopicPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicPersistenceResponse, error)

	// RemoveNonPersistentTopicProperties request
	RemoveNonPersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicPropertiesResponse, error)

	// GetNonPersistentTopicProperties request
	GetNonPersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPropertiesResponse, error)

	// UpdateNonPersistentTopicProperties request with any body
	UpdateNonPersistentTopicPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNonPersistentTopicPropertiesResponse, error)

	// RemoveNonPersistentTopicPublishRate request
	RemoveNonPersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicPublishRateResponse, error)

	// GetNonPersistentTopicPublishRate request
	GetNonPersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPublishRateResponse, error)

	// SetNonPersistentTopicPublishRate request with any body
	SetNonPersistentTopicPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicPublishRateResponse, error)

	// RemoveNonPersistentTopicReplicationClusters request
	RemoveNonPersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicReplicationClustersResponse, error)

	// GetNonPersistentTopicReplicationClusters request
	GetNonPersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicReplicationClustersResponse, error)

	// SetNonPersistentTopicReplicationClusters request with any body
	SetNonPersistentTopicReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicReplicationClustersResponse, error)

	// RemoveNonPersistentTopicReplicatorDispatchRate request
	RemoveNonPersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicReplicatorDispatchRateResponse, error)

	// GetNonPersistentTopicReplicatorDispatchRate request
	GetNonPersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicReplicatorDispatchRateResponse, error)

	// SetNonPersistentTopicReplicatorDispatchRate request with any body
	SetNonPersistentTopicReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicReplicatorDispatchRateResponse, error)

	// RemoveNonPersistentTopicRetention request
	RemoveNonPersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicRetentionResponse, error)

	// GetNonPersistentTopicRetention request
	GetNonPersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicRetentionResponse, error)

	// SetNonPersistentTopicRetention request with any body
	SetNonPersistentTopicRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicRetentionResponse, error)

	// RemoveNonPersistentTopicSchemaCompatibilityStrategy request with any body
	RemoveNonPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse, error)

	// GetNonPersistentTopicSchemaCompatibilityStrategy request
	GetNonPersistentTopicSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSchemaCompatibilityStrategyResponse, error)

	// SetNonPersistentTopicSchemaCompatibilityStrategy request with any body
	SetNonPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSchemaCompatibilityStrategyResponse, error)

	// GetNonPersistentTopicSchemaValidationEnforced request
	GetNonPersistentTopicSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSchemaValidationEnforcedResponse, error)

	// SetNonPersistentTopicSchemaValidationEnforced request with any body
	SetNonPersistentTopicSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSchemaValidationEnforcedResponse, error)

	// DeleteNonPersistentTopicShadowTopics request
	DeleteNonPersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicShadowTopicsResponse, error)

	// GetNonPersistentTopicShadowTopics request
	GetNonPersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicShadowTopicsResponse, error)

	// SetNonPersistentTopicShadowTopics request with any body
	SetNonPersistentTopicShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicShadowTopicsResponse, error)

	// GetNonPersistentTopicStats request
	GetNonPersistentTopicStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicStatsResponse, error)

	// RemoveNonPersistentTopicSubscribeRate request with any body
	RemoveNonPersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscribeRateResponse, error)

	// GetNonPersistentTopicSubscribeRate request
	GetNonPersistentTopicSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscribeRateResponse, error)

	// SetNonPersistentTopicSubscribeRate request with any body
	SetNonPersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscribeRateResponse, error)

	// DeleteNonPersistentTopicSubscription request
	DeleteNonPersistentTopicSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteNonPersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicSubscriptionResponse, error)

	// AnalyzeNonPersistentTopicSubscriptionBacklog request with any body
	AnalyzeNonPersistentTopicSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeNonPersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzeNonPersistentTopicSubscriptionBacklogResponse, error)

	// ExpireNonPersistentTopicMessages request with any body
	ExpireNonPersistentTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireNonPersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpireNonPersistentTopicMessagesResponse, error)

	// ExpireNonPersistentTopicMessagesTimeInSeconds request
	ExpireNonPersistentTopicMessagesTimeInSecondsWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*ExpireNonPersistentTopicMessagesTimeInSecondsResponse, error)

	// PeekNonPersistentTopicNthMessage request
	PeekNonPersistentTopicNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNonPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*PeekNonPersistentTopicNthMessageResponse, error)

	// GetNonPersistentTopicSubscriptionProperties request
	GetNonPersistentTopicSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionPropertiesResponse, error)

	// UpdateNonPersistentTopicSubscriptionProperties request with any body
	UpdateNonPersistentTopicSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateNonPersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNonPersistentTopicSubscriptionPropertiesResponse, error)

	// GetNonPersistentTopicReplicatedSubscriptionStatus request
	GetNonPersistentTopicReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicReplicatedSubscriptionStatusResponse, error)

	// SetNonPersistentTopicReplicatedSubscriptionStatus request with any body
	SetNonPersistentTopicReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicReplicatedSubscriptionStatusResponse, error)

	// ResetNonPersistentTopicCursorOnPosition request with any body
	ResetNonPersistentTopicCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetNonPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetNonPersistentTopicCursorOnPositionResponse, error)

	// ResetNonPersistentTopicCursor request
	ResetNonPersistentTopicCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetNonPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*ResetNonPersistentTopicCursorResponse, error)

	// SkipNonPersistentTopicMessages request
	SkipNonPersistentTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipNonPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*SkipNonPersistentTopicMessagesResponse, error)

	// SkipNonPersistentTopicAllMessages request
	SkipNonPersistentTopicAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipNonPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipNonPersistentTopicAllMessagesResponse, error)

	// CreateNonPersistentTopicSubscription request with any body
	CreateNonPersistentTopicSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateNonPersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicSubscriptionResponse, error)

	// RemoveNonPersistentTopicSubscriptionDispatchRate request
	RemoveNonPersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscriptionDispatchRateResponse, error)

	// GetNonPersistentTopicSubscriptionDispatchRate request
	GetNonPersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionDispatchRateResponse, error)

	// SetNonPersistentTopicSubscriptionDispatchRate request with any body
	SetNonPersistentTopicSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscriptionDispatchRateResponse, error)

	// RemoveNonPersistentTopicSubscriptionTypesEnabled request
	RemoveNonPersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscriptionTypesEnabledResponse, error)

	// GetNonPersistentTopicSubscriptionTypesEnabled request
	GetNonPersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionTypesEnabledResponse, error)

	// SetNonPersistentTopicSubscriptionTypesEnabled request with any body
	SetNonPersistentTopicSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscriptionTypesEnabledResponse, error)

	// GetNonPersistentTopicSubscriptions request
	GetNonPersistentTopicSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionsResponse, error)

	// TerminateNonPersistentTopic request
	TerminateNonPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*TerminateNonPersistentTopicResponse, error)

	// TerminateNonPersistentTopicPartitionedTopic request
	TerminateNonPersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminateNonPersistentTopicPartitionedTopicResponse, error)

	// TruncateNonPersistentTopicTopic request
	TruncateNonPersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncateNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*TruncateNonPersistentTopicTopicResponse, error)

	// UnloadNonPersistentTopicTopic request
	UnloadNonPersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*UnloadNonPersistentTopicTopicResponse, error)

	// RemoveNonPersistentTopicSubscriptionLevelDispatchRate request
	RemoveNonPersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse, error)

	// GetNonPersistentTopicSubscriptionLevelDispatchRate request
	GetNonPersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionLevelDispatchRateResponse, error)

	// SetNonPersistentTopicSubscriptionLevelDispatchRate request with any body
	SetNonPersistentTopicSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscriptionLevelDispatchRateResponse, error)

	// GetPersistentTopicList request
	GetPersistentTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPersistentTopicListParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicListResponse, error)

	// GetPersistentPartitionedTopicList request
	GetPersistentPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetPersistentPartitionedTopicListResponse, error)

	// DeletePersistentTopic request
	DeletePersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicResponse, error)

	// CreatePersistentTopicNonPartitionedTopic request with any body
	CreatePersistentTopicNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePersistentTopicNonPartitionedTopicResponse, error)

	// ExpirePersistentTopicMessagesForAllSubscriptions request
	ExpirePersistentTopicMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpirePersistentTopicMessagesForAllSubscriptionsResponse, error)

	// GetPersistentTopicBacklog request
	GetPersistentTopicBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicBacklogResponse, error)

	// RemovePersistentTopicBacklogQuota request
	RemovePersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicBacklogQuotaResponse, error)

	// SetPersistentTopicBacklogQuota request
	SetPersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetPersistentTopicBacklogQuotaResponse, error)

	// GetPersistentTopicBacklogQuotaMap request
	GetPersistentTopicBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicBacklogQuotaMapResponse, error)

	// GetPersistentTopicBacklogSizeByMessageId request
	GetPersistentTopicBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicBacklogSizeByMessageIdResponse, error)

	// GetPersistentTopicCompactionStatus request
	GetPersistentTopicCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicCompactionStatusResponse, error)

	// CompactPersistentTopic request
	CompactPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactPersistentTopicParams, reqEditors ...RequestEditorFn) (*CompactPersistentTopicResponse, error)

	// RemovePersistentTopicCompactionThreshold request
	RemovePersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicCompactionThresholdResponse, error)

	// GetPersistentTopicCompactionThreshold request
	GetPersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicCompactionThresholdResponse, error)

	// SetPersistentTopicCompactionThreshold request with any body
	SetPersistentTopicCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicCompactionThresholdResponse, error)

	// CreatePersistentTopicMissedPartitions request
	CreatePersistentTopicMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreatePersistentTopicMissedPartitionsResponse, error)

	// RemovePersistentTopicDeduplication request
	RemovePersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicDeduplicationResponse, error)

	// GetPersistentTopicDeduplication request
	GetPersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDeduplicationResponse, error)

	// SetPersistentTopicDeduplication request with any body
	SetPersistentTopicDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDeduplicationResponse, error)

	// DeletePersistentTopicDeduplicationSnapshotInterval request
	DeletePersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicDeduplicationSnapshotIntervalResponse, error)

	// GetPersistentTopicDeduplicationSnapshotInterval request
	GetPersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDeduplicationSnapshotIntervalResponse, error)

	// SetPersistentTopicDeduplicationSnapshotInterval request with any body
	SetPersistentTopicDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDeduplicationSnapshotIntervalResponse, error)

	// DeletePersistentTopicDelayedDeliveryPolicies request
	DeletePersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicDelayedDeliveryPoliciesResponse, error)

	// GetPersistentTopicDelayedDeliveryPolicies request
	GetPersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDelayedDeliveryPoliciesResponse, error)

	// SetPersistentTopicDelayedDeliveryPolicies request with any body
	SetPersistentTopicDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDelayedDeliveryPoliciesResponse, error)

	// RemovePersistentTopicDispatchRate request
	RemovePersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicDispatchRateResponse, error)

	// GetPersistentTopicDispatchRate request
	GetPersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDispatchRateResponse, error)

	// SetPersistentTopicDispatchRate request with any body
	SetPersistentTopicDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDispatchRateResponse, error)

	// RemovePersistentTopicEntryFilters request
	RemovePersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicEntryFiltersResponse, error)

	// GetPersistentTopicEntryFilters request
	GetPersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicEntryFiltersResponse, error)

	// SetPersistentTopicEntryFilters request with any body
	SetPersistentTopicEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicEntryFiltersResponse, error)

	// ExaminePersistentTopicMessage request
	ExaminePersistentTopicMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExaminePersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*ExaminePersistentTopicMessageResponse, error)

	// DeletePersistentTopicInactiveTopicPolicies request
	DeletePersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicInactiveTopicPoliciesResponse, error)

	// GetPersistentTopicInactiveTopicPolicies request
	GetPersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicInactiveTopicPoliciesResponse, error)

	// SetPersistentTopicInactiveTopicPolicies request with any body
	SetPersistentTopicInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicInactiveTopicPoliciesResponse, error)

	// GetPersistentTopicManagedLedgerInfo request
	GetPersistentTopicManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicManagedLedgerInfoResponse, error)

	// GetPersistentTopicInternalStats request
	GetPersistentTopicInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicInternalStatsResponse, error)

	// GetPersistentTopicLastMessageId request
	GetPersistentTopicLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicLastMessageIdResponse, error)

	// GetPersistentTopicMessageById request
	GetPersistentTopicMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMessageByIdResponse, error)

	// RemovePersistentTopicMaxConsumers request
	RemovePersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxConsumersResponse, error)

	// GetPersistentTopicMaxConsumers request
	GetPersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxConsumersResponse, error)

	// SetPersistentTopicMaxConsumers request with any body
	SetPersistentTopicMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxConsumersResponse, error)

	// RemovePersistentTopicMaxConsumersPerSubscription request
	RemovePersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxConsumersPerSubscriptionResponse, error)

	// GetPersistentTopicMaxConsumersPerSubscription request
	GetPersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxConsumersPerSubscriptionResponse, error)

	// SetPersistentTopicMaxConsumersPerSubscription request with any body
	SetPersistentTopicMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxConsumersPerSubscriptionResponse, error)

	// RemovePersistentTopicMaxMessageSize request
	RemovePersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxMessageSizeResponse, error)

	// GetPersistentTopicMaxMessageSize request
	GetPersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxMessageSizeResponse, error)

	// SetPersistentTopicMaxMessageSize request with any body
	SetPersistentTopicMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxMessageSizeResponse, error)

	// RemovePersistentTopicMaxProducers request
	RemovePersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxProducersResponse, error)

	// GetPersistentTopicMaxProducers request
	GetPersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxProducersResponse, error)

	// SetPersistentTopicMaxProducers request with any body
	SetPersistentTopicMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxProducersResponse, error)

	// RemovePersistentTopicMaxSubscriptionsPerTopic request
	RemovePersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxSubscriptionsPerTopicResponse, error)

	// GetPersistentTopicMaxSubscriptionsPerTopic request
	GetPersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxSubscriptionsPerTopicResponse, error)

	// SetPersistentTopicMaxSubscriptionsPerTopic request with any body
	SetPersistentTopicMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxSubscriptionsPerTopicResponse, error)

	// DeletePersistentTopicMaxUnackedMessagesOnConsumer request
	DeletePersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse, error)

	// GetPersistentTopicMaxUnackedMessagesOnConsumer request
	GetPersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxUnackedMessagesOnConsumerResponse, error)

	// SetPersistentTopicMaxUnackedMessagesOnConsumer request with any body
	SetPersistentTopicMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxUnackedMessagesOnConsumerResponse, error)

	// DeletePersistentTopicMaxUnackedMessagesOnSubscription request
	DeletePersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error)

	// GetPersistentTopicMaxUnackedMessagesOnSubscription request
	GetPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error)

	// SetPersistentTopicMaxUnackedMessagesOnSubscription request with any body
	SetPersistentTopicMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error)

	// RemovePersistentTopicMessageTTL request
	RemovePersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMessageTTLResponse, error)

	// GetPersistentTopicMessageTTL request
	GetPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMessageTTLResponse, error)

	// SetPersistentTopicMessageTTL request
	SetPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*SetPersistentTopicMessageTTLResponse, error)

	// GetPersistentTopicMessageIdByTimestamp request
	GetPersistentTopicMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMessageIdByTimestampResponse, error)

	// OffloadPersistentTopicStatus request
	OffloadPersistentTopicStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*OffloadPersistentTopicStatusResponse, error)

	// TriggerPersistentTopicOffload request
	TriggerPersistentTopicOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*TriggerPersistentTopicOffloadResponse, error)

	// RemovePersistentTopicOffloadPolicies request
	RemovePersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicOffloadPoliciesResponse, error)

	// GetPersistentTopicOffloadPolicies request
	GetPersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicOffloadPoliciesResponse, error)

	// SetPersistentTopicOffloadPolicies request with any body
	SetPersistentTopicOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicOffloadPoliciesResponse, error)

	// GetPersistentTopicPartitionedStats request
	GetPersistentTopicPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPartitionedStatsResponse, error)

	// DeletePersistentTopicPartitionedTopic request
	DeletePersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicPartitionedTopicResponse, error)

	// GetPersistentTopicPartitionedMetadata request
	GetPersistentTopicPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPartitionedMetadataResponse, error)

	// UpdatePersistentTopicPartitionedTopic request with any body
	UpdatePersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersistentTopicPartitionedTopicResponse, error)

	// CreatePersistentTopicPartitionedTopic request with any body
	CreatePersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePersistentTopicPartitionedTopicResponse, error)

	// GetPersistentTopicPermissionsOnTopic request
	GetPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetPersistentTopicPermissionsOnTopicResponse, error)

	// RevokePersistentTopicNonPersistentTopicPermissionsOnTopic request
	RevokePersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse, error)

	// GrantPersistentTopicPermissionsOnTopic request with any body
	GrantPersistentTopicPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPersistentTopicPermissionsOnTopicResponse, error)

	// RemovePersistentTopicPersistence request
	RemovePersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicPersistenceResponse, error)

	// GetPersistentTopicPersistence request
	GetPersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPersistenceResponse, error)

	// SetPersistentTopicPersistence request with any body
	SetPersistentTopicPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicPersistenceResponse, error)

	// RemovePersistentTopicProperties request
	RemovePersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicPropertiesResponse, error)

	// GetPersistentTopicProperties request
	GetPersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPropertiesResponse, error)

	// UpdatePersistentTopicProperties request with any body
	UpdatePersistentTopicPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersistentTopicPropertiesResponse, error)

	// RemovePersistentTopicPublishRate request
	RemovePersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicPublishRateResponse, error)

	// GetPersistentTopicPublishRate request
	GetPersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPublishRateResponse, error)

	// SetPersistentTopicPublishRate request with any body
	SetPersistentTopicPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicPublishRateResponse, error)

	// RemovePersistentTopicReplicationClusters request
	RemovePersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicReplicationClustersResponse, error)

	// GetPersistentTopicReplicationClusters request
	GetPersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicReplicationClustersResponse, error)

	// SetPersistentTopicReplicationClusters request with any body
	SetPersistentTopicReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicReplicationClustersResponse, error)

	// RemovePersistentTopicReplicatorDispatchRate request
	RemovePersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicReplicatorDispatchRateResponse, error)

	// GetPersistentTopicReplicatorDispatchRate request
	GetPersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicReplicatorDispatchRateResponse, error)

	// SetPersistentTopicReplicatorDispatchRate request with any body
	SetPersistentTopicReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicReplicatorDispatchRateResponse, error)

	// RemovePersistentTopicRetention request
	RemovePersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicRetentionResponse, error)

	// GetPersistentTopicRetention request
	GetPersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicRetentionResponse, error)

	// SetPersistentTopicRetention request with any body
	SetPersistentTopicRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicRetentionResponse, error)

	// RemovePersistentTopicSchemaCompatibilityStrategy request with any body
	RemovePersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSchemaCompatibilityStrategyResponse, error)

	// GetPersistentTopicSchemaCompatibilityStrategy request
	GetPersistentTopicSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSchemaCompatibilityStrategyResponse, error)

	// SetPersistentTopicSchemaCompatibilityStrategy request with any body
	SetPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSchemaCompatibilityStrategyResponse, error)

	// GetPersistentTopicSchemaValidationEnforced request
	GetPersistentTopicSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSchemaValidationEnforcedResponse, error)

	// SetPersistentTopicSchemaValidationEnforced request with any body
	SetPersistentTopicSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSchemaValidationEnforcedResponse, error)

	// DeletePersistentTopicShadowTopics request
	DeletePersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicShadowTopicsResponse, error)

	// GetPersistentTopicShadowTopics request
	GetPersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicShadowTopicsResponse, error)

	// SetPersistentTopicShadowTopics request with any body
	SetPersistentTopicShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicShadowTopicsResponse, error)

	// GetPersistentTopicStats request
	GetPersistentTopicStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicStatsResponse, error)

	// RemovePersistentTopicSubscribeRate request with any body
	RemovePersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscribeRateResponse, error)

	// GetPersistentTopicSubscribeRate request
	GetPersistentTopicSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscribeRateResponse, error)

	// SetPersistentTopicSubscribeRate request with any body
	SetPersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscribeRateResponse, error)

	// DeletePersistentTopicSubscription request
	DeletePersistentTopicSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeletePersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicSubscriptionResponse, error)

	// AnalyzePersistentTopicSubscriptionBacklog request with any body
	AnalyzePersistentTopicSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzePersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzePersistentTopicSubscriptionBacklogResponse, error)

	// ExpirePersistentTopicMessages request with any body
	ExpirePersistentTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpirePersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpirePersistentTopicMessagesResponse, error)

	// ExpirePersistentTopicMessagesTimeInSeconds request
	ExpirePersistentTopicMessagesTimeInSecondsWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*ExpirePersistentTopicMessagesTimeInSecondsResponse, error)

	// PeekPersistentTopicNthMessage request
	PeekPersistentTopicNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*PeekPersistentTopicNthMessageResponse, error)

	// GetPersistentTopicSubscriptionProperties request
	GetPersistentTopicSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionPropertiesResponse, error)

	// UpdatePersistentTopicSubscriptionProperties request with any body
	UpdatePersistentTopicSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdatePersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersistentTopicSubscriptionPropertiesResponse, error)

	// GetPersistentTopicReplicatedSubscriptionStatus request
	GetPersistentTopicReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicReplicatedSubscriptionStatusResponse, error)

	// SetPersistentTopicReplicatedSubscriptionStatus request with any body
	SetPersistentTopicReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicReplicatedSubscriptionStatusResponse, error)

	// ResetPersistentTopicCursorOnPosition request with any body
	ResetPersistentTopicCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPersistentTopicCursorOnPositionResponse, error)

	// ResetPersistentTopicCursor request
	ResetPersistentTopicCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*ResetPersistentTopicCursorResponse, error)

	// SkipPersistentTopicMessages request
	SkipPersistentTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*SkipPersistentTopicMessagesResponse, error)

	// SkipPersistentTopicAllMessages request
	SkipPersistentTopicAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipPersistentTopicAllMessagesResponse, error)

	// CreatePersistentTopicSubscription request with any body
	CreatePersistentTopicSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreatePersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePersistentTopicSubscriptionResponse, error)

	// RemovePersistentTopicSubscriptionDispatchRate request
	RemovePersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscriptionDispatchRateResponse, error)

	// GetPersistentTopicSubscriptionDispatchRate request
	GetPersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionDispatchRateResponse, error)

	// SetPersistentTopicSubscriptionDispatchRate request with any body
	SetPersistentTopicSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscriptionDispatchRateResponse, error)

	// RemovePersistentTopicSubscriptionTypesEnabled request
	RemovePersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscriptionTypesEnabledResponse, error)

	// GetPersistentTopicSubscriptionTypesEnabled request
	GetPersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionTypesEnabledResponse, error)

	// SetPersistentTopicSubscriptionTypesEnabled request with any body
	SetPersistentTopicSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscriptionTypesEnabledResponse, error)

	// GetPersistentTopicSubscriptions request
	GetPersistentTopicSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionsResponse, error)

	// TerminatePersistentTopic request
	TerminatePersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicParams, reqEditors ...RequestEditorFn) (*TerminatePersistentTopicResponse, error)

	// TerminatePersistentTopicPartitionedTopic request
	TerminatePersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminatePersistentTopicPartitionedTopicResponse, error)

	// TruncatePersistentTopicTopic request
	TruncatePersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncatePersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*TruncatePersistentTopicTopicResponse, error)

	// UnloadPersistentTopicTopic request
	UnloadPersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*UnloadPersistentTopicTopicResponse, error)

	// RemovePersistentTopicSubscriptionLevelDispatchRate request
	RemovePersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemovePersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscriptionLevelDispatchRateResponse, error)

	// GetPersistentTopicSubscriptionLevelDispatchRate request
	GetPersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionLevelDispatchRateResponse, error)

	// SetPersistentTopicSubscriptionLevelDispatchRate request with any body
	SetPersistentTopicSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscriptionLevelDispatchRateResponse, error)

	// GetDefaultResourceQuota request
	GetDefaultResourceQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultResourceQuotaResponse, error)

	// SetDefaultResourceQuota request with any body
	SetDefaultResourceQuotaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error)

	SetDefaultResourceQuotaWithResponse(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error)

	// RemoveNamespaceBundleResourceQuota request
	RemoveNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*RemoveNamespaceBundleResourceQuotaResponse, error)

	// GetNamespaceBundleResourceQuota request
	GetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetNamespaceBundleResourceQuotaResponse, error)

	// SetNamespaceBundleResourceQuota request with any body
	SetNamespaceBundleResourceQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error)

	SetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error)

	// GetResourceGroups request
	GetResourceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourceGroupsResponse, error)

	// DeleteResourceGroup request
	DeleteResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*DeleteResourceGroupResponse, error)

	// GetResourceGroup request
	GetResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*GetResourceGroupResponse, error)

	// CreateOrUpdateResourceGroup request with any body
	CreateOrUpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error)

	CreateOrUpdateResourceGroupWithResponse(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error)

	// TestCompatibility request with any body
	TestCompatibilityWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error)

	TestCompatibilityWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error)

	// DeleteSchema request
	DeleteSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResponse, error)

	// GetSchemaOfTopic request
	GetSchemaOfTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaOfTopicParams, reqEditors ...RequestEditorFn) (*GetSchemaOfTopicResponse, error)

	// PostSchema request with any body
	PostSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error)

	PostSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error)

	// GetSchemaOfTopicGivenVersion request
	GetSchemaOfTopicGivenVersionWithResponse(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaOfTopicGivenVersionParams, reqEditors ...RequestEditorFn) (*GetSchemaOfTopicGivenVersionResponse, error)

	// GetAllSchemas request
	GetAllSchemasWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*GetAllSchemasResponse, error)

	// GetVersionBySchema request with any body
	GetVersionBySchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error)

	GetVersionBySchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error)

	// GetTenants request
	GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error)

	// DeleteTenant request
	DeleteTenantWithResponse(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error)

	// GetTenantAdmin request
	GetTenantAdminWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantAdminResponse, error)

	// UpdateTenant request with any body
	UpdateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	UpdateTenantWithResponse(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	// CreateTenant request with any body
	CreateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	CreateTenantWithResponse(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error)

	// GetWorkerStats request
	GetWorkerStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerStatsResponse, error)

	// GetWorkerStatsMetrics request
	GetWorkerStatsMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerStatsMetricsResponse, error)

	// GetAssignments request
	GetAssignmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAssignmentsResponse, error)

	// GetWorkerCluster request
	GetWorkerClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerClusterResponse, error)

	// GetWorkerClusterLeader request
	GetWorkerClusterLeaderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerClusterLeaderResponse, error)

	// IsLeaderReady request
	IsLeaderReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsLeaderReadyResponse, error)

	// GetConnectorsList request
	GetConnectorsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectorsListResponse, error)

	// GetDrainStatus request
	GetDrainStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDrainStatusResponse, error)

	// Drain request
	DrainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DrainResponse, error)

	// GetDrainStatusFromLeader request
	GetDrainStatusFromLeaderWithResponse(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*GetDrainStatusFromLeaderResponse, error)

	// DrainAtLeader request
	DrainAtLeaderWithResponse(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*DrainAtLeaderResponse, error)

	// Rebalance request
	RebalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RebalanceResponse, error)
}

type GetAllBookiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookiesClusterInfo
}

// Status returns HTTPResponse.Status
func (r GetAllBookiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBookiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookiesRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]map[string]BookieInfo
}

// Status returns HTTPResponse.Status
func (r GetBookiesRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookiesRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookieInfo
}

// Status returns HTTPResponse.Status
func (r GetBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllocatorStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllocatorStats
}

// Status returns HTTPResponse.Status
func (r GetAllocatorStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllocatorStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingBookieOpsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]PendingBookieOpsStats
}

// Status returns HTTPResponse.Status
func (r GetPendingBookieOpsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingBookieOpsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrokerResourceAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]ResourceUnit
}

// Status returns HTTPResponse.Status
func (r GetBrokerResourceAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrokerResourceAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoadReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadReport
}

// Status returns HTTPResponse.Status
func (r GetLoadReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoadReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMBeansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r GetMBeansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMBeansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrokerStatsMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r GetBrokerStatsMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrokerStatsMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopics2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OutputStream
}

// Status returns HTTPResponse.Status
func (r GetTopics2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopics2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActiveBrokersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetActiveBrokersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActiveBrokersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BacklogQuotaCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BacklogQuotaCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BacklogQuotaCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDynamicConfigurationNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDynamicConfigurationNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDynamicConfigurationNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRuntimeConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDynamicConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAllDynamicConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDynamicConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDynamicConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDynamicConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDynamicConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDynamicConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateDynamicConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDynamicConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInternalConfigurationDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternalConfigurationData
}

// Status returns HTTPResponse.Status
func (r GetInternalConfigurationDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInternalConfigurationDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLeaderBrokerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrokerInfo
}

// Status returns HTTPResponse.Status
func (r GetLeaderBrokerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaderBrokerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IsReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShutDownBrokerGracefullyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ShutDownBrokerGracefullyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShutDownBrokerGracefullyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r VersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOwnedNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]NamespaceOwnershipStatus
}

// Status returns HTTPResponse.Status
func (r GetOwnedNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOwnedNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActiveClusterBrokersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetActiveClusterBrokersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActiveClusterBrokersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterData
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFailureDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]FailureDomain
}

// Status returns HTTPResponse.Status
func (r GetFailureDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFailureDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFailureDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFailureDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFailureDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FailureDomain
}

// Status returns HTTPResponse.Status
func (r GetDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetFailureDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetFailureDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetFailureDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceIsolationPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]NamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r GetNamespaceIsolationPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceIsolationPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrokersWithNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BrokerNamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r GetBrokersWithNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrokersWithNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrokerWithNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrokerNamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r GetBrokerWithNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrokerWithNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r GetNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetPeerClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPeerClusterNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPeerClusterNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPeerClusterNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAntiAffinityNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetAntiAffinityNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAntiAffinityNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookieAffinityGroupData
}

// Status returns HTTPResponse.Status
func (r GetBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTenantNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policies
}

// Status returns HTTPResponse.Status
func (r GetPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamesapceBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamesapceBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamesapceBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBundlesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBundlesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBundlesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBacklogForSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBacklogForSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBacklogForSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEncryptionRequiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEncryptionRequiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEncryptionRequiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyEncryptionRequiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyEncryptionRequiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyEncryptionRequiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceEntryFiltersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceEntryFiltersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceEntryFiltersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEntryFiltersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetEntryFiltersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEntryFiltersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIsAllowAutoUpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetIsAllowAutoUpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIsAllowAutoUpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIsAllowAutoUpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetIsAllowAutoUpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIsAllowAutoUpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceMaxTopicsPerNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceMaxTopicsPerNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceMaxTopicsPerNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMaxTopicsPerNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMaxTopicsPerNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMaxTopicsPerNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMaxTopicsPerNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMaxTopicsPerNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMaxTopicsPerNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMaxUnackedmessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMaxUnackedmessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMaxUnackedmessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMaxUnackedMessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMaxUnackedMessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMaxUnackedMessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMaxUnackedMessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMaxUnackedMessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMaxUnackedMessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMaxUnackedmessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMaxUnackedmessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMaxUnackedmessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMaxUnackedMessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMaxUnackedMessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMaxUnackedMessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r GetNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceOffloadThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceOffloadThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceOffloadThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceOffloadThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceOffloadThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceOffloadThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPermissionOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePermissionsOnNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokePermissionsOnNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePermissionsOnNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantPermissionOnNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GrantPermissionOnNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantPermissionOnNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespacePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespacePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespacePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespacePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespacePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespacePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespacePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespacePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespacePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetNamespaceReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScanOffloadedLedgersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScanOffloadedLedgersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScanOffloadedLedgersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaAutoUpdateCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetSchemaAutoUpdateCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaAutoUpdateCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSchemaAutoUpdateCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetSchemaAutoUpdateCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSchemaAutoUpdateCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaValidtionEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSchemaValidtionEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaValidtionEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionAuthModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionAuthModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionAuthModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceSubscriptionAuthModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceSubscriptionAuthModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceSubscriptionAuthModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsubscribeNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnsubscribeNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsubscribeNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBundleBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBundleBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBundleBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearNamespaceBundleBacklogForSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearNamespaceBundleBacklogForSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearNamespaceBundleBacklogForSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SplitNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SplitNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SplitNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopicHashPositionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTopicHashPositionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopicHashPositionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsubscribeNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnsubscribeNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsubscribeNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentPartitionedTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentPartitionedTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentPartitionedTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListFromBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetListFromBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListFromBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNonPersistentTopicNonPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNonPersistentTopicNonPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNonPersistentTopicNonPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicBacklogSizeByMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicBacklogSizeByMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicBacklogSizeByMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicCompactionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicCompactionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicCompactionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompactNonPersistentTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompactNonPersistentTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompactNonPersistentTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNonPersistentTopicMissedPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNonPersistentTopicMissedPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNonPersistentTopicMissedPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExamineNonPersistentTopicMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExamineNonPersistentTopicMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExamineNonPersistentTopicMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicManagedLedgerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicManagedLedgerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicManagedLedgerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicInternalStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicInternalStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicInternalStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicLastMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicLastMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicLastMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMessageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMessageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMessageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicMessageIdByTimestampResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicMessageIdByTimestampResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicMessageIdByTimestampResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OffloadNonPersistentTopicStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OffloadNonPersistentTopicStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OffloadNonPersistentTopicStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerNonPersistentTopicOffloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TriggerNonPersistentTopicOffloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerNonPersistentTopicOffloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicPartitionedStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicPartitionedStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicPartitionedStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicPartitionedMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicPartitionedMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicPartitionedMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNonPersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateNonPersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNonPersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNonPersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNonPersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNonPersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantNonPersistentTopicPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GrantNonPersistentTopicPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantNonPersistentTopicPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNonPersistentTopicPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateNonPersistentTopicPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNonPersistentTopicPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNonPersistentTopicSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNonPersistentTopicSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNonPersistentTopicSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnalyzeNonPersistentTopicSubscriptionBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AnalyzeNonPersistentTopicSubscriptionBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnalyzeNonPersistentTopicSubscriptionBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireNonPersistentTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireNonPersistentTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireNonPersistentTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireNonPersistentTopicMessagesTimeInSecondsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpireNonPersistentTopicMessagesTimeInSecondsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireNonPersistentTopicMessagesTimeInSecondsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PeekNonPersistentTopicNthMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PeekNonPersistentTopicNthMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PeekNonPersistentTopicNthMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNonPersistentTopicSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateNonPersistentTopicSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNonPersistentTopicSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetNonPersistentTopicCursorOnPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetNonPersistentTopicCursorOnPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetNonPersistentTopicCursorOnPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetNonPersistentTopicCursorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetNonPersistentTopicCursorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetNonPersistentTopicCursorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipNonPersistentTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipNonPersistentTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipNonPersistentTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipNonPersistentTopicAllMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipNonPersistentTopicAllMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipNonPersistentTopicAllMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNonPersistentTopicSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNonPersistentTopicSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNonPersistentTopicSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateNonPersistentTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminateNonPersistentTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateNonPersistentTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateNonPersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminateNonPersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateNonPersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TruncateNonPersistentTopicTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TruncateNonPersistentTopicTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TruncateNonPersistentTopicTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadNonPersistentTopicTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadNonPersistentTopicTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadNonPersistentTopicTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNonPersistentTopicSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNonPersistentTopicSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNonPersistentTopicSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNonPersistentTopicSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNonPersistentTopicSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNonPersistentTopicSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentPartitionedTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetPersistentPartitionedTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentPartitionedTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePersistentTopicNonPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePersistentTopicNonPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePersistentTopicNonPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpirePersistentTopicMessagesForAllSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpirePersistentTopicMessagesForAllSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpirePersistentTopicMessagesForAllSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicBacklogSizeByMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicBacklogSizeByMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicBacklogSizeByMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicCompactionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicCompactionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicCompactionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompactPersistentTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompactPersistentTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompactPersistentTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePersistentTopicMissedPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePersistentTopicMissedPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePersistentTopicMissedPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExaminePersistentTopicMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExaminePersistentTopicMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExaminePersistentTopicMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicManagedLedgerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicManagedLedgerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicManagedLedgerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicInternalStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicInternalStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicInternalStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicLastMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicLastMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicLastMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMessageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMessageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMessageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicMessageIdByTimestampResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicMessageIdByTimestampResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicMessageIdByTimestampResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OffloadPersistentTopicStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OffloadPersistentTopicStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OffloadPersistentTopicStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerPersistentTopicOffloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TriggerPersistentTopicOffloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerPersistentTopicOffloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicPartitionedStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicPartitionedStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicPartitionedStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicPartitionedMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicPartitionedMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicPartitionedMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GrantPersistentTopicPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GrantPersistentTopicPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GrantPersistentTopicPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePersistentTopicPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePersistentTopicPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePersistentTopicPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistentTopicSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistentTopicSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistentTopicSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnalyzePersistentTopicSubscriptionBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AnalyzePersistentTopicSubscriptionBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnalyzePersistentTopicSubscriptionBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpirePersistentTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpirePersistentTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpirePersistentTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpirePersistentTopicMessagesTimeInSecondsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExpirePersistentTopicMessagesTimeInSecondsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpirePersistentTopicMessagesTimeInSecondsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PeekPersistentTopicNthMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PeekPersistentTopicNthMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PeekPersistentTopicNthMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePersistentTopicSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePersistentTopicSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePersistentTopicSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPersistentTopicCursorOnPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetPersistentTopicCursorOnPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPersistentTopicCursorOnPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPersistentTopicCursorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetPersistentTopicCursorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPersistentTopicCursorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipPersistentTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipPersistentTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipPersistentTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipPersistentTopicAllMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SkipPersistentTopicAllMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipPersistentTopicAllMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePersistentTopicSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePersistentTopicSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePersistentTopicSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminatePersistentTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminatePersistentTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminatePersistentTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminatePersistentTopicPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminatePersistentTopicPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminatePersistentTopicPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TruncatePersistentTopicTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TruncatePersistentTopicTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TruncatePersistentTopicTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnloadPersistentTopicTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnloadPersistentTopicTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnloadPersistentTopicTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePersistentTopicSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemovePersistentTopicSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePersistentTopicSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistentTopicSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPersistentTopicSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistentTopicSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPersistentTopicSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPersistentTopicSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPersistentTopicSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetDefaultResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r SetDefaultResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetResourceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceGroup
}

// Status returns HTTPResponse.Status
func (r GetResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestCompatibilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IsCompatibilityResponse
}

// Status returns HTTPResponse.Status
func (r TestCompatibilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestCompatibilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteSchemaSuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaOfTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchemaResponse
}

// Status returns HTTPResponse.Status
func (r GetSchemaOfTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaOfTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostSchemaSuccessResponse
}

// Status returns HTTPResponse.Status
func (r PostSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaOfTopicGivenVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchemaResponse
}

// Status returns HTTPResponse.Status
func (r GetSchemaOfTopicGivenVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaOfTopicGivenVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllVersionsSchemaResponse
}

// Status returns HTTPResponse.Status
func (r GetAllSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionBySchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LongSchemaVersion
}

// Status returns HTTPResponse.Status
func (r GetVersionBySchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionBySchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTenantAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkerStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerFunctionInstanceStats
}

// Status returns HTTPResponse.Status
func (r GetWorkerStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkerStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkerStatsMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r GetWorkerStatsMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkerStatsMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkerClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerInfo
}

// Status returns HTTPResponse.Status
func (r GetWorkerClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkerClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkerClusterLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkerInfo
}

// Status returns HTTPResponse.Status
func (r GetWorkerClusterLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkerClusterLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsLeaderReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IsLeaderReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsLeaderReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetConnectorsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDrainStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDrainStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDrainStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DrainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DrainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DrainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDrainStatusFromLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDrainStatusFromLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDrainStatusFromLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DrainAtLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DrainAtLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DrainAtLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RebalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllBookiesWithResponse request returning *GetAllBookiesResponse
func (c *ClientWithResponses) GetAllBookiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllBookiesResponse, error) {
	rsp, err := c.GetAllBookies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBookiesResponse(rsp)
}

// GetBookiesRackInfoWithResponse request returning *GetBookiesRackInfoResponse
func (c *ClientWithResponses) GetBookiesRackInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBookiesRackInfoResponse, error) {
	rsp, err := c.GetBookiesRackInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookiesRackInfoResponse(rsp)
}

// DeleteBookieRackInfoWithResponse request returning *DeleteBookieRackInfoResponse
func (c *ClientWithResponses) DeleteBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*DeleteBookieRackInfoResponse, error) {
	rsp, err := c.DeleteBookieRackInfo(ctx, bookie, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBookieRackInfoResponse(rsp)
}

// GetBookieRackInfoWithResponse request returning *GetBookieRackInfoResponse
func (c *ClientWithResponses) GetBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*GetBookieRackInfoResponse, error) {
	rsp, err := c.GetBookieRackInfo(ctx, bookie, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookieRackInfoResponse(rsp)
}

// UpdateBookieRackInfoWithResponse request returning *UpdateBookieRackInfoResponse
func (c *ClientWithResponses) UpdateBookieRackInfoWithResponse(ctx context.Context, bookie string, params *UpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*UpdateBookieRackInfoResponse, error) {
	rsp, err := c.UpdateBookieRackInfo(ctx, bookie, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBookieRackInfoResponse(rsp)
}

// GetAllocatorStatsWithResponse request returning *GetAllocatorStatsResponse
func (c *ClientWithResponses) GetAllocatorStatsWithResponse(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*GetAllocatorStatsResponse, error) {
	rsp, err := c.GetAllocatorStats(ctx, allocator, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllocatorStatsResponse(rsp)
}

// GetPendingBookieOpsStatsWithResponse request returning *GetPendingBookieOpsStatsResponse
func (c *ClientWithResponses) GetPendingBookieOpsStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingBookieOpsStatsResponse, error) {
	rsp, err := c.GetPendingBookieOpsStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingBookieOpsStatsResponse(rsp)
}

// GetBrokerResourceAvailabilityWithResponse request returning *GetBrokerResourceAvailabilityResponse
func (c *ClientWithResponses) GetBrokerResourceAvailabilityWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBrokerResourceAvailabilityResponse, error) {
	rsp, err := c.GetBrokerResourceAvailability(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrokerResourceAvailabilityResponse(rsp)
}

// GetLoadReportWithResponse request returning *GetLoadReportResponse
func (c *ClientWithResponses) GetLoadReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoadReportResponse, error) {
	rsp, err := c.GetLoadReport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoadReportResponse(rsp)
}

// GetMBeansWithResponse request returning *GetMBeansResponse
func (c *ClientWithResponses) GetMBeansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMBeansResponse, error) {
	rsp, err := c.GetMBeans(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMBeansResponse(rsp)
}

// GetBrokerStatsMetricsWithResponse request returning *GetBrokerStatsMetricsResponse
func (c *ClientWithResponses) GetBrokerStatsMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrokerStatsMetricsResponse, error) {
	rsp, err := c.GetBrokerStatsMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrokerStatsMetricsResponse(rsp)
}

// GetTopics2WithResponse request returning *GetTopics2Response
func (c *ClientWithResponses) GetTopics2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTopics2Response, error) {
	rsp, err := c.GetTopics2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopics2Response(rsp)
}

// GetActiveBrokersWithResponse request returning *GetActiveBrokersResponse
func (c *ClientWithResponses) GetActiveBrokersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActiveBrokersResponse, error) {
	rsp, err := c.GetActiveBrokers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActiveBrokersResponse(rsp)
}

// BacklogQuotaCheckWithResponse request returning *BacklogQuotaCheckResponse
func (c *ClientWithResponses) BacklogQuotaCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BacklogQuotaCheckResponse, error) {
	rsp, err := c.BacklogQuotaCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBacklogQuotaCheckResponse(rsp)
}

// GetDynamicConfigurationNameWithResponse request returning *GetDynamicConfigurationNameResponse
func (c *ClientWithResponses) GetDynamicConfigurationNameWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDynamicConfigurationNameResponse, error) {
	rsp, err := c.GetDynamicConfigurationName(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDynamicConfigurationNameResponse(rsp)
}

// GetRuntimeConfigurationWithResponse request returning *GetRuntimeConfigurationResponse
func (c *ClientWithResponses) GetRuntimeConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeConfigurationResponse, error) {
	rsp, err := c.GetRuntimeConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeConfigurationResponse(rsp)
}

// GetAllDynamicConfigurationsWithResponse request returning *GetAllDynamicConfigurationsResponse
func (c *ClientWithResponses) GetAllDynamicConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDynamicConfigurationsResponse, error) {
	rsp, err := c.GetAllDynamicConfigurations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDynamicConfigurationsResponse(rsp)
}

// DeleteDynamicConfigurationWithResponse request returning *DeleteDynamicConfigurationResponse
func (c *ClientWithResponses) DeleteDynamicConfigurationWithResponse(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*DeleteDynamicConfigurationResponse, error) {
	rsp, err := c.DeleteDynamicConfiguration(ctx, configName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDynamicConfigurationResponse(rsp)
}

// UpdateDynamicConfigurationWithResponse request returning *UpdateDynamicConfigurationResponse
func (c *ClientWithResponses) UpdateDynamicConfigurationWithResponse(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*UpdateDynamicConfigurationResponse, error) {
	rsp, err := c.UpdateDynamicConfiguration(ctx, configName, configValue, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDynamicConfigurationResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// GetInternalConfigurationDataWithResponse request returning *GetInternalConfigurationDataResponse
func (c *ClientWithResponses) GetInternalConfigurationDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInternalConfigurationDataResponse, error) {
	rsp, err := c.GetInternalConfigurationData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInternalConfigurationDataResponse(rsp)
}

// GetLeaderBrokerWithResponse request returning *GetLeaderBrokerResponse
func (c *ClientWithResponses) GetLeaderBrokerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLeaderBrokerResponse, error) {
	rsp, err := c.GetLeaderBroker(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLeaderBrokerResponse(rsp)
}

// IsReadyWithResponse request returning *IsReadyResponse
func (c *ClientWithResponses) IsReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsReadyResponse, error) {
	rsp, err := c.IsReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsReadyResponse(rsp)
}

// ShutDownBrokerGracefullyWithResponse request returning *ShutDownBrokerGracefullyResponse
func (c *ClientWithResponses) ShutDownBrokerGracefullyWithResponse(ctx context.Context, params *ShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*ShutDownBrokerGracefullyResponse, error) {
	rsp, err := c.ShutDownBrokerGracefully(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShutDownBrokerGracefullyResponse(rsp)
}

// VersionWithResponse request returning *VersionResponse
func (c *ClientWithResponses) VersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VersionResponse, error) {
	rsp, err := c.Version(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionResponse(rsp)
}

// GetOwnedNamespacesWithResponse request returning *GetOwnedNamespacesResponse
func (c *ClientWithResponses) GetOwnedNamespacesWithResponse(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*GetOwnedNamespacesResponse, error) {
	rsp, err := c.GetOwnedNamespaces(ctx, clusterName, brokerWebserviceurl, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOwnedNamespacesResponse(rsp)
}

// GetActiveClusterBrokersWithResponse request returning *GetActiveClusterBrokersResponse
func (c *ClientWithResponses) GetActiveClusterBrokersWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetActiveClusterBrokersResponse, error) {
	rsp, err := c.GetActiveClusterBrokers(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActiveClusterBrokersResponse(rsp)
}

// GetClustersWithResponse request returning *GetClustersResponse
func (c *ClientWithResponses) GetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClustersResponse, error) {
	rsp, err := c.GetClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClustersResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// GetFailureDomainsWithResponse request returning *GetFailureDomainsResponse
func (c *ClientWithResponses) GetFailureDomainsWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetFailureDomainsResponse, error) {
	rsp, err := c.GetFailureDomains(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFailureDomainsResponse(rsp)
}

// DeleteFailureDomainWithResponse request returning *DeleteFailureDomainResponse
func (c *ClientWithResponses) DeleteFailureDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*DeleteFailureDomainResponse, error) {
	rsp, err := c.DeleteFailureDomain(ctx, cluster, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFailureDomainResponse(rsp)
}

// GetDomainWithResponse request returning *GetDomainResponse
func (c *ClientWithResponses) GetDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*GetDomainResponse, error) {
	rsp, err := c.GetDomain(ctx, cluster, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainResponse(rsp)
}

// SetFailureDomainWithBodyWithResponse request with arbitrary body returning *SetFailureDomainResponse
func (c *ClientWithResponses) SetFailureDomainWithBodyWithResponse(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFailureDomainResponse, error) {
	rsp, err := c.SetFailureDomainWithBody(ctx, cluster, domainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFailureDomainResponse(rsp)
}

// GetNamespaceIsolationPoliciesWithResponse request returning *GetNamespaceIsolationPoliciesResponse
func (c *ClientWithResponses) GetNamespaceIsolationPoliciesWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPoliciesResponse, error) {
	rsp, err := c.GetNamespaceIsolationPolicies(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceIsolationPoliciesResponse(rsp)
}

// GetBrokersWithNamespaceIsolationPolicyWithResponse request returning *GetBrokersWithNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) GetBrokersWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetBrokersWithNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.GetBrokersWithNamespaceIsolationPolicy(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrokersWithNamespaceIsolationPolicyResponse(rsp)
}

// GetBrokerWithNamespaceIsolationPolicyWithResponse request returning *GetBrokerWithNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) GetBrokerWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*GetBrokerWithNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.GetBrokerWithNamespaceIsolationPolicy(ctx, cluster, broker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrokerWithNamespaceIsolationPolicyResponse(rsp)
}

// DeleteNamespaceIsolationPolicyWithResponse request returning *DeleteNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) DeleteNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*DeleteNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.DeleteNamespaceIsolationPolicy(ctx, cluster, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceIsolationPolicyResponse(rsp)
}

// GetNamespaceIsolationPolicyWithResponse request returning *GetNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) GetNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*GetNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.GetNamespaceIsolationPolicy(ctx, cluster, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceIsolationPolicyResponse(rsp)
}

// SetNamespaceIsolationPolicyWithBodyWithResponse request with arbitrary body returning *SetNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) SetNamespaceIsolationPolicyWithBodyWithResponse(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.SetNamespaceIsolationPolicyWithBody(ctx, cluster, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceIsolationPolicyResponse(rsp)
}

// GetPeerClusterWithResponse request returning *GetPeerClusterResponse
func (c *ClientWithResponses) GetPeerClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*GetPeerClusterResponse, error) {
	rsp, err := c.GetPeerCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerClusterResponse(rsp)
}

// SetPeerClusterNamesWithBodyWithResponse request with arbitrary body returning *SetPeerClusterNamesResponse
func (c *ClientWithResponses) SetPeerClusterNamesWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPeerClusterNamesResponse, error) {
	rsp, err := c.SetPeerClusterNamesWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPeerClusterNamesResponse(rsp)
}

// GetAntiAffinityNamespacesWithResponse request returning *GetAntiAffinityNamespacesResponse
func (c *ClientWithResponses) GetAntiAffinityNamespacesWithResponse(ctx context.Context, cluster string, group string, params *GetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*GetAntiAffinityNamespacesResponse, error) {
	rsp, err := c.GetAntiAffinityNamespaces(ctx, cluster, group, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAntiAffinityNamespacesResponse(rsp)
}

// DeleteBookieAffinityGroupWithResponse request returning *DeleteBookieAffinityGroupResponse
func (c *ClientWithResponses) DeleteBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*DeleteBookieAffinityGroupResponse, error) {
	rsp, err := c.DeleteBookieAffinityGroup(ctx, property, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBookieAffinityGroupResponse(rsp)
}

// GetBookieAffinityGroupWithResponse request returning *GetBookieAffinityGroupResponse
func (c *ClientWithResponses) GetBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*GetBookieAffinityGroupResponse, error) {
	rsp, err := c.GetBookieAffinityGroup(ctx, property, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookieAffinityGroupResponse(rsp)
}

// GetTenantNamespacesWithResponse request returning *GetTenantNamespacesResponse
func (c *ClientWithResponses) GetTenantNamespacesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantNamespacesResponse, error) {
	rsp, err := c.GetTenantNamespaces(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantNamespacesResponse(rsp)
}

// DeleteNamespaceWithResponse request returning *DeleteNamespaceResponse
func (c *ClientWithResponses) DeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *DeleteNamespaceParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceResponse, error) {
	rsp, err := c.DeleteNamespace(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceResponse(rsp)
}

// GetPoliciesWithResponse request returning *GetPoliciesResponse
func (c *ClientWithResponses) GetPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPoliciesResponse, error) {
	rsp, err := c.GetPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPoliciesResponse(rsp)
}

// CreateNamespaceWithBodyWithResponse request with arbitrary body returning *CreateNamespaceResponse
func (c *ClientWithResponses) CreateNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error) {
	rsp, err := c.CreateNamespaceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceResponse(rsp)
}

func (c *ClientWithResponses) CreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body CreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNamespaceResponse, error) {
	rsp, err := c.CreateNamespace(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNamespaceResponse(rsp)
}

// RemoveNamespaceAntiAffinityGroupWithResponse request returning *RemoveNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) RemoveNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.RemoveNamespaceAntiAffinityGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceAntiAffinityGroupResponse(rsp)
}

// GetNamespaceAntiAffinityGroupWithResponse request returning *GetNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) GetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.GetNamespaceAntiAffinityGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceAntiAffinityGroupResponse(rsp)
}

// SetNamespaceAntiAffinityGroupWithBodyWithResponse request with arbitrary body returning *SetNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) SetNamespaceAntiAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.SetNamespaceAntiAffinityGroupWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceAntiAffinityGroupResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.SetNamespaceAntiAffinityGroup(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceAntiAffinityGroupResponse(rsp)
}

// RemoveAutoSubscriptionCreationWithResponse request returning *RemoveAutoSubscriptionCreationResponse
func (c *ClientWithResponses) RemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoSubscriptionCreationResponse, error) {
	rsp, err := c.RemoveAutoSubscriptionCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAutoSubscriptionCreationResponse(rsp)
}

// GetAutoSubscriptionCreationWithResponse request returning *GetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) GetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.GetAutoSubscriptionCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoSubscriptionCreationResponse(rsp)
}

// SetAutoSubscriptionCreationWithBodyWithResponse request with arbitrary body returning *SetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) SetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.SetAutoSubscriptionCreationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoSubscriptionCreationResponse(rsp)
}

func (c *ClientWithResponses) SetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.SetAutoSubscriptionCreation(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoSubscriptionCreationResponse(rsp)
}

// RemoveAutoTopicCreationWithResponse request returning *RemoveAutoTopicCreationResponse
func (c *ClientWithResponses) RemoveAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveAutoTopicCreationResponse, error) {
	rsp, err := c.RemoveAutoTopicCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAutoTopicCreationResponse(rsp)
}

// GetAutoTopicCreationWithResponse request returning *GetAutoTopicCreationResponse
func (c *ClientWithResponses) GetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetAutoTopicCreationResponse, error) {
	rsp, err := c.GetAutoTopicCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoTopicCreationResponse(rsp)
}

// SetAutoTopicCreationWithBodyWithResponse request with arbitrary body returning *SetAutoTopicCreationResponse
func (c *ClientWithResponses) SetAutoTopicCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error) {
	rsp, err := c.SetAutoTopicCreationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoTopicCreationResponse(rsp)
}

func (c *ClientWithResponses) SetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, body SetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAutoTopicCreationResponse, error) {
	rsp, err := c.SetAutoTopicCreation(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAutoTopicCreationResponse(rsp)
}

// RemoveNamesapceBacklogQuotaWithResponse request returning *RemoveNamesapceBacklogQuotaResponse
func (c *ClientWithResponses) RemoveNamesapceBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *RemoveNamesapceBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveNamesapceBacklogQuotaResponse, error) {
	rsp, err := c.RemoveNamesapceBacklogQuota(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamesapceBacklogQuotaResponse(rsp)
}

// SetNamespaceBacklogQuotaWithBodyWithResponse request with arbitrary body returning *SetNamespaceBacklogQuotaResponse
func (c *ClientWithResponses) SetNamespaceBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceBacklogQuotaResponse, error) {
	rsp, err := c.SetNamespaceBacklogQuotaWithBody(ctx, tenant, namespace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceBacklogQuotaResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *SetNamespaceBacklogQuotaParams, body SetNamespaceBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceBacklogQuotaResponse, error) {
	rsp, err := c.SetNamespaceBacklogQuota(ctx, tenant, namespace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceBacklogQuotaResponse(rsp)
}

// GetNamespaceBacklogQuotaMapWithResponse request returning *GetNamespaceBacklogQuotaMapResponse
func (c *ClientWithResponses) GetNamespaceBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceBacklogQuotaMapResponse, error) {
	rsp, err := c.GetNamespaceBacklogQuotaMap(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceBacklogQuotaMapResponse(rsp)
}

// GetBundlesDataWithResponse request returning *GetBundlesDataResponse
func (c *ClientWithResponses) GetBundlesDataWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetBundlesDataResponse, error) {
	rsp, err := c.GetBundlesData(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBundlesDataResponse(rsp)
}

// ClearNamespaceBacklogWithResponse request returning *ClearNamespaceBacklogResponse
func (c *ClientWithResponses) ClearNamespaceBacklogWithResponse(ctx context.Context, tenant string, namespace string, params *ClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogResponse, error) {
	rsp, err := c.ClearNamespaceBacklog(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBacklogResponse(rsp)
}

// ClearNamespaceBacklogForSubscriptionWithResponse request returning *ClearNamespaceBacklogForSubscriptionResponse
func (c *ClientWithResponses) ClearNamespaceBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *ClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBacklogForSubscriptionResponse, error) {
	rsp, err := c.ClearNamespaceBacklogForSubscription(ctx, tenant, namespace, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBacklogForSubscriptionResponse(rsp)
}

// DeleteCompactionThresholdWithResponse request returning *DeleteCompactionThresholdResponse
func (c *ClientWithResponses) DeleteCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteCompactionThresholdResponse, error) {
	rsp, err := c.DeleteCompactionThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCompactionThresholdResponse(rsp)
}

// GetNamespaceCompactionThresholdWithResponse request returning *GetNamespaceCompactionThresholdResponse
func (c *ClientWithResponses) GetNamespaceCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceCompactionThresholdResponse, error) {
	rsp, err := c.GetNamespaceCompactionThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceCompactionThresholdResponse(rsp)
}

// SetNamespaceCompactionThresholdWithBodyWithResponse request with arbitrary body returning *SetNamespaceCompactionThresholdResponse
func (c *ClientWithResponses) SetNamespaceCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceCompactionThresholdResponse, error) {
	rsp, err := c.SetNamespaceCompactionThresholdWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceCompactionThresholdResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceCompactionThresholdResponse, error) {
	rsp, err := c.SetNamespaceCompactionThreshold(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceCompactionThresholdResponse(rsp)
}

// RemoveNamespaceDeduplicationWithResponse request returning *RemoveNamespaceDeduplicationResponse
func (c *ClientWithResponses) RemoveNamespaceDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceDeduplicationResponse, error) {
	rsp, err := c.RemoveNamespaceDeduplication(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceDeduplicationResponse(rsp)
}

// GetNamespaceDeduplicationWithResponse request returning *GetNamespaceDeduplicationResponse
func (c *ClientWithResponses) GetNamespaceDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDeduplicationResponse, error) {
	rsp, err := c.GetNamespaceDeduplication(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceDeduplicationResponse(rsp)
}

// ModifyDeduplicationWithBodyWithResponse request with arbitrary body returning *ModifyDeduplicationResponse
func (c *ClientWithResponses) ModifyDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error) {
	rsp, err := c.ModifyDeduplicationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyDeduplicationResponse(rsp)
}

func (c *ClientWithResponses) ModifyDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, body ModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyDeduplicationResponse, error) {
	rsp, err := c.ModifyDeduplication(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyDeduplicationResponse(rsp)
}

// GetNamespaceDeduplicationSnapshotIntervalWithResponse request returning *GetNamespaceDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) GetNamespaceDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.GetNamespaceDeduplicationSnapshotInterval(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceDeduplicationSnapshotIntervalResponse(rsp)
}

// SetNamespaceDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *SetNamespaceDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) SetNamespaceDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetNamespaceDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceDeduplicationSnapshotIntervalResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetNamespaceDeduplicationSnapshotInterval(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceDeduplicationSnapshotIntervalResponse(rsp)
}

// RemoveDelayedDeliveryPoliciesWithResponse request returning *RemoveDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) RemoveDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.RemoveDelayedDeliveryPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveDelayedDeliveryPoliciesResponse(rsp)
}

// GetNamespaceDelayedDeliveryPoliciesWithResponse request returning *GetNamespaceDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) GetNamespaceDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.GetNamespaceDelayedDeliveryPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceDelayedDeliveryPoliciesResponse(rsp)
}

// SetNamespaceDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *SetNamespaceDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) SetNamespaceDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetNamespaceDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceDelayedDeliveryPoliciesResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetNamespaceDelayedDeliveryPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceDelayedDeliveryPoliciesResponse(rsp)
}

// DeleteDispatchRateWithResponse request returning *DeleteDispatchRateResponse
func (c *ClientWithResponses) DeleteDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteDispatchRateResponse, error) {
	rsp, err := c.DeleteDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDispatchRateResponse(rsp)
}

// GetNamespaceDispatchRateWithResponse request returning *GetNamespaceDispatchRateResponse
func (c *ClientWithResponses) GetNamespaceDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceDispatchRateResponse, error) {
	rsp, err := c.GetNamespaceDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceDispatchRateResponse(rsp)
}

// SetNamespaceDispatchRateWithBodyWithResponse request with arbitrary body returning *SetNamespaceDispatchRateResponse
func (c *ClientWithResponses) SetNamespaceDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceDispatchRateResponse, error) {
	rsp, err := c.SetNamespaceDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceDispatchRateResponse, error) {
	rsp, err := c.SetNamespaceDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceDispatchRateResponse(rsp)
}

// GetEncryptionRequiredWithResponse request returning *GetEncryptionRequiredResponse
func (c *ClientWithResponses) GetEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetEncryptionRequiredResponse, error) {
	rsp, err := c.GetEncryptionRequired(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEncryptionRequiredResponse(rsp)
}

// ModifyEncryptionRequiredWithBodyWithResponse request with arbitrary body returning *ModifyEncryptionRequiredResponse
func (c *ClientWithResponses) ModifyEncryptionRequiredWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error) {
	rsp, err := c.ModifyEncryptionRequiredWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyEncryptionRequiredResponse(rsp)
}

func (c *ClientWithResponses) ModifyEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, body ModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyEncryptionRequiredResponse, error) {
	rsp, err := c.ModifyEncryptionRequired(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyEncryptionRequiredResponse(rsp)
}

// RemoveNamespaceEntryFiltersWithResponse request returning *RemoveNamespaceEntryFiltersResponse
func (c *ClientWithResponses) RemoveNamespaceEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceEntryFiltersResponse, error) {
	rsp, err := c.RemoveNamespaceEntryFilters(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceEntryFiltersResponse(rsp)
}

// GetNamespaceEntryFiltersPerTopicWithResponse request returning *GetNamespaceEntryFiltersPerTopicResponse
func (c *ClientWithResponses) GetNamespaceEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceEntryFiltersPerTopicResponse, error) {
	rsp, err := c.GetNamespaceEntryFiltersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceEntryFiltersPerTopicResponse(rsp)
}

// SetEntryFiltersPerTopicWithBodyWithResponse request with arbitrary body returning *SetEntryFiltersPerTopicResponse
func (c *ClientWithResponses) SetEntryFiltersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.SetEntryFiltersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEntryFiltersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.SetEntryFiltersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEntryFiltersPerTopicResponse(rsp)
}

// RemoveInactiveTopicPoliciesWithResponse request returning *RemoveInactiveTopicPoliciesResponse
func (c *ClientWithResponses) RemoveInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveInactiveTopicPoliciesResponse, error) {
	rsp, err := c.RemoveInactiveTopicPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveInactiveTopicPoliciesResponse(rsp)
}

// GetNamespaceInactiveTopicPoliciesWithResponse request returning *GetNamespaceInactiveTopicPoliciesResponse
func (c *ClientWithResponses) GetNamespaceInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceInactiveTopicPoliciesResponse, error) {
	rsp, err := c.GetNamespaceInactiveTopicPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceInactiveTopicPoliciesResponse(rsp)
}

// SetNamespaceInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *SetNamespaceInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetNamespaceInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetNamespaceInactiveTopicPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceInactiveTopicPoliciesResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetNamespaceInactiveTopicPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceInactiveTopicPoliciesResponse(rsp)
}

// GetIsAllowAutoUpdateSchemaWithResponse request returning *GetIsAllowAutoUpdateSchemaResponse
func (c *ClientWithResponses) GetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.GetIsAllowAutoUpdateSchema(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIsAllowAutoUpdateSchemaResponse(rsp)
}

// SetIsAllowAutoUpdateSchemaWithBodyWithResponse request with arbitrary body returning *SetIsAllowAutoUpdateSchemaResponse
func (c *ClientWithResponses) SetIsAllowAutoUpdateSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.SetIsAllowAutoUpdateSchemaWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIsAllowAutoUpdateSchemaResponse(rsp)
}

func (c *ClientWithResponses) SetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, body SetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.SetIsAllowAutoUpdateSchema(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIsAllowAutoUpdateSchemaResponse(rsp)
}

// RemoveNamespaceMaxConsumersPerSubscriptionWithResponse request returning *RemoveNamespaceMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) RemoveNamespaceMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.RemoveNamespaceMaxConsumersPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMaxConsumersPerSubscriptionResponse(rsp)
}

// GetNamespaceMaxConsumersPerSubscriptionWithResponse request returning *GetNamespaceMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) GetNamespaceMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.GetNamespaceMaxConsumersPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMaxConsumersPerSubscriptionResponse(rsp)
}

// SetNamespaceMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetNamespaceMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) SetNamespaceMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetNamespaceMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxConsumersPerSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetNamespaceMaxConsumersPerSubscription(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxConsumersPerSubscriptionResponse(rsp)
}

// RemoveNamespaceMaxConsumersPerTopicWithResponse request returning *RemoveNamespaceMaxConsumersPerTopicResponse
func (c *ClientWithResponses) RemoveNamespaceMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxConsumersPerTopicResponse, error) {
	rsp, err := c.RemoveNamespaceMaxConsumersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMaxConsumersPerTopicResponse(rsp)
}

// GetNamespaceMaxConsumersPerTopicWithResponse request returning *GetNamespaceMaxConsumersPerTopicResponse
func (c *ClientWithResponses) GetNamespaceMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxConsumersPerTopicResponse, error) {
	rsp, err := c.GetNamespaceMaxConsumersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMaxConsumersPerTopicResponse(rsp)
}

// SetNamespaceMaxConsumersPerTopicWithBodyWithResponse request with arbitrary body returning *SetNamespaceMaxConsumersPerTopicResponse
func (c *ClientWithResponses) SetNamespaceMaxConsumersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerTopicResponse, error) {
	rsp, err := c.SetNamespaceMaxConsumersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxConsumersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxConsumersPerTopicResponse, error) {
	rsp, err := c.SetNamespaceMaxConsumersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxConsumersPerTopicResponse(rsp)
}

// RemoveNamespaceMaxProducersPerTopicWithResponse request returning *RemoveNamespaceMaxProducersPerTopicResponse
func (c *ClientWithResponses) RemoveNamespaceMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxProducersPerTopicResponse, error) {
	rsp, err := c.RemoveNamespaceMaxProducersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMaxProducersPerTopicResponse(rsp)
}

// GetNamespaceMaxProducersPerTopicWithResponse request returning *GetNamespaceMaxProducersPerTopicResponse
func (c *ClientWithResponses) GetNamespaceMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxProducersPerTopicResponse, error) {
	rsp, err := c.GetNamespaceMaxProducersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMaxProducersPerTopicResponse(rsp)
}

// SetNamespaceMaxProducersPerTopicWithBodyWithResponse request with arbitrary body returning *SetNamespaceMaxProducersPerTopicResponse
func (c *ClientWithResponses) SetNamespaceMaxProducersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxProducersPerTopicResponse, error) {
	rsp, err := c.SetNamespaceMaxProducersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxProducersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxProducersPerTopicResponse, error) {
	rsp, err := c.SetNamespaceMaxProducersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxProducersPerTopicResponse(rsp)
}

// RemoveNamespaceMaxSubscriptionsPerTopicWithResponse request returning *RemoveNamespaceMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) RemoveNamespaceMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.RemoveNamespaceMaxSubscriptionsPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMaxSubscriptionsPerTopicResponse(rsp)
}

// GetNamespaceMaxSubscriptionsPerTopicWithResponse request returning *GetNamespaceMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) GetNamespaceMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.GetNamespaceMaxSubscriptionsPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMaxSubscriptionsPerTopicResponse(rsp)
}

// SetNamespaceMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *SetNamespaceMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) SetNamespaceMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetNamespaceMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxSubscriptionsPerTopicResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetNamespaceMaxSubscriptionsPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxSubscriptionsPerTopicResponse(rsp)
}

// DeleteNamespaceMaxTopicsPerNamespaceWithResponse request returning *DeleteNamespaceMaxTopicsPerNamespaceResponse
func (c *ClientWithResponses) DeleteNamespaceMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteNamespaceMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.DeleteNamespaceMaxTopicsPerNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceMaxTopicsPerNamespaceResponse(rsp)
}

// GetNamespaceMaxTopicsPerNamespaceWithResponse request returning *GetNamespaceMaxTopicsPerNamespaceResponse
func (c *ClientWithResponses) GetNamespaceMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.GetNamespaceMaxTopicsPerNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMaxTopicsPerNamespaceResponse(rsp)
}

// SetNamespaceMaxTopicsPerNamespaceWithBodyWithResponse request with arbitrary body returning *SetNamespaceMaxTopicsPerNamespaceResponse
func (c *ClientWithResponses) SetNamespaceMaxTopicsPerNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.SetNamespaceMaxTopicsPerNamespaceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxTopicsPerNamespaceResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.SetNamespaceMaxTopicsPerNamespace(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxTopicsPerNamespaceResponse(rsp)
}

// RemoveNamespaceMaxUnackedmessagesPerConsumerWithResponse request returning *RemoveNamespaceMaxUnackedmessagesPerConsumerResponse
func (c *ClientWithResponses) RemoveNamespaceMaxUnackedmessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxUnackedmessagesPerConsumerResponse, error) {
	rsp, err := c.RemoveNamespaceMaxUnackedmessagesPerConsumer(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMaxUnackedmessagesPerConsumerResponse(rsp)
}

// GetNamespaceMaxUnackedMessagesPerConsumerWithResponse request returning *GetNamespaceMaxUnackedMessagesPerConsumerResponse
func (c *ClientWithResponses) GetNamespaceMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.GetNamespaceMaxUnackedMessagesPerConsumer(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMaxUnackedMessagesPerConsumerResponse(rsp)
}

// SetNamespaceMaxUnackedMessagesPerConsumerWithBodyWithResponse request with arbitrary body returning *SetNamespaceMaxUnackedMessagesPerConsumerResponse
func (c *ClientWithResponses) SetNamespaceMaxUnackedMessagesPerConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.SetNamespaceMaxUnackedMessagesPerConsumerWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxUnackedMessagesPerConsumerResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.SetNamespaceMaxUnackedMessagesPerConsumer(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxUnackedMessagesPerConsumerResponse(rsp)
}

// RemoveNamespaceMaxUnackedmessagesPerSubscriptionWithResponse request returning *RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse
func (c *ClientWithResponses) RemoveNamespaceMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse, error) {
	rsp, err := c.RemoveNamespaceMaxUnackedmessagesPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse(rsp)
}

// GetNamespaceMaxUnackedmessagesPerSubscriptionWithResponse request returning *GetNamespaceMaxUnackedmessagesPerSubscriptionResponse
func (c *ClientWithResponses) GetNamespaceMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMaxUnackedmessagesPerSubscriptionResponse, error) {
	rsp, err := c.GetNamespaceMaxUnackedmessagesPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMaxUnackedmessagesPerSubscriptionResponse(rsp)
}

// SetNamespaceMaxUnackedMessagesPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetNamespaceMaxUnackedMessagesPerSubscriptionResponse
func (c *ClientWithResponses) SetNamespaceMaxUnackedMessagesPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerSubscriptionResponse, error) {
	rsp, err := c.SetNamespaceMaxUnackedMessagesPerSubscriptionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxUnackedMessagesPerSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMaxUnackedMessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMaxUnackedMessagesPerSubscriptionResponse, error) {
	rsp, err := c.SetNamespaceMaxUnackedMessagesPerSubscription(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMaxUnackedMessagesPerSubscriptionResponse(rsp)
}

// RemoveNamespaceMessageTTLWithResponse request returning *RemoveNamespaceMessageTTLResponse
func (c *ClientWithResponses) RemoveNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceMessageTTLResponse, error) {
	rsp, err := c.RemoveNamespaceMessageTTL(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceMessageTTLResponse(rsp)
}

// GetNamespaceMessageTTLWithResponse request returning *GetNamespaceMessageTTLResponse
func (c *ClientWithResponses) GetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceMessageTTLResponse, error) {
	rsp, err := c.GetNamespaceMessageTTL(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceMessageTTLResponse(rsp)
}

// SetNamespaceMessageTTLWithBodyWithResponse request with arbitrary body returning *SetNamespaceMessageTTLResponse
func (c *ClientWithResponses) SetNamespaceMessageTTLWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error) {
	rsp, err := c.SetNamespaceMessageTTLWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMessageTTLResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceMessageTTLResponse, error) {
	rsp, err := c.SetNamespaceMessageTTL(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceMessageTTLResponse(rsp)
}

// ClearOffloadDeletionLagWithResponse request returning *ClearOffloadDeletionLagResponse
func (c *ClientWithResponses) ClearOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearOffloadDeletionLagResponse, error) {
	rsp, err := c.ClearOffloadDeletionLag(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearOffloadDeletionLagResponse(rsp)
}

// GetNamespaceOffloadDeletionLagWithResponse request returning *GetNamespaceOffloadDeletionLagResponse
func (c *ClientWithResponses) GetNamespaceOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceOffloadDeletionLagResponse, error) {
	rsp, err := c.GetNamespaceOffloadDeletionLag(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceOffloadDeletionLagResponse(rsp)
}

// SetNamespaceOffloadDeletionLagWithBodyWithResponse request with arbitrary body returning *SetNamespaceOffloadDeletionLagResponse
func (c *ClientWithResponses) SetNamespaceOffloadDeletionLagWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadDeletionLagResponse, error) {
	rsp, err := c.SetNamespaceOffloadDeletionLagWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceOffloadDeletionLagResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadDeletionLagResponse, error) {
	rsp, err := c.SetNamespaceOffloadDeletionLag(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceOffloadDeletionLagResponse(rsp)
}

// GetNamespaceOffloadPoliciesWithResponse request returning *GetNamespaceOffloadPoliciesResponse
func (c *ClientWithResponses) GetNamespaceOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceOffloadPoliciesResponse, error) {
	rsp, err := c.GetNamespaceOffloadPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceOffloadPoliciesResponse(rsp)
}

// SetNamespaceOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *SetNamespaceOffloadPoliciesResponse
func (c *ClientWithResponses) SetNamespaceOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadPoliciesResponse, error) {
	rsp, err := c.SetNamespaceOffloadPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceOffloadPoliciesResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadPoliciesResponse, error) {
	rsp, err := c.SetNamespaceOffloadPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceOffloadPoliciesResponse(rsp)
}

// GetNamespaceOffloadThresholdWithResponse request returning *GetNamespaceOffloadThresholdResponse
func (c *ClientWithResponses) GetNamespaceOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceOffloadThresholdResponse, error) {
	rsp, err := c.GetNamespaceOffloadThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceOffloadThresholdResponse(rsp)
}

// SetNamespaceOffloadThresholdWithBodyWithResponse request with arbitrary body returning *SetNamespaceOffloadThresholdResponse
func (c *ClientWithResponses) SetNamespaceOffloadThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadThresholdResponse, error) {
	rsp, err := c.SetNamespaceOffloadThresholdWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceOffloadThresholdResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceOffloadThresholdResponse, error) {
	rsp, err := c.SetNamespaceOffloadThreshold(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceOffloadThresholdResponse(rsp)
}

// GetPermissionsWithResponse request returning *GetPermissionsResponse
func (c *ClientWithResponses) GetPermissionsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionsResponse, error) {
	rsp, err := c.GetPermissions(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsResponse(rsp)
}

// GetPermissionOnSubscriptionWithResponse request returning *GetPermissionOnSubscriptionResponse
func (c *ClientWithResponses) GetPermissionOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetPermissionOnSubscriptionResponse, error) {
	rsp, err := c.GetPermissionOnSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionOnSubscriptionResponse(rsp)
}

// RevokePermissionsOnNamespaceWithResponse request returning *RevokePermissionsOnNamespaceResponse
func (c *ClientWithResponses) RevokePermissionsOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*RevokePermissionsOnNamespaceResponse, error) {
	rsp, err := c.RevokePermissionsOnNamespace(ctx, tenant, namespace, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePermissionsOnNamespaceResponse(rsp)
}

// GrantPermissionOnNamespaceWithBodyWithResponse request with arbitrary body returning *GrantPermissionOnNamespaceResponse
func (c *ClientWithResponses) GrantPermissionOnNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error) {
	rsp, err := c.GrantPermissionOnNamespaceWithBody(ctx, tenant, namespace, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantPermissionOnNamespaceResponse(rsp)
}

func (c *ClientWithResponses) GrantPermissionOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, body GrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*GrantPermissionOnNamespaceResponse, error) {
	rsp, err := c.GrantPermissionOnNamespace(ctx, tenant, namespace, role, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantPermissionOnNamespaceResponse(rsp)
}

// DeletePersistenceWithResponse request returning *DeletePersistenceResponse
func (c *ClientWithResponses) DeletePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeletePersistenceResponse, error) {
	rsp, err := c.DeletePersistence(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistenceResponse(rsp)
}

// GetNamespacePersistenceWithResponse request returning *GetNamespacePersistenceResponse
func (c *ClientWithResponses) GetNamespacePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespacePersistenceResponse, error) {
	rsp, err := c.GetNamespacePersistence(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespacePersistenceResponse(rsp)
}

// SetNamespacePersistenceWithBodyWithResponse request with arbitrary body returning *SetNamespacePersistenceResponse
func (c *ClientWithResponses) SetNamespacePersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespacePersistenceResponse, error) {
	rsp, err := c.SetNamespacePersistenceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespacePersistenceResponse(rsp)
}

func (c *ClientWithResponses) SetNamespacePersistenceWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespacePersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespacePersistenceResponse, error) {
	rsp, err := c.SetNamespacePersistence(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespacePersistenceResponse(rsp)
}

// SetBookieAffinityGroupWithBodyWithResponse request with arbitrary body returning *SetBookieAffinityGroupResponse
func (c *ClientWithResponses) SetBookieAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error) {
	rsp, err := c.SetBookieAffinityGroupWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBookieAffinityGroupResponse(rsp)
}

func (c *ClientWithResponses) SetBookieAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body SetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBookieAffinityGroupResponse, error) {
	rsp, err := c.SetBookieAffinityGroup(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBookieAffinityGroupResponse(rsp)
}

// ClearPropertiesWithResponse request returning *ClearPropertiesResponse
func (c *ClientWithResponses) ClearPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ClearPropertiesResponse, error) {
	rsp, err := c.ClearProperties(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearPropertiesResponse(rsp)
}

// GetNamespacePropertiesWithResponse request returning *GetNamespacePropertiesResponse
func (c *ClientWithResponses) GetNamespacePropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespacePropertiesResponse, error) {
	rsp, err := c.GetNamespaceProperties(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespacePropertiesResponse(rsp)
}

// SetPropertiesWithBodyWithResponse request with arbitrary body returning *SetPropertiesResponse
func (c *ClientWithResponses) SetPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error) {
	rsp, err := c.SetPropertiesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPropertiesResponse(rsp)
}

func (c *ClientWithResponses) SetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, body SetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPropertiesResponse, error) {
	rsp, err := c.SetProperties(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPropertiesResponse(rsp)
}

// RemovePropertyWithResponse request returning *RemovePropertyResponse
func (c *ClientWithResponses) RemovePropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*RemovePropertyResponse, error) {
	rsp, err := c.RemoveProperty(ctx, tenant, namespace, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePropertyResponse(rsp)
}

// GetPropertyWithResponse request returning *GetPropertyResponse
func (c *ClientWithResponses) GetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*GetPropertyResponse, error) {
	rsp, err := c.GetProperty(ctx, tenant, namespace, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPropertyResponse(rsp)
}

// SetPropertyWithResponse request returning *SetPropertyResponse
func (c *ClientWithResponses) SetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*SetPropertyResponse, error) {
	rsp, err := c.SetProperty(ctx, tenant, namespace, key, value, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPropertyResponse(rsp)
}

// RemoveNamespaceOffloadPoliciesWithResponse request returning *RemoveNamespaceOffloadPoliciesResponse
func (c *ClientWithResponses) RemoveNamespaceOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceOffloadPoliciesResponse, error) {
	rsp, err := c.RemoveNamespaceOffloadPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceOffloadPoliciesResponse(rsp)
}

// GetNamespaceReplicationClustersWithResponse request returning *GetNamespaceReplicationClustersResponse
func (c *ClientWithResponses) GetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.GetNamespaceReplicationClusters(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceReplicationClustersResponse(rsp)
}

// SetNamespaceReplicationClustersWithBodyWithResponse request with arbitrary body returning *SetNamespaceReplicationClustersResponse
func (c *ClientWithResponses) SetNamespaceReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.SetNamespaceReplicationClustersWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceReplicationClustersResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.SetNamespaceReplicationClusters(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceReplicationClustersResponse(rsp)
}

// RemoveNamespaceReplicatorDispatchRateWithResponse request returning *RemoveNamespaceReplicatorDispatchRateResponse
func (c *ClientWithResponses) RemoveNamespaceReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceReplicatorDispatchRateResponse, error) {
	rsp, err := c.RemoveNamespaceReplicatorDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceReplicatorDispatchRateResponse(rsp)
}

// GetNamespaceReplicatorDispatchRateWithResponse request returning *GetNamespaceReplicatorDispatchRateResponse
func (c *ClientWithResponses) GetNamespaceReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceReplicatorDispatchRateResponse, error) {
	rsp, err := c.GetNamespaceReplicatorDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceReplicatorDispatchRateResponse(rsp)
}

// SetNamespaceReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *SetNamespaceReplicatorDispatchRateResponse
func (c *ClientWithResponses) SetNamespaceReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetNamespaceReplicatorDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceReplicatorDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetNamespaceReplicatorDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceReplicatorDispatchRateResponse(rsp)
}

// RemoveNamespaceResourceGroupWithResponse request returning *RemoveNamespaceResourceGroupResponse
func (c *ClientWithResponses) RemoveNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceResourceGroupResponse, error) {
	rsp, err := c.RemoveNamespaceResourceGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceResourceGroupResponse(rsp)
}

// GetNamespaceResourceGroupWithResponse request returning *GetNamespaceResourceGroupResponse
func (c *ClientWithResponses) GetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceResourceGroupResponse, error) {
	rsp, err := c.GetNamespaceResourceGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceResourceGroupResponse(rsp)
}

// SetNamespaceResourceGroupWithResponse request returning *SetNamespaceResourceGroupResponse
func (c *ClientWithResponses) SetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*SetNamespaceResourceGroupResponse, error) {
	rsp, err := c.SetNamespaceResourceGroup(ctx, tenant, namespace, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceResourceGroupResponse(rsp)
}

// RemoveNamespaceRetentionWithBodyWithResponse request with arbitrary body returning *RemoveNamespaceRetentionResponse
func (c *ClientWithResponses) RemoveNamespaceRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNamespaceRetentionResponse, error) {
	rsp, err := c.RemoveNamespaceRetentionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceRetentionResponse(rsp)
}

func (c *ClientWithResponses) RemoveNamespaceRetentionWithResponse(ctx context.Context, tenant string, namespace string, body RemoveNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveNamespaceRetentionResponse, error) {
	rsp, err := c.RemoveNamespaceRetention(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceRetentionResponse(rsp)
}

// GetNamespaceRetentionWithResponse request returning *GetNamespaceRetentionResponse
func (c *ClientWithResponses) GetNamespaceRetentionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceRetentionResponse, error) {
	rsp, err := c.GetNamespaceRetention(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceRetentionResponse(rsp)
}

// SetNamespaceRetentionWithBodyWithResponse request with arbitrary body returning *SetNamespaceRetentionResponse
func (c *ClientWithResponses) SetNamespaceRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceRetentionResponse, error) {
	rsp, err := c.SetNamespaceRetentionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceRetentionResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceRetentionWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceRetentionResponse, error) {
	rsp, err := c.SetNamespaceRetention(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceRetentionResponse(rsp)
}

// ScanOffloadedLedgersWithResponse request returning *ScanOffloadedLedgersResponse
func (c *ClientWithResponses) ScanOffloadedLedgersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*ScanOffloadedLedgersResponse, error) {
	rsp, err := c.ScanOffloadedLedgers(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScanOffloadedLedgersResponse(rsp)
}

// GetSchemaAutoUpdateCompatibilityStrategyWithResponse request returning *GetSchemaAutoUpdateCompatibilityStrategyResponse
func (c *ClientWithResponses) GetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.GetSchemaAutoUpdateCompatibilityStrategy(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

// SetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetSchemaAutoUpdateCompatibilityStrategyResponse
func (c *ClientWithResponses) SetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

func (c *ClientWithResponses) SetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.SetSchemaAutoUpdateCompatibilityStrategy(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

// GetNamespaceSchemaCompatibilityStrategyWithResponse request returning *GetNamespaceSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) GetNamespaceSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.GetNamespaceSchemaCompatibilityStrategy(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceSchemaCompatibilityStrategyResponse(rsp)
}

// SetNamespaceSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetNamespaceSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) SetNamespaceSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetNamespaceSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSchemaCompatibilityStrategyResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetNamespaceSchemaCompatibilityStrategy(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSchemaCompatibilityStrategyResponse(rsp)
}

// GetSchemaValidtionEnforcedWithResponse request returning *GetSchemaValidtionEnforcedResponse
func (c *ClientWithResponses) GetSchemaValidtionEnforcedWithResponse(ctx context.Context, tenant string, namespace string, params *GetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*GetSchemaValidtionEnforcedResponse, error) {
	rsp, err := c.GetSchemaValidtionEnforced(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaValidtionEnforcedResponse(rsp)
}

// SetNamespaceSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *SetNamespaceSchemaValidationEnforcedResponse
func (c *ClientWithResponses) SetNamespaceSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetNamespaceSchemaValidationEnforcedWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSchemaValidationEnforcedResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetNamespaceSchemaValidationEnforced(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSchemaValidationEnforcedResponse(rsp)
}

// DeleteSubscribeRateWithResponse request returning *DeleteSubscribeRateResponse
func (c *ClientWithResponses) DeleteSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscribeRateResponse, error) {
	rsp, err := c.DeleteSubscribeRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscribeRateResponse(rsp)
}

// GetNamespaceSubscribeRateWithResponse request returning *GetNamespaceSubscribeRateResponse
func (c *ClientWithResponses) GetNamespaceSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSubscribeRateResponse, error) {
	rsp, err := c.GetNamespaceSubscribeRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceSubscribeRateResponse(rsp)
}

// SetNamespaceSubscribeRateWithBodyWithResponse request with arbitrary body returning *SetNamespaceSubscribeRateResponse
func (c *ClientWithResponses) SetNamespaceSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscribeRateResponse, error) {
	rsp, err := c.SetNamespaceSubscribeRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscribeRateResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscribeRateResponse, error) {
	rsp, err := c.SetNamespaceSubscribeRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscribeRateResponse(rsp)
}

// GetSubscriptionAuthModeWithResponse request returning *GetSubscriptionAuthModeResponse
func (c *ClientWithResponses) GetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionAuthModeResponse, error) {
	rsp, err := c.GetSubscriptionAuthMode(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionAuthModeResponse(rsp)
}

// SetNamespaceSubscriptionAuthModeWithBodyWithResponse request with arbitrary body returning *SetNamespaceSubscriptionAuthModeResponse
func (c *ClientWithResponses) SetNamespaceSubscriptionAuthModeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionAuthModeResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionAuthModeWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionAuthModeResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionAuthModeResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionAuthMode(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionAuthModeResponse(rsp)
}

// DeleteSubscriptionDispatchRateWithResponse request returning *DeleteSubscriptionDispatchRateResponse
func (c *ClientWithResponses) DeleteSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*DeleteSubscriptionDispatchRateResponse, error) {
	rsp, err := c.DeleteSubscriptionDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionDispatchRateResponse(rsp)
}

// GetNamespaceSubscriptionDispatchRateWithResponse request returning *GetNamespaceSubscriptionDispatchRateResponse
func (c *ClientWithResponses) GetNamespaceSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSubscriptionDispatchRateResponse, error) {
	rsp, err := c.GetNamespaceSubscriptionDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceSubscriptionDispatchRateResponse(rsp)
}

// SetNamespaceSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *SetNamespaceSubscriptionDispatchRateResponse
func (c *ClientWithResponses) SetNamespaceSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionDispatchRateResponse(rsp)
}

// RemoveSubscriptionExpirationTimeWithResponse request returning *RemoveSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) RemoveSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.RemoveSubscriptionExpirationTime(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionExpirationTimeResponse(rsp)
}

// GetSubscriptionExpirationTimeWithResponse request returning *GetSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) GetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.GetSubscriptionExpirationTime(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionExpirationTimeResponse(rsp)
}

// SetNamespaceSubscriptionExpirationTimeWithBodyWithResponse request with arbitrary body returning *SetNamespaceSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) SetNamespaceSubscriptionExpirationTimeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionExpirationTimeWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionExpirationTimeResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionExpirationTime(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionExpirationTimeResponse(rsp)
}

// RemoveNamespaceSubscriptionTypesEnabledWithResponse request returning *RemoveNamespaceSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) RemoveNamespaceSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*RemoveNamespaceSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.RemoveNamespaceSubscriptionTypesEnabled(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceSubscriptionTypesEnabledResponse(rsp)
}

// GetNamespaceSubscriptionTypesEnabledWithResponse request returning *GetNamespaceSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) GetNamespaceSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*GetNamespaceSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.GetNamespaceSubscriptionTypesEnabled(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceSubscriptionTypesEnabledResponse(rsp)
}

// SetNamespaceSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *SetNamespaceSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) SetNamespaceSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionTypesEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, body SetNamespaceSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetNamespaceSubscriptionTypesEnabled(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceSubscriptionTypesEnabledResponse(rsp)
}

// GetTopicsWithResponse request returning *GetTopicsResponse
func (c *ClientWithResponses) GetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *GetTopicsParams, reqEditors ...RequestEditorFn) (*GetTopicsResponse, error) {
	rsp, err := c.GetTopics(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopicsResponse(rsp)
}

// UnloadNamespaceWithResponse request returning *UnloadNamespaceResponse
func (c *ClientWithResponses) UnloadNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*UnloadNamespaceResponse, error) {
	rsp, err := c.UnloadNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadNamespaceResponse(rsp)
}

// UnsubscribeNamespaceWithResponse request returning *UnsubscribeNamespaceResponse
func (c *ClientWithResponses) UnsubscribeNamespaceWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *UnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceResponse, error) {
	rsp, err := c.UnsubscribeNamespace(ctx, tenant, namespace, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeNamespaceResponse(rsp)
}

// DeleteNamespaceBundleWithResponse request returning *DeleteNamespaceBundleResponse
func (c *ClientWithResponses) DeleteNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *DeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceBundleResponse, error) {
	rsp, err := c.DeleteNamespaceBundle(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceBundleResponse(rsp)
}

// ClearNamespaceBundleBacklogWithResponse request returning *ClearNamespaceBundleBacklogResponse
func (c *ClientWithResponses) ClearNamespaceBundleBacklogWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *ClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogResponse, error) {
	rsp, err := c.ClearNamespaceBundleBacklog(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBundleBacklogResponse(rsp)
}

// ClearNamespaceBundleBacklogForSubscriptionWithResponse request returning *ClearNamespaceBundleBacklogForSubscriptionResponse
func (c *ClientWithResponses) ClearNamespaceBundleBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *ClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*ClearNamespaceBundleBacklogForSubscriptionResponse, error) {
	rsp, err := c.ClearNamespaceBundleBacklogForSubscription(ctx, tenant, namespace, bundle, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearNamespaceBundleBacklogForSubscriptionResponse(rsp)
}

// SplitNamespaceBundleWithBodyWithResponse request with arbitrary body returning *SplitNamespaceBundleResponse
func (c *ClientWithResponses) SplitNamespaceBundleWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error) {
	rsp, err := c.SplitNamespaceBundleWithBody(ctx, tenant, namespace, bundle, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSplitNamespaceBundleResponse(rsp)
}

func (c *ClientWithResponses) SplitNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *SplitNamespaceBundleParams, body SplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*SplitNamespaceBundleResponse, error) {
	rsp, err := c.SplitNamespaceBundle(ctx, tenant, namespace, bundle, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSplitNamespaceBundleResponse(rsp)
}

// GetTopicHashPositionsWithResponse request returning *GetTopicHashPositionsResponse
func (c *ClientWithResponses) GetTopicHashPositionsWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *GetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*GetTopicHashPositionsResponse, error) {
	rsp, err := c.GetTopicHashPositions(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopicHashPositionsResponse(rsp)
}

// UnloadNamespaceBundleWithResponse request returning *UnloadNamespaceBundleResponse
func (c *ClientWithResponses) UnloadNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *UnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnloadNamespaceBundleResponse, error) {
	rsp, err := c.UnloadNamespaceBundle(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadNamespaceBundleResponse(rsp)
}

// UnsubscribeNamespaceBundleWithResponse request returning *UnsubscribeNamespaceBundleResponse
func (c *ClientWithResponses) UnsubscribeNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *UnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*UnsubscribeNamespaceBundleResponse, error) {
	rsp, err := c.UnsubscribeNamespaceBundle(ctx, tenant, namespace, bundle, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsubscribeNamespaceBundleResponse(rsp)
}

// GetNonPersistentTopicListWithResponse request returning *GetNonPersistentTopicListResponse
func (c *ClientWithResponses) GetNonPersistentTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetNonPersistentTopicListParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicListResponse, error) {
	rsp, err := c.GetNonPersistentTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicListResponse(rsp)
}

// GetNonPersistentPartitionedTopicListWithResponse request returning *GetNonPersistentPartitionedTopicListResponse
func (c *ClientWithResponses) GetNonPersistentPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetNonPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetNonPersistentPartitionedTopicListResponse, error) {
	rsp, err := c.GetNonPersistentPartitionedTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentPartitionedTopicListResponse(rsp)
}

// GetListFromBundleWithResponse request returning *GetListFromBundleResponse
func (c *ClientWithResponses) GetListFromBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetListFromBundleResponse, error) {
	rsp, err := c.GetListFromBundle(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListFromBundleResponse(rsp)
}

// DeleteNonPersistentTopicWithResponse request returning *DeleteNonPersistentTopicResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicResponse, error) {
	rsp, err := c.DeleteNonPersistentTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicResponse(rsp)
}

// CreateNonPersistentTopicNonPartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreateNonPersistentTopicNonPartitionedTopicResponse
func (c *ClientWithResponses) CreateNonPersistentTopicNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicNonPartitionedTopicResponse, error) {
	rsp, err := c.CreateNonPersistentTopicNonPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNonPersistentTopicNonPartitionedTopicResponse(rsp)
}

// ExpireNonPersistentTopicMessagesForAllSubscriptionsWithResponse request returning *ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse
func (c *ClientWithResponses) ExpireNonPersistentTopicMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse, error) {
	rsp, err := c.ExpireNonPersistentTopicMessagesForAllSubscriptions(ctx, tenant, namespace, topic, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireNonPersistentTopicMessagesForAllSubscriptionsResponse(rsp)
}

// GetNonPersistentTopicBacklogWithResponse request returning *GetNonPersistentTopicBacklogResponse
func (c *ClientWithResponses) GetNonPersistentTopicBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicBacklogResponse, error) {
	rsp, err := c.GetNonPersistentTopicBacklog(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicBacklogResponse(rsp)
}

// RemoveNonPersistentTopicBacklogQuotaWithResponse request returning *RemoveNonPersistentTopicBacklogQuotaResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicBacklogQuotaResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicBacklogQuotaResponse(rsp)
}

// SetNonPersistentTopicBacklogQuotaWithResponse request returning *SetNonPersistentTopicBacklogQuotaResponse
func (c *ClientWithResponses) SetNonPersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicBacklogQuotaResponse, error) {
	rsp, err := c.SetNonPersistentTopicBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicBacklogQuotaResponse(rsp)
}

// GetNonPersistentTopicBacklogQuotaMapWithResponse request returning *GetNonPersistentTopicBacklogQuotaMapResponse
func (c *ClientWithResponses) GetNonPersistentTopicBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicBacklogQuotaMapResponse, error) {
	rsp, err := c.GetNonPersistentTopicBacklogQuotaMap(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicBacklogQuotaMapResponse(rsp)
}

// GetNonPersistentTopicBacklogSizeByMessageIdWithResponse request returning *GetNonPersistentTopicBacklogSizeByMessageIdResponse
func (c *ClientWithResponses) GetNonPersistentTopicBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicBacklogSizeByMessageIdResponse, error) {
	rsp, err := c.GetNonPersistentTopicBacklogSizeByMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicBacklogSizeByMessageIdResponse(rsp)
}

// GetNonPersistentTopicCompactionStatusWithResponse request returning *GetNonPersistentTopicCompactionStatusResponse
func (c *ClientWithResponses) GetNonPersistentTopicCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicCompactionStatusResponse, error) {
	rsp, err := c.GetNonPersistentTopicCompactionStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicCompactionStatusResponse(rsp)
}

// CompactNonPersistentTopicWithResponse request returning *CompactNonPersistentTopicResponse
func (c *ClientWithResponses) CompactNonPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*CompactNonPersistentTopicResponse, error) {
	rsp, err := c.CompactNonPersistentTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompactNonPersistentTopicResponse(rsp)
}

// RemoveNonPersistentTopicCompactionThresholdWithResponse request returning *RemoveNonPersistentTopicCompactionThresholdResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicCompactionThresholdResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicCompactionThresholdResponse(rsp)
}

// GetNonPersistentTopicCompactionThresholdWithResponse request returning *GetNonPersistentTopicCompactionThresholdResponse
func (c *ClientWithResponses) GetNonPersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicCompactionThresholdResponse, error) {
	rsp, err := c.GetNonPersistentTopicCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicCompactionThresholdResponse(rsp)
}

// SetNonPersistentTopicCompactionThresholdWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicCompactionThresholdResponse
func (c *ClientWithResponses) SetNonPersistentTopicCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicCompactionThresholdResponse, error) {
	rsp, err := c.SetNonPersistentTopicCompactionThresholdWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicCompactionThresholdResponse(rsp)
}

// CreateNonPersistentTopicMissedPartitionsWithResponse request returning *CreateNonPersistentTopicMissedPartitionsResponse
func (c *ClientWithResponses) CreateNonPersistentTopicMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicMissedPartitionsResponse, error) {
	rsp, err := c.CreateNonPersistentTopicMissedPartitions(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNonPersistentTopicMissedPartitionsResponse(rsp)
}

// RemoveNonPersistentTopicDeduplicationWithResponse request returning *RemoveNonPersistentTopicDeduplicationResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicDeduplicationResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicDeduplicationResponse(rsp)
}

// GetNonPersistentTopicDeduplicationWithResponse request returning *GetNonPersistentTopicDeduplicationResponse
func (c *ClientWithResponses) GetNonPersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDeduplicationResponse, error) {
	rsp, err := c.GetNonPersistentTopicDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicDeduplicationResponse(rsp)
}

// SetNonPersistentTopicDeduplicationWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicDeduplicationResponse
func (c *ClientWithResponses) SetNonPersistentTopicDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDeduplicationResponse, error) {
	rsp, err := c.SetNonPersistentTopicDeduplicationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicDeduplicationResponse(rsp)
}

// DeleteNonPersistentTopicDeduplicationSnapshotIntervalWithResponse request returning *DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse(rsp)
}

// GetNonPersistentTopicDeduplicationSnapshotIntervalWithResponse request returning *GetNonPersistentTopicDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) GetNonPersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.GetNonPersistentTopicDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicDeduplicationSnapshotIntervalResponse(rsp)
}

// SetNonPersistentTopicDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) SetNonPersistentTopicDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetNonPersistentTopicDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicDeduplicationSnapshotIntervalResponse(rsp)
}

// DeleteNonPersistentTopicDelayedDeliveryPoliciesWithResponse request returning *DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicDelayedDeliveryPoliciesResponse(rsp)
}

// GetNonPersistentTopicDelayedDeliveryPoliciesWithResponse request returning *GetNonPersistentTopicDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) GetNonPersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.GetNonPersistentTopicDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicDelayedDeliveryPoliciesResponse(rsp)
}

// SetNonPersistentTopicDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) SetNonPersistentTopicDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetNonPersistentTopicDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicDelayedDeliveryPoliciesResponse(rsp)
}

// RemoveNonPersistentTopicDispatchRateWithResponse request returning *RemoveNonPersistentTopicDispatchRateResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicDispatchRateResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicDispatchRateResponse(rsp)
}

// GetNonPersistentTopicDispatchRateWithResponse request returning *GetNonPersistentTopicDispatchRateResponse
func (c *ClientWithResponses) GetNonPersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicDispatchRateResponse, error) {
	rsp, err := c.GetNonPersistentTopicDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicDispatchRateResponse(rsp)
}

// SetNonPersistentTopicDispatchRateWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicDispatchRateResponse
func (c *ClientWithResponses) SetNonPersistentTopicDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicDispatchRateResponse, error) {
	rsp, err := c.SetNonPersistentTopicDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicDispatchRateResponse(rsp)
}

// RemoveNonPersistentTopicEntryFiltersWithResponse request returning *RemoveNonPersistentTopicEntryFiltersResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicEntryFiltersResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicEntryFiltersResponse(rsp)
}

// GetNonPersistentTopicEntryFiltersWithResponse request returning *GetNonPersistentTopicEntryFiltersResponse
func (c *ClientWithResponses) GetNonPersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicEntryFiltersResponse, error) {
	rsp, err := c.GetNonPersistentTopicEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicEntryFiltersResponse(rsp)
}

// SetNonPersistentTopicEntryFiltersWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicEntryFiltersResponse
func (c *ClientWithResponses) SetNonPersistentTopicEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicEntryFiltersResponse, error) {
	rsp, err := c.SetNonPersistentTopicEntryFiltersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicEntryFiltersResponse(rsp)
}

// ExamineNonPersistentTopicMessageWithResponse request returning *ExamineNonPersistentTopicMessageResponse
func (c *ClientWithResponses) ExamineNonPersistentTopicMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExamineNonPersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*ExamineNonPersistentTopicMessageResponse, error) {
	rsp, err := c.ExamineNonPersistentTopicMessage(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExamineNonPersistentTopicMessageResponse(rsp)
}

// DeleteNonPersistentTopicInactiveTopicPoliciesWithResponse request returning *DeleteNonPersistentTopicInactiveTopicPoliciesResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicInactiveTopicPoliciesResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicInactiveTopicPoliciesResponse(rsp)
}

// GetNonPersistentTopicInactiveTopicPoliciesWithResponse request returning *GetNonPersistentTopicInactiveTopicPoliciesResponse
func (c *ClientWithResponses) GetNonPersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicInactiveTopicPoliciesResponse, error) {
	rsp, err := c.GetNonPersistentTopicInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicInactiveTopicPoliciesResponse(rsp)
}

// SetNonPersistentTopicInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetNonPersistentTopicInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetNonPersistentTopicInactiveTopicPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicInactiveTopicPoliciesResponse(rsp)
}

// GetNonPersistentTopicManagedLedgerInfoWithResponse request returning *GetNonPersistentTopicManagedLedgerInfoResponse
func (c *ClientWithResponses) GetNonPersistentTopicManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicManagedLedgerInfoResponse, error) {
	rsp, err := c.GetNonPersistentTopicManagedLedgerInfo(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicManagedLedgerInfoResponse(rsp)
}

// GetNonPersistentTopicInternalStatsWithResponse request returning *GetNonPersistentTopicInternalStatsResponse
func (c *ClientWithResponses) GetNonPersistentTopicInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicInternalStatsResponse, error) {
	rsp, err := c.GetNonPersistentTopicInternalStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicInternalStatsResponse(rsp)
}

// GetNonPersistentTopicLastMessageIdWithResponse request returning *GetNonPersistentTopicLastMessageIdResponse
func (c *ClientWithResponses) GetNonPersistentTopicLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicLastMessageIdResponse, error) {
	rsp, err := c.GetNonPersistentTopicLastMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicLastMessageIdResponse(rsp)
}

// GetNonPersistentTopicMessageByIdWithResponse request returning *GetNonPersistentTopicMessageByIdResponse
func (c *ClientWithResponses) GetNonPersistentTopicMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetNonPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMessageByIdResponse, error) {
	rsp, err := c.GetNonPersistentTopicMessageById(ctx, tenant, namespace, topic, ledgerId, entryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMessageByIdResponse(rsp)
}

// RemoveNonPersistentTopicMaxConsumersWithResponse request returning *RemoveNonPersistentTopicMaxConsumersResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxConsumersResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicMaxConsumersResponse(rsp)
}

// GetNonPersistentTopicMaxConsumersWithResponse request returning *GetNonPersistentTopicMaxConsumersResponse
func (c *ClientWithResponses) GetNonPersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxConsumersResponse, error) {
	rsp, err := c.GetNonPersistentTopicMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMaxConsumersResponse(rsp)
}

// SetNonPersistentTopicMaxConsumersWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicMaxConsumersResponse
func (c *ClientWithResponses) SetNonPersistentTopicMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxConsumersResponse, error) {
	rsp, err := c.SetNonPersistentTopicMaxConsumersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMaxConsumersResponse(rsp)
}

// RemoveNonPersistentTopicMaxConsumersPerSubscriptionWithResponse request returning *RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse(rsp)
}

// GetNonPersistentTopicMaxConsumersPerSubscriptionWithResponse request returning *GetNonPersistentTopicMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) GetNonPersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.GetNonPersistentTopicMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMaxConsumersPerSubscriptionResponse(rsp)
}

// SetNonPersistentTopicMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) SetNonPersistentTopicMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetNonPersistentTopicMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMaxConsumersPerSubscriptionResponse(rsp)
}

// RemoveNonPersistentTopicMaxMessageSizeWithResponse request returning *RemoveNonPersistentTopicMaxMessageSizeResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxMessageSizeResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicMaxMessageSizeResponse(rsp)
}

// GetNonPersistentTopicMaxMessageSizeWithResponse request returning *GetNonPersistentTopicMaxMessageSizeResponse
func (c *ClientWithResponses) GetNonPersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxMessageSizeResponse, error) {
	rsp, err := c.GetNonPersistentTopicMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMaxMessageSizeResponse(rsp)
}

// SetNonPersistentTopicMaxMessageSizeWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicMaxMessageSizeResponse
func (c *ClientWithResponses) SetNonPersistentTopicMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxMessageSizeResponse, error) {
	rsp, err := c.SetNonPersistentTopicMaxMessageSizeWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMaxMessageSizeResponse(rsp)
}

// RemoveNonPersistentTopicMaxProducersWithResponse request returning *RemoveNonPersistentTopicMaxProducersResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxProducersResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicMaxProducersResponse(rsp)
}

// GetNonPersistentTopicMaxProducersWithResponse request returning *GetNonPersistentTopicMaxProducersResponse
func (c *ClientWithResponses) GetNonPersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxProducersResponse, error) {
	rsp, err := c.GetNonPersistentTopicMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMaxProducersResponse(rsp)
}

// SetNonPersistentTopicMaxProducersWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicMaxProducersResponse
func (c *ClientWithResponses) SetNonPersistentTopicMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxProducersResponse, error) {
	rsp, err := c.SetNonPersistentTopicMaxProducersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMaxProducersResponse(rsp)
}

// RemoveNonPersistentTopicMaxSubscriptionsPerTopicWithResponse request returning *RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse(rsp)
}

// GetNonPersistentTopicMaxSubscriptionsPerTopicWithResponse request returning *GetNonPersistentTopicMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) GetNonPersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.GetNonPersistentTopicMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMaxSubscriptionsPerTopicResponse(rsp)
}

// SetNonPersistentTopicMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) SetNonPersistentTopicMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetNonPersistentTopicMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMaxSubscriptionsPerTopicResponse(rsp)
}

// DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse request returning *DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp)
}

// GetNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse request returning *GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) GetNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.GetNonPersistentTopicMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp)
}

// SetNonPersistentTopicMaxUnackedMessagesOnConsumerWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) SetNonPersistentTopicMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.SetNonPersistentTopicMaxUnackedMessagesOnConsumerWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp)
}

// DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse request returning *DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse request returning *GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.GetNonPersistentTopicMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// RemoveNonPersistentTopicMessageTTLWithResponse request returning *RemoveNonPersistentTopicMessageTTLResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicMessageTTLResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicMessageTTLResponse(rsp)
}

// GetNonPersistentTopicMessageTTLWithResponse request returning *GetNonPersistentTopicMessageTTLResponse
func (c *ClientWithResponses) GetNonPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMessageTTLResponse, error) {
	rsp, err := c.GetNonPersistentTopicMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMessageTTLResponse(rsp)
}

// SetNonPersistentTopicMessageTTLWithResponse request returning *SetNonPersistentTopicMessageTTLResponse
func (c *ClientWithResponses) SetNonPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicMessageTTLResponse, error) {
	rsp, err := c.SetNonPersistentTopicMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicMessageTTLResponse(rsp)
}

// GetNonPersistentTopicMessageIdByTimestampWithResponse request returning *GetNonPersistentTopicMessageIdByTimestampResponse
func (c *ClientWithResponses) GetNonPersistentTopicMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetNonPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicMessageIdByTimestampResponse, error) {
	rsp, err := c.GetNonPersistentTopicMessageIdByTimestamp(ctx, tenant, namespace, topic, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicMessageIdByTimestampResponse(rsp)
}

// OffloadNonPersistentTopicStatusWithResponse request returning *OffloadNonPersistentTopicStatusResponse
func (c *ClientWithResponses) OffloadNonPersistentTopicStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadNonPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*OffloadNonPersistentTopicStatusResponse, error) {
	rsp, err := c.OffloadNonPersistentTopicStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOffloadNonPersistentTopicStatusResponse(rsp)
}

// TriggerNonPersistentTopicOffloadWithResponse request returning *TriggerNonPersistentTopicOffloadResponse
func (c *ClientWithResponses) TriggerNonPersistentTopicOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerNonPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*TriggerNonPersistentTopicOffloadResponse, error) {
	rsp, err := c.TriggerNonPersistentTopicOffload(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerNonPersistentTopicOffloadResponse(rsp)
}

// RemoveNonPersistentTopicOffloadPoliciesWithResponse request returning *RemoveNonPersistentTopicOffloadPoliciesResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicOffloadPoliciesResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicOffloadPoliciesResponse(rsp)
}

// GetNonPersistentTopicOffloadPoliciesWithResponse request returning *GetNonPersistentTopicOffloadPoliciesResponse
func (c *ClientWithResponses) GetNonPersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicOffloadPoliciesResponse, error) {
	rsp, err := c.GetNonPersistentTopicOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicOffloadPoliciesResponse(rsp)
}

// SetNonPersistentTopicOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicOffloadPoliciesResponse
func (c *ClientWithResponses) SetNonPersistentTopicOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicOffloadPoliciesResponse, error) {
	rsp, err := c.SetNonPersistentTopicOffloadPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicOffloadPoliciesResponse(rsp)
}

// GetNonPersistentTopicPartitionedStatsWithResponse request returning *GetNonPersistentTopicPartitionedStatsResponse
func (c *ClientWithResponses) GetNonPersistentTopicPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPartitionedStatsResponse, error) {
	rsp, err := c.GetNonPersistentTopicPartitionedStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicPartitionedStatsResponse(rsp)
}

// DeleteNonPersistentTopicPartitionedTopicWithResponse request returning *DeleteNonPersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicPartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicPartitionedTopicResponse(rsp)
}

// GetNonPersistentTopicPartitionedMetadataWithResponse request returning *GetNonPersistentTopicPartitionedMetadataResponse
func (c *ClientWithResponses) GetNonPersistentTopicPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPartitionedMetadataResponse, error) {
	rsp, err := c.GetNonPersistentTopicPartitionedMetadata(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicPartitionedMetadataResponse(rsp)
}

// UpdateNonPersistentTopicPartitionedTopicWithBodyWithResponse request with arbitrary body returning *UpdateNonPersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) UpdateNonPersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNonPersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.UpdateNonPersistentTopicPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNonPersistentTopicPartitionedTopicResponse(rsp)
}

// CreateNonPersistentTopicPartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreateNonPersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) CreateNonPersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.CreateNonPersistentTopicPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNonPersistentTopicPartitionedTopicResponse(rsp)
}

func (c *ClientWithResponses) CreateNonPersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreateNonPersistentTopicPartitionedTopicParams, body CreateNonPersistentTopicPartitionedTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.CreateNonPersistentTopicPartitionedTopic(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNonPersistentTopicPartitionedTopicResponse(rsp)
}

// GetNonPersistentTopicPermissionsOnTopicWithResponse request returning *GetNonPersistentTopicPermissionsOnTopicResponse
func (c *ClientWithResponses) GetNonPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPermissionsOnTopicResponse, error) {
	rsp, err := c.GetNonPersistentTopicPermissionsOnTopic(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicPermissionsOnTopicResponse(rsp)
}

// RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse request returning *RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse
func (c *ClientWithResponses) RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse, error) {
	rsp, err := c.RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopic(ctx, tenant, namespace, topic, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse(rsp)
}

// GrantNonPersistentTopicPermissionsOnTopicWithBodyWithResponse request with arbitrary body returning *GrantNonPersistentTopicPermissionsOnTopicResponse
func (c *ClientWithResponses) GrantNonPersistentTopicPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantNonPersistentTopicPermissionsOnTopicResponse, error) {
	rsp, err := c.GrantNonPersistentTopicPermissionsOnTopicWithBody(ctx, tenant, namespace, topic, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantNonPersistentTopicPermissionsOnTopicResponse(rsp)
}

// RemoveNonPersistentTopicPersistenceWithResponse request returning *RemoveNonPersistentTopicPersistenceResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicPersistenceResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicPersistenceResponse(rsp)
}

// GetNonPersistentTopicPersistenceWithResponse request returning *GetNonPersistentTopicPersistenceResponse
func (c *ClientWithResponses) GetNonPersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPersistenceResponse, error) {
	rsp, err := c.GetNonPersistentTopicPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicPersistenceResponse(rsp)
}

// SetNonPersistentTopicPersistenceWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicPersistenceResponse
func (c *ClientWithResponses) SetNonPersistentTopicPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicPersistenceResponse, error) {
	rsp, err := c.SetNonPersistentTopicPersistenceWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicPersistenceResponse(rsp)
}

// RemoveNonPersistentTopicPropertiesWithResponse request returning *RemoveNonPersistentTopicPropertiesResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicPropertiesResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicPropertiesResponse(rsp)
}

// GetNonPersistentTopicPropertiesWithResponse request returning *GetNonPersistentTopicPropertiesResponse
func (c *ClientWithResponses) GetNonPersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPropertiesResponse, error) {
	rsp, err := c.GetNonPersistentTopicProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicPropertiesResponse(rsp)
}

// UpdateNonPersistentTopicPropertiesWithBodyWithResponse request with arbitrary body returning *UpdateNonPersistentTopicPropertiesResponse
func (c *ClientWithResponses) UpdateNonPersistentTopicPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdateNonPersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNonPersistentTopicPropertiesResponse, error) {
	rsp, err := c.UpdateNonPersistentTopicPropertiesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNonPersistentTopicPropertiesResponse(rsp)
}

// RemoveNonPersistentTopicPublishRateWithResponse request returning *RemoveNonPersistentTopicPublishRateResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicPublishRateResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicPublishRateResponse(rsp)
}

// GetNonPersistentTopicPublishRateWithResponse request returning *GetNonPersistentTopicPublishRateResponse
func (c *ClientWithResponses) GetNonPersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicPublishRateResponse, error) {
	rsp, err := c.GetNonPersistentTopicPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicPublishRateResponse(rsp)
}

// SetNonPersistentTopicPublishRateWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicPublishRateResponse
func (c *ClientWithResponses) SetNonPersistentTopicPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicPublishRateResponse, error) {
	rsp, err := c.SetNonPersistentTopicPublishRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicPublishRateResponse(rsp)
}

// RemoveNonPersistentTopicReplicationClustersWithResponse request returning *RemoveNonPersistentTopicReplicationClustersResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicReplicationClustersResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicReplicationClustersResponse(rsp)
}

// GetNonPersistentTopicReplicationClustersWithResponse request returning *GetNonPersistentTopicReplicationClustersResponse
func (c *ClientWithResponses) GetNonPersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicReplicationClustersResponse, error) {
	rsp, err := c.GetNonPersistentTopicReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicReplicationClustersResponse(rsp)
}

// SetNonPersistentTopicReplicationClustersWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicReplicationClustersResponse
func (c *ClientWithResponses) SetNonPersistentTopicReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicReplicationClustersResponse, error) {
	rsp, err := c.SetNonPersistentTopicReplicationClustersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicReplicationClustersResponse(rsp)
}

// RemoveNonPersistentTopicReplicatorDispatchRateWithResponse request returning *RemoveNonPersistentTopicReplicatorDispatchRateResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicReplicatorDispatchRateResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicReplicatorDispatchRateResponse(rsp)
}

// GetNonPersistentTopicReplicatorDispatchRateWithResponse request returning *GetNonPersistentTopicReplicatorDispatchRateResponse
func (c *ClientWithResponses) GetNonPersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicReplicatorDispatchRateResponse, error) {
	rsp, err := c.GetNonPersistentTopicReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicReplicatorDispatchRateResponse(rsp)
}

// SetNonPersistentTopicReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicReplicatorDispatchRateResponse
func (c *ClientWithResponses) SetNonPersistentTopicReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetNonPersistentTopicReplicatorDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicReplicatorDispatchRateResponse(rsp)
}

// RemoveNonPersistentTopicRetentionWithResponse request returning *RemoveNonPersistentTopicRetentionResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicRetentionResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicRetentionResponse(rsp)
}

// GetNonPersistentTopicRetentionWithResponse request returning *GetNonPersistentTopicRetentionResponse
func (c *ClientWithResponses) GetNonPersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicRetentionResponse, error) {
	rsp, err := c.GetNonPersistentTopicRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicRetentionResponse(rsp)
}

// SetNonPersistentTopicRetentionWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicRetentionResponse
func (c *ClientWithResponses) SetNonPersistentTopicRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicRetentionResponse, error) {
	rsp, err := c.SetNonPersistentTopicRetentionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicRetentionResponse(rsp)
}

// RemoveNonPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicSchemaCompatibilityStrategyResponse(rsp)
}

// GetNonPersistentTopicSchemaCompatibilityStrategyWithResponse request returning *GetNonPersistentTopicSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) GetNonPersistentTopicSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.GetNonPersistentTopicSchemaCompatibilityStrategy(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSchemaCompatibilityStrategyResponse(rsp)
}

// SetNonPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) SetNonPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetNonPersistentTopicSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicSchemaCompatibilityStrategyResponse(rsp)
}

// GetNonPersistentTopicSchemaValidationEnforcedWithResponse request returning *GetNonPersistentTopicSchemaValidationEnforcedResponse
func (c *ClientWithResponses) GetNonPersistentTopicSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSchemaValidationEnforcedResponse, error) {
	rsp, err := c.GetNonPersistentTopicSchemaValidationEnforced(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSchemaValidationEnforcedResponse(rsp)
}

// SetNonPersistentTopicSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicSchemaValidationEnforcedResponse
func (c *ClientWithResponses) SetNonPersistentTopicSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetNonPersistentTopicSchemaValidationEnforcedWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicSchemaValidationEnforcedResponse(rsp)
}

// DeleteNonPersistentTopicShadowTopicsWithResponse request returning *DeleteNonPersistentTopicShadowTopicsResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicShadowTopicsResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicShadowTopicsResponse(rsp)
}

// GetNonPersistentTopicShadowTopicsWithResponse request returning *GetNonPersistentTopicShadowTopicsResponse
func (c *ClientWithResponses) GetNonPersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicShadowTopicsResponse, error) {
	rsp, err := c.GetNonPersistentTopicShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicShadowTopicsResponse(rsp)
}

// SetNonPersistentTopicShadowTopicsWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicShadowTopicsResponse
func (c *ClientWithResponses) SetNonPersistentTopicShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicShadowTopicsResponse, error) {
	rsp, err := c.SetNonPersistentTopicShadowTopicsWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicShadowTopicsResponse(rsp)
}

// GetNonPersistentTopicStatsWithResponse request returning *GetNonPersistentTopicStatsResponse
func (c *ClientWithResponses) GetNonPersistentTopicStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicStatsResponse, error) {
	rsp, err := c.GetNonPersistentTopicStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicStatsResponse(rsp)
}

// RemoveNonPersistentTopicSubscribeRateWithBodyWithResponse request with arbitrary body returning *RemoveNonPersistentTopicSubscribeRateResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscribeRateResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicSubscribeRateResponse(rsp)
}

// GetNonPersistentTopicSubscribeRateWithResponse request returning *GetNonPersistentTopicSubscribeRateResponse
func (c *ClientWithResponses) GetNonPersistentTopicSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscribeRateResponse, error) {
	rsp, err := c.GetNonPersistentTopicSubscribeRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSubscribeRateResponse(rsp)
}

// SetNonPersistentTopicSubscribeRateWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicSubscribeRateResponse
func (c *ClientWithResponses) SetNonPersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscribeRateResponse, error) {
	rsp, err := c.SetNonPersistentTopicSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicSubscribeRateResponse(rsp)
}

// DeleteNonPersistentTopicSubscriptionWithResponse request returning *DeleteNonPersistentTopicSubscriptionResponse
func (c *ClientWithResponses) DeleteNonPersistentTopicSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeleteNonPersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteNonPersistentTopicSubscriptionResponse, error) {
	rsp, err := c.DeleteNonPersistentTopicSubscription(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNonPersistentTopicSubscriptionResponse(rsp)
}

// AnalyzeNonPersistentTopicSubscriptionBacklogWithBodyWithResponse request with arbitrary body returning *AnalyzeNonPersistentTopicSubscriptionBacklogResponse
func (c *ClientWithResponses) AnalyzeNonPersistentTopicSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzeNonPersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzeNonPersistentTopicSubscriptionBacklogResponse, error) {
	rsp, err := c.AnalyzeNonPersistentTopicSubscriptionBacklogWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnalyzeNonPersistentTopicSubscriptionBacklogResponse(rsp)
}

// ExpireNonPersistentTopicMessagesWithBodyWithResponse request with arbitrary body returning *ExpireNonPersistentTopicMessagesResponse
func (c *ClientWithResponses) ExpireNonPersistentTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpireNonPersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpireNonPersistentTopicMessagesResponse, error) {
	rsp, err := c.ExpireNonPersistentTopicMessagesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireNonPersistentTopicMessagesResponse(rsp)
}

// ExpireNonPersistentTopicMessagesTimeInSecondsWithResponse request returning *ExpireNonPersistentTopicMessagesTimeInSecondsResponse
func (c *ClientWithResponses) ExpireNonPersistentTopicMessagesTimeInSecondsWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpireNonPersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*ExpireNonPersistentTopicMessagesTimeInSecondsResponse, error) {
	rsp, err := c.ExpireNonPersistentTopicMessagesTimeInSeconds(ctx, tenant, namespace, topic, subName, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireNonPersistentTopicMessagesTimeInSecondsResponse(rsp)
}

// PeekNonPersistentTopicNthMessageWithResponse request returning *PeekNonPersistentTopicNthMessageResponse
func (c *ClientWithResponses) PeekNonPersistentTopicNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekNonPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*PeekNonPersistentTopicNthMessageResponse, error) {
	rsp, err := c.PeekNonPersistentTopicNthMessage(ctx, tenant, namespace, topic, subName, messagePosition, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePeekNonPersistentTopicNthMessageResponse(rsp)
}

// GetNonPersistentTopicSubscriptionPropertiesWithResponse request returning *GetNonPersistentTopicSubscriptionPropertiesResponse
func (c *ClientWithResponses) GetNonPersistentTopicSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionPropertiesResponse, error) {
	rsp, err := c.GetNonPersistentTopicSubscriptionProperties(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSubscriptionPropertiesResponse(rsp)
}

// UpdateNonPersistentTopicSubscriptionPropertiesWithBodyWithResponse request with arbitrary body returning *UpdateNonPersistentTopicSubscriptionPropertiesResponse
func (c *ClientWithResponses) UpdateNonPersistentTopicSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdateNonPersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNonPersistentTopicSubscriptionPropertiesResponse, error) {
	rsp, err := c.UpdateNonPersistentTopicSubscriptionPropertiesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNonPersistentTopicSubscriptionPropertiesResponse(rsp)
}

// GetNonPersistentTopicReplicatedSubscriptionStatusWithResponse request returning *GetNonPersistentTopicReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) GetNonPersistentTopicReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.GetNonPersistentTopicReplicatedSubscriptionStatus(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicReplicatedSubscriptionStatusResponse(rsp)
}

// SetNonPersistentTopicReplicatedSubscriptionStatusWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) SetNonPersistentTopicReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.SetNonPersistentTopicReplicatedSubscriptionStatusWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicReplicatedSubscriptionStatusResponse(rsp)
}

// ResetNonPersistentTopicCursorOnPositionWithBodyWithResponse request with arbitrary body returning *ResetNonPersistentTopicCursorOnPositionResponse
func (c *ClientWithResponses) ResetNonPersistentTopicCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetNonPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetNonPersistentTopicCursorOnPositionResponse, error) {
	rsp, err := c.ResetNonPersistentTopicCursorOnPositionWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetNonPersistentTopicCursorOnPositionResponse(rsp)
}

// ResetNonPersistentTopicCursorWithResponse request returning *ResetNonPersistentTopicCursorResponse
func (c *ClientWithResponses) ResetNonPersistentTopicCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetNonPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*ResetNonPersistentTopicCursorResponse, error) {
	rsp, err := c.ResetNonPersistentTopicCursor(ctx, tenant, namespace, topic, subName, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetNonPersistentTopicCursorResponse(rsp)
}

// SkipNonPersistentTopicMessagesWithResponse request returning *SkipNonPersistentTopicMessagesResponse
func (c *ClientWithResponses) SkipNonPersistentTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipNonPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*SkipNonPersistentTopicMessagesResponse, error) {
	rsp, err := c.SkipNonPersistentTopicMessages(ctx, tenant, namespace, topic, subName, numMessages, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipNonPersistentTopicMessagesResponse(rsp)
}

// SkipNonPersistentTopicAllMessagesWithResponse request returning *SkipNonPersistentTopicAllMessagesResponse
func (c *ClientWithResponses) SkipNonPersistentTopicAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipNonPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipNonPersistentTopicAllMessagesResponse, error) {
	rsp, err := c.SkipNonPersistentTopicAllMessages(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipNonPersistentTopicAllMessagesResponse(rsp)
}

// CreateNonPersistentTopicSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateNonPersistentTopicSubscriptionResponse
func (c *ClientWithResponses) CreateNonPersistentTopicSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreateNonPersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNonPersistentTopicSubscriptionResponse, error) {
	rsp, err := c.CreateNonPersistentTopicSubscriptionWithBody(ctx, tenant, namespace, topic, subscriptionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNonPersistentTopicSubscriptionResponse(rsp)
}

// RemoveNonPersistentTopicSubscriptionDispatchRateWithResponse request returning *RemoveNonPersistentTopicSubscriptionDispatchRateResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscriptionDispatchRateResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicSubscriptionDispatchRateResponse(rsp)
}

// GetNonPersistentTopicSubscriptionDispatchRateWithResponse request returning *GetNonPersistentTopicSubscriptionDispatchRateResponse
func (c *ClientWithResponses) GetNonPersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionDispatchRateResponse, error) {
	rsp, err := c.GetNonPersistentTopicSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSubscriptionDispatchRateResponse(rsp)
}

// SetNonPersistentTopicSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicSubscriptionDispatchRateResponse
func (c *ClientWithResponses) SetNonPersistentTopicSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetNonPersistentTopicSubscriptionDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicSubscriptionDispatchRateResponse(rsp)
}

// RemoveNonPersistentTopicSubscriptionTypesEnabledWithResponse request returning *RemoveNonPersistentTopicSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemoveNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicSubscriptionTypesEnabledResponse(rsp)
}

// GetNonPersistentTopicSubscriptionTypesEnabledWithResponse request returning *GetNonPersistentTopicSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) GetNonPersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.GetNonPersistentTopicSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSubscriptionTypesEnabledResponse(rsp)
}

// SetNonPersistentTopicSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) SetNonPersistentTopicSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetNonPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetNonPersistentTopicSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicSubscriptionTypesEnabledResponse(rsp)
}

// GetNonPersistentTopicSubscriptionsWithResponse request returning *GetNonPersistentTopicSubscriptionsResponse
func (c *ClientWithResponses) GetNonPersistentTopicSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetNonPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionsResponse, error) {
	rsp, err := c.GetNonPersistentTopicSubscriptions(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSubscriptionsResponse(rsp)
}

// TerminateNonPersistentTopicWithResponse request returning *TerminateNonPersistentTopicResponse
func (c *ClientWithResponses) TerminateNonPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicParams, reqEditors ...RequestEditorFn) (*TerminateNonPersistentTopicResponse, error) {
	rsp, err := c.TerminateNonPersistentTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateNonPersistentTopicResponse(rsp)
}

// TerminateNonPersistentTopicPartitionedTopicWithResponse request returning *TerminateNonPersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) TerminateNonPersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminateNonPersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminateNonPersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.TerminateNonPersistentTopicPartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateNonPersistentTopicPartitionedTopicResponse(rsp)
}

// TruncateNonPersistentTopicTopicWithResponse request returning *TruncateNonPersistentTopicTopicResponse
func (c *ClientWithResponses) TruncateNonPersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncateNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*TruncateNonPersistentTopicTopicResponse, error) {
	rsp, err := c.TruncateNonPersistentTopicTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTruncateNonPersistentTopicTopicResponse(rsp)
}

// UnloadNonPersistentTopicTopicWithResponse request returning *UnloadNonPersistentTopicTopicResponse
func (c *ClientWithResponses) UnloadNonPersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadNonPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*UnloadNonPersistentTopicTopicResponse, error) {
	rsp, err := c.UnloadNonPersistentTopicTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadNonPersistentTopicTopicResponse(rsp)
}

// RemoveNonPersistentTopicSubscriptionLevelDispatchRateWithResponse request returning *RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) RemoveNonPersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemoveNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.RemoveNonPersistentTopicSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse(rsp)
}

// GetNonPersistentTopicSubscriptionLevelDispatchRateWithResponse request returning *GetNonPersistentTopicSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) GetNonPersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetNonPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetNonPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.GetNonPersistentTopicSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNonPersistentTopicSubscriptionLevelDispatchRateResponse(rsp)
}

// SetNonPersistentTopicSubscriptionLevelDispatchRateWithBodyWithResponse request with arbitrary body returning *SetNonPersistentTopicSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) SetNonPersistentTopicSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetNonPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNonPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.SetNonPersistentTopicSubscriptionLevelDispatchRateWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNonPersistentTopicSubscriptionLevelDispatchRateResponse(rsp)
}

// GetPersistentTopicListWithResponse request returning *GetPersistentTopicListResponse
func (c *ClientWithResponses) GetPersistentTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPersistentTopicListParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicListResponse, error) {
	rsp, err := c.GetPersistentTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicListResponse(rsp)
}

// GetPersistentPartitionedTopicListWithResponse request returning *GetPersistentPartitionedTopicListResponse
func (c *ClientWithResponses) GetPersistentPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *GetPersistentPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*GetPersistentPartitionedTopicListResponse, error) {
	rsp, err := c.GetPersistentPartitionedTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentPartitionedTopicListResponse(rsp)
}

// DeletePersistentTopicWithResponse request returning *DeletePersistentTopicResponse
func (c *ClientWithResponses) DeletePersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicResponse, error) {
	rsp, err := c.DeletePersistentTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicResponse(rsp)
}

// CreatePersistentTopicNonPartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreatePersistentTopicNonPartitionedTopicResponse
func (c *ClientWithResponses) CreatePersistentTopicNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePersistentTopicNonPartitionedTopicResponse, error) {
	rsp, err := c.CreatePersistentTopicNonPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePersistentTopicNonPartitionedTopicResponse(rsp)
}

// ExpirePersistentTopicMessagesForAllSubscriptionsWithResponse request returning *ExpirePersistentTopicMessagesForAllSubscriptionsResponse
func (c *ClientWithResponses) ExpirePersistentTopicMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*ExpirePersistentTopicMessagesForAllSubscriptionsResponse, error) {
	rsp, err := c.ExpirePersistentTopicMessagesForAllSubscriptions(ctx, tenant, namespace, topic, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpirePersistentTopicMessagesForAllSubscriptionsResponse(rsp)
}

// GetPersistentTopicBacklogWithResponse request returning *GetPersistentTopicBacklogResponse
func (c *ClientWithResponses) GetPersistentTopicBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicBacklogResponse, error) {
	rsp, err := c.GetPersistentTopicBacklog(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicBacklogResponse(rsp)
}

// RemovePersistentTopicBacklogQuotaWithResponse request returning *RemovePersistentTopicBacklogQuotaResponse
func (c *ClientWithResponses) RemovePersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicBacklogQuotaResponse, error) {
	rsp, err := c.RemovePersistentTopicBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicBacklogQuotaResponse(rsp)
}

// SetPersistentTopicBacklogQuotaWithResponse request returning *SetPersistentTopicBacklogQuotaResponse
func (c *ClientWithResponses) SetPersistentTopicBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicBacklogQuotaParams, reqEditors ...RequestEditorFn) (*SetPersistentTopicBacklogQuotaResponse, error) {
	rsp, err := c.SetPersistentTopicBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicBacklogQuotaResponse(rsp)
}

// GetPersistentTopicBacklogQuotaMapWithResponse request returning *GetPersistentTopicBacklogQuotaMapResponse
func (c *ClientWithResponses) GetPersistentTopicBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicBacklogQuotaMapResponse, error) {
	rsp, err := c.GetPersistentTopicBacklogQuotaMap(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicBacklogQuotaMapResponse(rsp)
}

// GetPersistentTopicBacklogSizeByMessageIdWithResponse request returning *GetPersistentTopicBacklogSizeByMessageIdResponse
func (c *ClientWithResponses) GetPersistentTopicBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicBacklogSizeByMessageIdResponse, error) {
	rsp, err := c.GetPersistentTopicBacklogSizeByMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicBacklogSizeByMessageIdResponse(rsp)
}

// GetPersistentTopicCompactionStatusWithResponse request returning *GetPersistentTopicCompactionStatusResponse
func (c *ClientWithResponses) GetPersistentTopicCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionStatusParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicCompactionStatusResponse, error) {
	rsp, err := c.GetPersistentTopicCompactionStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicCompactionStatusResponse(rsp)
}

// CompactPersistentTopicWithResponse request returning *CompactPersistentTopicResponse
func (c *ClientWithResponses) CompactPersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CompactPersistentTopicParams, reqEditors ...RequestEditorFn) (*CompactPersistentTopicResponse, error) {
	rsp, err := c.CompactPersistentTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompactPersistentTopicResponse(rsp)
}

// RemovePersistentTopicCompactionThresholdWithResponse request returning *RemovePersistentTopicCompactionThresholdResponse
func (c *ClientWithResponses) RemovePersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicCompactionThresholdResponse, error) {
	rsp, err := c.RemovePersistentTopicCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicCompactionThresholdResponse(rsp)
}

// GetPersistentTopicCompactionThresholdWithResponse request returning *GetPersistentTopicCompactionThresholdResponse
func (c *ClientWithResponses) GetPersistentTopicCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicCompactionThresholdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicCompactionThresholdResponse, error) {
	rsp, err := c.GetPersistentTopicCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicCompactionThresholdResponse(rsp)
}

// SetPersistentTopicCompactionThresholdWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicCompactionThresholdResponse
func (c *ClientWithResponses) SetPersistentTopicCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicCompactionThresholdResponse, error) {
	rsp, err := c.SetPersistentTopicCompactionThresholdWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicCompactionThresholdResponse(rsp)
}

// CreatePersistentTopicMissedPartitionsWithResponse request returning *CreatePersistentTopicMissedPartitionsResponse
func (c *ClientWithResponses) CreatePersistentTopicMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*CreatePersistentTopicMissedPartitionsResponse, error) {
	rsp, err := c.CreatePersistentTopicMissedPartitions(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePersistentTopicMissedPartitionsResponse(rsp)
}

// RemovePersistentTopicDeduplicationWithResponse request returning *RemovePersistentTopicDeduplicationResponse
func (c *ClientWithResponses) RemovePersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicDeduplicationResponse, error) {
	rsp, err := c.RemovePersistentTopicDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicDeduplicationResponse(rsp)
}

// GetPersistentTopicDeduplicationWithResponse request returning *GetPersistentTopicDeduplicationResponse
func (c *ClientWithResponses) GetPersistentTopicDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDeduplicationResponse, error) {
	rsp, err := c.GetPersistentTopicDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicDeduplicationResponse(rsp)
}

// SetPersistentTopicDeduplicationWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicDeduplicationResponse
func (c *ClientWithResponses) SetPersistentTopicDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDeduplicationResponse, error) {
	rsp, err := c.SetPersistentTopicDeduplicationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicDeduplicationResponse(rsp)
}

// DeletePersistentTopicDeduplicationSnapshotIntervalWithResponse request returning *DeletePersistentTopicDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) DeletePersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.DeletePersistentTopicDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicDeduplicationSnapshotIntervalResponse(rsp)
}

// GetPersistentTopicDeduplicationSnapshotIntervalWithResponse request returning *GetPersistentTopicDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) GetPersistentTopicDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.GetPersistentTopicDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicDeduplicationSnapshotIntervalResponse(rsp)
}

// SetPersistentTopicDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) SetPersistentTopicDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.SetPersistentTopicDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicDeduplicationSnapshotIntervalResponse(rsp)
}

// DeletePersistentTopicDelayedDeliveryPoliciesWithResponse request returning *DeletePersistentTopicDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) DeletePersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.DeletePersistentTopicDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicDelayedDeliveryPoliciesResponse(rsp)
}

// GetPersistentTopicDelayedDeliveryPoliciesWithResponse request returning *GetPersistentTopicDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) GetPersistentTopicDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.GetPersistentTopicDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicDelayedDeliveryPoliciesResponse(rsp)
}

// SetPersistentTopicDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) SetPersistentTopicDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.SetPersistentTopicDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicDelayedDeliveryPoliciesResponse(rsp)
}

// RemovePersistentTopicDispatchRateWithResponse request returning *RemovePersistentTopicDispatchRateResponse
func (c *ClientWithResponses) RemovePersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicDispatchRateResponse, error) {
	rsp, err := c.RemovePersistentTopicDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicDispatchRateResponse(rsp)
}

// GetPersistentTopicDispatchRateWithResponse request returning *GetPersistentTopicDispatchRateResponse
func (c *ClientWithResponses) GetPersistentTopicDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicDispatchRateResponse, error) {
	rsp, err := c.GetPersistentTopicDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicDispatchRateResponse(rsp)
}

// SetPersistentTopicDispatchRateWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicDispatchRateResponse
func (c *ClientWithResponses) SetPersistentTopicDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicDispatchRateResponse, error) {
	rsp, err := c.SetPersistentTopicDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicDispatchRateResponse(rsp)
}

// RemovePersistentTopicEntryFiltersWithResponse request returning *RemovePersistentTopicEntryFiltersResponse
func (c *ClientWithResponses) RemovePersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicEntryFiltersResponse, error) {
	rsp, err := c.RemovePersistentTopicEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicEntryFiltersResponse(rsp)
}

// GetPersistentTopicEntryFiltersWithResponse request returning *GetPersistentTopicEntryFiltersResponse
func (c *ClientWithResponses) GetPersistentTopicEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicEntryFiltersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicEntryFiltersResponse, error) {
	rsp, err := c.GetPersistentTopicEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicEntryFiltersResponse(rsp)
}

// SetPersistentTopicEntryFiltersWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicEntryFiltersResponse
func (c *ClientWithResponses) SetPersistentTopicEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicEntryFiltersResponse, error) {
	rsp, err := c.SetPersistentTopicEntryFiltersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicEntryFiltersResponse(rsp)
}

// ExaminePersistentTopicMessageWithResponse request returning *ExaminePersistentTopicMessageResponse
func (c *ClientWithResponses) ExaminePersistentTopicMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *ExaminePersistentTopicMessageParams, reqEditors ...RequestEditorFn) (*ExaminePersistentTopicMessageResponse, error) {
	rsp, err := c.ExaminePersistentTopicMessage(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExaminePersistentTopicMessageResponse(rsp)
}

// DeletePersistentTopicInactiveTopicPoliciesWithResponse request returning *DeletePersistentTopicInactiveTopicPoliciesResponse
func (c *ClientWithResponses) DeletePersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicInactiveTopicPoliciesResponse, error) {
	rsp, err := c.DeletePersistentTopicInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicInactiveTopicPoliciesResponse(rsp)
}

// GetPersistentTopicInactiveTopicPoliciesWithResponse request returning *GetPersistentTopicInactiveTopicPoliciesResponse
func (c *ClientWithResponses) GetPersistentTopicInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicInactiveTopicPoliciesResponse, error) {
	rsp, err := c.GetPersistentTopicInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicInactiveTopicPoliciesResponse(rsp)
}

// SetPersistentTopicInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicInactiveTopicPoliciesResponse
func (c *ClientWithResponses) SetPersistentTopicInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicInactiveTopicPoliciesResponse, error) {
	rsp, err := c.SetPersistentTopicInactiveTopicPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicInactiveTopicPoliciesResponse(rsp)
}

// GetPersistentTopicManagedLedgerInfoWithResponse request returning *GetPersistentTopicManagedLedgerInfoResponse
func (c *ClientWithResponses) GetPersistentTopicManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicManagedLedgerInfoResponse, error) {
	rsp, err := c.GetPersistentTopicManagedLedgerInfo(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicManagedLedgerInfoResponse(rsp)
}

// GetPersistentTopicInternalStatsWithResponse request returning *GetPersistentTopicInternalStatsResponse
func (c *ClientWithResponses) GetPersistentTopicInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicInternalStatsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicInternalStatsResponse, error) {
	rsp, err := c.GetPersistentTopicInternalStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicInternalStatsResponse(rsp)
}

// GetPersistentTopicLastMessageIdWithResponse request returning *GetPersistentTopicLastMessageIdResponse
func (c *ClientWithResponses) GetPersistentTopicLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicLastMessageIdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicLastMessageIdResponse, error) {
	rsp, err := c.GetPersistentTopicLastMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicLastMessageIdResponse(rsp)
}

// GetPersistentTopicMessageByIdWithResponse request returning *GetPersistentTopicMessageByIdResponse
func (c *ClientWithResponses) GetPersistentTopicMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *GetPersistentTopicMessageByIdParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMessageByIdResponse, error) {
	rsp, err := c.GetPersistentTopicMessageById(ctx, tenant, namespace, topic, ledgerId, entryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMessageByIdResponse(rsp)
}

// RemovePersistentTopicMaxConsumersWithResponse request returning *RemovePersistentTopicMaxConsumersResponse
func (c *ClientWithResponses) RemovePersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxConsumersResponse, error) {
	rsp, err := c.RemovePersistentTopicMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicMaxConsumersResponse(rsp)
}

// GetPersistentTopicMaxConsumersWithResponse request returning *GetPersistentTopicMaxConsumersResponse
func (c *ClientWithResponses) GetPersistentTopicMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxConsumersResponse, error) {
	rsp, err := c.GetPersistentTopicMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMaxConsumersResponse(rsp)
}

// SetPersistentTopicMaxConsumersWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicMaxConsumersResponse
func (c *ClientWithResponses) SetPersistentTopicMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxConsumersResponse, error) {
	rsp, err := c.SetPersistentTopicMaxConsumersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMaxConsumersResponse(rsp)
}

// RemovePersistentTopicMaxConsumersPerSubscriptionWithResponse request returning *RemovePersistentTopicMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) RemovePersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.RemovePersistentTopicMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicMaxConsumersPerSubscriptionResponse(rsp)
}

// GetPersistentTopicMaxConsumersPerSubscriptionWithResponse request returning *GetPersistentTopicMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) GetPersistentTopicMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.GetPersistentTopicMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMaxConsumersPerSubscriptionResponse(rsp)
}

// SetPersistentTopicMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) SetPersistentTopicMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.SetPersistentTopicMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMaxConsumersPerSubscriptionResponse(rsp)
}

// RemovePersistentTopicMaxMessageSizeWithResponse request returning *RemovePersistentTopicMaxMessageSizeResponse
func (c *ClientWithResponses) RemovePersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxMessageSizeResponse, error) {
	rsp, err := c.RemovePersistentTopicMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicMaxMessageSizeResponse(rsp)
}

// GetPersistentTopicMaxMessageSizeWithResponse request returning *GetPersistentTopicMaxMessageSizeResponse
func (c *ClientWithResponses) GetPersistentTopicMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxMessageSizeResponse, error) {
	rsp, err := c.GetPersistentTopicMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMaxMessageSizeResponse(rsp)
}

// SetPersistentTopicMaxMessageSizeWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicMaxMessageSizeResponse
func (c *ClientWithResponses) SetPersistentTopicMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxMessageSizeResponse, error) {
	rsp, err := c.SetPersistentTopicMaxMessageSizeWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMaxMessageSizeResponse(rsp)
}

// RemovePersistentTopicMaxProducersWithResponse request returning *RemovePersistentTopicMaxProducersResponse
func (c *ClientWithResponses) RemovePersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxProducersResponse, error) {
	rsp, err := c.RemovePersistentTopicMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicMaxProducersResponse(rsp)
}

// GetPersistentTopicMaxProducersWithResponse request returning *GetPersistentTopicMaxProducersResponse
func (c *ClientWithResponses) GetPersistentTopicMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxProducersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxProducersResponse, error) {
	rsp, err := c.GetPersistentTopicMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMaxProducersResponse(rsp)
}

// SetPersistentTopicMaxProducersWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicMaxProducersResponse
func (c *ClientWithResponses) SetPersistentTopicMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxProducersResponse, error) {
	rsp, err := c.SetPersistentTopicMaxProducersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMaxProducersResponse(rsp)
}

// RemovePersistentTopicMaxSubscriptionsPerTopicWithResponse request returning *RemovePersistentTopicMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) RemovePersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.RemovePersistentTopicMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicMaxSubscriptionsPerTopicResponse(rsp)
}

// GetPersistentTopicMaxSubscriptionsPerTopicWithResponse request returning *GetPersistentTopicMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) GetPersistentTopicMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.GetPersistentTopicMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMaxSubscriptionsPerTopicResponse(rsp)
}

// SetPersistentTopicMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) SetPersistentTopicMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.SetPersistentTopicMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMaxSubscriptionsPerTopicResponse(rsp)
}

// DeletePersistentTopicMaxUnackedMessagesOnConsumerWithResponse request returning *DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) DeletePersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.DeletePersistentTopicMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp)
}

// GetPersistentTopicMaxUnackedMessagesOnConsumerWithResponse request returning *GetPersistentTopicMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) GetPersistentTopicMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.GetPersistentTopicMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp)
}

// SetPersistentTopicMaxUnackedMessagesOnConsumerWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) SetPersistentTopicMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.SetPersistentTopicMaxUnackedMessagesOnConsumerWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp)
}

// DeletePersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse request returning *DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) DeletePersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.DeletePersistentTopicMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// GetPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse request returning *GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) GetPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.GetPersistentTopicMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// SetPersistentTopicMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) SetPersistentTopicMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.SetPersistentTopicMaxUnackedMessagesOnSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// RemovePersistentTopicMessageTTLWithResponse request returning *RemovePersistentTopicMessageTTLResponse
func (c *ClientWithResponses) RemovePersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicMessageTTLResponse, error) {
	rsp, err := c.RemovePersistentTopicMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicMessageTTLResponse(rsp)
}

// GetPersistentTopicMessageTTLWithResponse request returning *GetPersistentTopicMessageTTLResponse
func (c *ClientWithResponses) GetPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMessageTTLResponse, error) {
	rsp, err := c.GetPersistentTopicMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMessageTTLResponse(rsp)
}

// SetPersistentTopicMessageTTLWithResponse request returning *SetPersistentTopicMessageTTLResponse
func (c *ClientWithResponses) SetPersistentTopicMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicMessageTTLParams, reqEditors ...RequestEditorFn) (*SetPersistentTopicMessageTTLResponse, error) {
	rsp, err := c.SetPersistentTopicMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicMessageTTLResponse(rsp)
}

// GetPersistentTopicMessageIdByTimestampWithResponse request returning *GetPersistentTopicMessageIdByTimestampResponse
func (c *ClientWithResponses) GetPersistentTopicMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *GetPersistentTopicMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicMessageIdByTimestampResponse, error) {
	rsp, err := c.GetPersistentTopicMessageIdByTimestamp(ctx, tenant, namespace, topic, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicMessageIdByTimestampResponse(rsp)
}

// OffloadPersistentTopicStatusWithResponse request returning *OffloadPersistentTopicStatusResponse
func (c *ClientWithResponses) OffloadPersistentTopicStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *OffloadPersistentTopicStatusParams, reqEditors ...RequestEditorFn) (*OffloadPersistentTopicStatusResponse, error) {
	rsp, err := c.OffloadPersistentTopicStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOffloadPersistentTopicStatusResponse(rsp)
}

// TriggerPersistentTopicOffloadWithResponse request returning *TriggerPersistentTopicOffloadResponse
func (c *ClientWithResponses) TriggerPersistentTopicOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TriggerPersistentTopicOffloadParams, reqEditors ...RequestEditorFn) (*TriggerPersistentTopicOffloadResponse, error) {
	rsp, err := c.TriggerPersistentTopicOffload(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPersistentTopicOffloadResponse(rsp)
}

// RemovePersistentTopicOffloadPoliciesWithResponse request returning *RemovePersistentTopicOffloadPoliciesResponse
func (c *ClientWithResponses) RemovePersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicOffloadPoliciesResponse, error) {
	rsp, err := c.RemovePersistentTopicOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicOffloadPoliciesResponse(rsp)
}

// GetPersistentTopicOffloadPoliciesWithResponse request returning *GetPersistentTopicOffloadPoliciesResponse
func (c *ClientWithResponses) GetPersistentTopicOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicOffloadPoliciesResponse, error) {
	rsp, err := c.GetPersistentTopicOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicOffloadPoliciesResponse(rsp)
}

// SetPersistentTopicOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicOffloadPoliciesResponse
func (c *ClientWithResponses) SetPersistentTopicOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicOffloadPoliciesResponse, error) {
	rsp, err := c.SetPersistentTopicOffloadPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicOffloadPoliciesResponse(rsp)
}

// GetPersistentTopicPartitionedStatsWithResponse request returning *GetPersistentTopicPartitionedStatsResponse
func (c *ClientWithResponses) GetPersistentTopicPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedStatsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPartitionedStatsResponse, error) {
	rsp, err := c.GetPersistentTopicPartitionedStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicPartitionedStatsResponse(rsp)
}

// DeletePersistentTopicPartitionedTopicWithResponse request returning *DeletePersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) DeletePersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.DeletePersistentTopicPartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicPartitionedTopicResponse(rsp)
}

// GetPersistentTopicPartitionedMetadataWithResponse request returning *GetPersistentTopicPartitionedMetadataResponse
func (c *ClientWithResponses) GetPersistentTopicPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPartitionedMetadataResponse, error) {
	rsp, err := c.GetPersistentTopicPartitionedMetadata(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicPartitionedMetadataResponse(rsp)
}

// UpdatePersistentTopicPartitionedTopicWithBodyWithResponse request with arbitrary body returning *UpdatePersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) UpdatePersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.UpdatePersistentTopicPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersistentTopicPartitionedTopicResponse(rsp)
}

// CreatePersistentTopicPartitionedTopicWithBodyWithResponse request with arbitrary body returning *CreatePersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) CreatePersistentTopicPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *CreatePersistentTopicPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.CreatePersistentTopicPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePersistentTopicPartitionedTopicResponse(rsp)
}

// GetPersistentTopicPermissionsOnTopicWithResponse request returning *GetPersistentTopicPermissionsOnTopicResponse
func (c *ClientWithResponses) GetPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*GetPersistentTopicPermissionsOnTopicResponse, error) {
	rsp, err := c.GetPersistentTopicPermissionsOnTopic(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicPermissionsOnTopicResponse(rsp)
}

// RevokePersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse request returning *RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse
func (c *ClientWithResponses) RevokePersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse, error) {
	rsp, err := c.RevokePersistentTopicNonPersistentTopicPermissionsOnTopic(ctx, tenant, namespace, topic, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse(rsp)
}

// GrantPersistentTopicPermissionsOnTopicWithBodyWithResponse request with arbitrary body returning *GrantPersistentTopicPermissionsOnTopicResponse
func (c *ClientWithResponses) GrantPersistentTopicPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GrantPersistentTopicPermissionsOnTopicResponse, error) {
	rsp, err := c.GrantPersistentTopicPermissionsOnTopicWithBody(ctx, tenant, namespace, topic, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGrantPersistentTopicPermissionsOnTopicResponse(rsp)
}

// RemovePersistentTopicPersistenceWithResponse request returning *RemovePersistentTopicPersistenceResponse
func (c *ClientWithResponses) RemovePersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicPersistenceResponse, error) {
	rsp, err := c.RemovePersistentTopicPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicPersistenceResponse(rsp)
}

// GetPersistentTopicPersistenceWithResponse request returning *GetPersistentTopicPersistenceResponse
func (c *ClientWithResponses) GetPersistentTopicPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPersistenceParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPersistenceResponse, error) {
	rsp, err := c.GetPersistentTopicPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicPersistenceResponse(rsp)
}

// SetPersistentTopicPersistenceWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicPersistenceResponse
func (c *ClientWithResponses) SetPersistentTopicPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicPersistenceResponse, error) {
	rsp, err := c.SetPersistentTopicPersistenceWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicPersistenceResponse(rsp)
}

// RemovePersistentTopicPropertiesWithResponse request returning *RemovePersistentTopicPropertiesResponse
func (c *ClientWithResponses) RemovePersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicPropertiesResponse, error) {
	rsp, err := c.RemovePersistentTopicProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicPropertiesResponse(rsp)
}

// GetPersistentTopicPropertiesWithResponse request returning *GetPersistentTopicPropertiesResponse
func (c *ClientWithResponses) GetPersistentTopicPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPropertiesResponse, error) {
	rsp, err := c.GetPersistentTopicProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicPropertiesResponse(rsp)
}

// UpdatePersistentTopicPropertiesWithBodyWithResponse request with arbitrary body returning *UpdatePersistentTopicPropertiesResponse
func (c *ClientWithResponses) UpdatePersistentTopicPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UpdatePersistentTopicPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersistentTopicPropertiesResponse, error) {
	rsp, err := c.UpdatePersistentTopicPropertiesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersistentTopicPropertiesResponse(rsp)
}

// RemovePersistentTopicPublishRateWithResponse request returning *RemovePersistentTopicPublishRateResponse
func (c *ClientWithResponses) RemovePersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicPublishRateResponse, error) {
	rsp, err := c.RemovePersistentTopicPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicPublishRateResponse(rsp)
}

// GetPersistentTopicPublishRateWithResponse request returning *GetPersistentTopicPublishRateResponse
func (c *ClientWithResponses) GetPersistentTopicPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicPublishRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicPublishRateResponse, error) {
	rsp, err := c.GetPersistentTopicPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicPublishRateResponse(rsp)
}

// SetPersistentTopicPublishRateWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicPublishRateResponse
func (c *ClientWithResponses) SetPersistentTopicPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicPublishRateResponse, error) {
	rsp, err := c.SetPersistentTopicPublishRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicPublishRateResponse(rsp)
}

// RemovePersistentTopicReplicationClustersWithResponse request returning *RemovePersistentTopicReplicationClustersResponse
func (c *ClientWithResponses) RemovePersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicReplicationClustersResponse, error) {
	rsp, err := c.RemovePersistentTopicReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicReplicationClustersResponse(rsp)
}

// GetPersistentTopicReplicationClustersWithResponse request returning *GetPersistentTopicReplicationClustersResponse
func (c *ClientWithResponses) GetPersistentTopicReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicationClustersParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicReplicationClustersResponse, error) {
	rsp, err := c.GetPersistentTopicReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicReplicationClustersResponse(rsp)
}

// SetPersistentTopicReplicationClustersWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicReplicationClustersResponse
func (c *ClientWithResponses) SetPersistentTopicReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicReplicationClustersResponse, error) {
	rsp, err := c.SetPersistentTopicReplicationClustersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicReplicationClustersResponse(rsp)
}

// RemovePersistentTopicReplicatorDispatchRateWithResponse request returning *RemovePersistentTopicReplicatorDispatchRateResponse
func (c *ClientWithResponses) RemovePersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicReplicatorDispatchRateResponse, error) {
	rsp, err := c.RemovePersistentTopicReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicReplicatorDispatchRateResponse(rsp)
}

// GetPersistentTopicReplicatorDispatchRateWithResponse request returning *GetPersistentTopicReplicatorDispatchRateResponse
func (c *ClientWithResponses) GetPersistentTopicReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicReplicatorDispatchRateResponse, error) {
	rsp, err := c.GetPersistentTopicReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicReplicatorDispatchRateResponse(rsp)
}

// SetPersistentTopicReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicReplicatorDispatchRateResponse
func (c *ClientWithResponses) SetPersistentTopicReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicReplicatorDispatchRateResponse, error) {
	rsp, err := c.SetPersistentTopicReplicatorDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicReplicatorDispatchRateResponse(rsp)
}

// RemovePersistentTopicRetentionWithResponse request returning *RemovePersistentTopicRetentionResponse
func (c *ClientWithResponses) RemovePersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicRetentionResponse, error) {
	rsp, err := c.RemovePersistentTopicRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicRetentionResponse(rsp)
}

// GetPersistentTopicRetentionWithResponse request returning *GetPersistentTopicRetentionResponse
func (c *ClientWithResponses) GetPersistentTopicRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicRetentionParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicRetentionResponse, error) {
	rsp, err := c.GetPersistentTopicRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicRetentionResponse(rsp)
}

// SetPersistentTopicRetentionWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicRetentionResponse
func (c *ClientWithResponses) SetPersistentTopicRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicRetentionResponse, error) {
	rsp, err := c.SetPersistentTopicRetentionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicRetentionResponse(rsp)
}

// RemovePersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *RemovePersistentTopicSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) RemovePersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.RemovePersistentTopicSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicSchemaCompatibilityStrategyResponse(rsp)
}

// GetPersistentTopicSchemaCompatibilityStrategyWithResponse request returning *GetPersistentTopicSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) GetPersistentTopicSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.GetPersistentTopicSchemaCompatibilityStrategy(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSchemaCompatibilityStrategyResponse(rsp)
}

// SetPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) SetPersistentTopicSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.SetPersistentTopicSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicSchemaCompatibilityStrategyResponse(rsp)
}

// GetPersistentTopicSchemaValidationEnforcedWithResponse request returning *GetPersistentTopicSchemaValidationEnforcedResponse
func (c *ClientWithResponses) GetPersistentTopicSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSchemaValidationEnforcedResponse, error) {
	rsp, err := c.GetPersistentTopicSchemaValidationEnforced(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSchemaValidationEnforcedResponse(rsp)
}

// SetPersistentTopicSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicSchemaValidationEnforcedResponse
func (c *ClientWithResponses) SetPersistentTopicSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSchemaValidationEnforcedResponse, error) {
	rsp, err := c.SetPersistentTopicSchemaValidationEnforcedWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicSchemaValidationEnforcedResponse(rsp)
}

// DeletePersistentTopicShadowTopicsWithResponse request returning *DeletePersistentTopicShadowTopicsResponse
func (c *ClientWithResponses) DeletePersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeletePersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicShadowTopicsResponse, error) {
	rsp, err := c.DeletePersistentTopicShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicShadowTopicsResponse(rsp)
}

// GetPersistentTopicShadowTopicsWithResponse request returning *GetPersistentTopicShadowTopicsResponse
func (c *ClientWithResponses) GetPersistentTopicShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicShadowTopicsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicShadowTopicsResponse, error) {
	rsp, err := c.GetPersistentTopicShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicShadowTopicsResponse(rsp)
}

// SetPersistentTopicShadowTopicsWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicShadowTopicsResponse
func (c *ClientWithResponses) SetPersistentTopicShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicShadowTopicsResponse, error) {
	rsp, err := c.SetPersistentTopicShadowTopicsWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicShadowTopicsResponse(rsp)
}

// GetPersistentTopicStatsWithResponse request returning *GetPersistentTopicStatsResponse
func (c *ClientWithResponses) GetPersistentTopicStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicStatsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicStatsResponse, error) {
	rsp, err := c.GetPersistentTopicStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicStatsResponse(rsp)
}

// RemovePersistentTopicSubscribeRateWithBodyWithResponse request with arbitrary body returning *RemovePersistentTopicSubscribeRateResponse
func (c *ClientWithResponses) RemovePersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscribeRateResponse, error) {
	rsp, err := c.RemovePersistentTopicSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicSubscribeRateResponse(rsp)
}

// GetPersistentTopicSubscribeRateWithResponse request returning *GetPersistentTopicSubscribeRateResponse
func (c *ClientWithResponses) GetPersistentTopicSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscribeRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscribeRateResponse, error) {
	rsp, err := c.GetPersistentTopicSubscribeRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSubscribeRateResponse(rsp)
}

// SetPersistentTopicSubscribeRateWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicSubscribeRateResponse
func (c *ClientWithResponses) SetPersistentTopicSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscribeRateResponse, error) {
	rsp, err := c.SetPersistentTopicSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicSubscribeRateResponse(rsp)
}

// DeletePersistentTopicSubscriptionWithResponse request returning *DeletePersistentTopicSubscriptionResponse
func (c *ClientWithResponses) DeletePersistentTopicSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *DeletePersistentTopicSubscriptionParams, reqEditors ...RequestEditorFn) (*DeletePersistentTopicSubscriptionResponse, error) {
	rsp, err := c.DeletePersistentTopicSubscription(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistentTopicSubscriptionResponse(rsp)
}

// AnalyzePersistentTopicSubscriptionBacklogWithBodyWithResponse request with arbitrary body returning *AnalyzePersistentTopicSubscriptionBacklogResponse
func (c *ClientWithResponses) AnalyzePersistentTopicSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *AnalyzePersistentTopicSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AnalyzePersistentTopicSubscriptionBacklogResponse, error) {
	rsp, err := c.AnalyzePersistentTopicSubscriptionBacklogWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnalyzePersistentTopicSubscriptionBacklogResponse(rsp)
}

// ExpirePersistentTopicMessagesWithBodyWithResponse request with arbitrary body returning *ExpirePersistentTopicMessagesResponse
func (c *ClientWithResponses) ExpirePersistentTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ExpirePersistentTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpirePersistentTopicMessagesResponse, error) {
	rsp, err := c.ExpirePersistentTopicMessagesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpirePersistentTopicMessagesResponse(rsp)
}

// ExpirePersistentTopicMessagesTimeInSecondsWithResponse request returning *ExpirePersistentTopicMessagesTimeInSecondsResponse
func (c *ClientWithResponses) ExpirePersistentTopicMessagesTimeInSecondsWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *ExpirePersistentTopicMessagesTimeInSecondsParams, reqEditors ...RequestEditorFn) (*ExpirePersistentTopicMessagesTimeInSecondsResponse, error) {
	rsp, err := c.ExpirePersistentTopicMessagesTimeInSeconds(ctx, tenant, namespace, topic, subName, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpirePersistentTopicMessagesTimeInSecondsResponse(rsp)
}

// PeekPersistentTopicNthMessageWithResponse request returning *PeekPersistentTopicNthMessageResponse
func (c *ClientWithResponses) PeekPersistentTopicNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PeekPersistentTopicNthMessageParams, reqEditors ...RequestEditorFn) (*PeekPersistentTopicNthMessageResponse, error) {
	rsp, err := c.PeekPersistentTopicNthMessage(ctx, tenant, namespace, topic, subName, messagePosition, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePeekPersistentTopicNthMessageResponse(rsp)
}

// GetPersistentTopicSubscriptionPropertiesWithResponse request returning *GetPersistentTopicSubscriptionPropertiesResponse
func (c *ClientWithResponses) GetPersistentTopicSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionPropertiesResponse, error) {
	rsp, err := c.GetPersistentTopicSubscriptionProperties(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSubscriptionPropertiesResponse(rsp)
}

// UpdatePersistentTopicSubscriptionPropertiesWithBodyWithResponse request with arbitrary body returning *UpdatePersistentTopicSubscriptionPropertiesResponse
func (c *ClientWithResponses) UpdatePersistentTopicSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *UpdatePersistentTopicSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePersistentTopicSubscriptionPropertiesResponse, error) {
	rsp, err := c.UpdatePersistentTopicSubscriptionPropertiesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePersistentTopicSubscriptionPropertiesResponse(rsp)
}

// GetPersistentTopicReplicatedSubscriptionStatusWithResponse request returning *GetPersistentTopicReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) GetPersistentTopicReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.GetPersistentTopicReplicatedSubscriptionStatus(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicReplicatedSubscriptionStatusResponse(rsp)
}

// SetPersistentTopicReplicatedSubscriptionStatusWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) SetPersistentTopicReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.SetPersistentTopicReplicatedSubscriptionStatusWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicReplicatedSubscriptionStatusResponse(rsp)
}

// ResetPersistentTopicCursorOnPositionWithBodyWithResponse request with arbitrary body returning *ResetPersistentTopicCursorOnPositionResponse
func (c *ClientWithResponses) ResetPersistentTopicCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *ResetPersistentTopicCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPersistentTopicCursorOnPositionResponse, error) {
	rsp, err := c.ResetPersistentTopicCursorOnPositionWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPersistentTopicCursorOnPositionResponse(rsp)
}

// ResetPersistentTopicCursorWithResponse request returning *ResetPersistentTopicCursorResponse
func (c *ClientWithResponses) ResetPersistentTopicCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *ResetPersistentTopicCursorParams, reqEditors ...RequestEditorFn) (*ResetPersistentTopicCursorResponse, error) {
	rsp, err := c.ResetPersistentTopicCursor(ctx, tenant, namespace, topic, subName, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPersistentTopicCursorResponse(rsp)
}

// SkipPersistentTopicMessagesWithResponse request returning *SkipPersistentTopicMessagesResponse
func (c *ClientWithResponses) SkipPersistentTopicMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *SkipPersistentTopicMessagesParams, reqEditors ...RequestEditorFn) (*SkipPersistentTopicMessagesResponse, error) {
	rsp, err := c.SkipPersistentTopicMessages(ctx, tenant, namespace, topic, subName, numMessages, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipPersistentTopicMessagesResponse(rsp)
}

// SkipPersistentTopicAllMessagesWithResponse request returning *SkipPersistentTopicAllMessagesResponse
func (c *ClientWithResponses) SkipPersistentTopicAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SkipPersistentTopicAllMessagesParams, reqEditors ...RequestEditorFn) (*SkipPersistentTopicAllMessagesResponse, error) {
	rsp, err := c.SkipPersistentTopicAllMessages(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipPersistentTopicAllMessagesResponse(rsp)
}

// CreatePersistentTopicSubscriptionWithBodyWithResponse request with arbitrary body returning *CreatePersistentTopicSubscriptionResponse
func (c *ClientWithResponses) CreatePersistentTopicSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *CreatePersistentTopicSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePersistentTopicSubscriptionResponse, error) {
	rsp, err := c.CreatePersistentTopicSubscriptionWithBody(ctx, tenant, namespace, topic, subscriptionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePersistentTopicSubscriptionResponse(rsp)
}

// RemovePersistentTopicSubscriptionDispatchRateWithResponse request returning *RemovePersistentTopicSubscriptionDispatchRateResponse
func (c *ClientWithResponses) RemovePersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscriptionDispatchRateResponse, error) {
	rsp, err := c.RemovePersistentTopicSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicSubscriptionDispatchRateResponse(rsp)
}

// GetPersistentTopicSubscriptionDispatchRateWithResponse request returning *GetPersistentTopicSubscriptionDispatchRateResponse
func (c *ClientWithResponses) GetPersistentTopicSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionDispatchRateResponse, error) {
	rsp, err := c.GetPersistentTopicSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSubscriptionDispatchRateResponse(rsp)
}

// SetPersistentTopicSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicSubscriptionDispatchRateResponse
func (c *ClientWithResponses) SetPersistentTopicSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscriptionDispatchRateResponse, error) {
	rsp, err := c.SetPersistentTopicSubscriptionDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicSubscriptionDispatchRateResponse(rsp)
}

// RemovePersistentTopicSubscriptionTypesEnabledWithResponse request returning *RemovePersistentTopicSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) RemovePersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *RemovePersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.RemovePersistentTopicSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicSubscriptionTypesEnabledResponse(rsp)
}

// GetPersistentTopicSubscriptionTypesEnabledWithResponse request returning *GetPersistentTopicSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) GetPersistentTopicSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.GetPersistentTopicSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSubscriptionTypesEnabledResponse(rsp)
}

// SetPersistentTopicSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) SetPersistentTopicSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SetPersistentTopicSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.SetPersistentTopicSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicSubscriptionTypesEnabledResponse(rsp)
}

// GetPersistentTopicSubscriptionsWithResponse request returning *GetPersistentTopicSubscriptionsResponse
func (c *ClientWithResponses) GetPersistentTopicSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetPersistentTopicSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionsResponse, error) {
	rsp, err := c.GetPersistentTopicSubscriptions(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSubscriptionsResponse(rsp)
}

// TerminatePersistentTopicWithResponse request returning *TerminatePersistentTopicResponse
func (c *ClientWithResponses) TerminatePersistentTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicParams, reqEditors ...RequestEditorFn) (*TerminatePersistentTopicResponse, error) {
	rsp, err := c.TerminatePersistentTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminatePersistentTopicResponse(rsp)
}

// TerminatePersistentTopicPartitionedTopicWithResponse request returning *TerminatePersistentTopicPartitionedTopicResponse
func (c *ClientWithResponses) TerminatePersistentTopicPartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TerminatePersistentTopicPartitionedTopicParams, reqEditors ...RequestEditorFn) (*TerminatePersistentTopicPartitionedTopicResponse, error) {
	rsp, err := c.TerminatePersistentTopicPartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminatePersistentTopicPartitionedTopicResponse(rsp)
}

// TruncatePersistentTopicTopicWithResponse request returning *TruncatePersistentTopicTopicResponse
func (c *ClientWithResponses) TruncatePersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TruncatePersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*TruncatePersistentTopicTopicResponse, error) {
	rsp, err := c.TruncatePersistentTopicTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTruncatePersistentTopicTopicResponse(rsp)
}

// UnloadPersistentTopicTopicWithResponse request returning *UnloadPersistentTopicTopicResponse
func (c *ClientWithResponses) UnloadPersistentTopicTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *UnloadPersistentTopicTopicParams, reqEditors ...RequestEditorFn) (*UnloadPersistentTopicTopicResponse, error) {
	rsp, err := c.UnloadPersistentTopicTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnloadPersistentTopicTopicResponse(rsp)
}

// RemovePersistentTopicSubscriptionLevelDispatchRateWithResponse request returning *RemovePersistentTopicSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) RemovePersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *RemovePersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*RemovePersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.RemovePersistentTopicSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePersistentTopicSubscriptionLevelDispatchRateResponse(rsp)
}

// GetPersistentTopicSubscriptionLevelDispatchRateWithResponse request returning *GetPersistentTopicSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) GetPersistentTopicSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *GetPersistentTopicSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*GetPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.GetPersistentTopicSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistentTopicSubscriptionLevelDispatchRateResponse(rsp)
}

// SetPersistentTopicSubscriptionLevelDispatchRateWithBodyWithResponse request with arbitrary body returning *SetPersistentTopicSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) SetPersistentTopicSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *SetPersistentTopicSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.SetPersistentTopicSubscriptionLevelDispatchRateWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPersistentTopicSubscriptionLevelDispatchRateResponse(rsp)
}

// GetDefaultResourceQuotaWithResponse request returning *GetDefaultResourceQuotaResponse
func (c *ClientWithResponses) GetDefaultResourceQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultResourceQuotaResponse, error) {
	rsp, err := c.GetDefaultResourceQuota(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultResourceQuotaResponse(rsp)
}

// SetDefaultResourceQuotaWithBodyWithResponse request with arbitrary body returning *SetDefaultResourceQuotaResponse
func (c *ClientWithResponses) SetDefaultResourceQuotaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error) {
	rsp, err := c.SetDefaultResourceQuotaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultResourceQuotaResponse(rsp)
}

func (c *ClientWithResponses) SetDefaultResourceQuotaWithResponse(ctx context.Context, body SetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetDefaultResourceQuotaResponse, error) {
	rsp, err := c.SetDefaultResourceQuota(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultResourceQuotaResponse(rsp)
}

// RemoveNamespaceBundleResourceQuotaWithResponse request returning *RemoveNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) RemoveNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*RemoveNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.RemoveNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNamespaceBundleResourceQuotaResponse(rsp)
}

// GetNamespaceBundleResourceQuotaWithResponse request returning *GetNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) GetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*GetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.GetNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamespaceBundleResourceQuotaResponse(rsp)
}

// SetNamespaceBundleResourceQuotaWithBodyWithResponse request with arbitrary body returning *SetNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) SetNamespaceBundleResourceQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.SetNamespaceBundleResourceQuotaWithBody(ctx, tenant, namespace, bundle, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceBundleResourceQuotaResponse(rsp)
}

func (c *ClientWithResponses) SetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, body SetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*SetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.SetNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetNamespaceBundleResourceQuotaResponse(rsp)
}

// GetResourceGroupsWithResponse request returning *GetResourceGroupsResponse
func (c *ClientWithResponses) GetResourceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetResourceGroupsResponse, error) {
	rsp, err := c.GetResourceGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceGroupsResponse(rsp)
}

// DeleteResourceGroupWithResponse request returning *DeleteResourceGroupResponse
func (c *ClientWithResponses) DeleteResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*DeleteResourceGroupResponse, error) {
	rsp, err := c.DeleteResourceGroup(ctx, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceGroupResponse(rsp)
}

// GetResourceGroupWithResponse request returning *GetResourceGroupResponse
func (c *ClientWithResponses) GetResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*GetResourceGroupResponse, error) {
	rsp, err := c.GetResourceGroup(ctx, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceGroupResponse(rsp)
}

// CreateOrUpdateResourceGroupWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateResourceGroupResponse
func (c *ClientWithResponses) CreateOrUpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error) {
	rsp, err := c.CreateOrUpdateResourceGroupWithBody(ctx, resourcegroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateResourceGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateResourceGroupWithResponse(ctx context.Context, resourcegroup string, body CreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateResourceGroupResponse, error) {
	rsp, err := c.CreateOrUpdateResourceGroup(ctx, resourcegroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateResourceGroupResponse(rsp)
}

// TestCompatibilityWithBodyWithResponse request with arbitrary body returning *TestCompatibilityResponse
func (c *ClientWithResponses) TestCompatibilityWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error) {
	rsp, err := c.TestCompatibilityWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestCompatibilityResponse(rsp)
}

func (c *ClientWithResponses) TestCompatibilityWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *TestCompatibilityParams, body TestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*TestCompatibilityResponse, error) {
	rsp, err := c.TestCompatibility(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestCompatibilityResponse(rsp)
}

// DeleteSchemaWithResponse request returning *DeleteSchemaResponse
func (c *ClientWithResponses) DeleteSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResponse, error) {
	rsp, err := c.DeleteSchema(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSchemaResponse(rsp)
}

// GetSchemaOfTopicWithResponse request returning *GetSchemaOfTopicResponse
func (c *ClientWithResponses) GetSchemaOfTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetSchemaOfTopicParams, reqEditors ...RequestEditorFn) (*GetSchemaOfTopicResponse, error) {
	rsp, err := c.GetSchemaOfTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaOfTopicResponse(rsp)
}

// PostSchemaWithBodyWithResponse request with arbitrary body returning *PostSchemaResponse
func (c *ClientWithResponses) PostSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error) {
	rsp, err := c.PostSchemaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemaResponse(rsp)
}

func (c *ClientWithResponses) PostSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PostSchemaParams, body PostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchemaResponse, error) {
	rsp, err := c.PostSchema(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchemaResponse(rsp)
}

// GetSchemaOfTopicGivenVersionWithResponse request returning *GetSchemaOfTopicGivenVersionResponse
func (c *ClientWithResponses) GetSchemaOfTopicGivenVersionWithResponse(ctx context.Context, tenant string, namespace string, topic string, version string, params *GetSchemaOfTopicGivenVersionParams, reqEditors ...RequestEditorFn) (*GetSchemaOfTopicGivenVersionResponse, error) {
	rsp, err := c.GetSchemaOfTopicGivenVersion(ctx, tenant, namespace, topic, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaOfTopicGivenVersionResponse(rsp)
}

// GetAllSchemasWithResponse request returning *GetAllSchemasResponse
func (c *ClientWithResponses) GetAllSchemasWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetAllSchemasParams, reqEditors ...RequestEditorFn) (*GetAllSchemasResponse, error) {
	rsp, err := c.GetAllSchemas(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSchemasResponse(rsp)
}

// GetVersionBySchemaWithBodyWithResponse request with arbitrary body returning *GetVersionBySchemaResponse
func (c *ClientWithResponses) GetVersionBySchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error) {
	rsp, err := c.GetVersionBySchemaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionBySchemaResponse(rsp)
}

func (c *ClientWithResponses) GetVersionBySchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *GetVersionBySchemaParams, body GetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionBySchemaResponse, error) {
	rsp, err := c.GetVersionBySchema(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionBySchemaResponse(rsp)
}

// GetTenantsWithResponse request returning *GetTenantsResponse
func (c *ClientWithResponses) GetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTenantsResponse, error) {
	rsp, err := c.GetTenants(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantsResponse(rsp)
}

// DeleteTenantWithResponse request returning *DeleteTenantResponse
func (c *ClientWithResponses) DeleteTenantWithResponse(ctx context.Context, tenant string, params *DeleteTenantParams, reqEditors ...RequestEditorFn) (*DeleteTenantResponse, error) {
	rsp, err := c.DeleteTenant(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTenantResponse(rsp)
}

// GetTenantAdminWithResponse request returning *GetTenantAdminResponse
func (c *ClientWithResponses) GetTenantAdminWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*GetTenantAdminResponse, error) {
	rsp, err := c.GetTenantAdmin(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantAdminResponse(rsp)
}

// UpdateTenantWithBodyWithResponse request with arbitrary body returning *UpdateTenantResponse
func (c *ClientWithResponses) UpdateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenantWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

func (c *ClientWithResponses) UpdateTenantWithResponse(ctx context.Context, tenant string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenant(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

// CreateTenantWithBodyWithResponse request with arbitrary body returning *CreateTenantResponse
func (c *ClientWithResponses) CreateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenantWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

func (c *ClientWithResponses) CreateTenantWithResponse(ctx context.Context, tenant string, body CreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTenantResponse, error) {
	rsp, err := c.CreateTenant(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTenantResponse(rsp)
}

// GetWorkerStatsWithResponse request returning *GetWorkerStatsResponse
func (c *ClientWithResponses) GetWorkerStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerStatsResponse, error) {
	rsp, err := c.GetWorkerStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkerStatsResponse(rsp)
}

// GetWorkerStatsMetricsWithResponse request returning *GetWorkerStatsMetricsResponse
func (c *ClientWithResponses) GetWorkerStatsMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerStatsMetricsResponse, error) {
	rsp, err := c.GetWorkerStatsMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkerStatsMetricsResponse(rsp)
}

// GetAssignmentsWithResponse request returning *GetAssignmentsResponse
func (c *ClientWithResponses) GetAssignmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAssignmentsResponse, error) {
	rsp, err := c.GetAssignments(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssignmentsResponse(rsp)
}

// GetWorkerClusterWithResponse request returning *GetWorkerClusterResponse
func (c *ClientWithResponses) GetWorkerClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerClusterResponse, error) {
	rsp, err := c.GetWorkerCluster(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkerClusterResponse(rsp)
}

// GetWorkerClusterLeaderWithResponse request returning *GetWorkerClusterLeaderResponse
func (c *ClientWithResponses) GetWorkerClusterLeaderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkerClusterLeaderResponse, error) {
	rsp, err := c.GetWorkerClusterLeader(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkerClusterLeaderResponse(rsp)
}

// IsLeaderReadyWithResponse request returning *IsLeaderReadyResponse
func (c *ClientWithResponses) IsLeaderReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsLeaderReadyResponse, error) {
	rsp, err := c.IsLeaderReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsLeaderReadyResponse(rsp)
}

// GetConnectorsListWithResponse request returning *GetConnectorsListResponse
func (c *ClientWithResponses) GetConnectorsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectorsListResponse, error) {
	rsp, err := c.GetConnectorsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorsListResponse(rsp)
}

// GetDrainStatusWithResponse request returning *GetDrainStatusResponse
func (c *ClientWithResponses) GetDrainStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDrainStatusResponse, error) {
	rsp, err := c.GetDrainStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDrainStatusResponse(rsp)
}

// DrainWithResponse request returning *DrainResponse
func (c *ClientWithResponses) DrainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DrainResponse, error) {
	rsp, err := c.Drain(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDrainResponse(rsp)
}

// GetDrainStatusFromLeaderWithResponse request returning *GetDrainStatusFromLeaderResponse
func (c *ClientWithResponses) GetDrainStatusFromLeaderWithResponse(ctx context.Context, params *GetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*GetDrainStatusFromLeaderResponse, error) {
	rsp, err := c.GetDrainStatusFromLeader(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDrainStatusFromLeaderResponse(rsp)
}

// DrainAtLeaderWithResponse request returning *DrainAtLeaderResponse
func (c *ClientWithResponses) DrainAtLeaderWithResponse(ctx context.Context, params *DrainAtLeaderParams, reqEditors ...RequestEditorFn) (*DrainAtLeaderResponse, error) {
	rsp, err := c.DrainAtLeader(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDrainAtLeaderResponse(rsp)
}

// RebalanceWithResponse request returning *RebalanceResponse
func (c *ClientWithResponses) RebalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RebalanceResponse, error) {
	rsp, err := c.Rebalance(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebalanceResponse(rsp)
}

// ParseGetAllBookiesResponse parses an HTTP response from a GetAllBookiesWithResponse call
func ParseGetAllBookiesResponse(rsp *http.Response) (*GetAllBookiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBookiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookiesClusterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBookiesRackInfoResponse parses an HTTP response from a GetBookiesRackInfoWithResponse call
func ParseGetBookiesRackInfoResponse(rsp *http.Response) (*GetBookiesRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookiesRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]map[string]BookieInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBookieRackInfoResponse parses an HTTP response from a DeleteBookieRackInfoWithResponse call
func ParseDeleteBookieRackInfoResponse(rsp *http.Response) (*DeleteBookieRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBookieRackInfoResponse parses an HTTP response from a GetBookieRackInfoWithResponse call
func ParseGetBookieRackInfoResponse(rsp *http.Response) (*GetBookieRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookieInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBookieRackInfoResponse parses an HTTP response from a UpdateBookieRackInfoWithResponse call
func ParseUpdateBookieRackInfoResponse(rsp *http.Response) (*UpdateBookieRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAllocatorStatsResponse parses an HTTP response from a GetAllocatorStatsWithResponse call
func ParseGetAllocatorStatsResponse(rsp *http.Response) (*GetAllocatorStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllocatorStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllocatorStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPendingBookieOpsStatsResponse parses an HTTP response from a GetPendingBookieOpsStatsWithResponse call
func ParseGetPendingBookieOpsStatsResponse(rsp *http.Response) (*GetPendingBookieOpsStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingBookieOpsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]PendingBookieOpsStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBrokerResourceAvailabilityResponse parses an HTTP response from a GetBrokerResourceAvailabilityWithResponse call
func ParseGetBrokerResourceAvailabilityResponse(rsp *http.Response) (*GetBrokerResourceAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrokerResourceAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]ResourceUnit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLoadReportResponse parses an HTTP response from a GetLoadReportWithResponse call
func ParseGetLoadReportResponse(rsp *http.Response) (*GetLoadReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoadReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMBeansResponse parses an HTTP response from a GetMBeansWithResponse call
func ParseGetMBeansResponse(rsp *http.Response) (*GetMBeansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMBeansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBrokerStatsMetricsResponse parses an HTTP response from a GetBrokerStatsMetricsWithResponse call
func ParseGetBrokerStatsMetricsResponse(rsp *http.Response) (*GetBrokerStatsMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrokerStatsMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopics2Response parses an HTTP response from a GetTopics2WithResponse call
func ParseGetTopics2Response(rsp *http.Response) (*GetTopics2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopics2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OutputStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActiveBrokersResponse parses an HTTP response from a GetActiveBrokersWithResponse call
func ParseGetActiveBrokersResponse(rsp *http.Response) (*GetActiveBrokersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActiveBrokersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBacklogQuotaCheckResponse parses an HTTP response from a BacklogQuotaCheckWithResponse call
func ParseBacklogQuotaCheckResponse(rsp *http.Response) (*BacklogQuotaCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BacklogQuotaCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDynamicConfigurationNameResponse parses an HTTP response from a GetDynamicConfigurationNameWithResponse call
func ParseGetDynamicConfigurationNameResponse(rsp *http.Response) (*GetDynamicConfigurationNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDynamicConfigurationNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuntimeConfigurationResponse parses an HTTP response from a GetRuntimeConfigurationWithResponse call
func ParseGetRuntimeConfigurationResponse(rsp *http.Response) (*GetRuntimeConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAllDynamicConfigurationsResponse parses an HTTP response from a GetAllDynamicConfigurationsWithResponse call
func ParseGetAllDynamicConfigurationsResponse(rsp *http.Response) (*GetAllDynamicConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDynamicConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDynamicConfigurationResponse parses an HTTP response from a DeleteDynamicConfigurationWithResponse call
func ParseDeleteDynamicConfigurationResponse(rsp *http.Response) (*DeleteDynamicConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDynamicConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateDynamicConfigurationResponse parses an HTTP response from a UpdateDynamicConfigurationWithResponse call
func ParseUpdateDynamicConfigurationResponse(rsp *http.Response) (*UpdateDynamicConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDynamicConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInternalConfigurationDataResponse parses an HTTP response from a GetInternalConfigurationDataWithResponse call
func ParseGetInternalConfigurationDataResponse(rsp *http.Response) (*GetInternalConfigurationDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInternalConfigurationDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternalConfigurationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLeaderBrokerResponse parses an HTTP response from a GetLeaderBrokerWithResponse call
func ParseGetLeaderBrokerResponse(rsp *http.Response) (*GetLeaderBrokerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLeaderBrokerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrokerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsReadyResponse parses an HTTP response from a IsReadyWithResponse call
func ParseIsReadyResponse(rsp *http.Response) (*IsReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseShutDownBrokerGracefullyResponse parses an HTTP response from a ShutDownBrokerGracefullyWithResponse call
func ParseShutDownBrokerGracefullyResponse(rsp *http.Response) (*ShutDownBrokerGracefullyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShutDownBrokerGracefullyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVersionResponse parses an HTTP response from a VersionWithResponse call
func ParseVersionResponse(rsp *http.Response) (*VersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOwnedNamespacesResponse parses an HTTP response from a GetOwnedNamespacesWithResponse call
func ParseGetOwnedNamespacesResponse(rsp *http.Response) (*GetOwnedNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOwnedNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]NamespaceOwnershipStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActiveClusterBrokersResponse parses an HTTP response from a GetActiveClusterBrokersWithResponse call
func ParseGetActiveClusterBrokersResponse(rsp *http.Response) (*GetActiveClusterBrokersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActiveClusterBrokersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClustersResponse parses an HTTP response from a GetClustersWithResponse call
func ParseGetClustersResponse(rsp *http.Response) (*GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFailureDomainsResponse parses an HTTP response from a GetFailureDomainsWithResponse call
func ParseGetFailureDomainsResponse(rsp *http.Response) (*GetFailureDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFailureDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]FailureDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFailureDomainResponse parses an HTTP response from a DeleteFailureDomainWithResponse call
func ParseDeleteFailureDomainResponse(rsp *http.Response) (*DeleteFailureDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFailureDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDomainResponse parses an HTTP response from a GetDomainWithResponse call
func ParseGetDomainResponse(rsp *http.Response) (*GetDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FailureDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetFailureDomainResponse parses an HTTP response from a SetFailureDomainWithResponse call
func ParseSetFailureDomainResponse(rsp *http.Response) (*SetFailureDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetFailureDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceIsolationPoliciesResponse parses an HTTP response from a GetNamespaceIsolationPoliciesWithResponse call
func ParseGetNamespaceIsolationPoliciesResponse(rsp *http.Response) (*GetNamespaceIsolationPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceIsolationPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]NamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBrokersWithNamespaceIsolationPolicyResponse parses an HTTP response from a GetBrokersWithNamespaceIsolationPolicyWithResponse call
func ParseGetBrokersWithNamespaceIsolationPolicyResponse(rsp *http.Response) (*GetBrokersWithNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrokersWithNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BrokerNamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBrokerWithNamespaceIsolationPolicyResponse parses an HTTP response from a GetBrokerWithNamespaceIsolationPolicyWithResponse call
func ParseGetBrokerWithNamespaceIsolationPolicyResponse(rsp *http.Response) (*GetBrokerWithNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrokerWithNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrokerNamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNamespaceIsolationPolicyResponse parses an HTTP response from a DeleteNamespaceIsolationPolicyWithResponse call
func ParseDeleteNamespaceIsolationPolicyResponse(rsp *http.Response) (*DeleteNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceIsolationPolicyResponse parses an HTTP response from a GetNamespaceIsolationPolicyWithResponse call
func ParseGetNamespaceIsolationPolicyResponse(rsp *http.Response) (*GetNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceIsolationPolicyResponse parses an HTTP response from a SetNamespaceIsolationPolicyWithResponse call
func ParseSetNamespaceIsolationPolicyResponse(rsp *http.Response) (*SetNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPeerClusterResponse parses an HTTP response from a GetPeerClusterWithResponse call
func ParseGetPeerClusterResponse(rsp *http.Response) (*GetPeerClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetPeerClusterNamesResponse parses an HTTP response from a SetPeerClusterNamesWithResponse call
func ParseSetPeerClusterNamesResponse(rsp *http.Response) (*SetPeerClusterNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPeerClusterNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAntiAffinityNamespacesResponse parses an HTTP response from a GetAntiAffinityNamespacesWithResponse call
func ParseGetAntiAffinityNamespacesResponse(rsp *http.Response) (*GetAntiAffinityNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAntiAffinityNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBookieAffinityGroupResponse parses an HTTP response from a DeleteBookieAffinityGroupWithResponse call
func ParseDeleteBookieAffinityGroupResponse(rsp *http.Response) (*DeleteBookieAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBookieAffinityGroupResponse parses an HTTP response from a GetBookieAffinityGroupWithResponse call
func ParseGetBookieAffinityGroupResponse(rsp *http.Response) (*GetBookieAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookieAffinityGroupData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTenantNamespacesResponse parses an HTTP response from a GetTenantNamespacesWithResponse call
func ParseGetTenantNamespacesResponse(rsp *http.Response) (*GetTenantNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNamespaceResponse parses an HTTP response from a DeleteNamespaceWithResponse call
func ParseDeleteNamespaceResponse(rsp *http.Response) (*DeleteNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPoliciesResponse parses an HTTP response from a GetPoliciesWithResponse call
func ParseGetPoliciesResponse(rsp *http.Response) (*GetPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNamespaceResponse parses an HTTP response from a CreateNamespaceWithResponse call
func ParseCreateNamespaceResponse(rsp *http.Response) (*CreateNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceAntiAffinityGroupResponse parses an HTTP response from a RemoveNamespaceAntiAffinityGroupWithResponse call
func ParseRemoveNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*RemoveNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceAntiAffinityGroupResponse parses an HTTP response from a GetNamespaceAntiAffinityGroupWithResponse call
func ParseGetNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*GetNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceAntiAffinityGroupResponse parses an HTTP response from a SetNamespaceAntiAffinityGroupWithResponse call
func ParseSetNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*SetNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveAutoSubscriptionCreationResponse parses an HTTP response from a RemoveAutoSubscriptionCreationWithResponse call
func ParseRemoveAutoSubscriptionCreationResponse(rsp *http.Response) (*RemoveAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAutoSubscriptionCreationResponse parses an HTTP response from a GetAutoSubscriptionCreationWithResponse call
func ParseGetAutoSubscriptionCreationResponse(rsp *http.Response) (*GetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetAutoSubscriptionCreationResponse parses an HTTP response from a SetAutoSubscriptionCreationWithResponse call
func ParseSetAutoSubscriptionCreationResponse(rsp *http.Response) (*SetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveAutoTopicCreationResponse parses an HTTP response from a RemoveAutoTopicCreationWithResponse call
func ParseRemoveAutoTopicCreationResponse(rsp *http.Response) (*RemoveAutoTopicCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAutoTopicCreationResponse parses an HTTP response from a GetAutoTopicCreationWithResponse call
func ParseGetAutoTopicCreationResponse(rsp *http.Response) (*GetAutoTopicCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetAutoTopicCreationResponse parses an HTTP response from a SetAutoTopicCreationWithResponse call
func ParseSetAutoTopicCreationResponse(rsp *http.Response) (*SetAutoTopicCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamesapceBacklogQuotaResponse parses an HTTP response from a RemoveNamesapceBacklogQuotaWithResponse call
func ParseRemoveNamesapceBacklogQuotaResponse(rsp *http.Response) (*RemoveNamesapceBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamesapceBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceBacklogQuotaResponse parses an HTTP response from a SetNamespaceBacklogQuotaWithResponse call
func ParseSetNamespaceBacklogQuotaResponse(rsp *http.Response) (*SetNamespaceBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceBacklogQuotaMapResponse parses an HTTP response from a GetNamespaceBacklogQuotaMapWithResponse call
func ParseGetNamespaceBacklogQuotaMapResponse(rsp *http.Response) (*GetNamespaceBacklogQuotaMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBundlesDataResponse parses an HTTP response from a GetBundlesDataWithResponse call
func ParseGetBundlesDataResponse(rsp *http.Response) (*GetBundlesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBundlesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBacklogResponse parses an HTTP response from a ClearNamespaceBacklogWithResponse call
func ParseClearNamespaceBacklogResponse(rsp *http.Response) (*ClearNamespaceBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBacklogForSubscriptionResponse parses an HTTP response from a ClearNamespaceBacklogForSubscriptionWithResponse call
func ParseClearNamespaceBacklogForSubscriptionResponse(rsp *http.Response) (*ClearNamespaceBacklogForSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBacklogForSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCompactionThresholdResponse parses an HTTP response from a DeleteCompactionThresholdWithResponse call
func ParseDeleteCompactionThresholdResponse(rsp *http.Response) (*DeleteCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceCompactionThresholdResponse parses an HTTP response from a GetNamespaceCompactionThresholdWithResponse call
func ParseGetNamespaceCompactionThresholdResponse(rsp *http.Response) (*GetNamespaceCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceCompactionThresholdResponse parses an HTTP response from a SetNamespaceCompactionThresholdWithResponse call
func ParseSetNamespaceCompactionThresholdResponse(rsp *http.Response) (*SetNamespaceCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceDeduplicationResponse parses an HTTP response from a RemoveNamespaceDeduplicationWithResponse call
func ParseRemoveNamespaceDeduplicationResponse(rsp *http.Response) (*RemoveNamespaceDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceDeduplicationResponse parses an HTTP response from a GetNamespaceDeduplicationWithResponse call
func ParseGetNamespaceDeduplicationResponse(rsp *http.Response) (*GetNamespaceDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyDeduplicationResponse parses an HTTP response from a ModifyDeduplicationWithResponse call
func ParseModifyDeduplicationResponse(rsp *http.Response) (*ModifyDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceDeduplicationSnapshotIntervalResponse parses an HTTP response from a GetNamespaceDeduplicationSnapshotIntervalWithResponse call
func ParseGetNamespaceDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*GetNamespaceDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceDeduplicationSnapshotIntervalResponse parses an HTTP response from a SetNamespaceDeduplicationSnapshotIntervalWithResponse call
func ParseSetNamespaceDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*SetNamespaceDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveDelayedDeliveryPoliciesResponse parses an HTTP response from a RemoveDelayedDeliveryPoliciesWithResponse call
func ParseRemoveDelayedDeliveryPoliciesResponse(rsp *http.Response) (*RemoveDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceDelayedDeliveryPoliciesResponse parses an HTTP response from a GetNamespaceDelayedDeliveryPoliciesWithResponse call
func ParseGetNamespaceDelayedDeliveryPoliciesResponse(rsp *http.Response) (*GetNamespaceDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceDelayedDeliveryPoliciesResponse parses an HTTP response from a SetNamespaceDelayedDeliveryPoliciesWithResponse call
func ParseSetNamespaceDelayedDeliveryPoliciesResponse(rsp *http.Response) (*SetNamespaceDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDispatchRateResponse parses an HTTP response from a DeleteDispatchRateWithResponse call
func ParseDeleteDispatchRateResponse(rsp *http.Response) (*DeleteDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceDispatchRateResponse parses an HTTP response from a GetNamespaceDispatchRateWithResponse call
func ParseGetNamespaceDispatchRateResponse(rsp *http.Response) (*GetNamespaceDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceDispatchRateResponse parses an HTTP response from a SetNamespaceDispatchRateWithResponse call
func ParseSetNamespaceDispatchRateResponse(rsp *http.Response) (*SetNamespaceDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEncryptionRequiredResponse parses an HTTP response from a GetEncryptionRequiredWithResponse call
func ParseGetEncryptionRequiredResponse(rsp *http.Response) (*GetEncryptionRequiredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEncryptionRequiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseModifyEncryptionRequiredResponse parses an HTTP response from a ModifyEncryptionRequiredWithResponse call
func ParseModifyEncryptionRequiredResponse(rsp *http.Response) (*ModifyEncryptionRequiredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyEncryptionRequiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceEntryFiltersResponse parses an HTTP response from a RemoveNamespaceEntryFiltersWithResponse call
func ParseRemoveNamespaceEntryFiltersResponse(rsp *http.Response) (*RemoveNamespaceEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceEntryFiltersPerTopicResponse parses an HTTP response from a GetNamespaceEntryFiltersPerTopicWithResponse call
func ParseGetNamespaceEntryFiltersPerTopicResponse(rsp *http.Response) (*GetNamespaceEntryFiltersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceEntryFiltersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetEntryFiltersPerTopicResponse parses an HTTP response from a SetEntryFiltersPerTopicWithResponse call
func ParseSetEntryFiltersPerTopicResponse(rsp *http.Response) (*SetEntryFiltersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEntryFiltersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveInactiveTopicPoliciesResponse parses an HTTP response from a RemoveInactiveTopicPoliciesWithResponse call
func ParseRemoveInactiveTopicPoliciesResponse(rsp *http.Response) (*RemoveInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceInactiveTopicPoliciesResponse parses an HTTP response from a GetNamespaceInactiveTopicPoliciesWithResponse call
func ParseGetNamespaceInactiveTopicPoliciesResponse(rsp *http.Response) (*GetNamespaceInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceInactiveTopicPoliciesResponse parses an HTTP response from a SetNamespaceInactiveTopicPoliciesWithResponse call
func ParseSetNamespaceInactiveTopicPoliciesResponse(rsp *http.Response) (*SetNamespaceInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIsAllowAutoUpdateSchemaResponse parses an HTTP response from a GetIsAllowAutoUpdateSchemaWithResponse call
func ParseGetIsAllowAutoUpdateSchemaResponse(rsp *http.Response) (*GetIsAllowAutoUpdateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIsAllowAutoUpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetIsAllowAutoUpdateSchemaResponse parses an HTTP response from a SetIsAllowAutoUpdateSchemaWithResponse call
func ParseSetIsAllowAutoUpdateSchemaResponse(rsp *http.Response) (*SetIsAllowAutoUpdateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIsAllowAutoUpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMaxConsumersPerSubscriptionResponse parses an HTTP response from a RemoveNamespaceMaxConsumersPerSubscriptionWithResponse call
func ParseRemoveNamespaceMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*RemoveNamespaceMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMaxConsumersPerSubscriptionResponse parses an HTTP response from a GetNamespaceMaxConsumersPerSubscriptionWithResponse call
func ParseGetNamespaceMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*GetNamespaceMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceMaxConsumersPerSubscriptionResponse parses an HTTP response from a SetNamespaceMaxConsumersPerSubscriptionWithResponse call
func ParseSetNamespaceMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*SetNamespaceMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMaxConsumersPerTopicResponse parses an HTTP response from a RemoveNamespaceMaxConsumersPerTopicWithResponse call
func ParseRemoveNamespaceMaxConsumersPerTopicResponse(rsp *http.Response) (*RemoveNamespaceMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMaxConsumersPerTopicResponse parses an HTTP response from a GetNamespaceMaxConsumersPerTopicWithResponse call
func ParseGetNamespaceMaxConsumersPerTopicResponse(rsp *http.Response) (*GetNamespaceMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceMaxConsumersPerTopicResponse parses an HTTP response from a SetNamespaceMaxConsumersPerTopicWithResponse call
func ParseSetNamespaceMaxConsumersPerTopicResponse(rsp *http.Response) (*SetNamespaceMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMaxProducersPerTopicResponse parses an HTTP response from a RemoveNamespaceMaxProducersPerTopicWithResponse call
func ParseRemoveNamespaceMaxProducersPerTopicResponse(rsp *http.Response) (*RemoveNamespaceMaxProducersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMaxProducersPerTopicResponse parses an HTTP response from a GetNamespaceMaxProducersPerTopicWithResponse call
func ParseGetNamespaceMaxProducersPerTopicResponse(rsp *http.Response) (*GetNamespaceMaxProducersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceMaxProducersPerTopicResponse parses an HTTP response from a SetNamespaceMaxProducersPerTopicWithResponse call
func ParseSetNamespaceMaxProducersPerTopicResponse(rsp *http.Response) (*SetNamespaceMaxProducersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMaxSubscriptionsPerTopicResponse parses an HTTP response from a RemoveNamespaceMaxSubscriptionsPerTopicWithResponse call
func ParseRemoveNamespaceMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*RemoveNamespaceMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMaxSubscriptionsPerTopicResponse parses an HTTP response from a GetNamespaceMaxSubscriptionsPerTopicWithResponse call
func ParseGetNamespaceMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*GetNamespaceMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceMaxSubscriptionsPerTopicResponse parses an HTTP response from a SetNamespaceMaxSubscriptionsPerTopicWithResponse call
func ParseSetNamespaceMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*SetNamespaceMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNamespaceMaxTopicsPerNamespaceResponse parses an HTTP response from a DeleteNamespaceMaxTopicsPerNamespaceWithResponse call
func ParseDeleteNamespaceMaxTopicsPerNamespaceResponse(rsp *http.Response) (*DeleteNamespaceMaxTopicsPerNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceMaxTopicsPerNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMaxTopicsPerNamespaceResponse parses an HTTP response from a GetNamespaceMaxTopicsPerNamespaceWithResponse call
func ParseGetNamespaceMaxTopicsPerNamespaceResponse(rsp *http.Response) (*GetNamespaceMaxTopicsPerNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMaxTopicsPerNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceMaxTopicsPerNamespaceResponse parses an HTTP response from a SetNamespaceMaxTopicsPerNamespaceWithResponse call
func ParseSetNamespaceMaxTopicsPerNamespaceResponse(rsp *http.Response) (*SetNamespaceMaxTopicsPerNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMaxTopicsPerNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMaxUnackedmessagesPerConsumerResponse parses an HTTP response from a RemoveNamespaceMaxUnackedmessagesPerConsumerWithResponse call
func ParseRemoveNamespaceMaxUnackedmessagesPerConsumerResponse(rsp *http.Response) (*RemoveNamespaceMaxUnackedmessagesPerConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMaxUnackedmessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMaxUnackedMessagesPerConsumerResponse parses an HTTP response from a GetNamespaceMaxUnackedMessagesPerConsumerWithResponse call
func ParseGetNamespaceMaxUnackedMessagesPerConsumerResponse(rsp *http.Response) (*GetNamespaceMaxUnackedMessagesPerConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMaxUnackedMessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceMaxUnackedMessagesPerConsumerResponse parses an HTTP response from a SetNamespaceMaxUnackedMessagesPerConsumerWithResponse call
func ParseSetNamespaceMaxUnackedMessagesPerConsumerResponse(rsp *http.Response) (*SetNamespaceMaxUnackedMessagesPerConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMaxUnackedMessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse parses an HTTP response from a RemoveNamespaceMaxUnackedmessagesPerSubscriptionWithResponse call
func ParseRemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse(rsp *http.Response) (*RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMaxUnackedmessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMaxUnackedmessagesPerSubscriptionResponse parses an HTTP response from a GetNamespaceMaxUnackedmessagesPerSubscriptionWithResponse call
func ParseGetNamespaceMaxUnackedmessagesPerSubscriptionResponse(rsp *http.Response) (*GetNamespaceMaxUnackedmessagesPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMaxUnackedmessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceMaxUnackedMessagesPerSubscriptionResponse parses an HTTP response from a SetNamespaceMaxUnackedMessagesPerSubscriptionWithResponse call
func ParseSetNamespaceMaxUnackedMessagesPerSubscriptionResponse(rsp *http.Response) (*SetNamespaceMaxUnackedMessagesPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMaxUnackedMessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceMessageTTLResponse parses an HTTP response from a RemoveNamespaceMessageTTLWithResponse call
func ParseRemoveNamespaceMessageTTLResponse(rsp *http.Response) (*RemoveNamespaceMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceMessageTTLResponse parses an HTTP response from a GetNamespaceMessageTTLWithResponse call
func ParseGetNamespaceMessageTTLResponse(rsp *http.Response) (*GetNamespaceMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceMessageTTLResponse parses an HTTP response from a SetNamespaceMessageTTLWithResponse call
func ParseSetNamespaceMessageTTLResponse(rsp *http.Response) (*SetNamespaceMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearOffloadDeletionLagResponse parses an HTTP response from a ClearOffloadDeletionLagWithResponse call
func ParseClearOffloadDeletionLagResponse(rsp *http.Response) (*ClearOffloadDeletionLagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceOffloadDeletionLagResponse parses an HTTP response from a GetNamespaceOffloadDeletionLagWithResponse call
func ParseGetNamespaceOffloadDeletionLagResponse(rsp *http.Response) (*GetNamespaceOffloadDeletionLagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceOffloadDeletionLagResponse parses an HTTP response from a SetNamespaceOffloadDeletionLagWithResponse call
func ParseSetNamespaceOffloadDeletionLagResponse(rsp *http.Response) (*SetNamespaceOffloadDeletionLagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceOffloadPoliciesResponse parses an HTTP response from a GetNamespaceOffloadPoliciesWithResponse call
func ParseGetNamespaceOffloadPoliciesResponse(rsp *http.Response) (*GetNamespaceOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceOffloadPoliciesResponse parses an HTTP response from a SetNamespaceOffloadPoliciesWithResponse call
func ParseSetNamespaceOffloadPoliciesResponse(rsp *http.Response) (*SetNamespaceOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceOffloadThresholdResponse parses an HTTP response from a GetNamespaceOffloadThresholdWithResponse call
func ParseGetNamespaceOffloadThresholdResponse(rsp *http.Response) (*GetNamespaceOffloadThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceOffloadThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceOffloadThresholdResponse parses an HTTP response from a SetNamespaceOffloadThresholdWithResponse call
func ParseSetNamespaceOffloadThresholdResponse(rsp *http.Response) (*SetNamespaceOffloadThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceOffloadThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPermissionsResponse parses an HTTP response from a GetPermissionsWithResponse call
func ParseGetPermissionsResponse(rsp *http.Response) (*GetPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPermissionOnSubscriptionResponse parses an HTTP response from a GetPermissionOnSubscriptionWithResponse call
func ParseGetPermissionOnSubscriptionResponse(rsp *http.Response) (*GetPermissionOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokePermissionsOnNamespaceResponse parses an HTTP response from a RevokePermissionsOnNamespaceWithResponse call
func ParseRevokePermissionsOnNamespaceResponse(rsp *http.Response) (*RevokePermissionsOnNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePermissionsOnNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGrantPermissionOnNamespaceResponse parses an HTTP response from a GrantPermissionOnNamespaceWithResponse call
func ParseGrantPermissionOnNamespaceResponse(rsp *http.Response) (*GrantPermissionOnNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantPermissionOnNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistenceResponse parses an HTTP response from a DeletePersistenceWithResponse call
func ParseDeletePersistenceResponse(rsp *http.Response) (*DeletePersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespacePersistenceResponse parses an HTTP response from a GetNamespacePersistenceWithResponse call
func ParseGetNamespacePersistenceResponse(rsp *http.Response) (*GetNamespacePersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespacePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespacePersistenceResponse parses an HTTP response from a SetNamespacePersistenceWithResponse call
func ParseSetNamespacePersistenceResponse(rsp *http.Response) (*SetNamespacePersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespacePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetBookieAffinityGroupResponse parses an HTTP response from a SetBookieAffinityGroupWithResponse call
func ParseSetBookieAffinityGroupResponse(rsp *http.Response) (*SetBookieAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearPropertiesResponse parses an HTTP response from a ClearPropertiesWithResponse call
func ParseClearPropertiesResponse(rsp *http.Response) (*ClearPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespacePropertiesResponse parses an HTTP response from a GetNamespacePropertiesWithResponse call
func ParseGetNamespacePropertiesResponse(rsp *http.Response) (*GetNamespacePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespacePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPropertiesResponse parses an HTTP response from a SetPropertiesWithResponse call
func ParseSetPropertiesResponse(rsp *http.Response) (*SetPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePropertyResponse parses an HTTP response from a RemovePropertyWithResponse call
func ParseRemovePropertyResponse(rsp *http.Response) (*RemovePropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPropertyResponse parses an HTTP response from a GetPropertyWithResponse call
func ParseGetPropertyResponse(rsp *http.Response) (*GetPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPropertyResponse parses an HTTP response from a SetPropertyWithResponse call
func ParseSetPropertyResponse(rsp *http.Response) (*SetPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceOffloadPoliciesResponse parses an HTTP response from a RemoveNamespaceOffloadPoliciesWithResponse call
func ParseRemoveNamespaceOffloadPoliciesResponse(rsp *http.Response) (*RemoveNamespaceOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceReplicationClustersResponse parses an HTTP response from a GetNamespaceReplicationClustersWithResponse call
func ParseGetNamespaceReplicationClustersResponse(rsp *http.Response) (*GetNamespaceReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetNamespaceReplicationClustersResponse parses an HTTP response from a SetNamespaceReplicationClustersWithResponse call
func ParseSetNamespaceReplicationClustersResponse(rsp *http.Response) (*SetNamespaceReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceReplicatorDispatchRateResponse parses an HTTP response from a RemoveNamespaceReplicatorDispatchRateWithResponse call
func ParseRemoveNamespaceReplicatorDispatchRateResponse(rsp *http.Response) (*RemoveNamespaceReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceReplicatorDispatchRateResponse parses an HTTP response from a GetNamespaceReplicatorDispatchRateWithResponse call
func ParseGetNamespaceReplicatorDispatchRateResponse(rsp *http.Response) (*GetNamespaceReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceReplicatorDispatchRateResponse parses an HTTP response from a SetNamespaceReplicatorDispatchRateWithResponse call
func ParseSetNamespaceReplicatorDispatchRateResponse(rsp *http.Response) (*SetNamespaceReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceResourceGroupResponse parses an HTTP response from a RemoveNamespaceResourceGroupWithResponse call
func ParseRemoveNamespaceResourceGroupResponse(rsp *http.Response) (*RemoveNamespaceResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceResourceGroupResponse parses an HTTP response from a GetNamespaceResourceGroupWithResponse call
func ParseGetNamespaceResourceGroupResponse(rsp *http.Response) (*GetNamespaceResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceResourceGroupResponse parses an HTTP response from a SetNamespaceResourceGroupWithResponse call
func ParseSetNamespaceResourceGroupResponse(rsp *http.Response) (*SetNamespaceResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceRetentionResponse parses an HTTP response from a RemoveNamespaceRetentionWithResponse call
func ParseRemoveNamespaceRetentionResponse(rsp *http.Response) (*RemoveNamespaceRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceRetentionResponse parses an HTTP response from a GetNamespaceRetentionWithResponse call
func ParseGetNamespaceRetentionResponse(rsp *http.Response) (*GetNamespaceRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceRetentionResponse parses an HTTP response from a SetNamespaceRetentionWithResponse call
func ParseSetNamespaceRetentionResponse(rsp *http.Response) (*SetNamespaceRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseScanOffloadedLedgersResponse parses an HTTP response from a ScanOffloadedLedgersWithResponse call
func ParseScanOffloadedLedgersResponse(rsp *http.Response) (*ScanOffloadedLedgersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScanOffloadedLedgersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaAutoUpdateCompatibilityStrategyResponse parses an HTTP response from a GetSchemaAutoUpdateCompatibilityStrategyWithResponse call
func ParseGetSchemaAutoUpdateCompatibilityStrategyResponse(rsp *http.Response) (*GetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaAutoUpdateCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetSchemaAutoUpdateCompatibilityStrategyResponse parses an HTTP response from a SetSchemaAutoUpdateCompatibilityStrategyWithResponse call
func ParseSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp *http.Response) (*SetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSchemaAutoUpdateCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceSchemaCompatibilityStrategyResponse parses an HTTP response from a GetNamespaceSchemaCompatibilityStrategyWithResponse call
func ParseGetNamespaceSchemaCompatibilityStrategyResponse(rsp *http.Response) (*GetNamespaceSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceSchemaCompatibilityStrategyResponse parses an HTTP response from a SetNamespaceSchemaCompatibilityStrategyWithResponse call
func ParseSetNamespaceSchemaCompatibilityStrategyResponse(rsp *http.Response) (*SetNamespaceSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSchemaValidtionEnforcedResponse parses an HTTP response from a GetSchemaValidtionEnforcedWithResponse call
func ParseGetSchemaValidtionEnforcedResponse(rsp *http.Response) (*GetSchemaValidtionEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaValidtionEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceSchemaValidationEnforcedResponse parses an HTTP response from a SetNamespaceSchemaValidationEnforcedWithResponse call
func ParseSetNamespaceSchemaValidationEnforcedResponse(rsp *http.Response) (*SetNamespaceSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubscribeRateResponse parses an HTTP response from a DeleteSubscribeRateWithResponse call
func ParseDeleteSubscribeRateResponse(rsp *http.Response) (*DeleteSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceSubscribeRateResponse parses an HTTP response from a GetNamespaceSubscribeRateWithResponse call
func ParseGetNamespaceSubscribeRateResponse(rsp *http.Response) (*GetNamespaceSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceSubscribeRateResponse parses an HTTP response from a SetNamespaceSubscribeRateWithResponse call
func ParseSetNamespaceSubscribeRateResponse(rsp *http.Response) (*SetNamespaceSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionAuthModeResponse parses an HTTP response from a GetSubscriptionAuthModeWithResponse call
func ParseGetSubscriptionAuthModeResponse(rsp *http.Response) (*GetSubscriptionAuthModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionAuthModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceSubscriptionAuthModeResponse parses an HTTP response from a SetNamespaceSubscriptionAuthModeWithResponse call
func ParseSetNamespaceSubscriptionAuthModeResponse(rsp *http.Response) (*SetNamespaceSubscriptionAuthModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceSubscriptionAuthModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubscriptionDispatchRateResponse parses an HTTP response from a DeleteSubscriptionDispatchRateWithResponse call
func ParseDeleteSubscriptionDispatchRateResponse(rsp *http.Response) (*DeleteSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceSubscriptionDispatchRateResponse parses an HTTP response from a GetNamespaceSubscriptionDispatchRateWithResponse call
func ParseGetNamespaceSubscriptionDispatchRateResponse(rsp *http.Response) (*GetNamespaceSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceSubscriptionDispatchRateResponse parses an HTTP response from a SetNamespaceSubscriptionDispatchRateWithResponse call
func ParseSetNamespaceSubscriptionDispatchRateResponse(rsp *http.Response) (*SetNamespaceSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSubscriptionExpirationTimeResponse parses an HTTP response from a RemoveSubscriptionExpirationTimeWithResponse call
func ParseRemoveSubscriptionExpirationTimeResponse(rsp *http.Response) (*RemoveSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubscriptionExpirationTimeResponse parses an HTTP response from a GetSubscriptionExpirationTimeWithResponse call
func ParseGetSubscriptionExpirationTimeResponse(rsp *http.Response) (*GetSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceSubscriptionExpirationTimeResponse parses an HTTP response from a SetNamespaceSubscriptionExpirationTimeWithResponse call
func ParseSetNamespaceSubscriptionExpirationTimeResponse(rsp *http.Response) (*SetNamespaceSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNamespaceSubscriptionTypesEnabledResponse parses an HTTP response from a RemoveNamespaceSubscriptionTypesEnabledWithResponse call
func ParseRemoveNamespaceSubscriptionTypesEnabledResponse(rsp *http.Response) (*RemoveNamespaceSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceSubscriptionTypesEnabledResponse parses an HTTP response from a GetNamespaceSubscriptionTypesEnabledWithResponse call
func ParseGetNamespaceSubscriptionTypesEnabledResponse(rsp *http.Response) (*GetNamespaceSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceSubscriptionTypesEnabledResponse parses an HTTP response from a SetNamespaceSubscriptionTypesEnabledWithResponse call
func ParseSetNamespaceSubscriptionTypesEnabledResponse(rsp *http.Response) (*SetNamespaceSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTopicsResponse parses an HTTP response from a GetTopicsWithResponse call
func ParseGetTopicsResponse(rsp *http.Response) (*GetTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnloadNamespaceResponse parses an HTTP response from a UnloadNamespaceWithResponse call
func ParseUnloadNamespaceResponse(rsp *http.Response) (*UnloadNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnsubscribeNamespaceResponse parses an HTTP response from a UnsubscribeNamespaceWithResponse call
func ParseUnsubscribeNamespaceResponse(rsp *http.Response) (*UnsubscribeNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsubscribeNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNamespaceBundleResponse parses an HTTP response from a DeleteNamespaceBundleWithResponse call
func ParseDeleteNamespaceBundleResponse(rsp *http.Response) (*DeleteNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBundleBacklogResponse parses an HTTP response from a ClearNamespaceBundleBacklogWithResponse call
func ParseClearNamespaceBundleBacklogResponse(rsp *http.Response) (*ClearNamespaceBundleBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBundleBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClearNamespaceBundleBacklogForSubscriptionResponse parses an HTTP response from a ClearNamespaceBundleBacklogForSubscriptionWithResponse call
func ParseClearNamespaceBundleBacklogForSubscriptionResponse(rsp *http.Response) (*ClearNamespaceBundleBacklogForSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearNamespaceBundleBacklogForSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSplitNamespaceBundleResponse parses an HTTP response from a SplitNamespaceBundleWithResponse call
func ParseSplitNamespaceBundleResponse(rsp *http.Response) (*SplitNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SplitNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTopicHashPositionsResponse parses an HTTP response from a GetTopicHashPositionsWithResponse call
func ParseGetTopicHashPositionsResponse(rsp *http.Response) (*GetTopicHashPositionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopicHashPositionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnloadNamespaceBundleResponse parses an HTTP response from a UnloadNamespaceBundleWithResponse call
func ParseUnloadNamespaceBundleResponse(rsp *http.Response) (*UnloadNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnsubscribeNamespaceBundleResponse parses an HTTP response from a UnsubscribeNamespaceBundleWithResponse call
func ParseUnsubscribeNamespaceBundleResponse(rsp *http.Response) (*UnsubscribeNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsubscribeNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicListResponse parses an HTTP response from a GetNonPersistentTopicListWithResponse call
func ParseGetNonPersistentTopicListResponse(rsp *http.Response) (*GetNonPersistentTopicListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNonPersistentPartitionedTopicListResponse parses an HTTP response from a GetNonPersistentPartitionedTopicListWithResponse call
func ParseGetNonPersistentPartitionedTopicListResponse(rsp *http.Response) (*GetNonPersistentPartitionedTopicListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentPartitionedTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetListFromBundleResponse parses an HTTP response from a GetListFromBundleWithResponse call
func ParseGetListFromBundleResponse(rsp *http.Response) (*GetListFromBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListFromBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNonPersistentTopicResponse parses an HTTP response from a DeleteNonPersistentTopicWithResponse call
func ParseDeleteNonPersistentTopicResponse(rsp *http.Response) (*DeleteNonPersistentTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNonPersistentTopicNonPartitionedTopicResponse parses an HTTP response from a CreateNonPersistentTopicNonPartitionedTopicWithResponse call
func ParseCreateNonPersistentTopicNonPartitionedTopicResponse(rsp *http.Response) (*CreateNonPersistentTopicNonPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNonPersistentTopicNonPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireNonPersistentTopicMessagesForAllSubscriptionsResponse parses an HTTP response from a ExpireNonPersistentTopicMessagesForAllSubscriptionsWithResponse call
func ParseExpireNonPersistentTopicMessagesForAllSubscriptionsResponse(rsp *http.Response) (*ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireNonPersistentTopicMessagesForAllSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicBacklogResponse parses an HTTP response from a GetNonPersistentTopicBacklogWithResponse call
func ParseGetNonPersistentTopicBacklogResponse(rsp *http.Response) (*GetNonPersistentTopicBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicBacklogQuotaResponse parses an HTTP response from a RemoveNonPersistentTopicBacklogQuotaWithResponse call
func ParseRemoveNonPersistentTopicBacklogQuotaResponse(rsp *http.Response) (*RemoveNonPersistentTopicBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicBacklogQuotaResponse parses an HTTP response from a SetNonPersistentTopicBacklogQuotaWithResponse call
func ParseSetNonPersistentTopicBacklogQuotaResponse(rsp *http.Response) (*SetNonPersistentTopicBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicBacklogQuotaMapResponse parses an HTTP response from a GetNonPersistentTopicBacklogQuotaMapWithResponse call
func ParseGetNonPersistentTopicBacklogQuotaMapResponse(rsp *http.Response) (*GetNonPersistentTopicBacklogQuotaMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicBacklogSizeByMessageIdResponse parses an HTTP response from a GetNonPersistentTopicBacklogSizeByMessageIdWithResponse call
func ParseGetNonPersistentTopicBacklogSizeByMessageIdResponse(rsp *http.Response) (*GetNonPersistentTopicBacklogSizeByMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicBacklogSizeByMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicCompactionStatusResponse parses an HTTP response from a GetNonPersistentTopicCompactionStatusWithResponse call
func ParseGetNonPersistentTopicCompactionStatusResponse(rsp *http.Response) (*GetNonPersistentTopicCompactionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicCompactionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompactNonPersistentTopicResponse parses an HTTP response from a CompactNonPersistentTopicWithResponse call
func ParseCompactNonPersistentTopicResponse(rsp *http.Response) (*CompactNonPersistentTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompactNonPersistentTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicCompactionThresholdResponse parses an HTTP response from a RemoveNonPersistentTopicCompactionThresholdWithResponse call
func ParseRemoveNonPersistentTopicCompactionThresholdResponse(rsp *http.Response) (*RemoveNonPersistentTopicCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicCompactionThresholdResponse parses an HTTP response from a GetNonPersistentTopicCompactionThresholdWithResponse call
func ParseGetNonPersistentTopicCompactionThresholdResponse(rsp *http.Response) (*GetNonPersistentTopicCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicCompactionThresholdResponse parses an HTTP response from a SetNonPersistentTopicCompactionThresholdWithResponse call
func ParseSetNonPersistentTopicCompactionThresholdResponse(rsp *http.Response) (*SetNonPersistentTopicCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNonPersistentTopicMissedPartitionsResponse parses an HTTP response from a CreateNonPersistentTopicMissedPartitionsWithResponse call
func ParseCreateNonPersistentTopicMissedPartitionsResponse(rsp *http.Response) (*CreateNonPersistentTopicMissedPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNonPersistentTopicMissedPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicDeduplicationResponse parses an HTTP response from a RemoveNonPersistentTopicDeduplicationWithResponse call
func ParseRemoveNonPersistentTopicDeduplicationResponse(rsp *http.Response) (*RemoveNonPersistentTopicDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicDeduplicationResponse parses an HTTP response from a GetNonPersistentTopicDeduplicationWithResponse call
func ParseGetNonPersistentTopicDeduplicationResponse(rsp *http.Response) (*GetNonPersistentTopicDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicDeduplicationResponse parses an HTTP response from a SetNonPersistentTopicDeduplicationWithResponse call
func ParseSetNonPersistentTopicDeduplicationResponse(rsp *http.Response) (*SetNonPersistentTopicDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse parses an HTTP response from a DeleteNonPersistentTopicDeduplicationSnapshotIntervalWithResponse call
func ParseDeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicDeduplicationSnapshotIntervalResponse parses an HTTP response from a GetNonPersistentTopicDeduplicationSnapshotIntervalWithResponse call
func ParseGetNonPersistentTopicDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*GetNonPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicDeduplicationSnapshotIntervalResponse parses an HTTP response from a SetNonPersistentTopicDeduplicationSnapshotIntervalWithResponse call
func ParseSetNonPersistentTopicDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*SetNonPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicDelayedDeliveryPoliciesResponse parses an HTTP response from a DeleteNonPersistentTopicDelayedDeliveryPoliciesWithResponse call
func ParseDeleteNonPersistentTopicDelayedDeliveryPoliciesResponse(rsp *http.Response) (*DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicDelayedDeliveryPoliciesResponse parses an HTTP response from a GetNonPersistentTopicDelayedDeliveryPoliciesWithResponse call
func ParseGetNonPersistentTopicDelayedDeliveryPoliciesResponse(rsp *http.Response) (*GetNonPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicDelayedDeliveryPoliciesResponse parses an HTTP response from a SetNonPersistentTopicDelayedDeliveryPoliciesWithResponse call
func ParseSetNonPersistentTopicDelayedDeliveryPoliciesResponse(rsp *http.Response) (*SetNonPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicDispatchRateResponse parses an HTTP response from a RemoveNonPersistentTopicDispatchRateWithResponse call
func ParseRemoveNonPersistentTopicDispatchRateResponse(rsp *http.Response) (*RemoveNonPersistentTopicDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicDispatchRateResponse parses an HTTP response from a GetNonPersistentTopicDispatchRateWithResponse call
func ParseGetNonPersistentTopicDispatchRateResponse(rsp *http.Response) (*GetNonPersistentTopicDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicDispatchRateResponse parses an HTTP response from a SetNonPersistentTopicDispatchRateWithResponse call
func ParseSetNonPersistentTopicDispatchRateResponse(rsp *http.Response) (*SetNonPersistentTopicDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicEntryFiltersResponse parses an HTTP response from a RemoveNonPersistentTopicEntryFiltersWithResponse call
func ParseRemoveNonPersistentTopicEntryFiltersResponse(rsp *http.Response) (*RemoveNonPersistentTopicEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicEntryFiltersResponse parses an HTTP response from a GetNonPersistentTopicEntryFiltersWithResponse call
func ParseGetNonPersistentTopicEntryFiltersResponse(rsp *http.Response) (*GetNonPersistentTopicEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicEntryFiltersResponse parses an HTTP response from a SetNonPersistentTopicEntryFiltersWithResponse call
func ParseSetNonPersistentTopicEntryFiltersResponse(rsp *http.Response) (*SetNonPersistentTopicEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExamineNonPersistentTopicMessageResponse parses an HTTP response from a ExamineNonPersistentTopicMessageWithResponse call
func ParseExamineNonPersistentTopicMessageResponse(rsp *http.Response) (*ExamineNonPersistentTopicMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExamineNonPersistentTopicMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicInactiveTopicPoliciesResponse parses an HTTP response from a DeleteNonPersistentTopicInactiveTopicPoliciesWithResponse call
func ParseDeleteNonPersistentTopicInactiveTopicPoliciesResponse(rsp *http.Response) (*DeleteNonPersistentTopicInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicInactiveTopicPoliciesResponse parses an HTTP response from a GetNonPersistentTopicInactiveTopicPoliciesWithResponse call
func ParseGetNonPersistentTopicInactiveTopicPoliciesResponse(rsp *http.Response) (*GetNonPersistentTopicInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicInactiveTopicPoliciesResponse parses an HTTP response from a SetNonPersistentTopicInactiveTopicPoliciesWithResponse call
func ParseSetNonPersistentTopicInactiveTopicPoliciesResponse(rsp *http.Response) (*SetNonPersistentTopicInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicManagedLedgerInfoResponse parses an HTTP response from a GetNonPersistentTopicManagedLedgerInfoWithResponse call
func ParseGetNonPersistentTopicManagedLedgerInfoResponse(rsp *http.Response) (*GetNonPersistentTopicManagedLedgerInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicManagedLedgerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicInternalStatsResponse parses an HTTP response from a GetNonPersistentTopicInternalStatsWithResponse call
func ParseGetNonPersistentTopicInternalStatsResponse(rsp *http.Response) (*GetNonPersistentTopicInternalStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicInternalStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicLastMessageIdResponse parses an HTTP response from a GetNonPersistentTopicLastMessageIdWithResponse call
func ParseGetNonPersistentTopicLastMessageIdResponse(rsp *http.Response) (*GetNonPersistentTopicLastMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicLastMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMessageByIdResponse parses an HTTP response from a GetNonPersistentTopicMessageByIdWithResponse call
func ParseGetNonPersistentTopicMessageByIdResponse(rsp *http.Response) (*GetNonPersistentTopicMessageByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMessageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicMaxConsumersResponse parses an HTTP response from a RemoveNonPersistentTopicMaxConsumersWithResponse call
func ParseRemoveNonPersistentTopicMaxConsumersResponse(rsp *http.Response) (*RemoveNonPersistentTopicMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMaxConsumersResponse parses an HTTP response from a GetNonPersistentTopicMaxConsumersWithResponse call
func ParseGetNonPersistentTopicMaxConsumersResponse(rsp *http.Response) (*GetNonPersistentTopicMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMaxConsumersResponse parses an HTTP response from a SetNonPersistentTopicMaxConsumersWithResponse call
func ParseSetNonPersistentTopicMaxConsumersResponse(rsp *http.Response) (*SetNonPersistentTopicMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse parses an HTTP response from a RemoveNonPersistentTopicMaxConsumersPerSubscriptionWithResponse call
func ParseRemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMaxConsumersPerSubscriptionResponse parses an HTTP response from a GetNonPersistentTopicMaxConsumersPerSubscriptionWithResponse call
func ParseGetNonPersistentTopicMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*GetNonPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMaxConsumersPerSubscriptionResponse parses an HTTP response from a SetNonPersistentTopicMaxConsumersPerSubscriptionWithResponse call
func ParseSetNonPersistentTopicMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*SetNonPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicMaxMessageSizeResponse parses an HTTP response from a RemoveNonPersistentTopicMaxMessageSizeWithResponse call
func ParseRemoveNonPersistentTopicMaxMessageSizeResponse(rsp *http.Response) (*RemoveNonPersistentTopicMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMaxMessageSizeResponse parses an HTTP response from a GetNonPersistentTopicMaxMessageSizeWithResponse call
func ParseGetNonPersistentTopicMaxMessageSizeResponse(rsp *http.Response) (*GetNonPersistentTopicMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMaxMessageSizeResponse parses an HTTP response from a SetNonPersistentTopicMaxMessageSizeWithResponse call
func ParseSetNonPersistentTopicMaxMessageSizeResponse(rsp *http.Response) (*SetNonPersistentTopicMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicMaxProducersResponse parses an HTTP response from a RemoveNonPersistentTopicMaxProducersWithResponse call
func ParseRemoveNonPersistentTopicMaxProducersResponse(rsp *http.Response) (*RemoveNonPersistentTopicMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMaxProducersResponse parses an HTTP response from a GetNonPersistentTopicMaxProducersWithResponse call
func ParseGetNonPersistentTopicMaxProducersResponse(rsp *http.Response) (*GetNonPersistentTopicMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMaxProducersResponse parses an HTTP response from a SetNonPersistentTopicMaxProducersWithResponse call
func ParseSetNonPersistentTopicMaxProducersResponse(rsp *http.Response) (*SetNonPersistentTopicMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse parses an HTTP response from a RemoveNonPersistentTopicMaxSubscriptionsPerTopicWithResponse call
func ParseRemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMaxSubscriptionsPerTopicResponse parses an HTTP response from a GetNonPersistentTopicMaxSubscriptionsPerTopicWithResponse call
func ParseGetNonPersistentTopicMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*GetNonPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMaxSubscriptionsPerTopicResponse parses an HTTP response from a SetNonPersistentTopicMaxSubscriptionsPerTopicWithResponse call
func ParseSetNonPersistentTopicMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*SetNonPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse call
func ParseDeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a GetNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse call
func ParseGetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a SetNonPersistentTopicMaxUnackedMessagesOnConsumerWithResponse call
func ParseSetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseDeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseGetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseSetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicMessageTTLResponse parses an HTTP response from a RemoveNonPersistentTopicMessageTTLWithResponse call
func ParseRemoveNonPersistentTopicMessageTTLResponse(rsp *http.Response) (*RemoveNonPersistentTopicMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMessageTTLResponse parses an HTTP response from a GetNonPersistentTopicMessageTTLWithResponse call
func ParseGetNonPersistentTopicMessageTTLResponse(rsp *http.Response) (*GetNonPersistentTopicMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicMessageTTLResponse parses an HTTP response from a SetNonPersistentTopicMessageTTLWithResponse call
func ParseSetNonPersistentTopicMessageTTLResponse(rsp *http.Response) (*SetNonPersistentTopicMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicMessageIdByTimestampResponse parses an HTTP response from a GetNonPersistentTopicMessageIdByTimestampWithResponse call
func ParseGetNonPersistentTopicMessageIdByTimestampResponse(rsp *http.Response) (*GetNonPersistentTopicMessageIdByTimestampResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicMessageIdByTimestampResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOffloadNonPersistentTopicStatusResponse parses an HTTP response from a OffloadNonPersistentTopicStatusWithResponse call
func ParseOffloadNonPersistentTopicStatusResponse(rsp *http.Response) (*OffloadNonPersistentTopicStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OffloadNonPersistentTopicStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTriggerNonPersistentTopicOffloadResponse parses an HTTP response from a TriggerNonPersistentTopicOffloadWithResponse call
func ParseTriggerNonPersistentTopicOffloadResponse(rsp *http.Response) (*TriggerNonPersistentTopicOffloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerNonPersistentTopicOffloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicOffloadPoliciesResponse parses an HTTP response from a RemoveNonPersistentTopicOffloadPoliciesWithResponse call
func ParseRemoveNonPersistentTopicOffloadPoliciesResponse(rsp *http.Response) (*RemoveNonPersistentTopicOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicOffloadPoliciesResponse parses an HTTP response from a GetNonPersistentTopicOffloadPoliciesWithResponse call
func ParseGetNonPersistentTopicOffloadPoliciesResponse(rsp *http.Response) (*GetNonPersistentTopicOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicOffloadPoliciesResponse parses an HTTP response from a SetNonPersistentTopicOffloadPoliciesWithResponse call
func ParseSetNonPersistentTopicOffloadPoliciesResponse(rsp *http.Response) (*SetNonPersistentTopicOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicPartitionedStatsResponse parses an HTTP response from a GetNonPersistentTopicPartitionedStatsWithResponse call
func ParseGetNonPersistentTopicPartitionedStatsResponse(rsp *http.Response) (*GetNonPersistentTopicPartitionedStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicPartitionedStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicPartitionedTopicResponse parses an HTTP response from a DeleteNonPersistentTopicPartitionedTopicWithResponse call
func ParseDeleteNonPersistentTopicPartitionedTopicResponse(rsp *http.Response) (*DeleteNonPersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicPartitionedMetadataResponse parses an HTTP response from a GetNonPersistentTopicPartitionedMetadataWithResponse call
func ParseGetNonPersistentTopicPartitionedMetadataResponse(rsp *http.Response) (*GetNonPersistentTopicPartitionedMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicPartitionedMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateNonPersistentTopicPartitionedTopicResponse parses an HTTP response from a UpdateNonPersistentTopicPartitionedTopicWithResponse call
func ParseUpdateNonPersistentTopicPartitionedTopicResponse(rsp *http.Response) (*UpdateNonPersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNonPersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNonPersistentTopicPartitionedTopicResponse parses an HTTP response from a CreateNonPersistentTopicPartitionedTopicWithResponse call
func ParseCreateNonPersistentTopicPartitionedTopicResponse(rsp *http.Response) (*CreateNonPersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNonPersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicPermissionsOnTopicResponse parses an HTTP response from a GetNonPersistentTopicPermissionsOnTopicWithResponse call
func ParseGetNonPersistentTopicPermissionsOnTopicResponse(rsp *http.Response) (*GetNonPersistentTopicPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse parses an HTTP response from a RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse call
func ParseRevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse(rsp *http.Response) (*RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeNonPersistentTopicNonPersistentTopicPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGrantNonPersistentTopicPermissionsOnTopicResponse parses an HTTP response from a GrantNonPersistentTopicPermissionsOnTopicWithResponse call
func ParseGrantNonPersistentTopicPermissionsOnTopicResponse(rsp *http.Response) (*GrantNonPersistentTopicPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantNonPersistentTopicPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicPersistenceResponse parses an HTTP response from a RemoveNonPersistentTopicPersistenceWithResponse call
func ParseRemoveNonPersistentTopicPersistenceResponse(rsp *http.Response) (*RemoveNonPersistentTopicPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicPersistenceResponse parses an HTTP response from a GetNonPersistentTopicPersistenceWithResponse call
func ParseGetNonPersistentTopicPersistenceResponse(rsp *http.Response) (*GetNonPersistentTopicPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicPersistenceResponse parses an HTTP response from a SetNonPersistentTopicPersistenceWithResponse call
func ParseSetNonPersistentTopicPersistenceResponse(rsp *http.Response) (*SetNonPersistentTopicPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicPropertiesResponse parses an HTTP response from a RemoveNonPersistentTopicPropertiesWithResponse call
func ParseRemoveNonPersistentTopicPropertiesResponse(rsp *http.Response) (*RemoveNonPersistentTopicPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicPropertiesResponse parses an HTTP response from a GetNonPersistentTopicPropertiesWithResponse call
func ParseGetNonPersistentTopicPropertiesResponse(rsp *http.Response) (*GetNonPersistentTopicPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateNonPersistentTopicPropertiesResponse parses an HTTP response from a UpdateNonPersistentTopicPropertiesWithResponse call
func ParseUpdateNonPersistentTopicPropertiesResponse(rsp *http.Response) (*UpdateNonPersistentTopicPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNonPersistentTopicPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicPublishRateResponse parses an HTTP response from a RemoveNonPersistentTopicPublishRateWithResponse call
func ParseRemoveNonPersistentTopicPublishRateResponse(rsp *http.Response) (*RemoveNonPersistentTopicPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicPublishRateResponse parses an HTTP response from a GetNonPersistentTopicPublishRateWithResponse call
func ParseGetNonPersistentTopicPublishRateResponse(rsp *http.Response) (*GetNonPersistentTopicPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicPublishRateResponse parses an HTTP response from a SetNonPersistentTopicPublishRateWithResponse call
func ParseSetNonPersistentTopicPublishRateResponse(rsp *http.Response) (*SetNonPersistentTopicPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicReplicationClustersResponse parses an HTTP response from a RemoveNonPersistentTopicReplicationClustersWithResponse call
func ParseRemoveNonPersistentTopicReplicationClustersResponse(rsp *http.Response) (*RemoveNonPersistentTopicReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicReplicationClustersResponse parses an HTTP response from a GetNonPersistentTopicReplicationClustersWithResponse call
func ParseGetNonPersistentTopicReplicationClustersResponse(rsp *http.Response) (*GetNonPersistentTopicReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicReplicationClustersResponse parses an HTTP response from a SetNonPersistentTopicReplicationClustersWithResponse call
func ParseSetNonPersistentTopicReplicationClustersResponse(rsp *http.Response) (*SetNonPersistentTopicReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicReplicatorDispatchRateResponse parses an HTTP response from a RemoveNonPersistentTopicReplicatorDispatchRateWithResponse call
func ParseRemoveNonPersistentTopicReplicatorDispatchRateResponse(rsp *http.Response) (*RemoveNonPersistentTopicReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicReplicatorDispatchRateResponse parses an HTTP response from a GetNonPersistentTopicReplicatorDispatchRateWithResponse call
func ParseGetNonPersistentTopicReplicatorDispatchRateResponse(rsp *http.Response) (*GetNonPersistentTopicReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicReplicatorDispatchRateResponse parses an HTTP response from a SetNonPersistentTopicReplicatorDispatchRateWithResponse call
func ParseSetNonPersistentTopicReplicatorDispatchRateResponse(rsp *http.Response) (*SetNonPersistentTopicReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicRetentionResponse parses an HTTP response from a RemoveNonPersistentTopicRetentionWithResponse call
func ParseRemoveNonPersistentTopicRetentionResponse(rsp *http.Response) (*RemoveNonPersistentTopicRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicRetentionResponse parses an HTTP response from a GetNonPersistentTopicRetentionWithResponse call
func ParseGetNonPersistentTopicRetentionResponse(rsp *http.Response) (*GetNonPersistentTopicRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicRetentionResponse parses an HTTP response from a SetNonPersistentTopicRetentionWithResponse call
func ParseSetNonPersistentTopicRetentionResponse(rsp *http.Response) (*SetNonPersistentTopicRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicSchemaCompatibilityStrategyResponse parses an HTTP response from a RemoveNonPersistentTopicSchemaCompatibilityStrategyWithResponse call
func ParseRemoveNonPersistentTopicSchemaCompatibilityStrategyResponse(rsp *http.Response) (*RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSchemaCompatibilityStrategyResponse parses an HTTP response from a GetNonPersistentTopicSchemaCompatibilityStrategyWithResponse call
func ParseGetNonPersistentTopicSchemaCompatibilityStrategyResponse(rsp *http.Response) (*GetNonPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicSchemaCompatibilityStrategyResponse parses an HTTP response from a SetNonPersistentTopicSchemaCompatibilityStrategyWithResponse call
func ParseSetNonPersistentTopicSchemaCompatibilityStrategyResponse(rsp *http.Response) (*SetNonPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSchemaValidationEnforcedResponse parses an HTTP response from a GetNonPersistentTopicSchemaValidationEnforcedWithResponse call
func ParseGetNonPersistentTopicSchemaValidationEnforcedResponse(rsp *http.Response) (*GetNonPersistentTopicSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicSchemaValidationEnforcedResponse parses an HTTP response from a SetNonPersistentTopicSchemaValidationEnforcedWithResponse call
func ParseSetNonPersistentTopicSchemaValidationEnforcedResponse(rsp *http.Response) (*SetNonPersistentTopicSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicShadowTopicsResponse parses an HTTP response from a DeleteNonPersistentTopicShadowTopicsWithResponse call
func ParseDeleteNonPersistentTopicShadowTopicsResponse(rsp *http.Response) (*DeleteNonPersistentTopicShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicShadowTopicsResponse parses an HTTP response from a GetNonPersistentTopicShadowTopicsWithResponse call
func ParseGetNonPersistentTopicShadowTopicsResponse(rsp *http.Response) (*GetNonPersistentTopicShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicShadowTopicsResponse parses an HTTP response from a SetNonPersistentTopicShadowTopicsWithResponse call
func ParseSetNonPersistentTopicShadowTopicsResponse(rsp *http.Response) (*SetNonPersistentTopicShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicStatsResponse parses an HTTP response from a GetNonPersistentTopicStatsWithResponse call
func ParseGetNonPersistentTopicStatsResponse(rsp *http.Response) (*GetNonPersistentTopicStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicSubscribeRateResponse parses an HTTP response from a RemoveNonPersistentTopicSubscribeRateWithResponse call
func ParseRemoveNonPersistentTopicSubscribeRateResponse(rsp *http.Response) (*RemoveNonPersistentTopicSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSubscribeRateResponse parses an HTTP response from a GetNonPersistentTopicSubscribeRateWithResponse call
func ParseGetNonPersistentTopicSubscribeRateResponse(rsp *http.Response) (*GetNonPersistentTopicSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicSubscribeRateResponse parses an HTTP response from a SetNonPersistentTopicSubscribeRateWithResponse call
func ParseSetNonPersistentTopicSubscribeRateResponse(rsp *http.Response) (*SetNonPersistentTopicSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNonPersistentTopicSubscriptionResponse parses an HTTP response from a DeleteNonPersistentTopicSubscriptionWithResponse call
func ParseDeleteNonPersistentTopicSubscriptionResponse(rsp *http.Response) (*DeleteNonPersistentTopicSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNonPersistentTopicSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAnalyzeNonPersistentTopicSubscriptionBacklogResponse parses an HTTP response from a AnalyzeNonPersistentTopicSubscriptionBacklogWithResponse call
func ParseAnalyzeNonPersistentTopicSubscriptionBacklogResponse(rsp *http.Response) (*AnalyzeNonPersistentTopicSubscriptionBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyzeNonPersistentTopicSubscriptionBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireNonPersistentTopicMessagesResponse parses an HTTP response from a ExpireNonPersistentTopicMessagesWithResponse call
func ParseExpireNonPersistentTopicMessagesResponse(rsp *http.Response) (*ExpireNonPersistentTopicMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireNonPersistentTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpireNonPersistentTopicMessagesTimeInSecondsResponse parses an HTTP response from a ExpireNonPersistentTopicMessagesTimeInSecondsWithResponse call
func ParseExpireNonPersistentTopicMessagesTimeInSecondsResponse(rsp *http.Response) (*ExpireNonPersistentTopicMessagesTimeInSecondsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireNonPersistentTopicMessagesTimeInSecondsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePeekNonPersistentTopicNthMessageResponse parses an HTTP response from a PeekNonPersistentTopicNthMessageWithResponse call
func ParsePeekNonPersistentTopicNthMessageResponse(rsp *http.Response) (*PeekNonPersistentTopicNthMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PeekNonPersistentTopicNthMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSubscriptionPropertiesResponse parses an HTTP response from a GetNonPersistentTopicSubscriptionPropertiesWithResponse call
func ParseGetNonPersistentTopicSubscriptionPropertiesResponse(rsp *http.Response) (*GetNonPersistentTopicSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateNonPersistentTopicSubscriptionPropertiesResponse parses an HTTP response from a UpdateNonPersistentTopicSubscriptionPropertiesWithResponse call
func ParseUpdateNonPersistentTopicSubscriptionPropertiesResponse(rsp *http.Response) (*UpdateNonPersistentTopicSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNonPersistentTopicSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicReplicatedSubscriptionStatusResponse parses an HTTP response from a GetNonPersistentTopicReplicatedSubscriptionStatusWithResponse call
func ParseGetNonPersistentTopicReplicatedSubscriptionStatusResponse(rsp *http.Response) (*GetNonPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicReplicatedSubscriptionStatusResponse parses an HTTP response from a SetNonPersistentTopicReplicatedSubscriptionStatusWithResponse call
func ParseSetNonPersistentTopicReplicatedSubscriptionStatusResponse(rsp *http.Response) (*SetNonPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetNonPersistentTopicCursorOnPositionResponse parses an HTTP response from a ResetNonPersistentTopicCursorOnPositionWithResponse call
func ParseResetNonPersistentTopicCursorOnPositionResponse(rsp *http.Response) (*ResetNonPersistentTopicCursorOnPositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetNonPersistentTopicCursorOnPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetNonPersistentTopicCursorResponse parses an HTTP response from a ResetNonPersistentTopicCursorWithResponse call
func ParseResetNonPersistentTopicCursorResponse(rsp *http.Response) (*ResetNonPersistentTopicCursorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetNonPersistentTopicCursorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipNonPersistentTopicMessagesResponse parses an HTTP response from a SkipNonPersistentTopicMessagesWithResponse call
func ParseSkipNonPersistentTopicMessagesResponse(rsp *http.Response) (*SkipNonPersistentTopicMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipNonPersistentTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipNonPersistentTopicAllMessagesResponse parses an HTTP response from a SkipNonPersistentTopicAllMessagesWithResponse call
func ParseSkipNonPersistentTopicAllMessagesResponse(rsp *http.Response) (*SkipNonPersistentTopicAllMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipNonPersistentTopicAllMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateNonPersistentTopicSubscriptionResponse parses an HTTP response from a CreateNonPersistentTopicSubscriptionWithResponse call
func ParseCreateNonPersistentTopicSubscriptionResponse(rsp *http.Response) (*CreateNonPersistentTopicSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNonPersistentTopicSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicSubscriptionDispatchRateResponse parses an HTTP response from a RemoveNonPersistentTopicSubscriptionDispatchRateWithResponse call
func ParseRemoveNonPersistentTopicSubscriptionDispatchRateResponse(rsp *http.Response) (*RemoveNonPersistentTopicSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSubscriptionDispatchRateResponse parses an HTTP response from a GetNonPersistentTopicSubscriptionDispatchRateWithResponse call
func ParseGetNonPersistentTopicSubscriptionDispatchRateResponse(rsp *http.Response) (*GetNonPersistentTopicSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicSubscriptionDispatchRateResponse parses an HTTP response from a SetNonPersistentTopicSubscriptionDispatchRateWithResponse call
func ParseSetNonPersistentTopicSubscriptionDispatchRateResponse(rsp *http.Response) (*SetNonPersistentTopicSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicSubscriptionTypesEnabledResponse parses an HTTP response from a RemoveNonPersistentTopicSubscriptionTypesEnabledWithResponse call
func ParseRemoveNonPersistentTopicSubscriptionTypesEnabledResponse(rsp *http.Response) (*RemoveNonPersistentTopicSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSubscriptionTypesEnabledResponse parses an HTTP response from a GetNonPersistentTopicSubscriptionTypesEnabledWithResponse call
func ParseGetNonPersistentTopicSubscriptionTypesEnabledResponse(rsp *http.Response) (*GetNonPersistentTopicSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicSubscriptionTypesEnabledResponse parses an HTTP response from a SetNonPersistentTopicSubscriptionTypesEnabledWithResponse call
func ParseSetNonPersistentTopicSubscriptionTypesEnabledResponse(rsp *http.Response) (*SetNonPersistentTopicSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSubscriptionsResponse parses an HTTP response from a GetNonPersistentTopicSubscriptionsWithResponse call
func ParseGetNonPersistentTopicSubscriptionsResponse(rsp *http.Response) (*GetNonPersistentTopicSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminateNonPersistentTopicResponse parses an HTTP response from a TerminateNonPersistentTopicWithResponse call
func ParseTerminateNonPersistentTopicResponse(rsp *http.Response) (*TerminateNonPersistentTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateNonPersistentTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminateNonPersistentTopicPartitionedTopicResponse parses an HTTP response from a TerminateNonPersistentTopicPartitionedTopicWithResponse call
func ParseTerminateNonPersistentTopicPartitionedTopicResponse(rsp *http.Response) (*TerminateNonPersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateNonPersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTruncateNonPersistentTopicTopicResponse parses an HTTP response from a TruncateNonPersistentTopicTopicWithResponse call
func ParseTruncateNonPersistentTopicTopicResponse(rsp *http.Response) (*TruncateNonPersistentTopicTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TruncateNonPersistentTopicTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnloadNonPersistentTopicTopicResponse parses an HTTP response from a UnloadNonPersistentTopicTopicWithResponse call
func ParseUnloadNonPersistentTopicTopicResponse(rsp *http.Response) (*UnloadNonPersistentTopicTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadNonPersistentTopicTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse parses an HTTP response from a RemoveNonPersistentTopicSubscriptionLevelDispatchRateWithResponse call
func ParseRemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNonPersistentTopicSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNonPersistentTopicSubscriptionLevelDispatchRateResponse parses an HTTP response from a GetNonPersistentTopicSubscriptionLevelDispatchRateWithResponse call
func ParseGetNonPersistentTopicSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*GetNonPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNonPersistentTopicSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNonPersistentTopicSubscriptionLevelDispatchRateResponse parses an HTTP response from a SetNonPersistentTopicSubscriptionLevelDispatchRateWithResponse call
func ParseSetNonPersistentTopicSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*SetNonPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNonPersistentTopicSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicListResponse parses an HTTP response from a GetPersistentTopicListWithResponse call
func ParseGetPersistentTopicListResponse(rsp *http.Response) (*GetPersistentTopicListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersistentPartitionedTopicListResponse parses an HTTP response from a GetPersistentPartitionedTopicListWithResponse call
func ParseGetPersistentPartitionedTopicListResponse(rsp *http.Response) (*GetPersistentPartitionedTopicListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentPartitionedTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePersistentTopicResponse parses an HTTP response from a DeletePersistentTopicWithResponse call
func ParseDeletePersistentTopicResponse(rsp *http.Response) (*DeletePersistentTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePersistentTopicNonPartitionedTopicResponse parses an HTTP response from a CreatePersistentTopicNonPartitionedTopicWithResponse call
func ParseCreatePersistentTopicNonPartitionedTopicResponse(rsp *http.Response) (*CreatePersistentTopicNonPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePersistentTopicNonPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpirePersistentTopicMessagesForAllSubscriptionsResponse parses an HTTP response from a ExpirePersistentTopicMessagesForAllSubscriptionsWithResponse call
func ParseExpirePersistentTopicMessagesForAllSubscriptionsResponse(rsp *http.Response) (*ExpirePersistentTopicMessagesForAllSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpirePersistentTopicMessagesForAllSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicBacklogResponse parses an HTTP response from a GetPersistentTopicBacklogWithResponse call
func ParseGetPersistentTopicBacklogResponse(rsp *http.Response) (*GetPersistentTopicBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicBacklogQuotaResponse parses an HTTP response from a RemovePersistentTopicBacklogQuotaWithResponse call
func ParseRemovePersistentTopicBacklogQuotaResponse(rsp *http.Response) (*RemovePersistentTopicBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicBacklogQuotaResponse parses an HTTP response from a SetPersistentTopicBacklogQuotaWithResponse call
func ParseSetPersistentTopicBacklogQuotaResponse(rsp *http.Response) (*SetPersistentTopicBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicBacklogQuotaMapResponse parses an HTTP response from a GetPersistentTopicBacklogQuotaMapWithResponse call
func ParseGetPersistentTopicBacklogQuotaMapResponse(rsp *http.Response) (*GetPersistentTopicBacklogQuotaMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicBacklogSizeByMessageIdResponse parses an HTTP response from a GetPersistentTopicBacklogSizeByMessageIdWithResponse call
func ParseGetPersistentTopicBacklogSizeByMessageIdResponse(rsp *http.Response) (*GetPersistentTopicBacklogSizeByMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicBacklogSizeByMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicCompactionStatusResponse parses an HTTP response from a GetPersistentTopicCompactionStatusWithResponse call
func ParseGetPersistentTopicCompactionStatusResponse(rsp *http.Response) (*GetPersistentTopicCompactionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicCompactionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompactPersistentTopicResponse parses an HTTP response from a CompactPersistentTopicWithResponse call
func ParseCompactPersistentTopicResponse(rsp *http.Response) (*CompactPersistentTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompactPersistentTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicCompactionThresholdResponse parses an HTTP response from a RemovePersistentTopicCompactionThresholdWithResponse call
func ParseRemovePersistentTopicCompactionThresholdResponse(rsp *http.Response) (*RemovePersistentTopicCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicCompactionThresholdResponse parses an HTTP response from a GetPersistentTopicCompactionThresholdWithResponse call
func ParseGetPersistentTopicCompactionThresholdResponse(rsp *http.Response) (*GetPersistentTopicCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicCompactionThresholdResponse parses an HTTP response from a SetPersistentTopicCompactionThresholdWithResponse call
func ParseSetPersistentTopicCompactionThresholdResponse(rsp *http.Response) (*SetPersistentTopicCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePersistentTopicMissedPartitionsResponse parses an HTTP response from a CreatePersistentTopicMissedPartitionsWithResponse call
func ParseCreatePersistentTopicMissedPartitionsResponse(rsp *http.Response) (*CreatePersistentTopicMissedPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePersistentTopicMissedPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicDeduplicationResponse parses an HTTP response from a RemovePersistentTopicDeduplicationWithResponse call
func ParseRemovePersistentTopicDeduplicationResponse(rsp *http.Response) (*RemovePersistentTopicDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicDeduplicationResponse parses an HTTP response from a GetPersistentTopicDeduplicationWithResponse call
func ParseGetPersistentTopicDeduplicationResponse(rsp *http.Response) (*GetPersistentTopicDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicDeduplicationResponse parses an HTTP response from a SetPersistentTopicDeduplicationWithResponse call
func ParseSetPersistentTopicDeduplicationResponse(rsp *http.Response) (*SetPersistentTopicDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicDeduplicationSnapshotIntervalResponse parses an HTTP response from a DeletePersistentTopicDeduplicationSnapshotIntervalWithResponse call
func ParseDeletePersistentTopicDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*DeletePersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicDeduplicationSnapshotIntervalResponse parses an HTTP response from a GetPersistentTopicDeduplicationSnapshotIntervalWithResponse call
func ParseGetPersistentTopicDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*GetPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicDeduplicationSnapshotIntervalResponse parses an HTTP response from a SetPersistentTopicDeduplicationSnapshotIntervalWithResponse call
func ParseSetPersistentTopicDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*SetPersistentTopicDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicDelayedDeliveryPoliciesResponse parses an HTTP response from a DeletePersistentTopicDelayedDeliveryPoliciesWithResponse call
func ParseDeletePersistentTopicDelayedDeliveryPoliciesResponse(rsp *http.Response) (*DeletePersistentTopicDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicDelayedDeliveryPoliciesResponse parses an HTTP response from a GetPersistentTopicDelayedDeliveryPoliciesWithResponse call
func ParseGetPersistentTopicDelayedDeliveryPoliciesResponse(rsp *http.Response) (*GetPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicDelayedDeliveryPoliciesResponse parses an HTTP response from a SetPersistentTopicDelayedDeliveryPoliciesWithResponse call
func ParseSetPersistentTopicDelayedDeliveryPoliciesResponse(rsp *http.Response) (*SetPersistentTopicDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicDispatchRateResponse parses an HTTP response from a RemovePersistentTopicDispatchRateWithResponse call
func ParseRemovePersistentTopicDispatchRateResponse(rsp *http.Response) (*RemovePersistentTopicDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicDispatchRateResponse parses an HTTP response from a GetPersistentTopicDispatchRateWithResponse call
func ParseGetPersistentTopicDispatchRateResponse(rsp *http.Response) (*GetPersistentTopicDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicDispatchRateResponse parses an HTTP response from a SetPersistentTopicDispatchRateWithResponse call
func ParseSetPersistentTopicDispatchRateResponse(rsp *http.Response) (*SetPersistentTopicDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicEntryFiltersResponse parses an HTTP response from a RemovePersistentTopicEntryFiltersWithResponse call
func ParseRemovePersistentTopicEntryFiltersResponse(rsp *http.Response) (*RemovePersistentTopicEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicEntryFiltersResponse parses an HTTP response from a GetPersistentTopicEntryFiltersWithResponse call
func ParseGetPersistentTopicEntryFiltersResponse(rsp *http.Response) (*GetPersistentTopicEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicEntryFiltersResponse parses an HTTP response from a SetPersistentTopicEntryFiltersWithResponse call
func ParseSetPersistentTopicEntryFiltersResponse(rsp *http.Response) (*SetPersistentTopicEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExaminePersistentTopicMessageResponse parses an HTTP response from a ExaminePersistentTopicMessageWithResponse call
func ParseExaminePersistentTopicMessageResponse(rsp *http.Response) (*ExaminePersistentTopicMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExaminePersistentTopicMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicInactiveTopicPoliciesResponse parses an HTTP response from a DeletePersistentTopicInactiveTopicPoliciesWithResponse call
func ParseDeletePersistentTopicInactiveTopicPoliciesResponse(rsp *http.Response) (*DeletePersistentTopicInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicInactiveTopicPoliciesResponse parses an HTTP response from a GetPersistentTopicInactiveTopicPoliciesWithResponse call
func ParseGetPersistentTopicInactiveTopicPoliciesResponse(rsp *http.Response) (*GetPersistentTopicInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicInactiveTopicPoliciesResponse parses an HTTP response from a SetPersistentTopicInactiveTopicPoliciesWithResponse call
func ParseSetPersistentTopicInactiveTopicPoliciesResponse(rsp *http.Response) (*SetPersistentTopicInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicManagedLedgerInfoResponse parses an HTTP response from a GetPersistentTopicManagedLedgerInfoWithResponse call
func ParseGetPersistentTopicManagedLedgerInfoResponse(rsp *http.Response) (*GetPersistentTopicManagedLedgerInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicManagedLedgerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicInternalStatsResponse parses an HTTP response from a GetPersistentTopicInternalStatsWithResponse call
func ParseGetPersistentTopicInternalStatsResponse(rsp *http.Response) (*GetPersistentTopicInternalStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicInternalStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicLastMessageIdResponse parses an HTTP response from a GetPersistentTopicLastMessageIdWithResponse call
func ParseGetPersistentTopicLastMessageIdResponse(rsp *http.Response) (*GetPersistentTopicLastMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicLastMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMessageByIdResponse parses an HTTP response from a GetPersistentTopicMessageByIdWithResponse call
func ParseGetPersistentTopicMessageByIdResponse(rsp *http.Response) (*GetPersistentTopicMessageByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMessageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicMaxConsumersResponse parses an HTTP response from a RemovePersistentTopicMaxConsumersWithResponse call
func ParseRemovePersistentTopicMaxConsumersResponse(rsp *http.Response) (*RemovePersistentTopicMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMaxConsumersResponse parses an HTTP response from a GetPersistentTopicMaxConsumersWithResponse call
func ParseGetPersistentTopicMaxConsumersResponse(rsp *http.Response) (*GetPersistentTopicMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMaxConsumersResponse parses an HTTP response from a SetPersistentTopicMaxConsumersWithResponse call
func ParseSetPersistentTopicMaxConsumersResponse(rsp *http.Response) (*SetPersistentTopicMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicMaxConsumersPerSubscriptionResponse parses an HTTP response from a RemovePersistentTopicMaxConsumersPerSubscriptionWithResponse call
func ParseRemovePersistentTopicMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*RemovePersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMaxConsumersPerSubscriptionResponse parses an HTTP response from a GetPersistentTopicMaxConsumersPerSubscriptionWithResponse call
func ParseGetPersistentTopicMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*GetPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMaxConsumersPerSubscriptionResponse parses an HTTP response from a SetPersistentTopicMaxConsumersPerSubscriptionWithResponse call
func ParseSetPersistentTopicMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*SetPersistentTopicMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicMaxMessageSizeResponse parses an HTTP response from a RemovePersistentTopicMaxMessageSizeWithResponse call
func ParseRemovePersistentTopicMaxMessageSizeResponse(rsp *http.Response) (*RemovePersistentTopicMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMaxMessageSizeResponse parses an HTTP response from a GetPersistentTopicMaxMessageSizeWithResponse call
func ParseGetPersistentTopicMaxMessageSizeResponse(rsp *http.Response) (*GetPersistentTopicMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMaxMessageSizeResponse parses an HTTP response from a SetPersistentTopicMaxMessageSizeWithResponse call
func ParseSetPersistentTopicMaxMessageSizeResponse(rsp *http.Response) (*SetPersistentTopicMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicMaxProducersResponse parses an HTTP response from a RemovePersistentTopicMaxProducersWithResponse call
func ParseRemovePersistentTopicMaxProducersResponse(rsp *http.Response) (*RemovePersistentTopicMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMaxProducersResponse parses an HTTP response from a GetPersistentTopicMaxProducersWithResponse call
func ParseGetPersistentTopicMaxProducersResponse(rsp *http.Response) (*GetPersistentTopicMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMaxProducersResponse parses an HTTP response from a SetPersistentTopicMaxProducersWithResponse call
func ParseSetPersistentTopicMaxProducersResponse(rsp *http.Response) (*SetPersistentTopicMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicMaxSubscriptionsPerTopicResponse parses an HTTP response from a RemovePersistentTopicMaxSubscriptionsPerTopicWithResponse call
func ParseRemovePersistentTopicMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*RemovePersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMaxSubscriptionsPerTopicResponse parses an HTTP response from a GetPersistentTopicMaxSubscriptionsPerTopicWithResponse call
func ParseGetPersistentTopicMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*GetPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMaxSubscriptionsPerTopicResponse parses an HTTP response from a SetPersistentTopicMaxSubscriptionsPerTopicWithResponse call
func ParseSetPersistentTopicMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*SetPersistentTopicMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a DeletePersistentTopicMaxUnackedMessagesOnConsumerWithResponse call
func ParseDeletePersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a GetPersistentTopicMaxUnackedMessagesOnConsumerWithResponse call
func ParseGetPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*GetPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a SetPersistentTopicMaxUnackedMessagesOnConsumerWithResponse call
func ParseSetPersistentTopicMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*SetPersistentTopicMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a DeletePersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseDeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a GetPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseGetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a SetPersistentTopicMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseSetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicMessageTTLResponse parses an HTTP response from a RemovePersistentTopicMessageTTLWithResponse call
func ParseRemovePersistentTopicMessageTTLResponse(rsp *http.Response) (*RemovePersistentTopicMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMessageTTLResponse parses an HTTP response from a GetPersistentTopicMessageTTLWithResponse call
func ParseGetPersistentTopicMessageTTLResponse(rsp *http.Response) (*GetPersistentTopicMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicMessageTTLResponse parses an HTTP response from a SetPersistentTopicMessageTTLWithResponse call
func ParseSetPersistentTopicMessageTTLResponse(rsp *http.Response) (*SetPersistentTopicMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicMessageIdByTimestampResponse parses an HTTP response from a GetPersistentTopicMessageIdByTimestampWithResponse call
func ParseGetPersistentTopicMessageIdByTimestampResponse(rsp *http.Response) (*GetPersistentTopicMessageIdByTimestampResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicMessageIdByTimestampResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOffloadPersistentTopicStatusResponse parses an HTTP response from a OffloadPersistentTopicStatusWithResponse call
func ParseOffloadPersistentTopicStatusResponse(rsp *http.Response) (*OffloadPersistentTopicStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OffloadPersistentTopicStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTriggerPersistentTopicOffloadResponse parses an HTTP response from a TriggerPersistentTopicOffloadWithResponse call
func ParseTriggerPersistentTopicOffloadResponse(rsp *http.Response) (*TriggerPersistentTopicOffloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerPersistentTopicOffloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicOffloadPoliciesResponse parses an HTTP response from a RemovePersistentTopicOffloadPoliciesWithResponse call
func ParseRemovePersistentTopicOffloadPoliciesResponse(rsp *http.Response) (*RemovePersistentTopicOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicOffloadPoliciesResponse parses an HTTP response from a GetPersistentTopicOffloadPoliciesWithResponse call
func ParseGetPersistentTopicOffloadPoliciesResponse(rsp *http.Response) (*GetPersistentTopicOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicOffloadPoliciesResponse parses an HTTP response from a SetPersistentTopicOffloadPoliciesWithResponse call
func ParseSetPersistentTopicOffloadPoliciesResponse(rsp *http.Response) (*SetPersistentTopicOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicPartitionedStatsResponse parses an HTTP response from a GetPersistentTopicPartitionedStatsWithResponse call
func ParseGetPersistentTopicPartitionedStatsResponse(rsp *http.Response) (*GetPersistentTopicPartitionedStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicPartitionedStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicPartitionedTopicResponse parses an HTTP response from a DeletePersistentTopicPartitionedTopicWithResponse call
func ParseDeletePersistentTopicPartitionedTopicResponse(rsp *http.Response) (*DeletePersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicPartitionedMetadataResponse parses an HTTP response from a GetPersistentTopicPartitionedMetadataWithResponse call
func ParseGetPersistentTopicPartitionedMetadataResponse(rsp *http.Response) (*GetPersistentTopicPartitionedMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicPartitionedMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePersistentTopicPartitionedTopicResponse parses an HTTP response from a UpdatePersistentTopicPartitionedTopicWithResponse call
func ParseUpdatePersistentTopicPartitionedTopicResponse(rsp *http.Response) (*UpdatePersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePersistentTopicPartitionedTopicResponse parses an HTTP response from a CreatePersistentTopicPartitionedTopicWithResponse call
func ParseCreatePersistentTopicPartitionedTopicResponse(rsp *http.Response) (*CreatePersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicPermissionsOnTopicResponse parses an HTTP response from a GetPersistentTopicPermissionsOnTopicWithResponse call
func ParseGetPersistentTopicPermissionsOnTopicResponse(rsp *http.Response) (*GetPersistentTopicPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse parses an HTTP response from a RevokePersistentTopicNonPersistentTopicPermissionsOnTopicWithResponse call
func ParseRevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse(rsp *http.Response) (*RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePersistentTopicNonPersistentTopicPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGrantPersistentTopicPermissionsOnTopicResponse parses an HTTP response from a GrantPersistentTopicPermissionsOnTopicWithResponse call
func ParseGrantPersistentTopicPermissionsOnTopicResponse(rsp *http.Response) (*GrantPersistentTopicPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GrantPersistentTopicPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicPersistenceResponse parses an HTTP response from a RemovePersistentTopicPersistenceWithResponse call
func ParseRemovePersistentTopicPersistenceResponse(rsp *http.Response) (*RemovePersistentTopicPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicPersistenceResponse parses an HTTP response from a GetPersistentTopicPersistenceWithResponse call
func ParseGetPersistentTopicPersistenceResponse(rsp *http.Response) (*GetPersistentTopicPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicPersistenceResponse parses an HTTP response from a SetPersistentTopicPersistenceWithResponse call
func ParseSetPersistentTopicPersistenceResponse(rsp *http.Response) (*SetPersistentTopicPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicPropertiesResponse parses an HTTP response from a RemovePersistentTopicPropertiesWithResponse call
func ParseRemovePersistentTopicPropertiesResponse(rsp *http.Response) (*RemovePersistentTopicPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicPropertiesResponse parses an HTTP response from a GetPersistentTopicPropertiesWithResponse call
func ParseGetPersistentTopicPropertiesResponse(rsp *http.Response) (*GetPersistentTopicPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePersistentTopicPropertiesResponse parses an HTTP response from a UpdatePersistentTopicPropertiesWithResponse call
func ParseUpdatePersistentTopicPropertiesResponse(rsp *http.Response) (*UpdatePersistentTopicPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePersistentTopicPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicPublishRateResponse parses an HTTP response from a RemovePersistentTopicPublishRateWithResponse call
func ParseRemovePersistentTopicPublishRateResponse(rsp *http.Response) (*RemovePersistentTopicPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicPublishRateResponse parses an HTTP response from a GetPersistentTopicPublishRateWithResponse call
func ParseGetPersistentTopicPublishRateResponse(rsp *http.Response) (*GetPersistentTopicPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicPublishRateResponse parses an HTTP response from a SetPersistentTopicPublishRateWithResponse call
func ParseSetPersistentTopicPublishRateResponse(rsp *http.Response) (*SetPersistentTopicPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicReplicationClustersResponse parses an HTTP response from a RemovePersistentTopicReplicationClustersWithResponse call
func ParseRemovePersistentTopicReplicationClustersResponse(rsp *http.Response) (*RemovePersistentTopicReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicReplicationClustersResponse parses an HTTP response from a GetPersistentTopicReplicationClustersWithResponse call
func ParseGetPersistentTopicReplicationClustersResponse(rsp *http.Response) (*GetPersistentTopicReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicReplicationClustersResponse parses an HTTP response from a SetPersistentTopicReplicationClustersWithResponse call
func ParseSetPersistentTopicReplicationClustersResponse(rsp *http.Response) (*SetPersistentTopicReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicReplicatorDispatchRateResponse parses an HTTP response from a RemovePersistentTopicReplicatorDispatchRateWithResponse call
func ParseRemovePersistentTopicReplicatorDispatchRateResponse(rsp *http.Response) (*RemovePersistentTopicReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicReplicatorDispatchRateResponse parses an HTTP response from a GetPersistentTopicReplicatorDispatchRateWithResponse call
func ParseGetPersistentTopicReplicatorDispatchRateResponse(rsp *http.Response) (*GetPersistentTopicReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicReplicatorDispatchRateResponse parses an HTTP response from a SetPersistentTopicReplicatorDispatchRateWithResponse call
func ParseSetPersistentTopicReplicatorDispatchRateResponse(rsp *http.Response) (*SetPersistentTopicReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicRetentionResponse parses an HTTP response from a RemovePersistentTopicRetentionWithResponse call
func ParseRemovePersistentTopicRetentionResponse(rsp *http.Response) (*RemovePersistentTopicRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicRetentionResponse parses an HTTP response from a GetPersistentTopicRetentionWithResponse call
func ParseGetPersistentTopicRetentionResponse(rsp *http.Response) (*GetPersistentTopicRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicRetentionResponse parses an HTTP response from a SetPersistentTopicRetentionWithResponse call
func ParseSetPersistentTopicRetentionResponse(rsp *http.Response) (*SetPersistentTopicRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicSchemaCompatibilityStrategyResponse parses an HTTP response from a RemovePersistentTopicSchemaCompatibilityStrategyWithResponse call
func ParseRemovePersistentTopicSchemaCompatibilityStrategyResponse(rsp *http.Response) (*RemovePersistentTopicSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSchemaCompatibilityStrategyResponse parses an HTTP response from a GetPersistentTopicSchemaCompatibilityStrategyWithResponse call
func ParseGetPersistentTopicSchemaCompatibilityStrategyResponse(rsp *http.Response) (*GetPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicSchemaCompatibilityStrategyResponse parses an HTTP response from a SetPersistentTopicSchemaCompatibilityStrategyWithResponse call
func ParseSetPersistentTopicSchemaCompatibilityStrategyResponse(rsp *http.Response) (*SetPersistentTopicSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSchemaValidationEnforcedResponse parses an HTTP response from a GetPersistentTopicSchemaValidationEnforcedWithResponse call
func ParseGetPersistentTopicSchemaValidationEnforcedResponse(rsp *http.Response) (*GetPersistentTopicSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicSchemaValidationEnforcedResponse parses an HTTP response from a SetPersistentTopicSchemaValidationEnforcedWithResponse call
func ParseSetPersistentTopicSchemaValidationEnforcedResponse(rsp *http.Response) (*SetPersistentTopicSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicShadowTopicsResponse parses an HTTP response from a DeletePersistentTopicShadowTopicsWithResponse call
func ParseDeletePersistentTopicShadowTopicsResponse(rsp *http.Response) (*DeletePersistentTopicShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicShadowTopicsResponse parses an HTTP response from a GetPersistentTopicShadowTopicsWithResponse call
func ParseGetPersistentTopicShadowTopicsResponse(rsp *http.Response) (*GetPersistentTopicShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicShadowTopicsResponse parses an HTTP response from a SetPersistentTopicShadowTopicsWithResponse call
func ParseSetPersistentTopicShadowTopicsResponse(rsp *http.Response) (*SetPersistentTopicShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicStatsResponse parses an HTTP response from a GetPersistentTopicStatsWithResponse call
func ParseGetPersistentTopicStatsResponse(rsp *http.Response) (*GetPersistentTopicStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicSubscribeRateResponse parses an HTTP response from a RemovePersistentTopicSubscribeRateWithResponse call
func ParseRemovePersistentTopicSubscribeRateResponse(rsp *http.Response) (*RemovePersistentTopicSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSubscribeRateResponse parses an HTTP response from a GetPersistentTopicSubscribeRateWithResponse call
func ParseGetPersistentTopicSubscribeRateResponse(rsp *http.Response) (*GetPersistentTopicSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicSubscribeRateResponse parses an HTTP response from a SetPersistentTopicSubscribeRateWithResponse call
func ParseSetPersistentTopicSubscribeRateResponse(rsp *http.Response) (*SetPersistentTopicSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistentTopicSubscriptionResponse parses an HTTP response from a DeletePersistentTopicSubscriptionWithResponse call
func ParseDeletePersistentTopicSubscriptionResponse(rsp *http.Response) (*DeletePersistentTopicSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistentTopicSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAnalyzePersistentTopicSubscriptionBacklogResponse parses an HTTP response from a AnalyzePersistentTopicSubscriptionBacklogWithResponse call
func ParseAnalyzePersistentTopicSubscriptionBacklogResponse(rsp *http.Response) (*AnalyzePersistentTopicSubscriptionBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnalyzePersistentTopicSubscriptionBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpirePersistentTopicMessagesResponse parses an HTTP response from a ExpirePersistentTopicMessagesWithResponse call
func ParseExpirePersistentTopicMessagesResponse(rsp *http.Response) (*ExpirePersistentTopicMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpirePersistentTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExpirePersistentTopicMessagesTimeInSecondsResponse parses an HTTP response from a ExpirePersistentTopicMessagesTimeInSecondsWithResponse call
func ParseExpirePersistentTopicMessagesTimeInSecondsResponse(rsp *http.Response) (*ExpirePersistentTopicMessagesTimeInSecondsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpirePersistentTopicMessagesTimeInSecondsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePeekPersistentTopicNthMessageResponse parses an HTTP response from a PeekPersistentTopicNthMessageWithResponse call
func ParsePeekPersistentTopicNthMessageResponse(rsp *http.Response) (*PeekPersistentTopicNthMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PeekPersistentTopicNthMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSubscriptionPropertiesResponse parses an HTTP response from a GetPersistentTopicSubscriptionPropertiesWithResponse call
func ParseGetPersistentTopicSubscriptionPropertiesResponse(rsp *http.Response) (*GetPersistentTopicSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePersistentTopicSubscriptionPropertiesResponse parses an HTTP response from a UpdatePersistentTopicSubscriptionPropertiesWithResponse call
func ParseUpdatePersistentTopicSubscriptionPropertiesResponse(rsp *http.Response) (*UpdatePersistentTopicSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePersistentTopicSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicReplicatedSubscriptionStatusResponse parses an HTTP response from a GetPersistentTopicReplicatedSubscriptionStatusWithResponse call
func ParseGetPersistentTopicReplicatedSubscriptionStatusResponse(rsp *http.Response) (*GetPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicReplicatedSubscriptionStatusResponse parses an HTTP response from a SetPersistentTopicReplicatedSubscriptionStatusWithResponse call
func ParseSetPersistentTopicReplicatedSubscriptionStatusResponse(rsp *http.Response) (*SetPersistentTopicReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetPersistentTopicCursorOnPositionResponse parses an HTTP response from a ResetPersistentTopicCursorOnPositionWithResponse call
func ParseResetPersistentTopicCursorOnPositionResponse(rsp *http.Response) (*ResetPersistentTopicCursorOnPositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPersistentTopicCursorOnPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetPersistentTopicCursorResponse parses an HTTP response from a ResetPersistentTopicCursorWithResponse call
func ParseResetPersistentTopicCursorResponse(rsp *http.Response) (*ResetPersistentTopicCursorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPersistentTopicCursorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipPersistentTopicMessagesResponse parses an HTTP response from a SkipPersistentTopicMessagesWithResponse call
func ParseSkipPersistentTopicMessagesResponse(rsp *http.Response) (*SkipPersistentTopicMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipPersistentTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSkipPersistentTopicAllMessagesResponse parses an HTTP response from a SkipPersistentTopicAllMessagesWithResponse call
func ParseSkipPersistentTopicAllMessagesResponse(rsp *http.Response) (*SkipPersistentTopicAllMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipPersistentTopicAllMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePersistentTopicSubscriptionResponse parses an HTTP response from a CreatePersistentTopicSubscriptionWithResponse call
func ParseCreatePersistentTopicSubscriptionResponse(rsp *http.Response) (*CreatePersistentTopicSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePersistentTopicSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicSubscriptionDispatchRateResponse parses an HTTP response from a RemovePersistentTopicSubscriptionDispatchRateWithResponse call
func ParseRemovePersistentTopicSubscriptionDispatchRateResponse(rsp *http.Response) (*RemovePersistentTopicSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSubscriptionDispatchRateResponse parses an HTTP response from a GetPersistentTopicSubscriptionDispatchRateWithResponse call
func ParseGetPersistentTopicSubscriptionDispatchRateResponse(rsp *http.Response) (*GetPersistentTopicSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicSubscriptionDispatchRateResponse parses an HTTP response from a SetPersistentTopicSubscriptionDispatchRateWithResponse call
func ParseSetPersistentTopicSubscriptionDispatchRateResponse(rsp *http.Response) (*SetPersistentTopicSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicSubscriptionTypesEnabledResponse parses an HTTP response from a RemovePersistentTopicSubscriptionTypesEnabledWithResponse call
func ParseRemovePersistentTopicSubscriptionTypesEnabledResponse(rsp *http.Response) (*RemovePersistentTopicSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSubscriptionTypesEnabledResponse parses an HTTP response from a GetPersistentTopicSubscriptionTypesEnabledWithResponse call
func ParseGetPersistentTopicSubscriptionTypesEnabledResponse(rsp *http.Response) (*GetPersistentTopicSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicSubscriptionTypesEnabledResponse parses an HTTP response from a SetPersistentTopicSubscriptionTypesEnabledWithResponse call
func ParseSetPersistentTopicSubscriptionTypesEnabledResponse(rsp *http.Response) (*SetPersistentTopicSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSubscriptionsResponse parses an HTTP response from a GetPersistentTopicSubscriptionsWithResponse call
func ParseGetPersistentTopicSubscriptionsResponse(rsp *http.Response) (*GetPersistentTopicSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminatePersistentTopicResponse parses an HTTP response from a TerminatePersistentTopicWithResponse call
func ParseTerminatePersistentTopicResponse(rsp *http.Response) (*TerminatePersistentTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminatePersistentTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTerminatePersistentTopicPartitionedTopicResponse parses an HTTP response from a TerminatePersistentTopicPartitionedTopicWithResponse call
func ParseTerminatePersistentTopicPartitionedTopicResponse(rsp *http.Response) (*TerminatePersistentTopicPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminatePersistentTopicPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTruncatePersistentTopicTopicResponse parses an HTTP response from a TruncatePersistentTopicTopicWithResponse call
func ParseTruncatePersistentTopicTopicResponse(rsp *http.Response) (*TruncatePersistentTopicTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TruncatePersistentTopicTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnloadPersistentTopicTopicResponse parses an HTTP response from a UnloadPersistentTopicTopicWithResponse call
func ParseUnloadPersistentTopicTopicResponse(rsp *http.Response) (*UnloadPersistentTopicTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnloadPersistentTopicTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemovePersistentTopicSubscriptionLevelDispatchRateResponse parses an HTTP response from a RemovePersistentTopicSubscriptionLevelDispatchRateWithResponse call
func ParseRemovePersistentTopicSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*RemovePersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePersistentTopicSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistentTopicSubscriptionLevelDispatchRateResponse parses an HTTP response from a GetPersistentTopicSubscriptionLevelDispatchRateWithResponse call
func ParseGetPersistentTopicSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*GetPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistentTopicSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetPersistentTopicSubscriptionLevelDispatchRateResponse parses an HTTP response from a SetPersistentTopicSubscriptionLevelDispatchRateWithResponse call
func ParseSetPersistentTopicSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*SetPersistentTopicSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPersistentTopicSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultResourceQuotaResponse parses an HTTP response from a GetDefaultResourceQuotaWithResponse call
func ParseGetDefaultResourceQuotaResponse(rsp *http.Response) (*GetDefaultResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetDefaultResourceQuotaResponse parses an HTTP response from a SetDefaultResourceQuotaWithResponse call
func ParseSetDefaultResourceQuotaResponse(rsp *http.Response) (*SetDefaultResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveNamespaceBundleResourceQuotaResponse parses an HTTP response from a RemoveNamespaceBundleResourceQuotaWithResponse call
func ParseRemoveNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*RemoveNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNamespaceBundleResourceQuotaResponse parses an HTTP response from a GetNamespaceBundleResourceQuotaWithResponse call
func ParseGetNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*GetNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetNamespaceBundleResourceQuotaResponse parses an HTTP response from a SetNamespaceBundleResourceQuotaWithResponse call
func ParseSetNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*SetNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResourceGroupsResponse parses an HTTP response from a GetResourceGroupsWithResponse call
func ParseGetResourceGroupsResponse(rsp *http.Response) (*GetResourceGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteResourceGroupResponse parses an HTTP response from a DeleteResourceGroupWithResponse call
func ParseDeleteResourceGroupResponse(rsp *http.Response) (*DeleteResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResourceGroupResponse parses an HTTP response from a GetResourceGroupWithResponse call
func ParseGetResourceGroupResponse(rsp *http.Response) (*GetResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateResourceGroupResponse parses an HTTP response from a CreateOrUpdateResourceGroupWithResponse call
func ParseCreateOrUpdateResourceGroupResponse(rsp *http.Response) (*CreateOrUpdateResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTestCompatibilityResponse parses an HTTP response from a TestCompatibilityWithResponse call
func ParseTestCompatibilityResponse(rsp *http.Response) (*TestCompatibilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestCompatibilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IsCompatibilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSchemaResponse parses an HTTP response from a DeleteSchemaWithResponse call
func ParseDeleteSchemaResponse(rsp *http.Response) (*DeleteSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteSchemaSuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemaOfTopicResponse parses an HTTP response from a GetSchemaOfTopicWithResponse call
func ParseGetSchemaOfTopicResponse(rsp *http.Response) (*GetSchemaOfTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaOfTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostSchemaResponse parses an HTTP response from a PostSchemaWithResponse call
func ParsePostSchemaResponse(rsp *http.Response) (*PostSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostSchemaSuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemaOfTopicGivenVersionResponse parses an HTTP response from a GetSchemaOfTopicGivenVersionWithResponse call
func ParseGetSchemaOfTopicGivenVersionResponse(rsp *http.Response) (*GetSchemaOfTopicGivenVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaOfTopicGivenVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllSchemasResponse parses an HTTP response from a GetAllSchemasWithResponse call
func ParseGetAllSchemasResponse(rsp *http.Response) (*GetAllSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllVersionsSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVersionBySchemaResponse parses an HTTP response from a GetVersionBySchemaWithResponse call
func ParseGetVersionBySchemaResponse(rsp *http.Response) (*GetVersionBySchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionBySchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LongSchemaVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTenantsResponse parses an HTTP response from a GetTenantsWithResponse call
func ParseGetTenantsResponse(rsp *http.Response) (*GetTenantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTenantResponse parses an HTTP response from a DeleteTenantWithResponse call
func ParseDeleteTenantResponse(rsp *http.Response) (*DeleteTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTenantAdminResponse parses an HTTP response from a GetTenantAdminWithResponse call
func ParseGetTenantAdminResponse(rsp *http.Response) (*GetTenantAdminResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateTenantResponse parses an HTTP response from a UpdateTenantWithResponse call
func ParseUpdateTenantResponse(rsp *http.Response) (*UpdateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTenantResponse parses an HTTP response from a CreateTenantWithResponse call
func ParseCreateTenantResponse(rsp *http.Response) (*CreateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkerStatsResponse parses an HTTP response from a GetWorkerStatsWithResponse call
func ParseGetWorkerStatsResponse(rsp *http.Response) (*GetWorkerStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkerStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerFunctionInstanceStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkerStatsMetricsResponse parses an HTTP response from a GetWorkerStatsMetricsWithResponse call
func ParseGetWorkerStatsMetricsResponse(rsp *http.Response) (*GetWorkerStatsMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkerStatsMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAssignmentsResponse parses an HTTP response from a GetAssignmentsWithResponse call
func ParseGetAssignmentsResponse(rsp *http.Response) (*GetAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkerClusterResponse parses an HTTP response from a GetWorkerClusterWithResponse call
func ParseGetWorkerClusterResponse(rsp *http.Response) (*GetWorkerClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkerClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkerClusterLeaderResponse parses an HTTP response from a GetWorkerClusterLeaderWithResponse call
func ParseGetWorkerClusterLeaderResponse(rsp *http.Response) (*GetWorkerClusterLeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkerClusterLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsLeaderReadyResponse parses an HTTP response from a IsLeaderReadyWithResponse call
func ParseIsLeaderReadyResponse(rsp *http.Response) (*IsLeaderReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsLeaderReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConnectorsListResponse parses an HTTP response from a GetConnectorsListWithResponse call
func ParseGetConnectorsListResponse(rsp *http.Response) (*GetConnectorsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDrainStatusResponse parses an HTTP response from a GetDrainStatusWithResponse call
func ParseGetDrainStatusResponse(rsp *http.Response) (*GetDrainStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDrainStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDrainResponse parses an HTTP response from a DrainWithResponse call
func ParseDrainResponse(rsp *http.Response) (*DrainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DrainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDrainStatusFromLeaderResponse parses an HTTP response from a GetDrainStatusFromLeaderWithResponse call
func ParseGetDrainStatusFromLeaderResponse(rsp *http.Response) (*GetDrainStatusFromLeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDrainStatusFromLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDrainAtLeaderResponse parses an HTTP response from a DrainAtLeaderWithResponse call
func ParseDrainAtLeaderResponse(rsp *http.Response) (*DrainAtLeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DrainAtLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRebalanceResponse parses an HTTP response from a RebalanceWithResponse call
func ParseRebalanceResponse(rsp *http.Response) (*RebalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
