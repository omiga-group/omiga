// Code generated by ent, DO NOT EDIT.

package entities

import (
	"errors"
	"fmt"
	"time"

	"github.com/omiga-group/omiga/src/exchange/shared/entities/currency"
	"github.com/omiga-group/omiga/src/exchange/shared/entities/exchange"
	"github.com/omiga-group/omiga/src/exchange/shared/entities/market"
	"github.com/omiga-group/omiga/src/exchange/shared/entities/outbox"
	"github.com/omiga-group/omiga/src/exchange/shared/entities/predicate"
	"github.com/omiga-group/omiga/src/exchange/shared/entities/ticker"
	"github.com/omiga-group/omiga/src/exchange/shared/entities/tradingpair"
)

// CurrencyWhereInput represents a where input for filtering Currency queries.
type CurrencyWhereInput struct {
	Predicates []predicate.Currency  `json:"-"`
	Not        *CurrencyWhereInput   `json:"not,omitempty"`
	Or         []*CurrencyWhereInput `json:"or,omitempty"`
	And        []*CurrencyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "symbol" field predicates.
	Symbol             *string  `json:"symbol,omitempty"`
	SymbolNEQ          *string  `json:"symbolNEQ,omitempty"`
	SymbolIn           []string `json:"symbolIn,omitempty"`
	SymbolNotIn        []string `json:"symbolNotIn,omitempty"`
	SymbolGT           *string  `json:"symbolGT,omitempty"`
	SymbolGTE          *string  `json:"symbolGTE,omitempty"`
	SymbolLT           *string  `json:"symbolLT,omitempty"`
	SymbolLTE          *string  `json:"symbolLTE,omitempty"`
	SymbolContains     *string  `json:"symbolContains,omitempty"`
	SymbolHasPrefix    *string  `json:"symbolHasPrefix,omitempty"`
	SymbolHasSuffix    *string  `json:"symbolHasSuffix,omitempty"`
	SymbolEqualFold    *string  `json:"symbolEqualFold,omitempty"`
	SymbolContainsFold *string  `json:"symbolContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type" field predicates.
	Type      *currency.Type  `json:"type,omitempty"`
	TypeNEQ   *currency.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []currency.Type `json:"typeIn,omitempty"`
	TypeNotIn []currency.Type `json:"typeNotIn,omitempty"`

	// "currency_base" edge predicates.
	HasCurrencyBase     *bool                    `json:"hasCurrencyBase,omitempty"`
	HasCurrencyBaseWith []*TradingPairWhereInput `json:"hasCurrencyBaseWith,omitempty"`

	// "currency_counter" edge predicates.
	HasCurrencyCounter     *bool                    `json:"hasCurrencyCounter,omitempty"`
	HasCurrencyCounterWith []*TradingPairWhereInput `json:"hasCurrencyCounterWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CurrencyWhereInput) AddPredicates(predicates ...predicate.Currency) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CurrencyWhereInput filter on the CurrencyQuery builder.
func (i *CurrencyWhereInput) Filter(q *CurrencyQuery) (*CurrencyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCurrencyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCurrencyWhereInput is returned in case the CurrencyWhereInput is empty.
var ErrEmptyCurrencyWhereInput = errors.New("entities: empty predicate CurrencyWhereInput")

// P returns a predicate for filtering currencies.
// An error is returned if the input is empty or invalid.
func (i *CurrencyWhereInput) P() (predicate.Currency, error) {
	var predicates []predicate.Currency
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, currency.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Currency, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, currency.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Currency, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, currency.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, currency.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, currency.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, currency.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, currency.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, currency.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, currency.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, currency.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, currency.IDLTE(*i.IDLTE))
	}
	if i.Symbol != nil {
		predicates = append(predicates, currency.SymbolEQ(*i.Symbol))
	}
	if i.SymbolNEQ != nil {
		predicates = append(predicates, currency.SymbolNEQ(*i.SymbolNEQ))
	}
	if len(i.SymbolIn) > 0 {
		predicates = append(predicates, currency.SymbolIn(i.SymbolIn...))
	}
	if len(i.SymbolNotIn) > 0 {
		predicates = append(predicates, currency.SymbolNotIn(i.SymbolNotIn...))
	}
	if i.SymbolGT != nil {
		predicates = append(predicates, currency.SymbolGT(*i.SymbolGT))
	}
	if i.SymbolGTE != nil {
		predicates = append(predicates, currency.SymbolGTE(*i.SymbolGTE))
	}
	if i.SymbolLT != nil {
		predicates = append(predicates, currency.SymbolLT(*i.SymbolLT))
	}
	if i.SymbolLTE != nil {
		predicates = append(predicates, currency.SymbolLTE(*i.SymbolLTE))
	}
	if i.SymbolContains != nil {
		predicates = append(predicates, currency.SymbolContains(*i.SymbolContains))
	}
	if i.SymbolHasPrefix != nil {
		predicates = append(predicates, currency.SymbolHasPrefix(*i.SymbolHasPrefix))
	}
	if i.SymbolHasSuffix != nil {
		predicates = append(predicates, currency.SymbolHasSuffix(*i.SymbolHasSuffix))
	}
	if i.SymbolEqualFold != nil {
		predicates = append(predicates, currency.SymbolEqualFold(*i.SymbolEqualFold))
	}
	if i.SymbolContainsFold != nil {
		predicates = append(predicates, currency.SymbolContainsFold(*i.SymbolContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, currency.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, currency.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, currency.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, currency.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, currency.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, currency.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, currency.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, currency.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, currency.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, currency.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, currency.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, currency.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, currency.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, currency.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, currency.NameContainsFold(*i.NameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, currency.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, currency.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, currency.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, currency.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasCurrencyBase != nil {
		p := currency.HasCurrencyBase()
		if !*i.HasCurrencyBase {
			p = currency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCurrencyBaseWith) > 0 {
		with := make([]predicate.TradingPair, 0, len(i.HasCurrencyBaseWith))
		for _, w := range i.HasCurrencyBaseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCurrencyBaseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, currency.HasCurrencyBaseWith(with...))
	}
	if i.HasCurrencyCounter != nil {
		p := currency.HasCurrencyCounter()
		if !*i.HasCurrencyCounter {
			p = currency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCurrencyCounterWith) > 0 {
		with := make([]predicate.TradingPair, 0, len(i.HasCurrencyCounterWith))
		for _, w := range i.HasCurrencyCounterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCurrencyCounterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, currency.HasCurrencyCounterWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCurrencyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return currency.And(predicates...), nil
	}
}

// ExchangeWhereInput represents a where input for filtering Exchange queries.
type ExchangeWhereInput struct {
	Predicates []predicate.Exchange  `json:"-"`
	Not        *ExchangeWhereInput   `json:"not,omitempty"`
	Or         []*ExchangeWhereInput `json:"or,omitempty"`
	And        []*ExchangeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "exchange_id" field predicates.
	ExchangeID             *string  `json:"exchangeID,omitempty"`
	ExchangeIDNEQ          *string  `json:"exchangeIDNEQ,omitempty"`
	ExchangeIDIn           []string `json:"exchangeIDIn,omitempty"`
	ExchangeIDNotIn        []string `json:"exchangeIDNotIn,omitempty"`
	ExchangeIDGT           *string  `json:"exchangeIDGT,omitempty"`
	ExchangeIDGTE          *string  `json:"exchangeIDGTE,omitempty"`
	ExchangeIDLT           *string  `json:"exchangeIDLT,omitempty"`
	ExchangeIDLTE          *string  `json:"exchangeIDLTE,omitempty"`
	ExchangeIDContains     *string  `json:"exchangeIDContains,omitempty"`
	ExchangeIDHasPrefix    *string  `json:"exchangeIDHasPrefix,omitempty"`
	ExchangeIDHasSuffix    *string  `json:"exchangeIDHasSuffix,omitempty"`
	ExchangeIDEqualFold    *string  `json:"exchangeIDEqualFold,omitempty"`
	ExchangeIDContainsFold *string  `json:"exchangeIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "year_established" field predicates.
	YearEstablished       *int  `json:"yearEstablished,omitempty"`
	YearEstablishedNEQ    *int  `json:"yearEstablishedNEQ,omitempty"`
	YearEstablishedIn     []int `json:"yearEstablishedIn,omitempty"`
	YearEstablishedNotIn  []int `json:"yearEstablishedNotIn,omitempty"`
	YearEstablishedGT     *int  `json:"yearEstablishedGT,omitempty"`
	YearEstablishedGTE    *int  `json:"yearEstablishedGTE,omitempty"`
	YearEstablishedLT     *int  `json:"yearEstablishedLT,omitempty"`
	YearEstablishedLTE    *int  `json:"yearEstablishedLTE,omitempty"`
	YearEstablishedIsNil  bool  `json:"yearEstablishedIsNil,omitempty"`
	YearEstablishedNotNil bool  `json:"yearEstablishedNotNil,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryIsNil        bool     `json:"countryIsNil,omitempty"`
	CountryNotNil       bool     `json:"countryNotNil,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageIsNil        bool     `json:"imageIsNil,omitempty"`
	ImageNotNil       bool     `json:"imageNotNil,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "has_trading_incentive" field predicates.
	HasTradingIncentive       *bool `json:"hasTradingIncentive,omitempty"`
	HasTradingIncentiveNEQ    *bool `json:"hasTradingIncentiveNEQ,omitempty"`
	HasTradingIncentiveIsNil  bool  `json:"hasTradingIncentiveIsNil,omitempty"`
	HasTradingIncentiveNotNil bool  `json:"hasTradingIncentiveNotNil,omitempty"`

	// "centralized" field predicates.
	Centralized       *bool `json:"centralized,omitempty"`
	CentralizedNEQ    *bool `json:"centralizedNEQ,omitempty"`
	CentralizedIsNil  bool  `json:"centralizedIsNil,omitempty"`
	CentralizedNotNil bool  `json:"centralizedNotNil,omitempty"`

	// "public_notice" field predicates.
	PublicNotice             *string  `json:"publicNotice,omitempty"`
	PublicNoticeNEQ          *string  `json:"publicNoticeNEQ,omitempty"`
	PublicNoticeIn           []string `json:"publicNoticeIn,omitempty"`
	PublicNoticeNotIn        []string `json:"publicNoticeNotIn,omitempty"`
	PublicNoticeGT           *string  `json:"publicNoticeGT,omitempty"`
	PublicNoticeGTE          *string  `json:"publicNoticeGTE,omitempty"`
	PublicNoticeLT           *string  `json:"publicNoticeLT,omitempty"`
	PublicNoticeLTE          *string  `json:"publicNoticeLTE,omitempty"`
	PublicNoticeContains     *string  `json:"publicNoticeContains,omitempty"`
	PublicNoticeHasPrefix    *string  `json:"publicNoticeHasPrefix,omitempty"`
	PublicNoticeHasSuffix    *string  `json:"publicNoticeHasSuffix,omitempty"`
	PublicNoticeIsNil        bool     `json:"publicNoticeIsNil,omitempty"`
	PublicNoticeNotNil       bool     `json:"publicNoticeNotNil,omitempty"`
	PublicNoticeEqualFold    *string  `json:"publicNoticeEqualFold,omitempty"`
	PublicNoticeContainsFold *string  `json:"publicNoticeContainsFold,omitempty"`

	// "alert_notice" field predicates.
	AlertNotice             *string  `json:"alertNotice,omitempty"`
	AlertNoticeNEQ          *string  `json:"alertNoticeNEQ,omitempty"`
	AlertNoticeIn           []string `json:"alertNoticeIn,omitempty"`
	AlertNoticeNotIn        []string `json:"alertNoticeNotIn,omitempty"`
	AlertNoticeGT           *string  `json:"alertNoticeGT,omitempty"`
	AlertNoticeGTE          *string  `json:"alertNoticeGTE,omitempty"`
	AlertNoticeLT           *string  `json:"alertNoticeLT,omitempty"`
	AlertNoticeLTE          *string  `json:"alertNoticeLTE,omitempty"`
	AlertNoticeContains     *string  `json:"alertNoticeContains,omitempty"`
	AlertNoticeHasPrefix    *string  `json:"alertNoticeHasPrefix,omitempty"`
	AlertNoticeHasSuffix    *string  `json:"alertNoticeHasSuffix,omitempty"`
	AlertNoticeIsNil        bool     `json:"alertNoticeIsNil,omitempty"`
	AlertNoticeNotNil       bool     `json:"alertNoticeNotNil,omitempty"`
	AlertNoticeEqualFold    *string  `json:"alertNoticeEqualFold,omitempty"`
	AlertNoticeContainsFold *string  `json:"alertNoticeContainsFold,omitempty"`

	// "trust_score" field predicates.
	TrustScore       *int  `json:"trustScore,omitempty"`
	TrustScoreNEQ    *int  `json:"trustScoreNEQ,omitempty"`
	TrustScoreIn     []int `json:"trustScoreIn,omitempty"`
	TrustScoreNotIn  []int `json:"trustScoreNotIn,omitempty"`
	TrustScoreGT     *int  `json:"trustScoreGT,omitempty"`
	TrustScoreGTE    *int  `json:"trustScoreGTE,omitempty"`
	TrustScoreLT     *int  `json:"trustScoreLT,omitempty"`
	TrustScoreLTE    *int  `json:"trustScoreLTE,omitempty"`
	TrustScoreIsNil  bool  `json:"trustScoreIsNil,omitempty"`
	TrustScoreNotNil bool  `json:"trustScoreNotNil,omitempty"`

	// "trust_score_rank" field predicates.
	TrustScoreRank       *int  `json:"trustScoreRank,omitempty"`
	TrustScoreRankNEQ    *int  `json:"trustScoreRankNEQ,omitempty"`
	TrustScoreRankIn     []int `json:"trustScoreRankIn,omitempty"`
	TrustScoreRankNotIn  []int `json:"trustScoreRankNotIn,omitempty"`
	TrustScoreRankGT     *int  `json:"trustScoreRankGT,omitempty"`
	TrustScoreRankGTE    *int  `json:"trustScoreRankGTE,omitempty"`
	TrustScoreRankLT     *int  `json:"trustScoreRankLT,omitempty"`
	TrustScoreRankLTE    *int  `json:"trustScoreRankLTE,omitempty"`
	TrustScoreRankIsNil  bool  `json:"trustScoreRankIsNil,omitempty"`
	TrustScoreRankNotNil bool  `json:"trustScoreRankNotNil,omitempty"`

	// "trade_volume_24h_btc" field predicates.
	TradeVolume24hBtc       *float64  `json:"tradeVolume24hBtc,omitempty"`
	TradeVolume24hBtcNEQ    *float64  `json:"tradeVolume24hBtcNEQ,omitempty"`
	TradeVolume24hBtcIn     []float64 `json:"tradeVolume24hBtcIn,omitempty"`
	TradeVolume24hBtcNotIn  []float64 `json:"tradeVolume24hBtcNotIn,omitempty"`
	TradeVolume24hBtcGT     *float64  `json:"tradeVolume24hBtcGT,omitempty"`
	TradeVolume24hBtcGTE    *float64  `json:"tradeVolume24hBtcGTE,omitempty"`
	TradeVolume24hBtcLT     *float64  `json:"tradeVolume24hBtcLT,omitempty"`
	TradeVolume24hBtcLTE    *float64  `json:"tradeVolume24hBtcLTE,omitempty"`
	TradeVolume24hBtcIsNil  bool      `json:"tradeVolume24hBtcIsNil,omitempty"`
	TradeVolume24hBtcNotNil bool      `json:"tradeVolume24hBtcNotNil,omitempty"`

	// "trade_volume_24h_btc_normalized" field predicates.
	TradeVolume24hBtcNormalized       *float64  `json:"tradeVolume24hBtcNormalized,omitempty"`
	TradeVolume24hBtcNormalizedNEQ    *float64  `json:"tradeVolume24hBtcNormalizedNEQ,omitempty"`
	TradeVolume24hBtcNormalizedIn     []float64 `json:"tradeVolume24hBtcNormalizedIn,omitempty"`
	TradeVolume24hBtcNormalizedNotIn  []float64 `json:"tradeVolume24hBtcNormalizedNotIn,omitempty"`
	TradeVolume24hBtcNormalizedGT     *float64  `json:"tradeVolume24hBtcNormalizedGT,omitempty"`
	TradeVolume24hBtcNormalizedGTE    *float64  `json:"tradeVolume24hBtcNormalizedGTE,omitempty"`
	TradeVolume24hBtcNormalizedLT     *float64  `json:"tradeVolume24hBtcNormalizedLT,omitempty"`
	TradeVolume24hBtcNormalizedLTE    *float64  `json:"tradeVolume24hBtcNormalizedLTE,omitempty"`
	TradeVolume24hBtcNormalizedIsNil  bool      `json:"tradeVolume24hBtcNormalizedIsNil,omitempty"`
	TradeVolume24hBtcNormalizedNotNil bool      `json:"tradeVolume24hBtcNormalizedNotNil,omitempty"`

	// "maker_fee" field predicates.
	MakerFee       *float64  `json:"makerFee,omitempty"`
	MakerFeeNEQ    *float64  `json:"makerFeeNEQ,omitempty"`
	MakerFeeIn     []float64 `json:"makerFeeIn,omitempty"`
	MakerFeeNotIn  []float64 `json:"makerFeeNotIn,omitempty"`
	MakerFeeGT     *float64  `json:"makerFeeGT,omitempty"`
	MakerFeeGTE    *float64  `json:"makerFeeGTE,omitempty"`
	MakerFeeLT     *float64  `json:"makerFeeLT,omitempty"`
	MakerFeeLTE    *float64  `json:"makerFeeLTE,omitempty"`
	MakerFeeIsNil  bool      `json:"makerFeeIsNil,omitempty"`
	MakerFeeNotNil bool      `json:"makerFeeNotNil,omitempty"`

	// "taker_fee" field predicates.
	TakerFee       *float64  `json:"takerFee,omitempty"`
	TakerFeeNEQ    *float64  `json:"takerFeeNEQ,omitempty"`
	TakerFeeIn     []float64 `json:"takerFeeIn,omitempty"`
	TakerFeeNotIn  []float64 `json:"takerFeeNotIn,omitempty"`
	TakerFeeGT     *float64  `json:"takerFeeGT,omitempty"`
	TakerFeeGTE    *float64  `json:"takerFeeGTE,omitempty"`
	TakerFeeLT     *float64  `json:"takerFeeLT,omitempty"`
	TakerFeeLTE    *float64  `json:"takerFeeLTE,omitempty"`
	TakerFeeIsNil  bool      `json:"takerFeeIsNil,omitempty"`
	TakerFeeNotNil bool      `json:"takerFeeNotNil,omitempty"`

	// "spread_fee" field predicates.
	SpreadFee       *bool `json:"spreadFee,omitempty"`
	SpreadFeeNEQ    *bool `json:"spreadFeeNEQ,omitempty"`
	SpreadFeeIsNil  bool  `json:"spreadFeeIsNil,omitempty"`
	SpreadFeeNotNil bool  `json:"spreadFeeNotNil,omitempty"`

	// "support_api" field predicates.
	SupportAPI       *bool `json:"supportAPI,omitempty"`
	SupportAPINEQ    *bool `json:"supportAPINEQ,omitempty"`
	SupportAPIIsNil  bool  `json:"supportAPIIsNil,omitempty"`
	SupportAPINotNil bool  `json:"supportAPINotNil,omitempty"`

	// "ticker" edge predicates.
	HasTicker     *bool               `json:"hasTicker,omitempty"`
	HasTickerWith []*TickerWhereInput `json:"hasTickerWith,omitempty"`

	// "trading_pair" edge predicates.
	HasTradingPair     *bool                    `json:"hasTradingPair,omitempty"`
	HasTradingPairWith []*TradingPairWhereInput `json:"hasTradingPairWith,omitempty"`

	// "market" edge predicates.
	HasMarket     *bool               `json:"hasMarket,omitempty"`
	HasMarketWith []*MarketWhereInput `json:"hasMarketWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExchangeWhereInput) AddPredicates(predicates ...predicate.Exchange) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExchangeWhereInput filter on the ExchangeQuery builder.
func (i *ExchangeWhereInput) Filter(q *ExchangeQuery) (*ExchangeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExchangeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExchangeWhereInput is returned in case the ExchangeWhereInput is empty.
var ErrEmptyExchangeWhereInput = errors.New("entities: empty predicate ExchangeWhereInput")

// P returns a predicate for filtering exchanges.
// An error is returned if the input is empty or invalid.
func (i *ExchangeWhereInput) P() (predicate.Exchange, error) {
	var predicates []predicate.Exchange
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, exchange.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Exchange, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, exchange.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Exchange, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, exchange.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, exchange.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, exchange.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, exchange.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, exchange.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, exchange.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, exchange.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, exchange.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, exchange.IDLTE(*i.IDLTE))
	}
	if i.ExchangeID != nil {
		predicates = append(predicates, exchange.ExchangeIDEQ(*i.ExchangeID))
	}
	if i.ExchangeIDNEQ != nil {
		predicates = append(predicates, exchange.ExchangeIDNEQ(*i.ExchangeIDNEQ))
	}
	if len(i.ExchangeIDIn) > 0 {
		predicates = append(predicates, exchange.ExchangeIDIn(i.ExchangeIDIn...))
	}
	if len(i.ExchangeIDNotIn) > 0 {
		predicates = append(predicates, exchange.ExchangeIDNotIn(i.ExchangeIDNotIn...))
	}
	if i.ExchangeIDGT != nil {
		predicates = append(predicates, exchange.ExchangeIDGT(*i.ExchangeIDGT))
	}
	if i.ExchangeIDGTE != nil {
		predicates = append(predicates, exchange.ExchangeIDGTE(*i.ExchangeIDGTE))
	}
	if i.ExchangeIDLT != nil {
		predicates = append(predicates, exchange.ExchangeIDLT(*i.ExchangeIDLT))
	}
	if i.ExchangeIDLTE != nil {
		predicates = append(predicates, exchange.ExchangeIDLTE(*i.ExchangeIDLTE))
	}
	if i.ExchangeIDContains != nil {
		predicates = append(predicates, exchange.ExchangeIDContains(*i.ExchangeIDContains))
	}
	if i.ExchangeIDHasPrefix != nil {
		predicates = append(predicates, exchange.ExchangeIDHasPrefix(*i.ExchangeIDHasPrefix))
	}
	if i.ExchangeIDHasSuffix != nil {
		predicates = append(predicates, exchange.ExchangeIDHasSuffix(*i.ExchangeIDHasSuffix))
	}
	if i.ExchangeIDEqualFold != nil {
		predicates = append(predicates, exchange.ExchangeIDEqualFold(*i.ExchangeIDEqualFold))
	}
	if i.ExchangeIDContainsFold != nil {
		predicates = append(predicates, exchange.ExchangeIDContainsFold(*i.ExchangeIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, exchange.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, exchange.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, exchange.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, exchange.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, exchange.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, exchange.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, exchange.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, exchange.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, exchange.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, exchange.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, exchange.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, exchange.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, exchange.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, exchange.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, exchange.NameContainsFold(*i.NameContainsFold))
	}
	if i.YearEstablished != nil {
		predicates = append(predicates, exchange.YearEstablishedEQ(*i.YearEstablished))
	}
	if i.YearEstablishedNEQ != nil {
		predicates = append(predicates, exchange.YearEstablishedNEQ(*i.YearEstablishedNEQ))
	}
	if len(i.YearEstablishedIn) > 0 {
		predicates = append(predicates, exchange.YearEstablishedIn(i.YearEstablishedIn...))
	}
	if len(i.YearEstablishedNotIn) > 0 {
		predicates = append(predicates, exchange.YearEstablishedNotIn(i.YearEstablishedNotIn...))
	}
	if i.YearEstablishedGT != nil {
		predicates = append(predicates, exchange.YearEstablishedGT(*i.YearEstablishedGT))
	}
	if i.YearEstablishedGTE != nil {
		predicates = append(predicates, exchange.YearEstablishedGTE(*i.YearEstablishedGTE))
	}
	if i.YearEstablishedLT != nil {
		predicates = append(predicates, exchange.YearEstablishedLT(*i.YearEstablishedLT))
	}
	if i.YearEstablishedLTE != nil {
		predicates = append(predicates, exchange.YearEstablishedLTE(*i.YearEstablishedLTE))
	}
	if i.YearEstablishedIsNil {
		predicates = append(predicates, exchange.YearEstablishedIsNil())
	}
	if i.YearEstablishedNotNil {
		predicates = append(predicates, exchange.YearEstablishedNotNil())
	}
	if i.Country != nil {
		predicates = append(predicates, exchange.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, exchange.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, exchange.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, exchange.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, exchange.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, exchange.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, exchange.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, exchange.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, exchange.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, exchange.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, exchange.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryIsNil {
		predicates = append(predicates, exchange.CountryIsNil())
	}
	if i.CountryNotNil {
		predicates = append(predicates, exchange.CountryNotNil())
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, exchange.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, exchange.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, exchange.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, exchange.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, exchange.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, exchange.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, exchange.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, exchange.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, exchange.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, exchange.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, exchange.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, exchange.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, exchange.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageIsNil {
		predicates = append(predicates, exchange.ImageIsNil())
	}
	if i.ImageNotNil {
		predicates = append(predicates, exchange.ImageNotNil())
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, exchange.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, exchange.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.HasTradingIncentive != nil {
		predicates = append(predicates, exchange.HasTradingIncentiveEQ(*i.HasTradingIncentive))
	}
	if i.HasTradingIncentiveNEQ != nil {
		predicates = append(predicates, exchange.HasTradingIncentiveNEQ(*i.HasTradingIncentiveNEQ))
	}
	if i.HasTradingIncentiveIsNil {
		predicates = append(predicates, exchange.HasTradingIncentiveIsNil())
	}
	if i.HasTradingIncentiveNotNil {
		predicates = append(predicates, exchange.HasTradingIncentiveNotNil())
	}
	if i.Centralized != nil {
		predicates = append(predicates, exchange.CentralizedEQ(*i.Centralized))
	}
	if i.CentralizedNEQ != nil {
		predicates = append(predicates, exchange.CentralizedNEQ(*i.CentralizedNEQ))
	}
	if i.CentralizedIsNil {
		predicates = append(predicates, exchange.CentralizedIsNil())
	}
	if i.CentralizedNotNil {
		predicates = append(predicates, exchange.CentralizedNotNil())
	}
	if i.PublicNotice != nil {
		predicates = append(predicates, exchange.PublicNoticeEQ(*i.PublicNotice))
	}
	if i.PublicNoticeNEQ != nil {
		predicates = append(predicates, exchange.PublicNoticeNEQ(*i.PublicNoticeNEQ))
	}
	if len(i.PublicNoticeIn) > 0 {
		predicates = append(predicates, exchange.PublicNoticeIn(i.PublicNoticeIn...))
	}
	if len(i.PublicNoticeNotIn) > 0 {
		predicates = append(predicates, exchange.PublicNoticeNotIn(i.PublicNoticeNotIn...))
	}
	if i.PublicNoticeGT != nil {
		predicates = append(predicates, exchange.PublicNoticeGT(*i.PublicNoticeGT))
	}
	if i.PublicNoticeGTE != nil {
		predicates = append(predicates, exchange.PublicNoticeGTE(*i.PublicNoticeGTE))
	}
	if i.PublicNoticeLT != nil {
		predicates = append(predicates, exchange.PublicNoticeLT(*i.PublicNoticeLT))
	}
	if i.PublicNoticeLTE != nil {
		predicates = append(predicates, exchange.PublicNoticeLTE(*i.PublicNoticeLTE))
	}
	if i.PublicNoticeContains != nil {
		predicates = append(predicates, exchange.PublicNoticeContains(*i.PublicNoticeContains))
	}
	if i.PublicNoticeHasPrefix != nil {
		predicates = append(predicates, exchange.PublicNoticeHasPrefix(*i.PublicNoticeHasPrefix))
	}
	if i.PublicNoticeHasSuffix != nil {
		predicates = append(predicates, exchange.PublicNoticeHasSuffix(*i.PublicNoticeHasSuffix))
	}
	if i.PublicNoticeIsNil {
		predicates = append(predicates, exchange.PublicNoticeIsNil())
	}
	if i.PublicNoticeNotNil {
		predicates = append(predicates, exchange.PublicNoticeNotNil())
	}
	if i.PublicNoticeEqualFold != nil {
		predicates = append(predicates, exchange.PublicNoticeEqualFold(*i.PublicNoticeEqualFold))
	}
	if i.PublicNoticeContainsFold != nil {
		predicates = append(predicates, exchange.PublicNoticeContainsFold(*i.PublicNoticeContainsFold))
	}
	if i.AlertNotice != nil {
		predicates = append(predicates, exchange.AlertNoticeEQ(*i.AlertNotice))
	}
	if i.AlertNoticeNEQ != nil {
		predicates = append(predicates, exchange.AlertNoticeNEQ(*i.AlertNoticeNEQ))
	}
	if len(i.AlertNoticeIn) > 0 {
		predicates = append(predicates, exchange.AlertNoticeIn(i.AlertNoticeIn...))
	}
	if len(i.AlertNoticeNotIn) > 0 {
		predicates = append(predicates, exchange.AlertNoticeNotIn(i.AlertNoticeNotIn...))
	}
	if i.AlertNoticeGT != nil {
		predicates = append(predicates, exchange.AlertNoticeGT(*i.AlertNoticeGT))
	}
	if i.AlertNoticeGTE != nil {
		predicates = append(predicates, exchange.AlertNoticeGTE(*i.AlertNoticeGTE))
	}
	if i.AlertNoticeLT != nil {
		predicates = append(predicates, exchange.AlertNoticeLT(*i.AlertNoticeLT))
	}
	if i.AlertNoticeLTE != nil {
		predicates = append(predicates, exchange.AlertNoticeLTE(*i.AlertNoticeLTE))
	}
	if i.AlertNoticeContains != nil {
		predicates = append(predicates, exchange.AlertNoticeContains(*i.AlertNoticeContains))
	}
	if i.AlertNoticeHasPrefix != nil {
		predicates = append(predicates, exchange.AlertNoticeHasPrefix(*i.AlertNoticeHasPrefix))
	}
	if i.AlertNoticeHasSuffix != nil {
		predicates = append(predicates, exchange.AlertNoticeHasSuffix(*i.AlertNoticeHasSuffix))
	}
	if i.AlertNoticeIsNil {
		predicates = append(predicates, exchange.AlertNoticeIsNil())
	}
	if i.AlertNoticeNotNil {
		predicates = append(predicates, exchange.AlertNoticeNotNil())
	}
	if i.AlertNoticeEqualFold != nil {
		predicates = append(predicates, exchange.AlertNoticeEqualFold(*i.AlertNoticeEqualFold))
	}
	if i.AlertNoticeContainsFold != nil {
		predicates = append(predicates, exchange.AlertNoticeContainsFold(*i.AlertNoticeContainsFold))
	}
	if i.TrustScore != nil {
		predicates = append(predicates, exchange.TrustScoreEQ(*i.TrustScore))
	}
	if i.TrustScoreNEQ != nil {
		predicates = append(predicates, exchange.TrustScoreNEQ(*i.TrustScoreNEQ))
	}
	if len(i.TrustScoreIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreIn(i.TrustScoreIn...))
	}
	if len(i.TrustScoreNotIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreNotIn(i.TrustScoreNotIn...))
	}
	if i.TrustScoreGT != nil {
		predicates = append(predicates, exchange.TrustScoreGT(*i.TrustScoreGT))
	}
	if i.TrustScoreGTE != nil {
		predicates = append(predicates, exchange.TrustScoreGTE(*i.TrustScoreGTE))
	}
	if i.TrustScoreLT != nil {
		predicates = append(predicates, exchange.TrustScoreLT(*i.TrustScoreLT))
	}
	if i.TrustScoreLTE != nil {
		predicates = append(predicates, exchange.TrustScoreLTE(*i.TrustScoreLTE))
	}
	if i.TrustScoreIsNil {
		predicates = append(predicates, exchange.TrustScoreIsNil())
	}
	if i.TrustScoreNotNil {
		predicates = append(predicates, exchange.TrustScoreNotNil())
	}
	if i.TrustScoreRank != nil {
		predicates = append(predicates, exchange.TrustScoreRankEQ(*i.TrustScoreRank))
	}
	if i.TrustScoreRankNEQ != nil {
		predicates = append(predicates, exchange.TrustScoreRankNEQ(*i.TrustScoreRankNEQ))
	}
	if len(i.TrustScoreRankIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreRankIn(i.TrustScoreRankIn...))
	}
	if len(i.TrustScoreRankNotIn) > 0 {
		predicates = append(predicates, exchange.TrustScoreRankNotIn(i.TrustScoreRankNotIn...))
	}
	if i.TrustScoreRankGT != nil {
		predicates = append(predicates, exchange.TrustScoreRankGT(*i.TrustScoreRankGT))
	}
	if i.TrustScoreRankGTE != nil {
		predicates = append(predicates, exchange.TrustScoreRankGTE(*i.TrustScoreRankGTE))
	}
	if i.TrustScoreRankLT != nil {
		predicates = append(predicates, exchange.TrustScoreRankLT(*i.TrustScoreRankLT))
	}
	if i.TrustScoreRankLTE != nil {
		predicates = append(predicates, exchange.TrustScoreRankLTE(*i.TrustScoreRankLTE))
	}
	if i.TrustScoreRankIsNil {
		predicates = append(predicates, exchange.TrustScoreRankIsNil())
	}
	if i.TrustScoreRankNotNil {
		predicates = append(predicates, exchange.TrustScoreRankNotNil())
	}
	if i.TradeVolume24hBtc != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcEQ(*i.TradeVolume24hBtc))
	}
	if i.TradeVolume24hBtcNEQ != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNEQ(*i.TradeVolume24hBtcNEQ))
	}
	if len(i.TradeVolume24hBtcIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcIn(i.TradeVolume24hBtcIn...))
	}
	if len(i.TradeVolume24hBtcNotIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNotIn(i.TradeVolume24hBtcNotIn...))
	}
	if i.TradeVolume24hBtcGT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcGT(*i.TradeVolume24hBtcGT))
	}
	if i.TradeVolume24hBtcGTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcGTE(*i.TradeVolume24hBtcGTE))
	}
	if i.TradeVolume24hBtcLT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcLT(*i.TradeVolume24hBtcLT))
	}
	if i.TradeVolume24hBtcLTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcLTE(*i.TradeVolume24hBtcLTE))
	}
	if i.TradeVolume24hBtcIsNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcIsNil())
	}
	if i.TradeVolume24hBtcNotNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNotNil())
	}
	if i.TradeVolume24hBtcNormalized != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedEQ(*i.TradeVolume24hBtcNormalized))
	}
	if i.TradeVolume24hBtcNormalizedNEQ != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNEQ(*i.TradeVolume24hBtcNormalizedNEQ))
	}
	if len(i.TradeVolume24hBtcNormalizedIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedIn(i.TradeVolume24hBtcNormalizedIn...))
	}
	if len(i.TradeVolume24hBtcNormalizedNotIn) > 0 {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNotIn(i.TradeVolume24hBtcNormalizedNotIn...))
	}
	if i.TradeVolume24hBtcNormalizedGT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedGT(*i.TradeVolume24hBtcNormalizedGT))
	}
	if i.TradeVolume24hBtcNormalizedGTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedGTE(*i.TradeVolume24hBtcNormalizedGTE))
	}
	if i.TradeVolume24hBtcNormalizedLT != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedLT(*i.TradeVolume24hBtcNormalizedLT))
	}
	if i.TradeVolume24hBtcNormalizedLTE != nil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedLTE(*i.TradeVolume24hBtcNormalizedLTE))
	}
	if i.TradeVolume24hBtcNormalizedIsNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedIsNil())
	}
	if i.TradeVolume24hBtcNormalizedNotNil {
		predicates = append(predicates, exchange.TradeVolume24hBtcNormalizedNotNil())
	}
	if i.MakerFee != nil {
		predicates = append(predicates, exchange.MakerFeeEQ(*i.MakerFee))
	}
	if i.MakerFeeNEQ != nil {
		predicates = append(predicates, exchange.MakerFeeNEQ(*i.MakerFeeNEQ))
	}
	if len(i.MakerFeeIn) > 0 {
		predicates = append(predicates, exchange.MakerFeeIn(i.MakerFeeIn...))
	}
	if len(i.MakerFeeNotIn) > 0 {
		predicates = append(predicates, exchange.MakerFeeNotIn(i.MakerFeeNotIn...))
	}
	if i.MakerFeeGT != nil {
		predicates = append(predicates, exchange.MakerFeeGT(*i.MakerFeeGT))
	}
	if i.MakerFeeGTE != nil {
		predicates = append(predicates, exchange.MakerFeeGTE(*i.MakerFeeGTE))
	}
	if i.MakerFeeLT != nil {
		predicates = append(predicates, exchange.MakerFeeLT(*i.MakerFeeLT))
	}
	if i.MakerFeeLTE != nil {
		predicates = append(predicates, exchange.MakerFeeLTE(*i.MakerFeeLTE))
	}
	if i.MakerFeeIsNil {
		predicates = append(predicates, exchange.MakerFeeIsNil())
	}
	if i.MakerFeeNotNil {
		predicates = append(predicates, exchange.MakerFeeNotNil())
	}
	if i.TakerFee != nil {
		predicates = append(predicates, exchange.TakerFeeEQ(*i.TakerFee))
	}
	if i.TakerFeeNEQ != nil {
		predicates = append(predicates, exchange.TakerFeeNEQ(*i.TakerFeeNEQ))
	}
	if len(i.TakerFeeIn) > 0 {
		predicates = append(predicates, exchange.TakerFeeIn(i.TakerFeeIn...))
	}
	if len(i.TakerFeeNotIn) > 0 {
		predicates = append(predicates, exchange.TakerFeeNotIn(i.TakerFeeNotIn...))
	}
	if i.TakerFeeGT != nil {
		predicates = append(predicates, exchange.TakerFeeGT(*i.TakerFeeGT))
	}
	if i.TakerFeeGTE != nil {
		predicates = append(predicates, exchange.TakerFeeGTE(*i.TakerFeeGTE))
	}
	if i.TakerFeeLT != nil {
		predicates = append(predicates, exchange.TakerFeeLT(*i.TakerFeeLT))
	}
	if i.TakerFeeLTE != nil {
		predicates = append(predicates, exchange.TakerFeeLTE(*i.TakerFeeLTE))
	}
	if i.TakerFeeIsNil {
		predicates = append(predicates, exchange.TakerFeeIsNil())
	}
	if i.TakerFeeNotNil {
		predicates = append(predicates, exchange.TakerFeeNotNil())
	}
	if i.SpreadFee != nil {
		predicates = append(predicates, exchange.SpreadFeeEQ(*i.SpreadFee))
	}
	if i.SpreadFeeNEQ != nil {
		predicates = append(predicates, exchange.SpreadFeeNEQ(*i.SpreadFeeNEQ))
	}
	if i.SpreadFeeIsNil {
		predicates = append(predicates, exchange.SpreadFeeIsNil())
	}
	if i.SpreadFeeNotNil {
		predicates = append(predicates, exchange.SpreadFeeNotNil())
	}
	if i.SupportAPI != nil {
		predicates = append(predicates, exchange.SupportAPIEQ(*i.SupportAPI))
	}
	if i.SupportAPINEQ != nil {
		predicates = append(predicates, exchange.SupportAPINEQ(*i.SupportAPINEQ))
	}
	if i.SupportAPIIsNil {
		predicates = append(predicates, exchange.SupportAPIIsNil())
	}
	if i.SupportAPINotNil {
		predicates = append(predicates, exchange.SupportAPINotNil())
	}

	if i.HasTicker != nil {
		p := exchange.HasTicker()
		if !*i.HasTicker {
			p = exchange.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTickerWith) > 0 {
		with := make([]predicate.Ticker, 0, len(i.HasTickerWith))
		for _, w := range i.HasTickerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTickerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exchange.HasTickerWith(with...))
	}
	if i.HasTradingPair != nil {
		p := exchange.HasTradingPair()
		if !*i.HasTradingPair {
			p = exchange.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTradingPairWith) > 0 {
		with := make([]predicate.TradingPair, 0, len(i.HasTradingPairWith))
		for _, w := range i.HasTradingPairWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTradingPairWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exchange.HasTradingPairWith(with...))
	}
	if i.HasMarket != nil {
		p := exchange.HasMarket()
		if !*i.HasMarket {
			p = exchange.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMarketWith) > 0 {
		with := make([]predicate.Market, 0, len(i.HasMarketWith))
		for _, w := range i.HasMarketWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMarketWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exchange.HasMarketWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExchangeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return exchange.And(predicates...), nil
	}
}

// MarketWhereInput represents a where input for filtering Market queries.
type MarketWhereInput struct {
	Predicates []predicate.Market  `json:"-"`
	Not        *MarketWhereInput   `json:"not,omitempty"`
	Or         []*MarketWhereInput `json:"or,omitempty"`
	And        []*MarketWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type" field predicates.
	Type      *market.Type  `json:"type,omitempty"`
	TypeNEQ   *market.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []market.Type `json:"typeIn,omitempty"`
	TypeNotIn []market.Type `json:"typeNotIn,omitempty"`

	// "exchange" edge predicates.
	HasExchange     *bool                 `json:"hasExchange,omitempty"`
	HasExchangeWith []*ExchangeWhereInput `json:"hasExchangeWith,omitempty"`

	// "trading_pair" edge predicates.
	HasTradingPair     *bool                    `json:"hasTradingPair,omitempty"`
	HasTradingPairWith []*TradingPairWhereInput `json:"hasTradingPairWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MarketWhereInput) AddPredicates(predicates ...predicate.Market) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MarketWhereInput filter on the MarketQuery builder.
func (i *MarketWhereInput) Filter(q *MarketQuery) (*MarketQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMarketWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMarketWhereInput is returned in case the MarketWhereInput is empty.
var ErrEmptyMarketWhereInput = errors.New("entities: empty predicate MarketWhereInput")

// P returns a predicate for filtering markets.
// An error is returned if the input is empty or invalid.
func (i *MarketWhereInput) P() (predicate.Market, error) {
	var predicates []predicate.Market
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, market.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Market, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, market.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Market, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, market.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, market.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, market.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, market.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, market.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, market.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, market.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, market.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, market.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, market.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, market.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, market.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, market.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, market.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, market.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, market.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, market.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, market.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, market.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, market.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, market.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, market.NameContainsFold(*i.NameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, market.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, market.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, market.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, market.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasExchange != nil {
		p := market.HasExchange()
		if !*i.HasExchange {
			p = market.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExchangeWith) > 0 {
		with := make([]predicate.Exchange, 0, len(i.HasExchangeWith))
		for _, w := range i.HasExchangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExchangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, market.HasExchangeWith(with...))
	}
	if i.HasTradingPair != nil {
		p := market.HasTradingPair()
		if !*i.HasTradingPair {
			p = market.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTradingPairWith) > 0 {
		with := make([]predicate.TradingPair, 0, len(i.HasTradingPairWith))
		for _, w := range i.HasTradingPairWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTradingPairWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, market.HasTradingPairWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMarketWhereInput
	case 1:
		return predicates[0], nil
	default:
		return market.And(predicates...), nil
	}
}

// OutboxWhereInput represents a where input for filtering Outbox queries.
type OutboxWhereInput struct {
	Predicates []predicate.Outbox  `json:"-"`
	Not        *OutboxWhereInput   `json:"not,omitempty"`
	Or         []*OutboxWhereInput `json:"or,omitempty"`
	And        []*OutboxWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "topic" field predicates.
	Topic             *string  `json:"topic,omitempty"`
	TopicNEQ          *string  `json:"topicNEQ,omitempty"`
	TopicIn           []string `json:"topicIn,omitempty"`
	TopicNotIn        []string `json:"topicNotIn,omitempty"`
	TopicGT           *string  `json:"topicGT,omitempty"`
	TopicGTE          *string  `json:"topicGTE,omitempty"`
	TopicLT           *string  `json:"topicLT,omitempty"`
	TopicLTE          *string  `json:"topicLTE,omitempty"`
	TopicContains     *string  `json:"topicContains,omitempty"`
	TopicHasPrefix    *string  `json:"topicHasPrefix,omitempty"`
	TopicHasSuffix    *string  `json:"topicHasSuffix,omitempty"`
	TopicEqualFold    *string  `json:"topicEqualFold,omitempty"`
	TopicContainsFold *string  `json:"topicContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "retry_count" field predicates.
	RetryCount      *int  `json:"retryCount,omitempty"`
	RetryCountNEQ   *int  `json:"retryCountNEQ,omitempty"`
	RetryCountIn    []int `json:"retryCountIn,omitempty"`
	RetryCountNotIn []int `json:"retryCountNotIn,omitempty"`
	RetryCountGT    *int  `json:"retryCountGT,omitempty"`
	RetryCountGTE   *int  `json:"retryCountGTE,omitempty"`
	RetryCountLT    *int  `json:"retryCountLT,omitempty"`
	RetryCountLTE   *int  `json:"retryCountLTE,omitempty"`

	// "status" field predicates.
	Status      *outbox.Status  `json:"status,omitempty"`
	StatusNEQ   *outbox.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []outbox.Status `json:"statusIn,omitempty"`
	StatusNotIn []outbox.Status `json:"statusNotIn,omitempty"`

	// "last_retry" field predicates.
	LastRetry       *time.Time  `json:"lastRetry,omitempty"`
	LastRetryNEQ    *time.Time  `json:"lastRetryNEQ,omitempty"`
	LastRetryIn     []time.Time `json:"lastRetryIn,omitempty"`
	LastRetryNotIn  []time.Time `json:"lastRetryNotIn,omitempty"`
	LastRetryGT     *time.Time  `json:"lastRetryGT,omitempty"`
	LastRetryGTE    *time.Time  `json:"lastRetryGTE,omitempty"`
	LastRetryLT     *time.Time  `json:"lastRetryLT,omitempty"`
	LastRetryLTE    *time.Time  `json:"lastRetryLTE,omitempty"`
	LastRetryIsNil  bool        `json:"lastRetryIsNil,omitempty"`
	LastRetryNotNil bool        `json:"lastRetryNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OutboxWhereInput) AddPredicates(predicates ...predicate.Outbox) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OutboxWhereInput filter on the OutboxQuery builder.
func (i *OutboxWhereInput) Filter(q *OutboxQuery) (*OutboxQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOutboxWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOutboxWhereInput is returned in case the OutboxWhereInput is empty.
var ErrEmptyOutboxWhereInput = errors.New("entities: empty predicate OutboxWhereInput")

// P returns a predicate for filtering outboxes.
// An error is returned if the input is empty or invalid.
func (i *OutboxWhereInput) P() (predicate.Outbox, error) {
	var predicates []predicate.Outbox
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, outbox.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Outbox, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, outbox.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Outbox, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, outbox.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, outbox.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, outbox.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, outbox.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, outbox.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, outbox.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, outbox.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, outbox.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, outbox.IDLTE(*i.IDLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, outbox.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, outbox.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, outbox.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, outbox.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, outbox.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, outbox.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, outbox.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, outbox.TimestampLTE(*i.TimestampLTE))
	}
	if i.Topic != nil {
		predicates = append(predicates, outbox.TopicEQ(*i.Topic))
	}
	if i.TopicNEQ != nil {
		predicates = append(predicates, outbox.TopicNEQ(*i.TopicNEQ))
	}
	if len(i.TopicIn) > 0 {
		predicates = append(predicates, outbox.TopicIn(i.TopicIn...))
	}
	if len(i.TopicNotIn) > 0 {
		predicates = append(predicates, outbox.TopicNotIn(i.TopicNotIn...))
	}
	if i.TopicGT != nil {
		predicates = append(predicates, outbox.TopicGT(*i.TopicGT))
	}
	if i.TopicGTE != nil {
		predicates = append(predicates, outbox.TopicGTE(*i.TopicGTE))
	}
	if i.TopicLT != nil {
		predicates = append(predicates, outbox.TopicLT(*i.TopicLT))
	}
	if i.TopicLTE != nil {
		predicates = append(predicates, outbox.TopicLTE(*i.TopicLTE))
	}
	if i.TopicContains != nil {
		predicates = append(predicates, outbox.TopicContains(*i.TopicContains))
	}
	if i.TopicHasPrefix != nil {
		predicates = append(predicates, outbox.TopicHasPrefix(*i.TopicHasPrefix))
	}
	if i.TopicHasSuffix != nil {
		predicates = append(predicates, outbox.TopicHasSuffix(*i.TopicHasSuffix))
	}
	if i.TopicEqualFold != nil {
		predicates = append(predicates, outbox.TopicEqualFold(*i.TopicEqualFold))
	}
	if i.TopicContainsFold != nil {
		predicates = append(predicates, outbox.TopicContainsFold(*i.TopicContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, outbox.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, outbox.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, outbox.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, outbox.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, outbox.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, outbox.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, outbox.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, outbox.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, outbox.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, outbox.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, outbox.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, outbox.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, outbox.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.RetryCount != nil {
		predicates = append(predicates, outbox.RetryCountEQ(*i.RetryCount))
	}
	if i.RetryCountNEQ != nil {
		predicates = append(predicates, outbox.RetryCountNEQ(*i.RetryCountNEQ))
	}
	if len(i.RetryCountIn) > 0 {
		predicates = append(predicates, outbox.RetryCountIn(i.RetryCountIn...))
	}
	if len(i.RetryCountNotIn) > 0 {
		predicates = append(predicates, outbox.RetryCountNotIn(i.RetryCountNotIn...))
	}
	if i.RetryCountGT != nil {
		predicates = append(predicates, outbox.RetryCountGT(*i.RetryCountGT))
	}
	if i.RetryCountGTE != nil {
		predicates = append(predicates, outbox.RetryCountGTE(*i.RetryCountGTE))
	}
	if i.RetryCountLT != nil {
		predicates = append(predicates, outbox.RetryCountLT(*i.RetryCountLT))
	}
	if i.RetryCountLTE != nil {
		predicates = append(predicates, outbox.RetryCountLTE(*i.RetryCountLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, outbox.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, outbox.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, outbox.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, outbox.StatusNotIn(i.StatusNotIn...))
	}
	if i.LastRetry != nil {
		predicates = append(predicates, outbox.LastRetryEQ(*i.LastRetry))
	}
	if i.LastRetryNEQ != nil {
		predicates = append(predicates, outbox.LastRetryNEQ(*i.LastRetryNEQ))
	}
	if len(i.LastRetryIn) > 0 {
		predicates = append(predicates, outbox.LastRetryIn(i.LastRetryIn...))
	}
	if len(i.LastRetryNotIn) > 0 {
		predicates = append(predicates, outbox.LastRetryNotIn(i.LastRetryNotIn...))
	}
	if i.LastRetryGT != nil {
		predicates = append(predicates, outbox.LastRetryGT(*i.LastRetryGT))
	}
	if i.LastRetryGTE != nil {
		predicates = append(predicates, outbox.LastRetryGTE(*i.LastRetryGTE))
	}
	if i.LastRetryLT != nil {
		predicates = append(predicates, outbox.LastRetryLT(*i.LastRetryLT))
	}
	if i.LastRetryLTE != nil {
		predicates = append(predicates, outbox.LastRetryLTE(*i.LastRetryLTE))
	}
	if i.LastRetryIsNil {
		predicates = append(predicates, outbox.LastRetryIsNil())
	}
	if i.LastRetryNotNil {
		predicates = append(predicates, outbox.LastRetryNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOutboxWhereInput
	case 1:
		return predicates[0], nil
	default:
		return outbox.And(predicates...), nil
	}
}

// TickerWhereInput represents a where input for filtering Ticker queries.
type TickerWhereInput struct {
	Predicates []predicate.Ticker  `json:"-"`
	Not        *TickerWhereInput   `json:"not,omitempty"`
	Or         []*TickerWhereInput `json:"or,omitempty"`
	And        []*TickerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "base" field predicates.
	Base             *string  `json:"base,omitempty"`
	BaseNEQ          *string  `json:"baseNEQ,omitempty"`
	BaseIn           []string `json:"baseIn,omitempty"`
	BaseNotIn        []string `json:"baseNotIn,omitempty"`
	BaseGT           *string  `json:"baseGT,omitempty"`
	BaseGTE          *string  `json:"baseGTE,omitempty"`
	BaseLT           *string  `json:"baseLT,omitempty"`
	BaseLTE          *string  `json:"baseLTE,omitempty"`
	BaseContains     *string  `json:"baseContains,omitempty"`
	BaseHasPrefix    *string  `json:"baseHasPrefix,omitempty"`
	BaseHasSuffix    *string  `json:"baseHasSuffix,omitempty"`
	BaseEqualFold    *string  `json:"baseEqualFold,omitempty"`
	BaseContainsFold *string  `json:"baseContainsFold,omitempty"`

	// "base_coin_id" field predicates.
	BaseCoinID             *string  `json:"baseCoinID,omitempty"`
	BaseCoinIDNEQ          *string  `json:"baseCoinIDNEQ,omitempty"`
	BaseCoinIDIn           []string `json:"baseCoinIDIn,omitempty"`
	BaseCoinIDNotIn        []string `json:"baseCoinIDNotIn,omitempty"`
	BaseCoinIDGT           *string  `json:"baseCoinIDGT,omitempty"`
	BaseCoinIDGTE          *string  `json:"baseCoinIDGTE,omitempty"`
	BaseCoinIDLT           *string  `json:"baseCoinIDLT,omitempty"`
	BaseCoinIDLTE          *string  `json:"baseCoinIDLTE,omitempty"`
	BaseCoinIDContains     *string  `json:"baseCoinIDContains,omitempty"`
	BaseCoinIDHasPrefix    *string  `json:"baseCoinIDHasPrefix,omitempty"`
	BaseCoinIDHasSuffix    *string  `json:"baseCoinIDHasSuffix,omitempty"`
	BaseCoinIDIsNil        bool     `json:"baseCoinIDIsNil,omitempty"`
	BaseCoinIDNotNil       bool     `json:"baseCoinIDNotNil,omitempty"`
	BaseCoinIDEqualFold    *string  `json:"baseCoinIDEqualFold,omitempty"`
	BaseCoinIDContainsFold *string  `json:"baseCoinIDContainsFold,omitempty"`

	// "counter" field predicates.
	Counter             *string  `json:"counter,omitempty"`
	CounterNEQ          *string  `json:"counterNEQ,omitempty"`
	CounterIn           []string `json:"counterIn,omitempty"`
	CounterNotIn        []string `json:"counterNotIn,omitempty"`
	CounterGT           *string  `json:"counterGT,omitempty"`
	CounterGTE          *string  `json:"counterGTE,omitempty"`
	CounterLT           *string  `json:"counterLT,omitempty"`
	CounterLTE          *string  `json:"counterLTE,omitempty"`
	CounterContains     *string  `json:"counterContains,omitempty"`
	CounterHasPrefix    *string  `json:"counterHasPrefix,omitempty"`
	CounterHasSuffix    *string  `json:"counterHasSuffix,omitempty"`
	CounterEqualFold    *string  `json:"counterEqualFold,omitempty"`
	CounterContainsFold *string  `json:"counterContainsFold,omitempty"`

	// "counter_coin_id" field predicates.
	CounterCoinID             *string  `json:"counterCoinID,omitempty"`
	CounterCoinIDNEQ          *string  `json:"counterCoinIDNEQ,omitempty"`
	CounterCoinIDIn           []string `json:"counterCoinIDIn,omitempty"`
	CounterCoinIDNotIn        []string `json:"counterCoinIDNotIn,omitempty"`
	CounterCoinIDGT           *string  `json:"counterCoinIDGT,omitempty"`
	CounterCoinIDGTE          *string  `json:"counterCoinIDGTE,omitempty"`
	CounterCoinIDLT           *string  `json:"counterCoinIDLT,omitempty"`
	CounterCoinIDLTE          *string  `json:"counterCoinIDLTE,omitempty"`
	CounterCoinIDContains     *string  `json:"counterCoinIDContains,omitempty"`
	CounterCoinIDHasPrefix    *string  `json:"counterCoinIDHasPrefix,omitempty"`
	CounterCoinIDHasSuffix    *string  `json:"counterCoinIDHasSuffix,omitempty"`
	CounterCoinIDIsNil        bool     `json:"counterCoinIDIsNil,omitempty"`
	CounterCoinIDNotNil       bool     `json:"counterCoinIDNotNil,omitempty"`
	CounterCoinIDEqualFold    *string  `json:"counterCoinIDEqualFold,omitempty"`
	CounterCoinIDContainsFold *string  `json:"counterCoinIDContainsFold,omitempty"`

	// "last" field predicates.
	Last       *float64  `json:"last,omitempty"`
	LastNEQ    *float64  `json:"lastNEQ,omitempty"`
	LastIn     []float64 `json:"lastIn,omitempty"`
	LastNotIn  []float64 `json:"lastNotIn,omitempty"`
	LastGT     *float64  `json:"lastGT,omitempty"`
	LastGTE    *float64  `json:"lastGTE,omitempty"`
	LastLT     *float64  `json:"lastLT,omitempty"`
	LastLTE    *float64  `json:"lastLTE,omitempty"`
	LastIsNil  bool      `json:"lastIsNil,omitempty"`
	LastNotNil bool      `json:"lastNotNil,omitempty"`

	// "volume" field predicates.
	Volume       *float64  `json:"volume,omitempty"`
	VolumeNEQ    *float64  `json:"volumeNEQ,omitempty"`
	VolumeIn     []float64 `json:"volumeIn,omitempty"`
	VolumeNotIn  []float64 `json:"volumeNotIn,omitempty"`
	VolumeGT     *float64  `json:"volumeGT,omitempty"`
	VolumeGTE    *float64  `json:"volumeGTE,omitempty"`
	VolumeLT     *float64  `json:"volumeLT,omitempty"`
	VolumeLTE    *float64  `json:"volumeLTE,omitempty"`
	VolumeIsNil  bool      `json:"volumeIsNil,omitempty"`
	VolumeNotNil bool      `json:"volumeNotNil,omitempty"`

	// "trust_score" field predicates.
	TrustScore             *string  `json:"trustScore,omitempty"`
	TrustScoreNEQ          *string  `json:"trustScoreNEQ,omitempty"`
	TrustScoreIn           []string `json:"trustScoreIn,omitempty"`
	TrustScoreNotIn        []string `json:"trustScoreNotIn,omitempty"`
	TrustScoreGT           *string  `json:"trustScoreGT,omitempty"`
	TrustScoreGTE          *string  `json:"trustScoreGTE,omitempty"`
	TrustScoreLT           *string  `json:"trustScoreLT,omitempty"`
	TrustScoreLTE          *string  `json:"trustScoreLTE,omitempty"`
	TrustScoreContains     *string  `json:"trustScoreContains,omitempty"`
	TrustScoreHasPrefix    *string  `json:"trustScoreHasPrefix,omitempty"`
	TrustScoreHasSuffix    *string  `json:"trustScoreHasSuffix,omitempty"`
	TrustScoreIsNil        bool     `json:"trustScoreIsNil,omitempty"`
	TrustScoreNotNil       bool     `json:"trustScoreNotNil,omitempty"`
	TrustScoreEqualFold    *string  `json:"trustScoreEqualFold,omitempty"`
	TrustScoreContainsFold *string  `json:"trustScoreContainsFold,omitempty"`

	// "bid_ask_spread_percentage" field predicates.
	BidAskSpreadPercentage       *float64  `json:"bidAskSpreadPercentage,omitempty"`
	BidAskSpreadPercentageNEQ    *float64  `json:"bidAskSpreadPercentageNEQ,omitempty"`
	BidAskSpreadPercentageIn     []float64 `json:"bidAskSpreadPercentageIn,omitempty"`
	BidAskSpreadPercentageNotIn  []float64 `json:"bidAskSpreadPercentageNotIn,omitempty"`
	BidAskSpreadPercentageGT     *float64  `json:"bidAskSpreadPercentageGT,omitempty"`
	BidAskSpreadPercentageGTE    *float64  `json:"bidAskSpreadPercentageGTE,omitempty"`
	BidAskSpreadPercentageLT     *float64  `json:"bidAskSpreadPercentageLT,omitempty"`
	BidAskSpreadPercentageLTE    *float64  `json:"bidAskSpreadPercentageLTE,omitempty"`
	BidAskSpreadPercentageIsNil  bool      `json:"bidAskSpreadPercentageIsNil,omitempty"`
	BidAskSpreadPercentageNotNil bool      `json:"bidAskSpreadPercentageNotNil,omitempty"`

	// "timestamp" field predicates.
	Timestamp       *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ    *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn     []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn  []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT     *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE    *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT     *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE    *time.Time  `json:"timestampLTE,omitempty"`
	TimestampIsNil  bool        `json:"timestampIsNil,omitempty"`
	TimestampNotNil bool        `json:"timestampNotNil,omitempty"`

	// "last_traded_at" field predicates.
	LastTradedAt       *time.Time  `json:"lastTradedAt,omitempty"`
	LastTradedAtNEQ    *time.Time  `json:"lastTradedAtNEQ,omitempty"`
	LastTradedAtIn     []time.Time `json:"lastTradedAtIn,omitempty"`
	LastTradedAtNotIn  []time.Time `json:"lastTradedAtNotIn,omitempty"`
	LastTradedAtGT     *time.Time  `json:"lastTradedAtGT,omitempty"`
	LastTradedAtGTE    *time.Time  `json:"lastTradedAtGTE,omitempty"`
	LastTradedAtLT     *time.Time  `json:"lastTradedAtLT,omitempty"`
	LastTradedAtLTE    *time.Time  `json:"lastTradedAtLTE,omitempty"`
	LastTradedAtIsNil  bool        `json:"lastTradedAtIsNil,omitempty"`
	LastTradedAtNotNil bool        `json:"lastTradedAtNotNil,omitempty"`

	// "last_fetch_at" field predicates.
	LastFetchAt       *time.Time  `json:"lastFetchAt,omitempty"`
	LastFetchAtNEQ    *time.Time  `json:"lastFetchAtNEQ,omitempty"`
	LastFetchAtIn     []time.Time `json:"lastFetchAtIn,omitempty"`
	LastFetchAtNotIn  []time.Time `json:"lastFetchAtNotIn,omitempty"`
	LastFetchAtGT     *time.Time  `json:"lastFetchAtGT,omitempty"`
	LastFetchAtGTE    *time.Time  `json:"lastFetchAtGTE,omitempty"`
	LastFetchAtLT     *time.Time  `json:"lastFetchAtLT,omitempty"`
	LastFetchAtLTE    *time.Time  `json:"lastFetchAtLTE,omitempty"`
	LastFetchAtIsNil  bool        `json:"lastFetchAtIsNil,omitempty"`
	LastFetchAtNotNil bool        `json:"lastFetchAtNotNil,omitempty"`

	// "is_anomaly" field predicates.
	IsAnomaly       *bool `json:"isAnomaly,omitempty"`
	IsAnomalyNEQ    *bool `json:"isAnomalyNEQ,omitempty"`
	IsAnomalyIsNil  bool  `json:"isAnomalyIsNil,omitempty"`
	IsAnomalyNotNil bool  `json:"isAnomalyNotNil,omitempty"`

	// "is_stale" field predicates.
	IsStale       *bool `json:"isStale,omitempty"`
	IsStaleNEQ    *bool `json:"isStaleNEQ,omitempty"`
	IsStaleIsNil  bool  `json:"isStaleIsNil,omitempty"`
	IsStaleNotNil bool  `json:"isStaleNotNil,omitempty"`

	// "trade_url" field predicates.
	TradeURL             *string  `json:"tradeURL,omitempty"`
	TradeURLNEQ          *string  `json:"tradeURLNEQ,omitempty"`
	TradeURLIn           []string `json:"tradeURLIn,omitempty"`
	TradeURLNotIn        []string `json:"tradeURLNotIn,omitempty"`
	TradeURLGT           *string  `json:"tradeURLGT,omitempty"`
	TradeURLGTE          *string  `json:"tradeURLGTE,omitempty"`
	TradeURLLT           *string  `json:"tradeURLLT,omitempty"`
	TradeURLLTE          *string  `json:"tradeURLLTE,omitempty"`
	TradeURLContains     *string  `json:"tradeURLContains,omitempty"`
	TradeURLHasPrefix    *string  `json:"tradeURLHasPrefix,omitempty"`
	TradeURLHasSuffix    *string  `json:"tradeURLHasSuffix,omitempty"`
	TradeURLIsNil        bool     `json:"tradeURLIsNil,omitempty"`
	TradeURLNotNil       bool     `json:"tradeURLNotNil,omitempty"`
	TradeURLEqualFold    *string  `json:"tradeURLEqualFold,omitempty"`
	TradeURLContainsFold *string  `json:"tradeURLContainsFold,omitempty"`

	// "token_info_url" field predicates.
	TokenInfoURL             *string  `json:"tokenInfoURL,omitempty"`
	TokenInfoURLNEQ          *string  `json:"tokenInfoURLNEQ,omitempty"`
	TokenInfoURLIn           []string `json:"tokenInfoURLIn,omitempty"`
	TokenInfoURLNotIn        []string `json:"tokenInfoURLNotIn,omitempty"`
	TokenInfoURLGT           *string  `json:"tokenInfoURLGT,omitempty"`
	TokenInfoURLGTE          *string  `json:"tokenInfoURLGTE,omitempty"`
	TokenInfoURLLT           *string  `json:"tokenInfoURLLT,omitempty"`
	TokenInfoURLLTE          *string  `json:"tokenInfoURLLTE,omitempty"`
	TokenInfoURLContains     *string  `json:"tokenInfoURLContains,omitempty"`
	TokenInfoURLHasPrefix    *string  `json:"tokenInfoURLHasPrefix,omitempty"`
	TokenInfoURLHasSuffix    *string  `json:"tokenInfoURLHasSuffix,omitempty"`
	TokenInfoURLIsNil        bool     `json:"tokenInfoURLIsNil,omitempty"`
	TokenInfoURLNotNil       bool     `json:"tokenInfoURLNotNil,omitempty"`
	TokenInfoURLEqualFold    *string  `json:"tokenInfoURLEqualFold,omitempty"`
	TokenInfoURLContainsFold *string  `json:"tokenInfoURLContainsFold,omitempty"`

	// "exchange" edge predicates.
	HasExchange     *bool                 `json:"hasExchange,omitempty"`
	HasExchangeWith []*ExchangeWhereInput `json:"hasExchangeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TickerWhereInput) AddPredicates(predicates ...predicate.Ticker) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TickerWhereInput filter on the TickerQuery builder.
func (i *TickerWhereInput) Filter(q *TickerQuery) (*TickerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTickerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTickerWhereInput is returned in case the TickerWhereInput is empty.
var ErrEmptyTickerWhereInput = errors.New("entities: empty predicate TickerWhereInput")

// P returns a predicate for filtering tickers.
// An error is returned if the input is empty or invalid.
func (i *TickerWhereInput) P() (predicate.Ticker, error) {
	var predicates []predicate.Ticker
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, ticker.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Ticker, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, ticker.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Ticker, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, ticker.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, ticker.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, ticker.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, ticker.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, ticker.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, ticker.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, ticker.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, ticker.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, ticker.IDLTE(*i.IDLTE))
	}
	if i.Base != nil {
		predicates = append(predicates, ticker.BaseEQ(*i.Base))
	}
	if i.BaseNEQ != nil {
		predicates = append(predicates, ticker.BaseNEQ(*i.BaseNEQ))
	}
	if len(i.BaseIn) > 0 {
		predicates = append(predicates, ticker.BaseIn(i.BaseIn...))
	}
	if len(i.BaseNotIn) > 0 {
		predicates = append(predicates, ticker.BaseNotIn(i.BaseNotIn...))
	}
	if i.BaseGT != nil {
		predicates = append(predicates, ticker.BaseGT(*i.BaseGT))
	}
	if i.BaseGTE != nil {
		predicates = append(predicates, ticker.BaseGTE(*i.BaseGTE))
	}
	if i.BaseLT != nil {
		predicates = append(predicates, ticker.BaseLT(*i.BaseLT))
	}
	if i.BaseLTE != nil {
		predicates = append(predicates, ticker.BaseLTE(*i.BaseLTE))
	}
	if i.BaseContains != nil {
		predicates = append(predicates, ticker.BaseContains(*i.BaseContains))
	}
	if i.BaseHasPrefix != nil {
		predicates = append(predicates, ticker.BaseHasPrefix(*i.BaseHasPrefix))
	}
	if i.BaseHasSuffix != nil {
		predicates = append(predicates, ticker.BaseHasSuffix(*i.BaseHasSuffix))
	}
	if i.BaseEqualFold != nil {
		predicates = append(predicates, ticker.BaseEqualFold(*i.BaseEqualFold))
	}
	if i.BaseContainsFold != nil {
		predicates = append(predicates, ticker.BaseContainsFold(*i.BaseContainsFold))
	}
	if i.BaseCoinID != nil {
		predicates = append(predicates, ticker.BaseCoinIDEQ(*i.BaseCoinID))
	}
	if i.BaseCoinIDNEQ != nil {
		predicates = append(predicates, ticker.BaseCoinIDNEQ(*i.BaseCoinIDNEQ))
	}
	if len(i.BaseCoinIDIn) > 0 {
		predicates = append(predicates, ticker.BaseCoinIDIn(i.BaseCoinIDIn...))
	}
	if len(i.BaseCoinIDNotIn) > 0 {
		predicates = append(predicates, ticker.BaseCoinIDNotIn(i.BaseCoinIDNotIn...))
	}
	if i.BaseCoinIDGT != nil {
		predicates = append(predicates, ticker.BaseCoinIDGT(*i.BaseCoinIDGT))
	}
	if i.BaseCoinIDGTE != nil {
		predicates = append(predicates, ticker.BaseCoinIDGTE(*i.BaseCoinIDGTE))
	}
	if i.BaseCoinIDLT != nil {
		predicates = append(predicates, ticker.BaseCoinIDLT(*i.BaseCoinIDLT))
	}
	if i.BaseCoinIDLTE != nil {
		predicates = append(predicates, ticker.BaseCoinIDLTE(*i.BaseCoinIDLTE))
	}
	if i.BaseCoinIDContains != nil {
		predicates = append(predicates, ticker.BaseCoinIDContains(*i.BaseCoinIDContains))
	}
	if i.BaseCoinIDHasPrefix != nil {
		predicates = append(predicates, ticker.BaseCoinIDHasPrefix(*i.BaseCoinIDHasPrefix))
	}
	if i.BaseCoinIDHasSuffix != nil {
		predicates = append(predicates, ticker.BaseCoinIDHasSuffix(*i.BaseCoinIDHasSuffix))
	}
	if i.BaseCoinIDIsNil {
		predicates = append(predicates, ticker.BaseCoinIDIsNil())
	}
	if i.BaseCoinIDNotNil {
		predicates = append(predicates, ticker.BaseCoinIDNotNil())
	}
	if i.BaseCoinIDEqualFold != nil {
		predicates = append(predicates, ticker.BaseCoinIDEqualFold(*i.BaseCoinIDEqualFold))
	}
	if i.BaseCoinIDContainsFold != nil {
		predicates = append(predicates, ticker.BaseCoinIDContainsFold(*i.BaseCoinIDContainsFold))
	}
	if i.Counter != nil {
		predicates = append(predicates, ticker.CounterEQ(*i.Counter))
	}
	if i.CounterNEQ != nil {
		predicates = append(predicates, ticker.CounterNEQ(*i.CounterNEQ))
	}
	if len(i.CounterIn) > 0 {
		predicates = append(predicates, ticker.CounterIn(i.CounterIn...))
	}
	if len(i.CounterNotIn) > 0 {
		predicates = append(predicates, ticker.CounterNotIn(i.CounterNotIn...))
	}
	if i.CounterGT != nil {
		predicates = append(predicates, ticker.CounterGT(*i.CounterGT))
	}
	if i.CounterGTE != nil {
		predicates = append(predicates, ticker.CounterGTE(*i.CounterGTE))
	}
	if i.CounterLT != nil {
		predicates = append(predicates, ticker.CounterLT(*i.CounterLT))
	}
	if i.CounterLTE != nil {
		predicates = append(predicates, ticker.CounterLTE(*i.CounterLTE))
	}
	if i.CounterContains != nil {
		predicates = append(predicates, ticker.CounterContains(*i.CounterContains))
	}
	if i.CounterHasPrefix != nil {
		predicates = append(predicates, ticker.CounterHasPrefix(*i.CounterHasPrefix))
	}
	if i.CounterHasSuffix != nil {
		predicates = append(predicates, ticker.CounterHasSuffix(*i.CounterHasSuffix))
	}
	if i.CounterEqualFold != nil {
		predicates = append(predicates, ticker.CounterEqualFold(*i.CounterEqualFold))
	}
	if i.CounterContainsFold != nil {
		predicates = append(predicates, ticker.CounterContainsFold(*i.CounterContainsFold))
	}
	if i.CounterCoinID != nil {
		predicates = append(predicates, ticker.CounterCoinIDEQ(*i.CounterCoinID))
	}
	if i.CounterCoinIDNEQ != nil {
		predicates = append(predicates, ticker.CounterCoinIDNEQ(*i.CounterCoinIDNEQ))
	}
	if len(i.CounterCoinIDIn) > 0 {
		predicates = append(predicates, ticker.CounterCoinIDIn(i.CounterCoinIDIn...))
	}
	if len(i.CounterCoinIDNotIn) > 0 {
		predicates = append(predicates, ticker.CounterCoinIDNotIn(i.CounterCoinIDNotIn...))
	}
	if i.CounterCoinIDGT != nil {
		predicates = append(predicates, ticker.CounterCoinIDGT(*i.CounterCoinIDGT))
	}
	if i.CounterCoinIDGTE != nil {
		predicates = append(predicates, ticker.CounterCoinIDGTE(*i.CounterCoinIDGTE))
	}
	if i.CounterCoinIDLT != nil {
		predicates = append(predicates, ticker.CounterCoinIDLT(*i.CounterCoinIDLT))
	}
	if i.CounterCoinIDLTE != nil {
		predicates = append(predicates, ticker.CounterCoinIDLTE(*i.CounterCoinIDLTE))
	}
	if i.CounterCoinIDContains != nil {
		predicates = append(predicates, ticker.CounterCoinIDContains(*i.CounterCoinIDContains))
	}
	if i.CounterCoinIDHasPrefix != nil {
		predicates = append(predicates, ticker.CounterCoinIDHasPrefix(*i.CounterCoinIDHasPrefix))
	}
	if i.CounterCoinIDHasSuffix != nil {
		predicates = append(predicates, ticker.CounterCoinIDHasSuffix(*i.CounterCoinIDHasSuffix))
	}
	if i.CounterCoinIDIsNil {
		predicates = append(predicates, ticker.CounterCoinIDIsNil())
	}
	if i.CounterCoinIDNotNil {
		predicates = append(predicates, ticker.CounterCoinIDNotNil())
	}
	if i.CounterCoinIDEqualFold != nil {
		predicates = append(predicates, ticker.CounterCoinIDEqualFold(*i.CounterCoinIDEqualFold))
	}
	if i.CounterCoinIDContainsFold != nil {
		predicates = append(predicates, ticker.CounterCoinIDContainsFold(*i.CounterCoinIDContainsFold))
	}
	if i.Last != nil {
		predicates = append(predicates, ticker.LastEQ(*i.Last))
	}
	if i.LastNEQ != nil {
		predicates = append(predicates, ticker.LastNEQ(*i.LastNEQ))
	}
	if len(i.LastIn) > 0 {
		predicates = append(predicates, ticker.LastIn(i.LastIn...))
	}
	if len(i.LastNotIn) > 0 {
		predicates = append(predicates, ticker.LastNotIn(i.LastNotIn...))
	}
	if i.LastGT != nil {
		predicates = append(predicates, ticker.LastGT(*i.LastGT))
	}
	if i.LastGTE != nil {
		predicates = append(predicates, ticker.LastGTE(*i.LastGTE))
	}
	if i.LastLT != nil {
		predicates = append(predicates, ticker.LastLT(*i.LastLT))
	}
	if i.LastLTE != nil {
		predicates = append(predicates, ticker.LastLTE(*i.LastLTE))
	}
	if i.LastIsNil {
		predicates = append(predicates, ticker.LastIsNil())
	}
	if i.LastNotNil {
		predicates = append(predicates, ticker.LastNotNil())
	}
	if i.Volume != nil {
		predicates = append(predicates, ticker.VolumeEQ(*i.Volume))
	}
	if i.VolumeNEQ != nil {
		predicates = append(predicates, ticker.VolumeNEQ(*i.VolumeNEQ))
	}
	if len(i.VolumeIn) > 0 {
		predicates = append(predicates, ticker.VolumeIn(i.VolumeIn...))
	}
	if len(i.VolumeNotIn) > 0 {
		predicates = append(predicates, ticker.VolumeNotIn(i.VolumeNotIn...))
	}
	if i.VolumeGT != nil {
		predicates = append(predicates, ticker.VolumeGT(*i.VolumeGT))
	}
	if i.VolumeGTE != nil {
		predicates = append(predicates, ticker.VolumeGTE(*i.VolumeGTE))
	}
	if i.VolumeLT != nil {
		predicates = append(predicates, ticker.VolumeLT(*i.VolumeLT))
	}
	if i.VolumeLTE != nil {
		predicates = append(predicates, ticker.VolumeLTE(*i.VolumeLTE))
	}
	if i.VolumeIsNil {
		predicates = append(predicates, ticker.VolumeIsNil())
	}
	if i.VolumeNotNil {
		predicates = append(predicates, ticker.VolumeNotNil())
	}
	if i.TrustScore != nil {
		predicates = append(predicates, ticker.TrustScoreEQ(*i.TrustScore))
	}
	if i.TrustScoreNEQ != nil {
		predicates = append(predicates, ticker.TrustScoreNEQ(*i.TrustScoreNEQ))
	}
	if len(i.TrustScoreIn) > 0 {
		predicates = append(predicates, ticker.TrustScoreIn(i.TrustScoreIn...))
	}
	if len(i.TrustScoreNotIn) > 0 {
		predicates = append(predicates, ticker.TrustScoreNotIn(i.TrustScoreNotIn...))
	}
	if i.TrustScoreGT != nil {
		predicates = append(predicates, ticker.TrustScoreGT(*i.TrustScoreGT))
	}
	if i.TrustScoreGTE != nil {
		predicates = append(predicates, ticker.TrustScoreGTE(*i.TrustScoreGTE))
	}
	if i.TrustScoreLT != nil {
		predicates = append(predicates, ticker.TrustScoreLT(*i.TrustScoreLT))
	}
	if i.TrustScoreLTE != nil {
		predicates = append(predicates, ticker.TrustScoreLTE(*i.TrustScoreLTE))
	}
	if i.TrustScoreContains != nil {
		predicates = append(predicates, ticker.TrustScoreContains(*i.TrustScoreContains))
	}
	if i.TrustScoreHasPrefix != nil {
		predicates = append(predicates, ticker.TrustScoreHasPrefix(*i.TrustScoreHasPrefix))
	}
	if i.TrustScoreHasSuffix != nil {
		predicates = append(predicates, ticker.TrustScoreHasSuffix(*i.TrustScoreHasSuffix))
	}
	if i.TrustScoreIsNil {
		predicates = append(predicates, ticker.TrustScoreIsNil())
	}
	if i.TrustScoreNotNil {
		predicates = append(predicates, ticker.TrustScoreNotNil())
	}
	if i.TrustScoreEqualFold != nil {
		predicates = append(predicates, ticker.TrustScoreEqualFold(*i.TrustScoreEqualFold))
	}
	if i.TrustScoreContainsFold != nil {
		predicates = append(predicates, ticker.TrustScoreContainsFold(*i.TrustScoreContainsFold))
	}
	if i.BidAskSpreadPercentage != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageEQ(*i.BidAskSpreadPercentage))
	}
	if i.BidAskSpreadPercentageNEQ != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageNEQ(*i.BidAskSpreadPercentageNEQ))
	}
	if len(i.BidAskSpreadPercentageIn) > 0 {
		predicates = append(predicates, ticker.BidAskSpreadPercentageIn(i.BidAskSpreadPercentageIn...))
	}
	if len(i.BidAskSpreadPercentageNotIn) > 0 {
		predicates = append(predicates, ticker.BidAskSpreadPercentageNotIn(i.BidAskSpreadPercentageNotIn...))
	}
	if i.BidAskSpreadPercentageGT != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageGT(*i.BidAskSpreadPercentageGT))
	}
	if i.BidAskSpreadPercentageGTE != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageGTE(*i.BidAskSpreadPercentageGTE))
	}
	if i.BidAskSpreadPercentageLT != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageLT(*i.BidAskSpreadPercentageLT))
	}
	if i.BidAskSpreadPercentageLTE != nil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageLTE(*i.BidAskSpreadPercentageLTE))
	}
	if i.BidAskSpreadPercentageIsNil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageIsNil())
	}
	if i.BidAskSpreadPercentageNotNil {
		predicates = append(predicates, ticker.BidAskSpreadPercentageNotNil())
	}
	if i.Timestamp != nil {
		predicates = append(predicates, ticker.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, ticker.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, ticker.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, ticker.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, ticker.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, ticker.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, ticker.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, ticker.TimestampLTE(*i.TimestampLTE))
	}
	if i.TimestampIsNil {
		predicates = append(predicates, ticker.TimestampIsNil())
	}
	if i.TimestampNotNil {
		predicates = append(predicates, ticker.TimestampNotNil())
	}
	if i.LastTradedAt != nil {
		predicates = append(predicates, ticker.LastTradedAtEQ(*i.LastTradedAt))
	}
	if i.LastTradedAtNEQ != nil {
		predicates = append(predicates, ticker.LastTradedAtNEQ(*i.LastTradedAtNEQ))
	}
	if len(i.LastTradedAtIn) > 0 {
		predicates = append(predicates, ticker.LastTradedAtIn(i.LastTradedAtIn...))
	}
	if len(i.LastTradedAtNotIn) > 0 {
		predicates = append(predicates, ticker.LastTradedAtNotIn(i.LastTradedAtNotIn...))
	}
	if i.LastTradedAtGT != nil {
		predicates = append(predicates, ticker.LastTradedAtGT(*i.LastTradedAtGT))
	}
	if i.LastTradedAtGTE != nil {
		predicates = append(predicates, ticker.LastTradedAtGTE(*i.LastTradedAtGTE))
	}
	if i.LastTradedAtLT != nil {
		predicates = append(predicates, ticker.LastTradedAtLT(*i.LastTradedAtLT))
	}
	if i.LastTradedAtLTE != nil {
		predicates = append(predicates, ticker.LastTradedAtLTE(*i.LastTradedAtLTE))
	}
	if i.LastTradedAtIsNil {
		predicates = append(predicates, ticker.LastTradedAtIsNil())
	}
	if i.LastTradedAtNotNil {
		predicates = append(predicates, ticker.LastTradedAtNotNil())
	}
	if i.LastFetchAt != nil {
		predicates = append(predicates, ticker.LastFetchAtEQ(*i.LastFetchAt))
	}
	if i.LastFetchAtNEQ != nil {
		predicates = append(predicates, ticker.LastFetchAtNEQ(*i.LastFetchAtNEQ))
	}
	if len(i.LastFetchAtIn) > 0 {
		predicates = append(predicates, ticker.LastFetchAtIn(i.LastFetchAtIn...))
	}
	if len(i.LastFetchAtNotIn) > 0 {
		predicates = append(predicates, ticker.LastFetchAtNotIn(i.LastFetchAtNotIn...))
	}
	if i.LastFetchAtGT != nil {
		predicates = append(predicates, ticker.LastFetchAtGT(*i.LastFetchAtGT))
	}
	if i.LastFetchAtGTE != nil {
		predicates = append(predicates, ticker.LastFetchAtGTE(*i.LastFetchAtGTE))
	}
	if i.LastFetchAtLT != nil {
		predicates = append(predicates, ticker.LastFetchAtLT(*i.LastFetchAtLT))
	}
	if i.LastFetchAtLTE != nil {
		predicates = append(predicates, ticker.LastFetchAtLTE(*i.LastFetchAtLTE))
	}
	if i.LastFetchAtIsNil {
		predicates = append(predicates, ticker.LastFetchAtIsNil())
	}
	if i.LastFetchAtNotNil {
		predicates = append(predicates, ticker.LastFetchAtNotNil())
	}
	if i.IsAnomaly != nil {
		predicates = append(predicates, ticker.IsAnomalyEQ(*i.IsAnomaly))
	}
	if i.IsAnomalyNEQ != nil {
		predicates = append(predicates, ticker.IsAnomalyNEQ(*i.IsAnomalyNEQ))
	}
	if i.IsAnomalyIsNil {
		predicates = append(predicates, ticker.IsAnomalyIsNil())
	}
	if i.IsAnomalyNotNil {
		predicates = append(predicates, ticker.IsAnomalyNotNil())
	}
	if i.IsStale != nil {
		predicates = append(predicates, ticker.IsStaleEQ(*i.IsStale))
	}
	if i.IsStaleNEQ != nil {
		predicates = append(predicates, ticker.IsStaleNEQ(*i.IsStaleNEQ))
	}
	if i.IsStaleIsNil {
		predicates = append(predicates, ticker.IsStaleIsNil())
	}
	if i.IsStaleNotNil {
		predicates = append(predicates, ticker.IsStaleNotNil())
	}
	if i.TradeURL != nil {
		predicates = append(predicates, ticker.TradeURLEQ(*i.TradeURL))
	}
	if i.TradeURLNEQ != nil {
		predicates = append(predicates, ticker.TradeURLNEQ(*i.TradeURLNEQ))
	}
	if len(i.TradeURLIn) > 0 {
		predicates = append(predicates, ticker.TradeURLIn(i.TradeURLIn...))
	}
	if len(i.TradeURLNotIn) > 0 {
		predicates = append(predicates, ticker.TradeURLNotIn(i.TradeURLNotIn...))
	}
	if i.TradeURLGT != nil {
		predicates = append(predicates, ticker.TradeURLGT(*i.TradeURLGT))
	}
	if i.TradeURLGTE != nil {
		predicates = append(predicates, ticker.TradeURLGTE(*i.TradeURLGTE))
	}
	if i.TradeURLLT != nil {
		predicates = append(predicates, ticker.TradeURLLT(*i.TradeURLLT))
	}
	if i.TradeURLLTE != nil {
		predicates = append(predicates, ticker.TradeURLLTE(*i.TradeURLLTE))
	}
	if i.TradeURLContains != nil {
		predicates = append(predicates, ticker.TradeURLContains(*i.TradeURLContains))
	}
	if i.TradeURLHasPrefix != nil {
		predicates = append(predicates, ticker.TradeURLHasPrefix(*i.TradeURLHasPrefix))
	}
	if i.TradeURLHasSuffix != nil {
		predicates = append(predicates, ticker.TradeURLHasSuffix(*i.TradeURLHasSuffix))
	}
	if i.TradeURLIsNil {
		predicates = append(predicates, ticker.TradeURLIsNil())
	}
	if i.TradeURLNotNil {
		predicates = append(predicates, ticker.TradeURLNotNil())
	}
	if i.TradeURLEqualFold != nil {
		predicates = append(predicates, ticker.TradeURLEqualFold(*i.TradeURLEqualFold))
	}
	if i.TradeURLContainsFold != nil {
		predicates = append(predicates, ticker.TradeURLContainsFold(*i.TradeURLContainsFold))
	}
	if i.TokenInfoURL != nil {
		predicates = append(predicates, ticker.TokenInfoURLEQ(*i.TokenInfoURL))
	}
	if i.TokenInfoURLNEQ != nil {
		predicates = append(predicates, ticker.TokenInfoURLNEQ(*i.TokenInfoURLNEQ))
	}
	if len(i.TokenInfoURLIn) > 0 {
		predicates = append(predicates, ticker.TokenInfoURLIn(i.TokenInfoURLIn...))
	}
	if len(i.TokenInfoURLNotIn) > 0 {
		predicates = append(predicates, ticker.TokenInfoURLNotIn(i.TokenInfoURLNotIn...))
	}
	if i.TokenInfoURLGT != nil {
		predicates = append(predicates, ticker.TokenInfoURLGT(*i.TokenInfoURLGT))
	}
	if i.TokenInfoURLGTE != nil {
		predicates = append(predicates, ticker.TokenInfoURLGTE(*i.TokenInfoURLGTE))
	}
	if i.TokenInfoURLLT != nil {
		predicates = append(predicates, ticker.TokenInfoURLLT(*i.TokenInfoURLLT))
	}
	if i.TokenInfoURLLTE != nil {
		predicates = append(predicates, ticker.TokenInfoURLLTE(*i.TokenInfoURLLTE))
	}
	if i.TokenInfoURLContains != nil {
		predicates = append(predicates, ticker.TokenInfoURLContains(*i.TokenInfoURLContains))
	}
	if i.TokenInfoURLHasPrefix != nil {
		predicates = append(predicates, ticker.TokenInfoURLHasPrefix(*i.TokenInfoURLHasPrefix))
	}
	if i.TokenInfoURLHasSuffix != nil {
		predicates = append(predicates, ticker.TokenInfoURLHasSuffix(*i.TokenInfoURLHasSuffix))
	}
	if i.TokenInfoURLIsNil {
		predicates = append(predicates, ticker.TokenInfoURLIsNil())
	}
	if i.TokenInfoURLNotNil {
		predicates = append(predicates, ticker.TokenInfoURLNotNil())
	}
	if i.TokenInfoURLEqualFold != nil {
		predicates = append(predicates, ticker.TokenInfoURLEqualFold(*i.TokenInfoURLEqualFold))
	}
	if i.TokenInfoURLContainsFold != nil {
		predicates = append(predicates, ticker.TokenInfoURLContainsFold(*i.TokenInfoURLContainsFold))
	}

	if i.HasExchange != nil {
		p := ticker.HasExchange()
		if !*i.HasExchange {
			p = ticker.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExchangeWith) > 0 {
		with := make([]predicate.Exchange, 0, len(i.HasExchangeWith))
		for _, w := range i.HasExchangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExchangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, ticker.HasExchangeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTickerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return ticker.And(predicates...), nil
	}
}

// TradingPairWhereInput represents a where input for filtering TradingPair queries.
type TradingPairWhereInput struct {
	Predicates []predicate.TradingPair  `json:"-"`
	Not        *TradingPairWhereInput   `json:"not,omitempty"`
	Or         []*TradingPairWhereInput `json:"or,omitempty"`
	And        []*TradingPairWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "symbol" field predicates.
	Symbol             *string  `json:"symbol,omitempty"`
	SymbolNEQ          *string  `json:"symbolNEQ,omitempty"`
	SymbolIn           []string `json:"symbolIn,omitempty"`
	SymbolNotIn        []string `json:"symbolNotIn,omitempty"`
	SymbolGT           *string  `json:"symbolGT,omitempty"`
	SymbolGTE          *string  `json:"symbolGTE,omitempty"`
	SymbolLT           *string  `json:"symbolLT,omitempty"`
	SymbolLTE          *string  `json:"symbolLTE,omitempty"`
	SymbolContains     *string  `json:"symbolContains,omitempty"`
	SymbolHasPrefix    *string  `json:"symbolHasPrefix,omitempty"`
	SymbolHasSuffix    *string  `json:"symbolHasSuffix,omitempty"`
	SymbolEqualFold    *string  `json:"symbolEqualFold,omitempty"`
	SymbolContainsFold *string  `json:"symbolContainsFold,omitempty"`

	// "base_price_min_precision" field predicates.
	BasePriceMinPrecision       *int  `json:"basePriceMinPrecision,omitempty"`
	BasePriceMinPrecisionNEQ    *int  `json:"basePriceMinPrecisionNEQ,omitempty"`
	BasePriceMinPrecisionIn     []int `json:"basePriceMinPrecisionIn,omitempty"`
	BasePriceMinPrecisionNotIn  []int `json:"basePriceMinPrecisionNotIn,omitempty"`
	BasePriceMinPrecisionGT     *int  `json:"basePriceMinPrecisionGT,omitempty"`
	BasePriceMinPrecisionGTE    *int  `json:"basePriceMinPrecisionGTE,omitempty"`
	BasePriceMinPrecisionLT     *int  `json:"basePriceMinPrecisionLT,omitempty"`
	BasePriceMinPrecisionLTE    *int  `json:"basePriceMinPrecisionLTE,omitempty"`
	BasePriceMinPrecisionIsNil  bool  `json:"basePriceMinPrecisionIsNil,omitempty"`
	BasePriceMinPrecisionNotNil bool  `json:"basePriceMinPrecisionNotNil,omitempty"`

	// "base_price_max_precision" field predicates.
	BasePriceMaxPrecision       *int  `json:"basePriceMaxPrecision,omitempty"`
	BasePriceMaxPrecisionNEQ    *int  `json:"basePriceMaxPrecisionNEQ,omitempty"`
	BasePriceMaxPrecisionIn     []int `json:"basePriceMaxPrecisionIn,omitempty"`
	BasePriceMaxPrecisionNotIn  []int `json:"basePriceMaxPrecisionNotIn,omitempty"`
	BasePriceMaxPrecisionGT     *int  `json:"basePriceMaxPrecisionGT,omitempty"`
	BasePriceMaxPrecisionGTE    *int  `json:"basePriceMaxPrecisionGTE,omitempty"`
	BasePriceMaxPrecisionLT     *int  `json:"basePriceMaxPrecisionLT,omitempty"`
	BasePriceMaxPrecisionLTE    *int  `json:"basePriceMaxPrecisionLTE,omitempty"`
	BasePriceMaxPrecisionIsNil  bool  `json:"basePriceMaxPrecisionIsNil,omitempty"`
	BasePriceMaxPrecisionNotNil bool  `json:"basePriceMaxPrecisionNotNil,omitempty"`

	// "base_quantity_min_precision" field predicates.
	BaseQuantityMinPrecision       *int  `json:"baseQuantityMinPrecision,omitempty"`
	BaseQuantityMinPrecisionNEQ    *int  `json:"baseQuantityMinPrecisionNEQ,omitempty"`
	BaseQuantityMinPrecisionIn     []int `json:"baseQuantityMinPrecisionIn,omitempty"`
	BaseQuantityMinPrecisionNotIn  []int `json:"baseQuantityMinPrecisionNotIn,omitempty"`
	BaseQuantityMinPrecisionGT     *int  `json:"baseQuantityMinPrecisionGT,omitempty"`
	BaseQuantityMinPrecisionGTE    *int  `json:"baseQuantityMinPrecisionGTE,omitempty"`
	BaseQuantityMinPrecisionLT     *int  `json:"baseQuantityMinPrecisionLT,omitempty"`
	BaseQuantityMinPrecisionLTE    *int  `json:"baseQuantityMinPrecisionLTE,omitempty"`
	BaseQuantityMinPrecisionIsNil  bool  `json:"baseQuantityMinPrecisionIsNil,omitempty"`
	BaseQuantityMinPrecisionNotNil bool  `json:"baseQuantityMinPrecisionNotNil,omitempty"`

	// "base_quantity_max_precision" field predicates.
	BaseQuantityMaxPrecision       *int  `json:"baseQuantityMaxPrecision,omitempty"`
	BaseQuantityMaxPrecisionNEQ    *int  `json:"baseQuantityMaxPrecisionNEQ,omitempty"`
	BaseQuantityMaxPrecisionIn     []int `json:"baseQuantityMaxPrecisionIn,omitempty"`
	BaseQuantityMaxPrecisionNotIn  []int `json:"baseQuantityMaxPrecisionNotIn,omitempty"`
	BaseQuantityMaxPrecisionGT     *int  `json:"baseQuantityMaxPrecisionGT,omitempty"`
	BaseQuantityMaxPrecisionGTE    *int  `json:"baseQuantityMaxPrecisionGTE,omitempty"`
	BaseQuantityMaxPrecisionLT     *int  `json:"baseQuantityMaxPrecisionLT,omitempty"`
	BaseQuantityMaxPrecisionLTE    *int  `json:"baseQuantityMaxPrecisionLTE,omitempty"`
	BaseQuantityMaxPrecisionIsNil  bool  `json:"baseQuantityMaxPrecisionIsNil,omitempty"`
	BaseQuantityMaxPrecisionNotNil bool  `json:"baseQuantityMaxPrecisionNotNil,omitempty"`

	// "counter_price_min_precision" field predicates.
	CounterPriceMinPrecision       *int  `json:"counterPriceMinPrecision,omitempty"`
	CounterPriceMinPrecisionNEQ    *int  `json:"counterPriceMinPrecisionNEQ,omitempty"`
	CounterPriceMinPrecisionIn     []int `json:"counterPriceMinPrecisionIn,omitempty"`
	CounterPriceMinPrecisionNotIn  []int `json:"counterPriceMinPrecisionNotIn,omitempty"`
	CounterPriceMinPrecisionGT     *int  `json:"counterPriceMinPrecisionGT,omitempty"`
	CounterPriceMinPrecisionGTE    *int  `json:"counterPriceMinPrecisionGTE,omitempty"`
	CounterPriceMinPrecisionLT     *int  `json:"counterPriceMinPrecisionLT,omitempty"`
	CounterPriceMinPrecisionLTE    *int  `json:"counterPriceMinPrecisionLTE,omitempty"`
	CounterPriceMinPrecisionIsNil  bool  `json:"counterPriceMinPrecisionIsNil,omitempty"`
	CounterPriceMinPrecisionNotNil bool  `json:"counterPriceMinPrecisionNotNil,omitempty"`

	// "counter_price_max_precision" field predicates.
	CounterPriceMaxPrecision       *int  `json:"counterPriceMaxPrecision,omitempty"`
	CounterPriceMaxPrecisionNEQ    *int  `json:"counterPriceMaxPrecisionNEQ,omitempty"`
	CounterPriceMaxPrecisionIn     []int `json:"counterPriceMaxPrecisionIn,omitempty"`
	CounterPriceMaxPrecisionNotIn  []int `json:"counterPriceMaxPrecisionNotIn,omitempty"`
	CounterPriceMaxPrecisionGT     *int  `json:"counterPriceMaxPrecisionGT,omitempty"`
	CounterPriceMaxPrecisionGTE    *int  `json:"counterPriceMaxPrecisionGTE,omitempty"`
	CounterPriceMaxPrecisionLT     *int  `json:"counterPriceMaxPrecisionLT,omitempty"`
	CounterPriceMaxPrecisionLTE    *int  `json:"counterPriceMaxPrecisionLTE,omitempty"`
	CounterPriceMaxPrecisionIsNil  bool  `json:"counterPriceMaxPrecisionIsNil,omitempty"`
	CounterPriceMaxPrecisionNotNil bool  `json:"counterPriceMaxPrecisionNotNil,omitempty"`

	// "counter_quantity_min_precision" field predicates.
	CounterQuantityMinPrecision       *int  `json:"counterQuantityMinPrecision,omitempty"`
	CounterQuantityMinPrecisionNEQ    *int  `json:"counterQuantityMinPrecisionNEQ,omitempty"`
	CounterQuantityMinPrecisionIn     []int `json:"counterQuantityMinPrecisionIn,omitempty"`
	CounterQuantityMinPrecisionNotIn  []int `json:"counterQuantityMinPrecisionNotIn,omitempty"`
	CounterQuantityMinPrecisionGT     *int  `json:"counterQuantityMinPrecisionGT,omitempty"`
	CounterQuantityMinPrecisionGTE    *int  `json:"counterQuantityMinPrecisionGTE,omitempty"`
	CounterQuantityMinPrecisionLT     *int  `json:"counterQuantityMinPrecisionLT,omitempty"`
	CounterQuantityMinPrecisionLTE    *int  `json:"counterQuantityMinPrecisionLTE,omitempty"`
	CounterQuantityMinPrecisionIsNil  bool  `json:"counterQuantityMinPrecisionIsNil,omitempty"`
	CounterQuantityMinPrecisionNotNil bool  `json:"counterQuantityMinPrecisionNotNil,omitempty"`

	// "counter_quantity_max_precision" field predicates.
	CounterQuantityMaxPrecision       *int  `json:"counterQuantityMaxPrecision,omitempty"`
	CounterQuantityMaxPrecisionNEQ    *int  `json:"counterQuantityMaxPrecisionNEQ,omitempty"`
	CounterQuantityMaxPrecisionIn     []int `json:"counterQuantityMaxPrecisionIn,omitempty"`
	CounterQuantityMaxPrecisionNotIn  []int `json:"counterQuantityMaxPrecisionNotIn,omitempty"`
	CounterQuantityMaxPrecisionGT     *int  `json:"counterQuantityMaxPrecisionGT,omitempty"`
	CounterQuantityMaxPrecisionGTE    *int  `json:"counterQuantityMaxPrecisionGTE,omitempty"`
	CounterQuantityMaxPrecisionLT     *int  `json:"counterQuantityMaxPrecisionLT,omitempty"`
	CounterQuantityMaxPrecisionLTE    *int  `json:"counterQuantityMaxPrecisionLTE,omitempty"`
	CounterQuantityMaxPrecisionIsNil  bool  `json:"counterQuantityMaxPrecisionIsNil,omitempty"`
	CounterQuantityMaxPrecisionNotNil bool  `json:"counterQuantityMaxPrecisionNotNil,omitempty"`

	// "exchange" edge predicates.
	HasExchange     *bool                 `json:"hasExchange,omitempty"`
	HasExchangeWith []*ExchangeWhereInput `json:"hasExchangeWith,omitempty"`

	// "base" edge predicates.
	HasBase     *bool                 `json:"hasBase,omitempty"`
	HasBaseWith []*CurrencyWhereInput `json:"hasBaseWith,omitempty"`

	// "counter" edge predicates.
	HasCounter     *bool                 `json:"hasCounter,omitempty"`
	HasCounterWith []*CurrencyWhereInput `json:"hasCounterWith,omitempty"`

	// "market" edge predicates.
	HasMarket     *bool               `json:"hasMarket,omitempty"`
	HasMarketWith []*MarketWhereInput `json:"hasMarketWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TradingPairWhereInput) AddPredicates(predicates ...predicate.TradingPair) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TradingPairWhereInput filter on the TradingPairQuery builder.
func (i *TradingPairWhereInput) Filter(q *TradingPairQuery) (*TradingPairQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTradingPairWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTradingPairWhereInput is returned in case the TradingPairWhereInput is empty.
var ErrEmptyTradingPairWhereInput = errors.New("entities: empty predicate TradingPairWhereInput")

// P returns a predicate for filtering tradingpairs.
// An error is returned if the input is empty or invalid.
func (i *TradingPairWhereInput) P() (predicate.TradingPair, error) {
	var predicates []predicate.TradingPair
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tradingpair.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TradingPair, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tradingpair.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TradingPair, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tradingpair.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tradingpair.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tradingpair.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tradingpair.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tradingpair.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tradingpair.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tradingpair.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tradingpair.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tradingpair.IDLTE(*i.IDLTE))
	}
	if i.Symbol != nil {
		predicates = append(predicates, tradingpair.SymbolEQ(*i.Symbol))
	}
	if i.SymbolNEQ != nil {
		predicates = append(predicates, tradingpair.SymbolNEQ(*i.SymbolNEQ))
	}
	if len(i.SymbolIn) > 0 {
		predicates = append(predicates, tradingpair.SymbolIn(i.SymbolIn...))
	}
	if len(i.SymbolNotIn) > 0 {
		predicates = append(predicates, tradingpair.SymbolNotIn(i.SymbolNotIn...))
	}
	if i.SymbolGT != nil {
		predicates = append(predicates, tradingpair.SymbolGT(*i.SymbolGT))
	}
	if i.SymbolGTE != nil {
		predicates = append(predicates, tradingpair.SymbolGTE(*i.SymbolGTE))
	}
	if i.SymbolLT != nil {
		predicates = append(predicates, tradingpair.SymbolLT(*i.SymbolLT))
	}
	if i.SymbolLTE != nil {
		predicates = append(predicates, tradingpair.SymbolLTE(*i.SymbolLTE))
	}
	if i.SymbolContains != nil {
		predicates = append(predicates, tradingpair.SymbolContains(*i.SymbolContains))
	}
	if i.SymbolHasPrefix != nil {
		predicates = append(predicates, tradingpair.SymbolHasPrefix(*i.SymbolHasPrefix))
	}
	if i.SymbolHasSuffix != nil {
		predicates = append(predicates, tradingpair.SymbolHasSuffix(*i.SymbolHasSuffix))
	}
	if i.SymbolEqualFold != nil {
		predicates = append(predicates, tradingpair.SymbolEqualFold(*i.SymbolEqualFold))
	}
	if i.SymbolContainsFold != nil {
		predicates = append(predicates, tradingpair.SymbolContainsFold(*i.SymbolContainsFold))
	}
	if i.BasePriceMinPrecision != nil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionEQ(*i.BasePriceMinPrecision))
	}
	if i.BasePriceMinPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionNEQ(*i.BasePriceMinPrecisionNEQ))
	}
	if len(i.BasePriceMinPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionIn(i.BasePriceMinPrecisionIn...))
	}
	if len(i.BasePriceMinPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionNotIn(i.BasePriceMinPrecisionNotIn...))
	}
	if i.BasePriceMinPrecisionGT != nil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionGT(*i.BasePriceMinPrecisionGT))
	}
	if i.BasePriceMinPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionGTE(*i.BasePriceMinPrecisionGTE))
	}
	if i.BasePriceMinPrecisionLT != nil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionLT(*i.BasePriceMinPrecisionLT))
	}
	if i.BasePriceMinPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionLTE(*i.BasePriceMinPrecisionLTE))
	}
	if i.BasePriceMinPrecisionIsNil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionIsNil())
	}
	if i.BasePriceMinPrecisionNotNil {
		predicates = append(predicates, tradingpair.BasePriceMinPrecisionNotNil())
	}
	if i.BasePriceMaxPrecision != nil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionEQ(*i.BasePriceMaxPrecision))
	}
	if i.BasePriceMaxPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionNEQ(*i.BasePriceMaxPrecisionNEQ))
	}
	if len(i.BasePriceMaxPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionIn(i.BasePriceMaxPrecisionIn...))
	}
	if len(i.BasePriceMaxPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionNotIn(i.BasePriceMaxPrecisionNotIn...))
	}
	if i.BasePriceMaxPrecisionGT != nil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionGT(*i.BasePriceMaxPrecisionGT))
	}
	if i.BasePriceMaxPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionGTE(*i.BasePriceMaxPrecisionGTE))
	}
	if i.BasePriceMaxPrecisionLT != nil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionLT(*i.BasePriceMaxPrecisionLT))
	}
	if i.BasePriceMaxPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionLTE(*i.BasePriceMaxPrecisionLTE))
	}
	if i.BasePriceMaxPrecisionIsNil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionIsNil())
	}
	if i.BasePriceMaxPrecisionNotNil {
		predicates = append(predicates, tradingpair.BasePriceMaxPrecisionNotNil())
	}
	if i.BaseQuantityMinPrecision != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionEQ(*i.BaseQuantityMinPrecision))
	}
	if i.BaseQuantityMinPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionNEQ(*i.BaseQuantityMinPrecisionNEQ))
	}
	if len(i.BaseQuantityMinPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionIn(i.BaseQuantityMinPrecisionIn...))
	}
	if len(i.BaseQuantityMinPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionNotIn(i.BaseQuantityMinPrecisionNotIn...))
	}
	if i.BaseQuantityMinPrecisionGT != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionGT(*i.BaseQuantityMinPrecisionGT))
	}
	if i.BaseQuantityMinPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionGTE(*i.BaseQuantityMinPrecisionGTE))
	}
	if i.BaseQuantityMinPrecisionLT != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionLT(*i.BaseQuantityMinPrecisionLT))
	}
	if i.BaseQuantityMinPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionLTE(*i.BaseQuantityMinPrecisionLTE))
	}
	if i.BaseQuantityMinPrecisionIsNil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionIsNil())
	}
	if i.BaseQuantityMinPrecisionNotNil {
		predicates = append(predicates, tradingpair.BaseQuantityMinPrecisionNotNil())
	}
	if i.BaseQuantityMaxPrecision != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionEQ(*i.BaseQuantityMaxPrecision))
	}
	if i.BaseQuantityMaxPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionNEQ(*i.BaseQuantityMaxPrecisionNEQ))
	}
	if len(i.BaseQuantityMaxPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionIn(i.BaseQuantityMaxPrecisionIn...))
	}
	if len(i.BaseQuantityMaxPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionNotIn(i.BaseQuantityMaxPrecisionNotIn...))
	}
	if i.BaseQuantityMaxPrecisionGT != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionGT(*i.BaseQuantityMaxPrecisionGT))
	}
	if i.BaseQuantityMaxPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionGTE(*i.BaseQuantityMaxPrecisionGTE))
	}
	if i.BaseQuantityMaxPrecisionLT != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionLT(*i.BaseQuantityMaxPrecisionLT))
	}
	if i.BaseQuantityMaxPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionLTE(*i.BaseQuantityMaxPrecisionLTE))
	}
	if i.BaseQuantityMaxPrecisionIsNil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionIsNil())
	}
	if i.BaseQuantityMaxPrecisionNotNil {
		predicates = append(predicates, tradingpair.BaseQuantityMaxPrecisionNotNil())
	}
	if i.CounterPriceMinPrecision != nil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionEQ(*i.CounterPriceMinPrecision))
	}
	if i.CounterPriceMinPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionNEQ(*i.CounterPriceMinPrecisionNEQ))
	}
	if len(i.CounterPriceMinPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionIn(i.CounterPriceMinPrecisionIn...))
	}
	if len(i.CounterPriceMinPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionNotIn(i.CounterPriceMinPrecisionNotIn...))
	}
	if i.CounterPriceMinPrecisionGT != nil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionGT(*i.CounterPriceMinPrecisionGT))
	}
	if i.CounterPriceMinPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionGTE(*i.CounterPriceMinPrecisionGTE))
	}
	if i.CounterPriceMinPrecisionLT != nil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionLT(*i.CounterPriceMinPrecisionLT))
	}
	if i.CounterPriceMinPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionLTE(*i.CounterPriceMinPrecisionLTE))
	}
	if i.CounterPriceMinPrecisionIsNil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionIsNil())
	}
	if i.CounterPriceMinPrecisionNotNil {
		predicates = append(predicates, tradingpair.CounterPriceMinPrecisionNotNil())
	}
	if i.CounterPriceMaxPrecision != nil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionEQ(*i.CounterPriceMaxPrecision))
	}
	if i.CounterPriceMaxPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionNEQ(*i.CounterPriceMaxPrecisionNEQ))
	}
	if len(i.CounterPriceMaxPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionIn(i.CounterPriceMaxPrecisionIn...))
	}
	if len(i.CounterPriceMaxPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionNotIn(i.CounterPriceMaxPrecisionNotIn...))
	}
	if i.CounterPriceMaxPrecisionGT != nil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionGT(*i.CounterPriceMaxPrecisionGT))
	}
	if i.CounterPriceMaxPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionGTE(*i.CounterPriceMaxPrecisionGTE))
	}
	if i.CounterPriceMaxPrecisionLT != nil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionLT(*i.CounterPriceMaxPrecisionLT))
	}
	if i.CounterPriceMaxPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionLTE(*i.CounterPriceMaxPrecisionLTE))
	}
	if i.CounterPriceMaxPrecisionIsNil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionIsNil())
	}
	if i.CounterPriceMaxPrecisionNotNil {
		predicates = append(predicates, tradingpair.CounterPriceMaxPrecisionNotNil())
	}
	if i.CounterQuantityMinPrecision != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionEQ(*i.CounterQuantityMinPrecision))
	}
	if i.CounterQuantityMinPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionNEQ(*i.CounterQuantityMinPrecisionNEQ))
	}
	if len(i.CounterQuantityMinPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionIn(i.CounterQuantityMinPrecisionIn...))
	}
	if len(i.CounterQuantityMinPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionNotIn(i.CounterQuantityMinPrecisionNotIn...))
	}
	if i.CounterQuantityMinPrecisionGT != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionGT(*i.CounterQuantityMinPrecisionGT))
	}
	if i.CounterQuantityMinPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionGTE(*i.CounterQuantityMinPrecisionGTE))
	}
	if i.CounterQuantityMinPrecisionLT != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionLT(*i.CounterQuantityMinPrecisionLT))
	}
	if i.CounterQuantityMinPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionLTE(*i.CounterQuantityMinPrecisionLTE))
	}
	if i.CounterQuantityMinPrecisionIsNil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionIsNil())
	}
	if i.CounterQuantityMinPrecisionNotNil {
		predicates = append(predicates, tradingpair.CounterQuantityMinPrecisionNotNil())
	}
	if i.CounterQuantityMaxPrecision != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionEQ(*i.CounterQuantityMaxPrecision))
	}
	if i.CounterQuantityMaxPrecisionNEQ != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionNEQ(*i.CounterQuantityMaxPrecisionNEQ))
	}
	if len(i.CounterQuantityMaxPrecisionIn) > 0 {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionIn(i.CounterQuantityMaxPrecisionIn...))
	}
	if len(i.CounterQuantityMaxPrecisionNotIn) > 0 {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionNotIn(i.CounterQuantityMaxPrecisionNotIn...))
	}
	if i.CounterQuantityMaxPrecisionGT != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionGT(*i.CounterQuantityMaxPrecisionGT))
	}
	if i.CounterQuantityMaxPrecisionGTE != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionGTE(*i.CounterQuantityMaxPrecisionGTE))
	}
	if i.CounterQuantityMaxPrecisionLT != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionLT(*i.CounterQuantityMaxPrecisionLT))
	}
	if i.CounterQuantityMaxPrecisionLTE != nil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionLTE(*i.CounterQuantityMaxPrecisionLTE))
	}
	if i.CounterQuantityMaxPrecisionIsNil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionIsNil())
	}
	if i.CounterQuantityMaxPrecisionNotNil {
		predicates = append(predicates, tradingpair.CounterQuantityMaxPrecisionNotNil())
	}

	if i.HasExchange != nil {
		p := tradingpair.HasExchange()
		if !*i.HasExchange {
			p = tradingpair.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExchangeWith) > 0 {
		with := make([]predicate.Exchange, 0, len(i.HasExchangeWith))
		for _, w := range i.HasExchangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExchangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tradingpair.HasExchangeWith(with...))
	}
	if i.HasBase != nil {
		p := tradingpair.HasBase()
		if !*i.HasBase {
			p = tradingpair.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBaseWith) > 0 {
		with := make([]predicate.Currency, 0, len(i.HasBaseWith))
		for _, w := range i.HasBaseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBaseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tradingpair.HasBaseWith(with...))
	}
	if i.HasCounter != nil {
		p := tradingpair.HasCounter()
		if !*i.HasCounter {
			p = tradingpair.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCounterWith) > 0 {
		with := make([]predicate.Currency, 0, len(i.HasCounterWith))
		for _, w := range i.HasCounterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCounterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tradingpair.HasCounterWith(with...))
	}
	if i.HasMarket != nil {
		p := tradingpair.HasMarket()
		if !*i.HasMarket {
			p = tradingpair.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMarketWith) > 0 {
		with := make([]predicate.Market, 0, len(i.HasMarketWith))
		for _, w := range i.HasMarketWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMarketWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tradingpair.HasMarketWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTradingPairWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tradingpair.And(predicates...), nil
	}
}
